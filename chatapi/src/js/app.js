/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer, console) {'use strict';

	var _classCallCheck2 = __webpack_require__(209);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(210);

	var _createClass3 = _interopRequireDefault(_createClass2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	global.Buffer = global.Buffer || __webpack_require__(205).Buffer;
	var $ = __webpack_require__(204);
	var _ = __webpack_require__(214);
	var Backbone = __webpack_require__(216);
	Backbone.$ = $;
	var asyncjs = __webpack_require__(218);
	var StanzaIO = __webpack_require__(221);
	var AppState = __webpack_require__(504);
	var MeModel = __webpack_require__(507);
	var MainView = __webpack_require__(637);
	var Router = __webpack_require__(643);
	var Storage = __webpack_require__(654);
	var xmppEventHandlers = __webpack_require__(660);
	var pushNotifications = __webpack_require__(664);
	var Notify = __webpack_require__(665);
	var Desktop = __webpack_require__(667);
	var AppCache = __webpack_require__(671);
	var url = __webpack_require__(672);
	var SoundEffectManager = __webpack_require__(677);
	var app = null;

	var App = (function () {
	    function App() {
	        (0, _classCallCheck3.default)(this, App);
	    }

	    (0, _createClass3.default)(App, [{
	        key: 'launch',
	        value: function launch() {
	            function parseConfig(json) {
	                var config = json; //JSON.parse(json);
	                var credentials = config.credentials;
	                if (!credentials) return config;
	                for (var property in credentials) {
	                    if (!credentials.hasOwnProperty(property)) continue;
	                    var value = credentials[property];
	                    if (value.type === 'Buffer') {
	                        credentials[property] = new Buffer(value);
	                    }
	                }
	                return config;
	            }
	            var self = window['app'] = this;
	            //var config = localStorage['config'];
	            
		var config = null; //localStorage.config;

		var username = atob(SERVER_CONFIG.authorization.substring(6)).split(":")[0];
		var password = atob(SERVER_CONFIG.authorization.substring(6)).split(":")[1]; 

		var jid = username + "@" + SERVER_CONFIG.domain;
	            
	            if (!config) {
			config = {jid: jid, rosterVer: "0.1", domain: SERVER_CONFIG.domain, password: password, server: SERVER_CONFIG.name, wsURL: SERVER_CONFIG.wss, credentials: {username: username, password: password}}
	            }
	            app.config = parseConfig(config);
	            app.config.useStreamManagement = false;
	            if (SERVER_CONFIG.sasl) {
	                app.config.sasl = SERVER_CONFIG.sasl;
	            }
	            _.extend(this, Backbone.Events);
	            var profile = {};
	            asyncjs.series([function (cb) {
	                app.notifications = new Notify();
	                app.soundManager = new SoundEffectManager();
	                app.desktop = new Desktop();
	                app.cache = new AppCache();
	                app.storage = new Storage();
	                app.storage.open(cb);
	                app.composing = {};
	                app.timeInterval = 0;
	                app.mucInfos = [];
	            }, function (cb) {
	                app.storage.profiles.get(app.config.jid, function (err, res) {
	                    if (res) {
	                        profile = res;
	                        profile['jid'] = { full: app.config.jid, bare: app.config.jid };
	                        app.config.rosterVer = res.rosterVer;
	                    }
	                    cb();
	                });
	            }, function (cb) {
	                app.state = new AppState();
	                app.me = window['me'] = new MeModel(profile);
	                window.onbeforeunload = function () {
	                    if (app.api.sessionStarted) {
	                        app.api.disconnect();
	                    }
	                };
	                self.api = window['client'] = StanzaIO.createClient(app.config);
	                client.use(pushNotifications);
	                xmppEventHandlers(self.api, self);
	                self.api.once('session:started', function () {
	                    app.state.hasConnected = true;
	                    cb();
	                });
	                self.api.connect();
	            }, function (cb) {
	                app.soundManager.loadFile('sounds/ding.wav', 'ding');
	                app.soundManager.loadFile('sounds/threetone-alert.wav', 'threetone-alert');
	                cb();
	            }, function (cb) {
	                app.whenConnected(function () {
	                    function getInterval() {
	                        if (client.sessionStarted) {
	                            client.getTime(self.id, function (err, res) {
	                                if (err) return;
	                                self.timeInterval = res.time.utc - Date.now();
	                            });
	                            setTimeout(getInterval, 600000);
	                        }
	                    }
	                    getInterval();
	                });
	                cb();
	            }, function (cb) {
	                app.whenConnected(function () {
	                    me.publishAvatar();
	                });
	                function start() {
	                    var baseUrl = url.parse(SERVER_CONFIG.baseUrl);
	                    app.history.start({ pushState: false, root: baseUrl.pathname });
	                    if (app.history.fragment == '' && SERVER_CONFIG.startup) app.navigate(SERVER_CONFIG.startup);
	                    cb();
	                }
	                new Router();
	                app.history = Backbone.history;
	                app.history.on("route", function (route, params) {
                    	    console.log("history onroute", params);	                
	                    app.state.pageChanged = params;
	                });
	                self.view = new MainView({
	                    model: app.state,
	                    el: document.body
	                });
	                self.view.render();
	                if (me.contacts.length) {
	                    start();
	                } else {
	                    me.contacts.once('loaded', start);
	                }
	            }]);
	        }
	    }, {
	        key: 'whenConnected',
	        value: function whenConnected(func) {
	            if (app.api.sessionStarted) {
	                func();
	            } else {
	                app.api.once('session:started', func);
	            }
	        }
	    }, {
	        key: 'navigate',
	        value: function navigate(page) {
	            var url = page.charAt(0) === '/' ? page.slice(1) : page;
	            app.state.markActive();
	            app.history.navigate(url, true);
	        }
	    }, {
	        key: 'renderPage',
	        value: function renderPage(view, animation) {
	            var container = $('#pages');
	            if (app.currentPage) {
	                app.currentPage.hide(animation);
	            }
	            container.append(view.render(animation === 'none').el);
	            view.show(animation);
	        }
	    }, {
	        key: 'serverConfig',
	        value: function serverConfig() {
	            return SERVER_CONFIG;
	        }
	    }]);
	    return App;
	})();

	app = new App();
	module.exports = app;
	$(function () {
	    return app.launch();
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(205).Buffer, __webpack_require__(196)))

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global window, global*/
	var util = __webpack_require__(197)
	var assert = __webpack_require__(200)
	var now = __webpack_require__(201)

	var slice = Array.prototype.slice
	var console
	var times = {}

	if (typeof global !== "undefined" && global.console) {
	    console = global.console
	} else if (typeof window !== "undefined" && window.console) {
	    console = window.console
	} else {
	    console = {}
	}

	var functions = [
	    [log, "log"],
	    [info, "info"],
	    [warn, "warn"],
	    [error, "error"],
	    [time, "time"],
	    [timeEnd, "timeEnd"],
	    [trace, "trace"],
	    [dir, "dir"],
	    [consoleAssert, "assert"]
	]

	for (var i = 0; i < functions.length; i++) {
	    var tuple = functions[i]
	    var f = tuple[0]
	    var name = tuple[1]

	    if (!console[name]) {
	        console[name] = f
	    }
	}

	module.exports = console

	function log() {}

	function info() {
	    console.log.apply(console, arguments)
	}

	function warn() {
	    console.log.apply(console, arguments)
	}

	function error() {
	    console.warn.apply(console, arguments)
	}

	function time(label) {
	    times[label] = now()
	}

	function timeEnd(label) {
	    var time = times[label]
	    if (!time) {
	        throw new Error("No such label: " + label)
	    }

	    var duration = now() - time
	    console.log(label + ": " + duration + "ms")
	}

	function trace() {
	    var err = new Error()
	    err.name = "Trace"
	    err.message = util.format.apply(null, arguments)
	    console.error(err.stack)
	}

	function dir(object) {
	    console.log(util.inspect(object) + "\n")
	}

	function consoleAssert(expression) {
	    if (!expression) {
	        var arr = slice.call(arguments, 1)
	        assert.ok(false, util.format.apply(null, arr))
	    }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(198);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(199);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(189), __webpack_require__(196)))

/***/ },
/* 198 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 199 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(197);

	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 201 */
/***/ function(module, exports) {

	module.exports = now

	function now() {
	    return new Date().getTime()
	}


/***/ },
/* 202 */,
/* 203 */,
/* 204 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, console) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	var base64 = __webpack_require__(206)
	var ieee754 = __webpack_require__(207)
	var isArray = __webpack_require__(208)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer, (function() { return this; }()), __webpack_require__(196)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 207 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 208 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 209 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(211);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = (function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	})();

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(212), __esModule: true };

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(213);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ },
/* 213 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.10.1';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;

	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;

	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }

	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);

	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;

	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);

	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;

	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;

	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);

	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      if (pathKey !== undefined && pathKey in toObject(object)) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];

	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value && (value !== undefined || (key in toObject(object)));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');

	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);

	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;

	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;

	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;

	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;

	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);

	      view.set(new Uint8Array(buffer));
	      return result;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;

	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;

	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }

	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }

	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }

	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }

	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);

	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }

	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }

	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }

	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }

	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }

	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }

	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }

	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);

	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = func.name,
	          array = realNames[result],
	          length = array ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');

	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;

	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }

	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func);
	      if (!(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      var other = lodash[funcName];
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;

	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;

	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          result = [];

	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];

	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);

	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it is invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;

	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }

	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);

	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;

	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;

	      var interceptor = function(value) {
	        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      return baseAt(collection, baseFlatten(props));
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Checks if `value` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it is
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;

	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];

	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);

	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });

	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);

	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, isDeep);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, true);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 equivalents which return 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }

	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && reIsHostCtor.test(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object)));
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object != 'function' && isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object)) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);

	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });

	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it is invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : object[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : object[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }

	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it is created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it is set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj  vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);

	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }

	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);

	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);

	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), path + '');
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it is
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }

	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);

	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };

	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name,
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module), (function() { return this; }())))

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	//     Backbone.js 1.0.0

	//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
	//     Backbone may be freely distributed under the MIT license.
	//     For all details and documentation:
	//     http://backbonejs.org

	(function(){

	  // Initial Setup
	  // -------------

	  // Save a reference to the global object (`window` in the browser, `exports`
	  // on the server).
	  var root = this;

	  // Save the previous value of the `Backbone` variable, so that it can be
	  // restored later on, if `noConflict` is used.
	  var previousBackbone = root.Backbone;

	  // Create local references to array methods we'll want to use later.
	  var array = [];
	  var push = array.push;
	  var slice = array.slice;
	  var splice = array.splice;

	  // The top-level namespace. All public Backbone classes and modules will
	  // be attached to this. Exported for both the browser and the server.
	  var Backbone;
	  if (true) {
	    Backbone = exports;
	  } else {
	    Backbone = root.Backbone = {};
	  }

	  // Current version of the library. Keep in sync with `package.json`.
	  Backbone.VERSION = '1.0.0';

	  // Require Underscore, if we're on the server, and it's not already present.
	  var _ = root._;
	  if (!_ && ("function" !== 'undefined')) _ = __webpack_require__(217);

	  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	  // the `$` variable.
	  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

	  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	  // to its previous owner. Returns a reference to this Backbone object.
	  Backbone.noConflict = function() {
	    root.Backbone = previousBackbone;
	    return this;
	  };

	  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	  // set a `X-Http-Method-Override` header.
	  Backbone.emulateHTTP = false;

	  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
	  // `application/json` requests ... will encode the body as
	  // `application/x-www-form-urlencoded` instead and will send the model in a
	  // form param named `model`.
	  Backbone.emulateJSON = false;

	  // Backbone.Events
	  // ---------------

	  // A module that can be mixed in to *any object* in order to provide it with
	  // custom events. You may bind with `on` or remove with `off` callback
	  // functions to an event; `trigger`-ing an event fires all callbacks in
	  // succession.
	  //
	  //     var object = {};
	  //     _.extend(object, Backbone.Events);
	  //     object.on('expand', function(){ alert('expanded'); });
	  //     object.trigger('expand');
	  //
	  var Events = Backbone.Events = {

	    // Bind an event to a `callback` function. Passing `"all"` will bind
	    // the callback to all events fired.
	    on: function(name, callback, context) {
	      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
	      this._events || (this._events = {});
	      var events = this._events[name] || (this._events[name] = []);
	      events.push({callback: callback, context: context, ctx: context || this});
	      return this;
	    },

	    // Bind an event to only be triggered a single time. After the first time
	    // the callback is invoked, it will be removed.
	    once: function(name, callback, context) {
	      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
	      var self = this;
	      var once = _.once(function() {
	        self.off(name, once);
	        callback.apply(this, arguments);
	      });
	      once._callback = callback;
	      return this.on(name, once, context);
	    },

	    // Remove one or many callbacks. If `context` is null, removes all
	    // callbacks with that function. If `callback` is null, removes all
	    // callbacks for the event. If `name` is null, removes all bound
	    // callbacks for all events.
	    off: function(name, callback, context) {
	      var retain, ev, events, names, i, l, j, k;
	      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
	      if (!name && !callback && !context) {
	        this._events = {};
	        return this;
	      }

	      names = name ? [name] : _.keys(this._events);
	      for (i = 0, l = names.length; i < l; i++) {
	        name = names[i];
	        if (events = this._events[name]) {
	          this._events[name] = retain = [];
	          if (callback || context) {
	            for (j = 0, k = events.length; j < k; j++) {
	              ev = events[j];
	              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
	                  (context && context !== ev.context)) {
	                retain.push(ev);
	              }
	            }
	          }
	          if (!retain.length) delete this._events[name];
	        }
	      }

	      return this;
	    },

	    // Trigger one or many events, firing all bound callbacks. Callbacks are
	    // passed the same arguments as `trigger` is, apart from the event name
	    // (unless you're listening on `"all"`, which will cause your callback to
	    // receive the true name of the event as the first argument).
	    trigger: function(name) {
	      if (!this._events) return this;
	      var args = slice.call(arguments, 1);
	      if (!eventsApi(this, 'trigger', name, args)) return this;
	      var events = this._events[name];
	      var allEvents = this._events.all;
	      if (events) triggerEvents(events, args);
	      if (allEvents) triggerEvents(allEvents, arguments);
	      return this;
	    },

	    // Tell this object to stop listening to either specific events ... or
	    // to every object it's currently listening to.
	    stopListening: function(obj, name, callback) {
	      var listeners = this._listeners;
	      if (!listeners) return this;
	      var deleteListener = !name && !callback;
	      if (typeof name === 'object') callback = this;
	      if (obj) (listeners = {})[obj._listenerId] = obj;
	      for (var id in listeners) {
	        listeners[id].off(name, callback, this);
	        if (deleteListener) delete this._listeners[id];
	      }
	      return this;
	    }

	  };

	  // Regular expression used to split event strings.
	  var eventSplitter = /\s+/;

	  // Implement fancy features of the Events API such as multiple event
	  // names `"change blur"` and jQuery-style event maps `{change: action}`
	  // in terms of the existing API.
	  var eventsApi = function(obj, action, name, rest) {
	    if (!name) return true;

	    // Handle event maps.
	    if (typeof name === 'object') {
	      for (var key in name) {
	        obj[action].apply(obj, [key, name[key]].concat(rest));
	      }
	      return false;
	    }

	    // Handle space separated event names.
	    if (eventSplitter.test(name)) {
	      var names = name.split(eventSplitter);
	      for (var i = 0, l = names.length; i < l; i++) {
	        obj[action].apply(obj, [names[i]].concat(rest));
	      }
	      return false;
	    }

	    return true;
	  };

	  // A difficult-to-believe, but optimized internal dispatch function for
	  // triggering events. Tries to keep the usual cases speedy (most internal
	  // Backbone events have 3 arguments).
	  var triggerEvents = function(events, args) {
	    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
	    switch (args.length) {
	      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
	      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
	      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
	      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
	      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
	    }
	  };

	  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

	  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
	  // listen to an event in another object ... keeping track of what it's
	  // listening to.
	  _.each(listenMethods, function(implementation, method) {
	    Events[method] = function(obj, name, callback) {
	      var listeners = this._listeners || (this._listeners = {});
	      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
	      listeners[id] = obj;
	      if (typeof name === 'object') callback = this;
	      obj[implementation](name, callback, this);
	      return this;
	    };
	  });

	  // Aliases for backwards compatibility.
	  Events.bind   = Events.on;
	  Events.unbind = Events.off;

	  // Allow the `Backbone` object to serve as a global event bus, for folks who
	  // want global "pubsub" in a convenient place.
	  _.extend(Backbone, Events);

	  // Backbone.Model
	  // --------------

	  // Backbone **Models** are the basic data object in the framework --
	  // frequently representing a row in a table in a database on your server.
	  // A discrete chunk of data and a bunch of useful, related methods for
	  // performing computations and transformations on that data.

	  // Create a new model with the specified attributes. A client id (`cid`)
	  // is automatically generated and assigned for you.
	  var Model = Backbone.Model = function(attributes, options) {
	    var defaults;
	    var attrs = attributes || {};
	    options || (options = {});
	    this.cid = _.uniqueId('c');
	    this.attributes = {};
	    _.extend(this, _.pick(options, modelOptions));
	    if (options.parse) attrs = this.parse(attrs, options) || {};
	    if (defaults = _.result(this, 'defaults')) {
	      attrs = _.defaults({}, attrs, defaults);
	    }
	    this.set(attrs, options);
	    this.changed = {};
	    this.initialize.apply(this, arguments);
	  };

	  // A list of options to be attached directly to the model, if provided.
	  var modelOptions = ['url', 'urlRoot', 'collection'];

	  // Attach all inheritable methods to the Model prototype.
	  _.extend(Model.prototype, Events, {

	    // A hash of attributes whose current and previous value differ.
	    changed: null,

	    // The value returned during the last failed validation.
	    validationError: null,

	    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
	    // CouchDB users may want to set this to `"_id"`.
	    idAttribute: 'id',

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Return a copy of the model's `attributes` object.
	    toJSON: function(options) {
	      return _.clone(this.attributes);
	    },

	    // Proxy `Backbone.sync` by default -- but override this if you need
	    // custom syncing semantics for *this* particular model.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Get the value of an attribute.
	    get: function(attr) {
	      return this.attributes[attr];
	    },

	    // Get the HTML-escaped value of an attribute.
	    escape: function(attr) {
	      return _.escape(this.get(attr));
	    },

	    // Returns `true` if the attribute contains a value that is not null
	    // or undefined.
	    has: function(attr) {
	      return this.get(attr) != null;
	    },

	    // Set a hash of model attributes on the object, firing `"change"`. This is
	    // the core primitive operation of a model, updating the data and notifying
	    // anyone who needs to know about the change in state. The heart of the beast.
	    set: function(key, val, options) {
	      var attr, attrs, unset, changes, silent, changing, prev, current;
	      if (key == null) return this;

	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      options || (options = {});

	      // Run validation.
	      if (!this._validate(attrs, options)) return false;

	      // Extract attributes and options.
	      unset           = options.unset;
	      silent          = options.silent;
	      changes         = [];
	      changing        = this._changing;
	      this._changing  = true;

	      if (!changing) {
	        this._previousAttributes = _.clone(this.attributes);
	        this.changed = {};
	      }
	      current = this.attributes, prev = this._previousAttributes;

	      // Check for changes of `id`.
	      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

	      // For each `set` attribute, update or delete the current value.
	      for (attr in attrs) {
	        val = attrs[attr];
	        if (!_.isEqual(current[attr], val)) changes.push(attr);
	        if (!_.isEqual(prev[attr], val)) {
	          this.changed[attr] = val;
	        } else {
	          delete this.changed[attr];
	        }
	        unset ? delete current[attr] : current[attr] = val;
	      }

	      // Trigger all relevant attribute changes.
	      if (!silent) {
	        if (changes.length) this._pending = true;
	        for (var i = 0, l = changes.length; i < l; i++) {
	          this.trigger('change:' + changes[i], this, current[changes[i]], options);
	        }
	      }

	      // You might be wondering why there's a `while` loop here. Changes can
	      // be recursively nested within `"change"` events.
	      if (changing) return this;
	      if (!silent) {
	        while (this._pending) {
	          this._pending = false;
	          this.trigger('change', this, options);
	        }
	      }
	      this._pending = false;
	      this._changing = false;
	      return this;
	    },

	    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
	    // if the attribute doesn't exist.
	    unset: function(attr, options) {
	      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
	    },

	    // Clear all attributes on the model, firing `"change"`.
	    clear: function(options) {
	      var attrs = {};
	      for (var key in this.attributes) attrs[key] = void 0;
	      return this.set(attrs, _.extend({}, options, {unset: true}));
	    },

	    // Determine if the model has changed since the last `"change"` event.
	    // If you specify an attribute name, determine if that attribute has changed.
	    hasChanged: function(attr) {
	      if (attr == null) return !_.isEmpty(this.changed);
	      return _.has(this.changed, attr);
	    },

	    // Return an object containing all the attributes that have changed, or
	    // false if there are no changed attributes. Useful for determining what
	    // parts of a view need to be updated and/or what attributes need to be
	    // persisted to the server. Unset attributes will be set to undefined.
	    // You can also pass an attributes object to diff against the model,
	    // determining if there *would be* a change.
	    changedAttributes: function(diff) {
	      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
	      var val, changed = false;
	      var old = this._changing ? this._previousAttributes : this.attributes;
	      for (var attr in diff) {
	        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
	        (changed || (changed = {}))[attr] = val;
	      }
	      return changed;
	    },

	    // Get the previous value of an attribute, recorded at the time the last
	    // `"change"` event was fired.
	    previous: function(attr) {
	      if (attr == null || !this._previousAttributes) return null;
	      return this._previousAttributes[attr];
	    },

	    // Get all of the attributes of the model at the time of the previous
	    // `"change"` event.
	    previousAttributes: function() {
	      return _.clone(this._previousAttributes);
	    },

	    // Fetch the model from the server. If the server's representation of the
	    // model differs from its current attributes, they will be overridden,
	    // triggering a `"change"` event.
	    fetch: function(options) {
	      options = options ? _.clone(options) : {};
	      if (options.parse === void 0) options.parse = true;
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        if (!model.set(model.parse(resp, options), options)) return false;
	        if (success) success(model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Set a hash of model attributes, and sync the model to the server.
	    // If the server returns an attributes hash that differs, the model's
	    // state will be `set` again.
	    save: function(key, val, options) {
	      var attrs, method, xhr, attributes = this.attributes;

	      // Handle both `"key", value` and `{key: value}` -style arguments.
	      if (key == null || typeof key === 'object') {
	        attrs = key;
	        options = val;
	      } else {
	        (attrs = {})[key] = val;
	      }

	      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
	      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

	      options = _.extend({validate: true}, options);

	      // Do not persist invalid models.
	      if (!this._validate(attrs, options)) return false;

	      // Set temporary attributes if `{wait: true}`.
	      if (attrs && options.wait) {
	        this.attributes = _.extend({}, attributes, attrs);
	      }

	      // After a successful server-side save, the client is (optionally)
	      // updated with the server-side state.
	      if (options.parse === void 0) options.parse = true;
	      var model = this;
	      var success = options.success;
	      options.success = function(resp) {
	        // Ensure attributes are restored during synchronous saves.
	        model.attributes = attributes;
	        var serverAttrs = model.parse(resp, options);
	        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
	        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
	          return false;
	        }
	        if (success) success(model, resp, options);
	        model.trigger('sync', model, resp, options);
	      };
	      wrapError(this, options);

	      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	      if (method === 'patch') options.attrs = attrs;
	      xhr = this.sync(method, this, options);

	      // Restore attributes.
	      if (attrs && options.wait) this.attributes = attributes;

	      return xhr;
	    },

	    // Destroy this model on the server if it was already persisted.
	    // Optimistically removes the model from its collection, if it has one.
	    // If `wait: true` is passed, waits for the server to respond before removal.
	    destroy: function(options) {
	      options = options ? _.clone(options) : {};
	      var model = this;
	      var success = options.success;

	      var destroy = function() {
	        model.trigger('destroy', model, model.collection, options);
	      };

	      options.success = function(resp) {
	        if (options.wait || model.isNew()) destroy();
	        if (success) success(model, resp, options);
	        if (!model.isNew()) model.trigger('sync', model, resp, options);
	      };

	      if (this.isNew()) {
	        options.success();
	        return false;
	      }
	      wrapError(this, options);

	      var xhr = this.sync('delete', this, options);
	      if (!options.wait) destroy();
	      return xhr;
	    },

	    // Default URL for the model's representation on the server -- if you're
	    // using Backbone's restful methods, override this to change the endpoint
	    // that will be called.
	    url: function() {
	      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
	      if (this.isNew()) return base;
	      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
	    },

	    // **parse** converts a response into the hash of attributes to be `set` on
	    // the model. The default implementation is just to pass the response along.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new model with identical attributes to this one.
	    clone: function() {
	      return new this.constructor(this.attributes);
	    },

	    // A model is new if it has never been saved to the server, and lacks an id.
	    isNew: function() {
	      return this.id == null;
	    },

	    // Check if the model is currently in a valid state.
	    isValid: function(options) {
	      return this._validate({}, _.extend(options || {}, { validate: true }));
	    },

	    // Run validation against the next complete set of model attributes,
	    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	    _validate: function(attrs, options) {
	      if (!options.validate || !this.validate) return true;
	      attrs = _.extend({}, this.attributes, attrs);
	      var error = this.validationError = this.validate(attrs, options) || null;
	      if (!error) return true;
	      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
	      return false;
	    }

	  });

	  // Underscore methods that we want to implement on the Model.
	  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

	  // Mix in each Underscore method as a proxy to `Model#attributes`.
	  _.each(modelMethods, function(method) {
	    Model.prototype[method] = function() {
	      var args = slice.call(arguments);
	      args.unshift(this.attributes);
	      return _[method].apply(_, args);
	    };
	  });

	  // Backbone.Collection
	  // -------------------

	  // If models tend to represent a single row of data, a Backbone Collection is
	  // more analagous to a table full of data ... or a small slice or page of that
	  // table, or a collection of rows that belong together for a particular reason
	  // -- all of the messages in this particular folder, all of the documents
	  // belonging to this particular author, and so on. Collections maintain
	  // indexes of their models, both in order, and for lookup by `id`.

	  // Create a new **Collection**, perhaps to contain a specific type of `model`.
	  // If a `comparator` is specified, the Collection will maintain
	  // its models in sort order, as they're added and removed.
	  var Collection = Backbone.Collection = function(models, options) {
	    options || (options = {});
	    if (options.url) this.url = options.url;
	    if (options.model) this.model = options.model;
	    if (options.comparator !== void 0) this.comparator = options.comparator;
	    this._reset();
	    this.initialize.apply(this, arguments);
	    if (models) this.reset(models, _.extend({silent: true}, options));
	  };

	  // Default options for `Collection#set`.
	  var setOptions = {add: true, remove: true, merge: true};
	  var addOptions = {add: true, merge: false, remove: false};

	  // Define the Collection's inheritable methods.
	  _.extend(Collection.prototype, Events, {

	    // The default model for a collection is just a **Backbone.Model**.
	    // This should be overridden in most cases.
	    model: Model,

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // The JSON representation of a Collection is an array of the
	    // models' attributes.
	    toJSON: function(options) {
	      return this.map(function(model){ return model.toJSON(options); });
	    },

	    // Proxy `Backbone.sync` by default.
	    sync: function() {
	      return Backbone.sync.apply(this, arguments);
	    },

	    // Add a model, or list of models to the set.
	    add: function(models, options) {
	      return this.set(models, _.defaults(options || {}, addOptions));
	    },

	    // Remove a model, or a list of models from the set.
	    remove: function(models, options) {
	      models = _.isArray(models) ? models.slice() : [models];
	      options || (options = {});
	      var i, l, index, model;
	      for (i = 0, l = models.length; i < l; i++) {
	        model = this.get(models[i]);
	        if (!model) continue;
	        delete this._byId[model.id];
	        delete this._byId[model.cid];
	        index = this.indexOf(model);
	        this.models.splice(index, 1);
	        this.length--;
	        if (!options.silent) {
	          options.index = index;
	          model.trigger('remove', model, this, options);
	        }
	        this._removeReference(model);
	      }
	      return this;
	    },

	    // Update a collection by `set`-ing a new list of models, adding new ones,
	    // removing models that are no longer present, and merging models that
	    // already exist in the collection, as necessary. Similar to **Model#set**,
	    // the core operation for updating the data contained by the collection.
	    set: function(models, options) {
	      options = _.defaults(options || {}, setOptions);
	      if (options.parse) models = this.parse(models, options);
	      if (!_.isArray(models)) models = models ? [models] : [];
	      var i, l, model, attrs, existing, sort;
	      var at = options.at;
	      var sortable = this.comparator && (at == null) && options.sort !== false;
	      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
	      var toAdd = [], toRemove = [], modelMap = {};

	      // Turn bare objects into model references, and prevent invalid models
	      // from being added.
	      for (i = 0, l = models.length; i < l; i++) {
	        if (!(model = this._prepareModel(models[i], options))) continue;

	        // If a duplicate is found, prevent it from being added and
	        // optionally merge it into the existing model.
	        if (existing = this.get(model)) {
	          if (options.remove) modelMap[existing.cid] = true;
	          if (options.merge) {
	            existing.set(model.attributes, options);
	            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
	          }

	        // This is a new model, push it to the `toAdd` list.
	        } else if (options.add) {
	          toAdd.push(model);

	          // Listen to added models' events, and index models for lookup by
	          // `id` and by `cid`.
	          model.on('all', this._onModelEvent, this);
	          this._byId[model.cid] = model;
	          if (model.id != null) this._byId[model.id] = model;
	        }
	      }

	      // Remove nonexistent models if appropriate.
	      if (options.remove) {
	        for (i = 0, l = this.length; i < l; ++i) {
	          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
	        }
	        if (toRemove.length) this.remove(toRemove, options);
	      }

	      // See if sorting is needed, update `length` and splice in new models.
	      if (toAdd.length) {
	        if (sortable) sort = true;
	        this.length += toAdd.length;
	        if (at != null) {
	          splice.apply(this.models, [at, 0].concat(toAdd));
	        } else {
	          push.apply(this.models, toAdd);
	        }
	      }

	      // Silently sort the collection if appropriate.
	      if (sort) this.sort({silent: true});

	      if (options.silent) return this;

	      // Trigger `add` events.
	      for (i = 0, l = toAdd.length; i < l; i++) {
	        (model = toAdd[i]).trigger('add', model, this, options);
	      }

	      // Trigger `sort` if the collection was sorted.
	      if (sort) this.trigger('sort', this, options);
	      return this;
	    },

	    // When you have more items than you want to add or remove individually,
	    // you can reset the entire set with a new list of models, without firing
	    // any granular `add` or `remove` events. Fires `reset` when finished.
	    // Useful for bulk operations and optimizations.
	    reset: function(models, options) {
	      options || (options = {});
	      for (var i = 0, l = this.models.length; i < l; i++) {
	        this._removeReference(this.models[i]);
	      }
	      options.previousModels = this.models;
	      this._reset();
	      this.add(models, _.extend({silent: true}, options));
	      if (!options.silent) this.trigger('reset', this, options);
	      return this;
	    },

	    // Add a model to the end of the collection.
	    push: function(model, options) {
	      model = this._prepareModel(model, options);
	      this.add(model, _.extend({at: this.length}, options));
	      return model;
	    },

	    // Remove a model from the end of the collection.
	    pop: function(options) {
	      var model = this.at(this.length - 1);
	      this.remove(model, options);
	      return model;
	    },

	    // Add a model to the beginning of the collection.
	    unshift: function(model, options) {
	      model = this._prepareModel(model, options);
	      this.add(model, _.extend({at: 0}, options));
	      return model;
	    },

	    // Remove a model from the beginning of the collection.
	    shift: function(options) {
	      var model = this.at(0);
	      this.remove(model, options);
	      return model;
	    },

	    // Slice out a sub-array of models from the collection.
	    slice: function(begin, end) {
	      return this.models.slice(begin, end);
	    },

	    // Get a model from the set by id.
	    get: function(obj) {
	      if (obj == null) return void 0;
	      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
	    },

	    // Get the model at the given index.
	    at: function(index) {
	      return this.models[index];
	    },

	    // Return models with matching attributes. Useful for simple cases of
	    // `filter`.
	    where: function(attrs, first) {
	      if (_.isEmpty(attrs)) return first ? void 0 : [];
	      return this[first ? 'find' : 'filter'](function(model) {
	        for (var key in attrs) {
	          if (attrs[key] !== model.get(key)) return false;
	        }
	        return true;
	      });
	    },

	    // Return the first model with matching attributes. Useful for simple cases
	    // of `find`.
	    findWhere: function(attrs) {
	      return this.where(attrs, true);
	    },

	    // Force the collection to re-sort itself. You don't need to call this under
	    // normal circumstances, as the set will maintain sort order as each item
	    // is added.
	    sort: function(options) {
	      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
	      options || (options = {});

	      // Run sort based on type of `comparator`.
	      if (_.isString(this.comparator) || this.comparator.length === 1) {
	        this.models = this.sortBy(this.comparator, this);
	      } else {
	        this.models.sort(_.bind(this.comparator, this));
	      }

	      if (!options.silent) this.trigger('sort', this, options);
	      return this;
	    },

	    // Figure out the smallest index at which a model should be inserted so as
	    // to maintain order.
	    sortedIndex: function(model, value, context) {
	      value || (value = this.comparator);
	      var iterator = _.isFunction(value) ? value : function(model) {
	        return model.get(value);
	      };
	      return _.sortedIndex(this.models, model, iterator, context);
	    },

	    // Pluck an attribute from each model in the collection.
	    pluck: function(attr) {
	      return _.invoke(this.models, 'get', attr);
	    },

	    // Fetch the default set of models for this collection, resetting the
	    // collection when they arrive. If `reset: true` is passed, the response
	    // data will be passed through the `reset` method instead of `set`.
	    fetch: function(options) {
	      options = options ? _.clone(options) : {};
	      if (options.parse === void 0) options.parse = true;
	      var success = options.success;
	      var collection = this;
	      options.success = function(resp) {
	        var method = options.reset ? 'reset' : 'set';
	        collection[method](resp, options);
	        if (success) success(collection, resp, options);
	        collection.trigger('sync', collection, resp, options);
	      };
	      wrapError(this, options);
	      return this.sync('read', this, options);
	    },

	    // Create a new instance of a model in this collection. Add the model to the
	    // collection immediately, unless `wait: true` is passed, in which case we
	    // wait for the server to agree.
	    create: function(model, options) {
	      options = options ? _.clone(options) : {};
	      if (!(model = this._prepareModel(model, options))) return false;
	      if (!options.wait) this.add(model, options);
	      var collection = this;
	      var success = options.success;
	      options.success = function(resp) {
	        if (options.wait) collection.add(model, options);
	        if (success) success(model, resp, options);
	      };
	      model.save(null, options);
	      return model;
	    },

	    // **parse** converts a response into a list of models to be added to the
	    // collection. The default implementation is just to pass it through.
	    parse: function(resp, options) {
	      return resp;
	    },

	    // Create a new collection with an identical list of models as this one.
	    clone: function() {
	      return new this.constructor(this.models);
	    },

	    // Private method to reset all internal state. Called when the collection
	    // is first initialized or reset.
	    _reset: function() {
	      this.length = 0;
	      this.models = [];
	      this._byId  = {};
	    },

	    // Prepare a hash of attributes (or other model) to be added to this
	    // collection.
	    _prepareModel: function(attrs, options) {
	      if (attrs instanceof Model) {
	        if (!attrs.collection) attrs.collection = this;
	        return attrs;
	      }
	      options || (options = {});
	      options.collection = this;
	      var model = new this.model(attrs, options);
	      if (!model._validate(attrs, options)) {
	        this.trigger('invalid', this, attrs, options);
	        return false;
	      }
	      return model;
	    },

	    // Internal method to sever a model's ties to a collection.
	    _removeReference: function(model) {
	      if (this === model.collection) delete model.collection;
	      model.off('all', this._onModelEvent, this);
	    },

	    // Internal method called every time a model in the set fires an event.
	    // Sets need to update their indexes when models change ids. All other
	    // events simply proxy through. "add" and "remove" events that originate
	    // in other collections are ignored.
	    _onModelEvent: function(event, model, collection, options) {
	      if ((event === 'add' || event === 'remove') && collection !== this) return;
	      if (event === 'destroy') this.remove(model, options);
	      if (model && event === 'change:' + model.idAttribute) {
	        delete this._byId[model.previous(model.idAttribute)];
	        if (model.id != null) this._byId[model.id] = model;
	      }
	      this.trigger.apply(this, arguments);
	    }

	  });

	  // Underscore methods that we want to implement on the Collection.
	  // 90% of the core usefulness of Backbone Collections is actually implemented
	  // right here:
	  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
	    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
	    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
	    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
	    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
	    'isEmpty', 'chain'];

	  // Mix in each Underscore method as a proxy to `Collection#models`.
	  _.each(methods, function(method) {
	    Collection.prototype[method] = function() {
	      var args = slice.call(arguments);
	      args.unshift(this.models);
	      return _[method].apply(_, args);
	    };
	  });

	  // Underscore methods that take a property name as an argument.
	  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

	  // Use attributes instead of properties.
	  _.each(attributeMethods, function(method) {
	    Collection.prototype[method] = function(value, context) {
	      var iterator = _.isFunction(value) ? value : function(model) {
	        return model.get(value);
	      };
	      return _[method](this.models, iterator, context);
	    };
	  });

	  // Backbone.View
	  // -------------

	  // Backbone Views are almost more convention than they are actual code. A View
	  // is simply a JavaScript object that represents a logical chunk of UI in the
	  // DOM. This might be a single item, an entire list, a sidebar or panel, or
	  // even the surrounding frame which wraps your whole app. Defining a chunk of
	  // UI as a **View** allows you to define your DOM events declaratively, without
	  // having to worry about render order ... and makes it easy for the view to
	  // react to specific changes in the state of your models.

	  // Creating a Backbone.View creates its initial element outside of the DOM,
	  // if an existing element is not provided...
	  var View = Backbone.View = function(options) {
	    this.cid = _.uniqueId('view');
	    this._configure(options || {});
	    this._ensureElement();
	    this.initialize.apply(this, arguments);
	    this.delegateEvents();
	  };

	  // Cached regex to split keys for `delegate`.
	  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	  // List of view options to be merged as properties.
	  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

	  // Set up all inheritable **Backbone.View** properties and methods.
	  _.extend(View.prototype, Events, {

	    // The default `tagName` of a View's element is `"div"`.
	    tagName: 'div',

	    // jQuery delegate for element lookup, scoped to DOM elements within the
	    // current view. This should be prefered to global lookups where possible.
	    $: function(selector) {
	      return this.$el.find(selector);
	    },

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // **render** is the core function that your view should override, in order
	    // to populate its element (`this.el`), with the appropriate HTML. The
	    // convention is for **render** to always return `this`.
	    render: function() {
	      return this;
	    },

	    // Remove this view by taking the element out of the DOM, and removing any
	    // applicable Backbone.Events listeners.
	    remove: function() {
	      this.$el.remove();
	      this.stopListening();
	      return this;
	    },

	    // Change the view's element (`this.el` property), including event
	    // re-delegation.
	    setElement: function(element, delegate) {
	      if (this.$el) this.undelegateEvents();
	      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
	      this.el = this.$el[0];
	      if (delegate !== false) this.delegateEvents();
	      return this;
	    },

	    // Set callbacks, where `this.events` is a hash of
	    //
	    // *{"event selector": "callback"}*
	    //
	    //     {
	    //       'mousedown .title':  'edit',
	    //       'click .button':     'save'
	    //       'click .open':       function(e) { ... }
	    //     }
	    //
	    // pairs. Callbacks will be bound to the view, with `this` set properly.
	    // Uses event delegation for efficiency.
	    // Omitting the selector binds the event to `this.el`.
	    // This only works for delegate-able events: not `focus`, `blur`, and
	    // not `change`, `submit`, and `reset` in Internet Explorer.
	    delegateEvents: function(events) {
	      if (!(events || (events = _.result(this, 'events')))) return this;
	      this.undelegateEvents();
	      for (var key in events) {
	        var method = events[key];
	        if (!_.isFunction(method)) method = this[events[key]];
	        if (!method) continue;

	        var match = key.match(delegateEventSplitter);
	        var eventName = match[1], selector = match[2];
	        method = _.bind(method, this);
	        eventName += '.delegateEvents' + this.cid;
	        if (selector === '') {
	          this.$el.on(eventName, method);
	        } else {
	          this.$el.on(eventName, selector, method);
	        }
	      }
	      return this;
	    },

	    // Clears all callbacks previously bound to the view with `delegateEvents`.
	    // You usually don't need to use this, but may wish to if you have multiple
	    // Backbone views attached to the same DOM element.
	    undelegateEvents: function() {
	      this.$el.off('.delegateEvents' + this.cid);
	      return this;
	    },

	    // Performs the initial configuration of a View with a set of options.
	    // Keys with special meaning *(e.g. model, collection, id, className)* are
	    // attached directly to the view.  See `viewOptions` for an exhaustive
	    // list.
	    _configure: function(options) {
	      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
	      _.extend(this, _.pick(options, viewOptions));
	      this.options = options;
	    },

	    // Ensure that the View has a DOM element to render into.
	    // If `this.el` is a string, pass it through `$()`, take the first
	    // matching element, and re-assign it to `el`. Otherwise, create
	    // an element from the `id`, `className` and `tagName` properties.
	    _ensureElement: function() {
	      if (!this.el) {
	        var attrs = _.extend({}, _.result(this, 'attributes'));
	        if (this.id) attrs.id = _.result(this, 'id');
	        if (this.className) attrs['class'] = _.result(this, 'className');
	        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
	        this.setElement($el, false);
	      } else {
	        this.setElement(_.result(this, 'el'), false);
	      }
	    }

	  });

	  // Backbone.sync
	  // -------------

	  // Override this function to change the manner in which Backbone persists
	  // models to the server. You will be passed the type of request, and the
	  // model in question. By default, makes a RESTful Ajax request
	  // to the model's `url()`. Some possible customizations could be:
	  //
	  // * Use `setTimeout` to batch rapid-fire updates into a single request.
	  // * Send up the models as XML instead of JSON.
	  // * Persist models via WebSockets instead of Ajax.
	  //
	  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	  // as `POST`, with a `_method` parameter containing the true HTTP method,
	  // as well as all requests with the body as `application/x-www-form-urlencoded`
	  // instead of `application/json` with the model in a param named `model`.
	  // Useful when interfacing with server-side languages like **PHP** that make
	  // it difficult to read the body of `PUT` requests.
	  Backbone.sync = function(method, model, options) {
	    var type = methodMap[method];

	    // Default options, unless specified.
	    _.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });

	    // Default JSON-request options.
	    var params = {type: type, dataType: 'json'};

	    // Ensure that we have a URL.
	    if (!options.url) {
	      params.url = _.result(model, 'url') || urlError();
	    }

	    // Ensure that we have the appropriate request data.
	    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	    }

	    // For older servers, emulate JSON by encoding the request into an HTML-form.
	    if (options.emulateJSON) {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? {model: params.data} : {};
	    }

	    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	    // And an `X-HTTP-Method-Override` header.
	    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
	      params.type = 'POST';
	      if (options.emulateJSON) params.data._method = type;
	      var beforeSend = options.beforeSend;
	      options.beforeSend = function(xhr) {
	        xhr.setRequestHeader('X-HTTP-Method-Override', type);
	        if (beforeSend) return beforeSend.apply(this, arguments);
	      };
	    }

	    // Don't process data on a non-GET request.
	    if (params.type !== 'GET' && !options.emulateJSON) {
	      params.processData = false;
	    }

	    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
	    // that still has ActiveX enabled by default, override jQuery to use that
	    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
	    if (params.type === 'PATCH' && window.ActiveXObject &&
	          !(window.external && window.external.msActiveXFilteringEnabled)) {
	      params.xhr = function() {
	        return new ActiveXObject("Microsoft.XMLHTTP");
	      };
	    }

	    // Make the request, allowing the user to override any Ajax options.
	    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
	    model.trigger('request', model, xhr, options);
	    return xhr;
	  };

	  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	  var methodMap = {
	    'create': 'POST',
	    'update': 'PUT',
	    'patch':  'PATCH',
	    'delete': 'DELETE',
	    'read':   'GET'
	  };

	  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	  // Override this if you'd like to use a different library.
	  Backbone.ajax = function() {
	    return Backbone.$.ajax.apply(Backbone.$, arguments);
	  };

	  // Backbone.Router
	  // ---------------

	  // Routers map faux-URLs to actions, and fire events when routes are
	  // matched. Creating a new one sets its `routes` hash, if not set statically.
	  var Router = Backbone.Router = function(options) {
	    options || (options = {});
	    if (options.routes) this.routes = options.routes;
	    this._bindRoutes();
	    this.initialize.apply(this, arguments);
	  };

	  // Cached regular expressions for matching named param parts and splatted
	  // parts of route strings.
	  var optionalParam = /\((.*?)\)/g;
	  var namedParam    = /(\(\?)?:\w+/g;
	  var splatParam    = /\*\w+/g;
	  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

	  // Set up all inheritable **Backbone.Router** properties and methods.
	  _.extend(Router.prototype, Events, {

	    // Initialize is an empty function by default. Override it with your own
	    // initialization logic.
	    initialize: function(){},

	    // Manually bind a single named route to a callback. For example:
	    //
	    //     this.route('search/:query/p:num', 'search', function(query, num) {
	    //       ...
	    //     });
	    //
	    route: function(route, name, callback) {
	      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
	      if (_.isFunction(name)) {
	        callback = name;
	        name = '';
	      }
	      if (!callback) callback = this[name];
	      var router = this;
	      Backbone.history.route(route, function(fragment) {
	        var args = router._extractParameters(route, fragment);
	        callback && callback.apply(router, args);
	        router.trigger.apply(router, ['route:' + name].concat(args));
	        router.trigger('route', name, args);
	        Backbone.history.trigger('route', router, name, args);
	      });
	      return this;
	    },

	    // Simple proxy to `Backbone.history` to save a fragment into the history.
	    navigate: function(fragment, options) {
	      Backbone.history.navigate(fragment, options);
	      return this;
	    },

	    // Bind all defined routes to `Backbone.history`. We have to reverse the
	    // order of the routes here to support behavior where the most general
	    // routes can be defined at the bottom of the route map.
	    _bindRoutes: function() {
	      if (!this.routes) return;
	      this.routes = _.result(this, 'routes');
	      var route, routes = _.keys(this.routes);
	      while ((route = routes.pop()) != null) {
	        this.route(route, this.routes[route]);
	      }
	    },

	    // Convert a route string into a regular expression, suitable for matching
	    // against the current location hash.
	    _routeToRegExp: function(route) {
	      route = route.replace(escapeRegExp, '\\$&')
	                   .replace(optionalParam, '(?:$1)?')
	                   .replace(namedParam, function(match, optional){
	                     return optional ? match : '([^\/]+)';
	                   })
	                   .replace(splatParam, '(.*?)');
	      return new RegExp('^' + route + '$');
	    },

	    // Given a route, and a URL fragment that it matches, return the array of
	    // extracted decoded parameters. Empty or unmatched parameters will be
	    // treated as `null` to normalize cross-browser behavior.
	    _extractParameters: function(route, fragment) {
	      var params = route.exec(fragment).slice(1);
	      return _.map(params, function(param) {
	        return param ? decodeURIComponent(param) : null;
	      });
	    }

	  });

	  // Backbone.History
	  // ----------------

	  // Handles cross-browser history management, based on either
	  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	  // and URL fragments. If the browser supports neither (old IE, natch),
	  // falls back to polling.
	  var History = Backbone.History = function() {
	    this.handlers = [];
	    _.bindAll(this, 'checkUrl');

	    // Ensure that `History` can be used outside of the browser.
	    if (typeof window !== 'undefined') {
	      this.location = window.location;
	      this.history = window.history;
	    }
	  };

	  // Cached regex for stripping a leading hash/slash and trailing space.
	  var routeStripper = /^[#\/]|\s+$/g;

	  // Cached regex for stripping leading and trailing slashes.
	  var rootStripper = /^\/+|\/+$/g;

	  // Cached regex for detecting MSIE.
	  var isExplorer = /msie [\w.]+/;

	  // Cached regex for removing a trailing slash.
	  var trailingSlash = /\/$/;

	  // Has the history handling already been started?
	  History.started = false;

	  // Set up all inheritable **Backbone.History** properties and methods.
	  _.extend(History.prototype, Events, {

	    // The default interval to poll for hash changes, if necessary, is
	    // twenty times a second.
	    interval: 50,

	    // Gets the true hash value. Cannot use location.hash directly due to bug
	    // in Firefox where location.hash will always be decoded.
	    getHash: function(window) {
	      var match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	    },

	    // Get the cross-browser normalized URL fragment, either from the URL,
	    // the hash, or the override.
	    getFragment: function(fragment, forcePushState) {
	      if (fragment == null) {
	        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
	          fragment = this.location.pathname;
	          var root = this.root.replace(trailingSlash, '');
	          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
	        } else {
	          fragment = this.getHash();
	        }
	      }
	      return fragment.replace(routeStripper, '');
	    },

	    // Start the hash change handling, returning `true` if the current URL matches
	    // an existing route, and `false` otherwise.
	    start: function(options) {
	      if (History.started) throw new Error("Backbone.history has already been started");
	      History.started = true;

	      // Figure out the initial configuration. Do we need an iframe?
	      // Is pushState desired ... is it available?
	      this.options          = _.extend({}, {root: '/'}, this.options, options);
	      this.root             = this.options.root;
	      this._wantsHashChange = this.options.hashChange !== false;
	      this._wantsPushState  = !!this.options.pushState;
	      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
	      var fragment          = this.getFragment();
	      var docMode           = document.documentMode;
	      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

	      // Normalize root to always include a leading and trailing slash.
	      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

	      if (oldIE && this._wantsHashChange) {
	        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
	        this.navigate(fragment);
	      }

	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._hasPushState) {
	        Backbone.$(window).on('popstate', this.checkUrl);
	      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
	        Backbone.$(window).on('hashchange', this.checkUrl);
	      } else if (this._wantsHashChange) {
	        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }

	      // Determine if we need to change the base url, for a pushState link
	      // opened by a non-pushState browser.
	      this.fragment = fragment;
	      var loc = this.location;
	      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

	      // If we've started off with a route from a `pushState`-enabled browser,
	      // but we're currently in a browser that doesn't support it...
	      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
	        this.fragment = this.getFragment(null, true);
	        this.location.replace(this.root + this.location.search + '#' + this.fragment);
	        // Return immediately as browser will do redirect to new url
	        return true;

	      // Or if we've started out with a hash-based route, but we're currently
	      // in a browser where it could be `pushState`-based instead...
	      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
	        this.fragment = this.getHash().replace(routeStripper, '');
	        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
	      }

	      if (!this.options.silent) return this.loadUrl();
	    },

	    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
	    // but possibly useful for unit testing Routers.
	    stop: function() {
	      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
	      clearInterval(this._checkUrlInterval);
	      History.started = false;
	    },

	    // Add a route to be tested when the fragment changes. Routes added later
	    // may override previous routes.
	    route: function(route, callback) {
	      this.handlers.unshift({route: route, callback: callback});
	    },

	    // Checks the current URL to see if it has changed, and if it has,
	    // calls `loadUrl`, normalizing across the hidden iframe.
	    checkUrl: function(e) {
	      var current = this.getFragment();
	      if (current === this.fragment && this.iframe) {
	        current = this.getFragment(this.getHash(this.iframe));
	      }
	      if (current === this.fragment) return false;
	      if (this.iframe) this.navigate(current);
	      this.loadUrl() || this.loadUrl(this.getHash());
	    },

	    // Attempt to load the current URL fragment. If a route succeeds with a
	    // match, returns `true`. If no defined routes matches the fragment,
	    // returns `false`.
	    loadUrl: function(fragmentOverride) {
	      var fragment = this.fragment = this.getFragment(fragmentOverride);
	      var matched = _.any(this.handlers, function(handler) {
	        if (handler.route.test(fragment)) {
	          handler.callback(fragment);
	          return true;
	        }
	      });
	      return matched;
	    },

	    // Save a fragment into the hash history, or replace the URL state if the
	    // 'replace' option is passed. You are responsible for properly URL-encoding
	    // the fragment in advance.
	    //
	    // The options object can contain `trigger: true` if you wish to have the
	    // route callback be fired (not usually desirable), or `replace: true`, if
	    // you wish to modify the current URL without adding an entry to the history.
	    navigate: function(fragment, options) {
	      if (!History.started) return false;
	      if (!options || options === true) options = {trigger: options};
	      fragment = this.getFragment(fragment || '');
	      if (this.fragment === fragment) return;
	      this.fragment = fragment;
	      var url = this.root + fragment;

	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._hasPushState) {
	        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

	      // If hash changes haven't been explicitly disabled, update the hash
	      // fragment to store history.
	      } else if (this._wantsHashChange) {
	        this._updateHash(this.location, fragment, options.replace);
	        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
	          // Opening and closing the iframe tricks IE7 and earlier to push a
	          // history entry on hash-tag change.  When replace is true, we don't
	          // want this.
	          if(!options.replace) this.iframe.document.open().close();
	          this._updateHash(this.iframe.location, fragment, options.replace);
	        }

	      // If you've told us that you explicitly don't want fallback hashchange-
	      // based history, then `navigate` becomes a page refresh.
	      } else {
	        return this.location.assign(url);
	      }
	      if (options.trigger) this.loadUrl(fragment);
	    },

	    // Update the hash location, either replacing the current entry, or adding
	    // a new one to the browser history.
	    _updateHash: function(location, fragment, replace) {
	      if (replace) {
	        var href = location.href.replace(/(javascript:|#).*$/, '');
	        location.replace(href + '#' + fragment);
	      } else {
	        // Some browsers require that `hash` contains a leading #.
	        location.hash = '#' + fragment;
	      }
	    }

	  });

	  // Create the default Backbone.history.
	  Backbone.history = new History;

	  // Helpers
	  // -------

	  // Helper function to correctly set up the prototype chain, for subclasses.
	  // Similar to `goog.inherits`, but uses a hash of prototype properties and
	  // class properties to be extended.
	  var extend = function(protoProps, staticProps) {
	    var parent = this;
	    var child;

	    // The constructor function for the new subclass is either defined by you
	    // (the "constructor" property in your `extend` definition), or defaulted
	    // by us to simply call the parent's constructor.
	    if (protoProps && _.has(protoProps, 'constructor')) {
	      child = protoProps.constructor;
	    } else {
	      child = function(){ return parent.apply(this, arguments); };
	    }

	    // Add static properties to the constructor function, if supplied.
	    _.extend(child, parent, staticProps);

	    // Set the prototype chain to inherit from `parent`, without calling
	    // `parent`'s constructor function.
	    var Surrogate = function(){ this.constructor = child; };
	    Surrogate.prototype = parent.prototype;
	    child.prototype = new Surrogate;

	    // Add prototype properties (instance properties) to the subclass,
	    // if supplied.
	    if (protoProps) _.extend(child.prototype, protoProps);

	    // Set a convenience property in case the parent's prototype is needed
	    // later.
	    child.__super__ = parent.prototype;

	    return child;
	  };

	  // Set up inheritance for the model, collection, router, view and history.
	  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function() {
	    throw new Error('A "url" property or function must be specified');
	  };

	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function (model, options) {
	    var error = options.error;
	    options.error = function(resp) {
	      if (error) error(model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };

	}).call(this);


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process, console) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {

	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }

	    // global on the server, window in the browser
	    var previous_async;

	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;

	    if (root != null) {
	        previous_async = root.async;
	    }

	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };

	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }

	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }

	    //// cross-browser compatiblity functions ////

	    var _toString = Object.prototype.toString;

	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };

	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };

	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }

	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;

	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }

	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);

	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }

	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }

	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }

	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }

	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }

	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };

	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }

	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }

	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }

	    //// exported async module functions ////

	    //// nextTick implementation with browser-compatible fallback ////

	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };

	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;


	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };

	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };


	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };

	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];

	        var iter = _keyIterator(object);
	        var key, completed = 0;

	        while ((key = iter()) != null) {
	            completed += 1;
	            iterator(object[key], key, only_once(done));
	        }

	        if (completed === 0) callback(null);

	        function done(err) {
	            completed--;
	            if (err) {
	                callback(err);
	            }
	            // Check key is null in case iterator isn't exhausted
	            // and done resolved synchronously.
	            else if (key === null && completed <= 0) {
	                callback(null);
	            }
	        }
	    };

	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.setImmediate(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };



	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };

	    function _eachOfLimit(limit) {

	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;

	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }

	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }


	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }

	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        arr = arr || [];
	        var results = _isArrayLike(arr) ? [] : {};
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }

	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);

	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };

	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };

	    async.transform = function (arr, memo, iterator, callback) {
	        if (arguments.length === 3) {
	            callback = iterator;
	            iterator = memo;
	            memo = _isArray(arr) ? [] : {};
	        }

	        async.eachOf(arr, function(v, k, cb) {
	            iterator(memo, v, k, cb);
	        }, function(err) {
	            callback(err, memo);
	        });
	    };

	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }

	    async.select =
	    async.filter = doParallel(_filter);

	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);

	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);

	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);

	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }

	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);

	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);

	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }

	        });

	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };

	    async.auto = function (tasks, concurrency, callback) {
	        if (!callback) {
	            // concurrency is optional, shift the args.
	            callback = concurrency;
	            concurrency = null;
	        }
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	        if (!concurrency) {
	            concurrency = remainingTasks;
	        }

	        var results = {};
	        var runningTasks = 0;

	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }

	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });

	        _arrayEach(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                runningTasks--;
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has inexistant dependency');
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return runningTasks < concurrency && _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                runningTasks++;
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    runningTasks++;
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };



	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;

	        var attempts = [];

	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };

	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }

	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;

	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }

	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }

	            while (opts.times) {

	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }

	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }

	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };

	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };

	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};

	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }

	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };

	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };

	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };

	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };

	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });

	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);

	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback(null);
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };

	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };

	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };

	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };

	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;

	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });

	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };

	        test(check);
	    };

	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };

	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };

	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }

	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;

	                var removed = false;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    _arrayEach(workersList, function (worker, index) {
	                        if (worker === task && !removed) {
	                            workersList.splice(index, 1);
	                            removed = true;
	                        }
	                    });

	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }

	        var workers = 0;
	        var workersList = [];
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    while(workers < q.concurrency && q.tasks.length){
	                        var tasks = q.payload ?
	                            q.tasks.splice(0, q.payload) :
	                            q.tasks.splice(0, q.tasks.length);

	                        var data = _map(tasks, function (task) {
	                            return task.data;
	                        });

	                        if (q.tasks.length === 0) {
	                            q.empty();
	                        }
	                        workers += 1;
	                        workersList.push(tasks[0]);
	                        var cb = only_once(_next(q, tasks));
	                        worker(data, cb);
	                    }
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            workersList: function () {
	                return workersList;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }

	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);

	        return q;
	    };

	    async.priorityQueue = function (worker, concurrency) {

	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }

	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }

	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };

	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }

	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);

	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };

	        // Remove unshift function
	        delete q.unshift;

	        return q;
	    };

	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };

	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/

	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.setImmediate(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };

	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };

	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }

	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };

	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;

	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }

	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };

	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };


	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }

	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);


	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };

	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }

	    async.ensureAsync = ensureAsync;

	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });

	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };

	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }

	}());

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(219).setImmediate, __webpack_require__(189), __webpack_require__(196)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(220).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(219).setImmediate, __webpack_require__(219).clearImmediate))

/***/ },
/* 220 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.VERSION = '__STANZAIO_VERSION__';

	exports.JID = __webpack_require__(222).JID;
	exports.Client = __webpack_require__(225);


	exports.createClient = function (opts) {
	    var client = new exports.Client(opts);
	    client.use(__webpack_require__(421));

	    return client;
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var StringPrep = __webpack_require__(223);

	// All of our StringPrep fallbacks work correctly
	// in the ASCII range, so we can reliably mark
	// ASCII-only JIDs as prepped.
	var ASCII = /^[\x00-\x7F]*$/;



	function bareJID(local, domain) {
	    if (local) {
	        return local + '@' + domain;
	    }
	    return domain;
	}

	function fullJID(local, domain, resource) {
	    if (resource) {
	        return bareJID(local, domain) + '/' + resource;
	    }
	    return bareJID(local, domain);
	}


	exports.prep = function (data) {
	    var local = data.local;
	    var domain = data.domain;
	    var resource = data.resource;
	    var unescapedLocal = local;

	    if (local) {
	        local = StringPrep.nodeprep(local);
	        unescapedLocal = exports.unescape(local);
	    }

	    if (resource) {
	        resource = StringPrep.resourceprep(resource);
	    }

	    if (domain[domain.length - 1] === '.') {
	        domain = domain.slice(0, domain.length - 1);
	    }

	    domain = StringPrep.nameprep(domain.split('.').map(StringPrep.toUnicode).join('.'));

	    return {
	        prepped: data.prepped || StringPrep.available,
	        local: local,
	        domain: domain,
	        resource: resource,
	        bare: bareJID(local, domain),
	        full: fullJID(local, domain, resource),
	        unescapedLocal: unescapedLocal,
	        unescapedBare: bareJID(unescapedLocal, domain),
	        unescapedFull: fullJID(unescapedLocal, domain, resource)
	    };
	};

	exports.parse = function (jid, trusted) {
	    var local = '';
	    var domain = '';
	    var resource = '';

	    trusted = trusted || ASCII.test(jid);

	    var resourceStart = jid.indexOf('/');
	    if (resourceStart > 0) {
	        resource = jid.slice(resourceStart + 1);
	        jid = jid.slice(0, resourceStart);
	    }

	    var localEnd = jid.indexOf('@');
	    if (localEnd > 0) {
	        local = jid.slice(0, localEnd);
	        jid = jid.slice(localEnd + 1);
	    }

	    domain = jid;

	    var preppedJID = exports.prep({
	        local: local,
	        domain: domain,
	        resource: resource,
	    });

	    preppedJID.prepped = preppedJID.prepped || trusted;

	    return preppedJID;
	};

	exports.equal = function (jid1, jid2, requirePrep) {
	    jid1 = new exports.JID(jid1);
	    jid2 = new exports.JID(jid2);
	    if (arguments.length === 2) {
	        requirePrep = true;
	    }
	    return jid1.local === jid2.local &&
	           jid1.domain === jid2.domain &&
	           jid1.resource === jid2.resource &&
	           (requirePrep ? jid1.prepped && jid2.prepped : true);
	};

	exports.equalBare = function (jid1, jid2, requirePrep) {
	    jid1 = new exports.JID(jid1);
	    jid2 = new exports.JID(jid2);
	    if (arguments.length === 2) {
	        requirePrep = true;
	    }
	    return jid1.local === jid2.local &&
	           jid1.domain === jid2.domain &&
	           (requirePrep ? jid1.prepped && jid2.prepped : true);
	};

	exports.isBare = function (jid) {
	    jid = new exports.JID(jid);

	    var hasResource = !!jid.resource;

	    return !hasResource;
	};

	exports.isFull = function (jid) {
	    jid = new exports.JID(jid);

	    var hasResource = !!jid.resource;

	    return hasResource;
	};

	exports.escape = function (val) {
	    return val.replace(/^\s+|\s+$/g, '')
	              .replace(/\\5c/g, '\\5c5c')
	              .replace(/\\20/g, '\\5c20')
	              .replace(/\\22/g, '\\5c22')
	              .replace(/\\26/g, '\\5c26')
	              .replace(/\\27/g, '\\5c27')
	              .replace(/\\2f/g, '\\5c2f')
	              .replace(/\\3a/g, '\\5c3a')
	              .replace(/\\3c/g, '\\5c3c')
	              .replace(/\\3e/g, '\\5c3e')
	              .replace(/\\40/g, '\\5c40')
	              .replace(/ /g, '\\20')
	              .replace(/\"/g, '\\22')
	              .replace(/\&/g, '\\26')
	              .replace(/\'/g, '\\27')
	              .replace(/\//g, '\\2f')
	              .replace(/:/g, '\\3a')
	              .replace(/</g, '\\3c')
	              .replace(/>/g, '\\3e')
	              .replace(/@/g, '\\40');
	};

	exports.unescape = function (val) {
	    return val.replace(/\\20/g, ' ')
	              .replace(/\\22/g, '"')
	              .replace(/\\26/g, '&')
	              .replace(/\\27/g, '\'')
	              .replace(/\\2f/g, '/')
	              .replace(/\\3a/g, ':')
	              .replace(/\\3c/g, '<')
	              .replace(/\\3e/g, '>')
	              .replace(/\\40/g, '@')
	              .replace(/\\5c/g, '\\');
	};


	exports.create = function (local, domain, resource) {
	    return new exports.JID(local, domain, resource);
	};

	exports.JID = function JID(localOrJID, domain, resource) {
	    var parsed = {};
	    if (localOrJID && !domain && !resource) {
	        if (typeof localOrJID === 'string') {
	            parsed = exports.parse(localOrJID);
	        } else if (localOrJID._isJID || localOrJID instanceof exports.JID) {
	            parsed = localOrJID;
	        } else {
	            throw new Error('Invalid argument type');
	        }
	    } else if (domain) {
	        var trusted = ASCII.test(localOrJID) && ASCII.test(domain);
	        if (resource) {
	            trusted = trusted && ASCII.test(resource);
	        }

	        parsed = exports.prep({
	            local: exports.escape(localOrJID),
	            domain: domain,
	            resource: resource,
	            prepped: trusted
	        });
	    } else {
	        parsed = {};
	    }

	    this._isJID = true;

	    this.local = parsed.local || '';
	    this.domain = parsed.domain || '';
	    this.resource = parsed.resource || '';
	    this.bare = parsed.bare || '';
	    this.full = parsed.full || '';

	    this.unescapedLocal = parsed.unescapedLocal || '';
	    this.unescapedBare = parsed.unescapedBare || '';
	    this.unescapedFull = parsed.unescapedFull || '';

	    this.prepped = parsed.prepped;
	};

	exports.JID.prototype.toString = function () {
	    return this.full;
	};

	exports.JID.prototype.toJSON = function () {
	    return this.full;
	};


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var punycode = __webpack_require__(224);


	exports.available = false;

	exports.toUnicode = punycode.toUnicode;

	exports.nameprep = function (str) {
	    return str.toLowerCase();
	};

	exports.nodeprep = function (str) {
	    return str.toLowerCase();
	};

	exports.resourceprep = function (str) {
	    return str;
	};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.0 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module), (function() { return this; }())))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';

	var each = __webpack_require__(226);
	var extend = __webpack_require__(234);
	var isArray = __webpack_require__(232);

	var jxt = __webpack_require__(240);
	var WildEmitter = __webpack_require__(257);
	var util = __webpack_require__(197);
	var BPromise = __webpack_require__(258);
	var uuid = __webpack_require__(241);
	var JID = __webpack_require__(222).JID;
	var StreamManagement = __webpack_require__(259);
	var getHostMeta = __webpack_require__(260);
	var SASLFactory = __webpack_require__(271);


	var SASL_MECHS = {
	    external: __webpack_require__(273),
	    'scram-sha-1': __webpack_require__(275),
	    'digest-md5': __webpack_require__(309),
	    'x-oauth2': __webpack_require__(310),
	    plain: __webpack_require__(312),
	    anonymous: __webpack_require__(314)
	};


	function Client(opts) {
	    var self = this;

	    WildEmitter.call(this);

	    opts = opts || {};
	    this._initConfig(opts);

	    this.stanzas = jxt.getGlobalJXT();

	    this.jid = new JID();

	    this.stanzas = jxt.createRegistry();
	    this.stanzas.use(__webpack_require__(316));
	    this.stanzas.use(__webpack_require__(325));

	    this.use(__webpack_require__(402));
	    this.use(__webpack_require__(403));
	    this.use(__webpack_require__(404));
	    this.use(__webpack_require__(405));
	    this.use(__webpack_require__(406));

	    this.sm = new StreamManagement(this);

	    this.transports = {};

	    this.use(__webpack_require__(407));
	    this.use(__webpack_require__(410));
	    this.use(__webpack_require__(412));


	    this.on('stream:data', function (data) {
	        var json = data.toJSON();

	        if (data._name === 'iq') {
	            json._xmlChildCount = 0;
	            each(data.xml.childNodes, function (child) {
	                if (child.nodeType === 1) {
	                    json._xmlChildCount += 1;
	                }
	            });
	        }

	        self.emit(data._eventname || data._name, json);
	        if (data._name === 'message' || data._name === 'presence' || data._name === 'iq') {
	            self.sm.handle(json);
	            self.emit('stanza', json);
	        } else if (data._name === 'smAck') {
	            return self.sm.process(json);
	        } else if (data._name === 'smRequest') {
	            return self.sm.ack();
	        }

	        if (json.id) {
	            self.emit('id:' + json.id, json);
	            self.emit(data._name + ':id:' + json.id, json);
	        }
	    });

	    this.on('disconnected', function () {
	        if (self.transport) {
	            self.transport.off('*');
	            delete self.transport;
	        }
	        self.releaseGroup('connection');
	    });

	    this.on('iq', function (iq) {
	        var iqType = iq.type;
	        var xmlChildCount = iq._xmlChildCount;
	        delete iq._xmlChildCount;

	        var exts = Object.keys(iq).filter(function (ext) {
	            return ext !== 'id' && 
	                   ext !== 'to' && 
	                   ext !== 'from' &&
	                   ext !== 'lang' &&
	                   ext !== 'type' &&
	                   ext !== 'errorReply' &&
	                   ext !== 'resultReply';
	        });

	        if (iq.type === 'get' || iq.type === 'set') {
	            // Invalid request
	            if (xmlChildCount !== 1) {
	                return self.sendIq(iq.errorReply({
	                    error: {
	                        type: 'modify',
	                        condition: 'bad-request'
	                    }
	                }));
	            }

	            // Valid request, but we don't have support for the
	            // payload data.
	            if (!exts.length) {
	                return self.sendIq(iq.errorReply({
	                    error: {
	                        type: 'cancel',
	                        condition: 'feature-not-implemented'
	                    }
	                }));
	            }

	            var iqEvent = 'iq:' + iqType + ':' + exts[0];
	            if (self.callbacks[iqEvent]) {
	                self.emit(iqEvent, iq);
	            } else {
	                // We support the payload data, but there's
	                // nothing registered to handle it.
	                self.sendIq(iq.errorReply({
	                    error: {
	                        type: 'cancel',
	                        condition: 'feature-not-implemented'
	                    }
	                }));
	            }
	        }
	    });

	    this.on('message', function (msg) {
	        if (Object.keys(msg.$body || {}).length) {
	            if (msg.type === 'chat' || msg.type === 'normal') {
	                self.emit('chat', msg);
	            } else if (msg.type === 'groupchat') {
	                self.emit('groupchat', msg);
	            }
	        }
	        if (msg.type === 'error') {
	            self.emit('message:error', msg);
	        }
	    });

	    this.on('presence', function (pres) {
	        var presType = pres.type || 'available';
	        if (presType === 'error') {
	            presType = 'presence:error';
	        }
	        self.emit(presType, pres);
	    });
	}

	util.inherits(Client, WildEmitter);

	Object.defineProperty(Client.prototype, 'stream', {
	    get: function () {
	        return this.transport ? this.transport.stream : undefined;
	    }
	});

	Client.prototype._initConfig = function (opts) {
	    var self = this;
	    var currConfig = this.config || {};

	    this.config = extend({
	        useStreamManagement: true,
	        transports: ['websocket', 'bosh'],
	        sasl: ['external', 'scram-sha-1', 'digest-md5', 'plain', 'anonymous']
	    }, currConfig, opts);

	    // Enable SASL authentication mechanisms (and their preferred order)
	    // based on user configuration.
	    if (!isArray(this.config.sasl)) {
	        this.config.sasl = [this.config.sasl];
	    }

	    this.SASLFactory = new SASLFactory();
	    this.config.sasl.forEach(function (mech) {
	        if (typeof mech === 'string') {
	            var existingMech = SASL_MECHS[mech.toLowerCase()];
	            if (existingMech) {
	                self.SASLFactory.use(existingMech);
	            }
	        } else {
	            self.SASLFactory.use(mech);
	        }
	    });

	    this.config.jid = new JID(this.config.jid);

	    if (!this.config.server) {
	        this.config.server = this.config.jid.domain;
	    }

	    if (this.config.password) {
	        this.config.credentials = this.config.credentials || {};
	        this.config.credentials.password = this.config.password;
	        delete this.config.password;
	    }

	    if (this.config.transport) {
	        this.config.transports = [this.config.transport];
	    }

	    if (!isArray(this.config.transports)) {
	        this.config.transports = [this.config.transports];
	    }
	};

	Client.prototype.use = function (pluginInit) {
	    pluginInit(this, this.stanzas, this.config);
	};

	Client.prototype.nextId = function () {
	    return uuid.v4();
	};

	Client.prototype.discoverBindings = function (server, cb) {
	    getHostMeta(server, function (err, data) {
	        if (err) {
	            return cb(err, []);
	        }

	        var results = {
	            websocket: [],
	            bosh: []
	        };
	        var links = data.links || [];

	        links.forEach(function (link) {
	            if (link.href && link.rel === 'urn:xmpp:alt-connections:websocket') {
	                results.websocket.push(link.href);
	            }
	            if (link.href && link.rel === 'urn:xmpp:altconnect:websocket') {
	                results.websocket.push(link.href);
	            }
	            if (link.href && link.rel === 'urn:xmpp:alt-connections:xbosh') {
	                results.bosh.push(link.href);
	            }
	            if (link.href && link.rel === 'urn:xmpp:altconnect:bosh') {
	                results.bosh.push(link.href);
	            }
	        });

	        cb(false, results);
	    });
	};

	Client.prototype._getConfiguredCredentials = function () {
	    var creds = this.config.credentials || {};
	    var requestedJID = new JID(this.config.jid);

	    var username = creds.username || requestedJID.local;
	    var server = creds.server || requestedJID.domain;

	    var defaultCreds = {
	        username: username,
	        password: this.config.password,
	        server: server,
	        host: server,
	        realm: server,
	        serviceType: 'xmpp',
	        serviceName: server
	    };

	    var result = extend(defaultCreds, creds);

	    return result;
	};

	Client.prototype.getCredentials = function (cb) {
	    return cb(null, this._getConfiguredCredentials());
	};

	Client.prototype.connect = function (opts, transInfo) {
	    var self = this;

	    this._initConfig(opts);

	    if (transInfo && transInfo.name && transInfo.url) {
	        var trans = self.transport = new self.transports[transInfo.name](self.sm, self.stanzas);
	        trans.on('*', function (event, data) {
	            self.emit(event, data);
	        });
	        return trans.connect(self.config);
	    }

	    if (!transInfo && self.config.transports.length === 1) {
	        transInfo = {};
	        transInfo.name = self.config.transports[0];
	        if (transInfo.name === 'websocket' || transInfo.name === 'old-websocket') {
	            transInfo.url = self.config.wsURL;
	        }
	        if (transInfo.name === 'bosh') {
	            transInfo.url = self.config.boshURL;
	        }
	        if (transInfo.name && transInfo.url) {
	            return self.connect(null, transInfo);
	        }
	    }

	   return self.connect(null, {
		name: "websocket",
		url: self.config.wsURL
	   });
	};

	Client.prototype.disconnect = function () {
	    if (this.sessionStarted) {
	        this.releaseGroup('session');
	        if (!this.sm.started) {
	            // Only emit session:end if we had a session, and we aren't using
	            // stream management to keep the session alive.
	            this.emit('session:end');
	        }
	    }
	    this.sessionStarted = false;
	    this.releaseGroup('connection');
	    if (this.transport) {
	        this.transport.disconnect();
	    } else {
	        this.emit('disconnected');
	    }
	};

	Client.prototype.send = function (data) {
	    this.sm.track(data);
	    if (this.transport) {
	        this.transport.send(data);
	    }
	};

	Client.prototype.sendMessage = function (data) {
	    data = data || {};
	    if (!data.id) {
	        data.id = this.nextId();
	    }

	    var Message = this.stanzas.getMessage();
	    var msg = new Message(data);

	    this.emit('message:sent', msg.toJSON());
	    this.send(msg);

	    return data.id;
	};

	Client.prototype.sendPresence = function (data) {
	    data = data || {};
	    if (!data.id) {
	        data.id = this.nextId();
	    }
	    var Presence = this.stanzas.getPresence();
	    this.send(new Presence(data));

	    return data.id;
	};

	Client.prototype.sendIq = function (data, cb) {
	    var result, respEvent, allowed, dest;
	    var self = this;

	    data = data || {};
	    if (!data.id) {
	        data.id = this.nextId();
	    }

	    var Iq = this.stanzas.getIq();
	    var iq = (!data.toJSON) ? new Iq(data) : data;

	    if (data.type === 'error' || data.type === 'result') {
	        this.send(iq);
	        return;
	    }

	    dest = new JID(data.to);
	    allowed = {};
	    allowed[''] = true;
	    allowed[dest.full] = true;
	    allowed[dest.bare] = true;
	    allowed[dest.domain] = true;
	    allowed[self.jid.bare] = true;
	    allowed[self.jid.domain] = true;

	    respEvent = 'iq:id:' + data.id;
	    result = new BPromise(function (resolve, reject) {
	        var handler = function (res) {
	            // Only process result from the correct responder
	            if (!allowed[res.from.full]) {
	                return;
	            }

	            // Only process result or error responses, if the responder
	            // happened to send us a request using the same ID value at
	            // the same time.
	            if (res.type !== 'result' && res.type !== 'error') {
	                return;
	            }

	            self.off(respEvent, handler);
	            if (!res.error) {
	                resolve(res);
	            } else {
	                reject(res);
	            }
	        };
	        self.on(respEvent, 'session', handler);
	    });

	    this.send(iq);

	    return result.timeout(self.config.timeout * 1000 || 15000)
	        .catch(BPromise.TimeoutError, function () {
	            throw {
	                id: data.id,
	                type: 'error',
	                error: {
	                    condition: 'timeout'
	                }
	            };
	        })
	        .nodeify(cb);
	};

	Client.prototype.sendStreamError = function (data) {
	    data = data || {};

	    var StreamError = this.stanzas.getStreamError();
	    var error = new StreamError(data);

	    this.emit('stream:error', error.toJSON());
	    this.send(error);
	    this.disconnect();
	};


	module.exports = Client;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var arrayEach = __webpack_require__(227),
	    baseEach = __webpack_require__(228),
	    bindCallback = __webpack_require__(233),
	    isArray = __webpack_require__(232);

	/**
	 * Creates a function for `_.forEach` or `_.forEachRight`.
	 *
	 * @private
	 * @param {Function} arrayFunc The function to iterate over an array.
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @returns {Function} Returns the new each function.
	 */
	function createForEach(arrayFunc, eachFunc) {
	  return function(collection, iteratee, thisArg) {
	    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	      ? arrayFunc(collection, iteratee)
	      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	  };
	}

	/**
	 * Iterates over elements of `collection` invoking `iteratee` for each element.
	 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	 * (value, index|key, collection). Iteratee functions may exit iteration early
	 * by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length" property
	 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	 * may be used for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @alias each
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array|Object|string} Returns `collection`.
	 * @example
	 *
	 * _([1, 2]).forEach(function(n) {
	 *   console.log(n);
	 * }).value();
	 * // => logs each value from left to right and returns the array
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	 *   console.log(n, key);
	 * });
	 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	 */
	var forEach = createForEach(arrayEach, baseEach);

	module.exports = forEach;


/***/ },
/* 227 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * A specialized version of `_.forEach` for arrays without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	module.exports = arrayEach;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var keys = __webpack_require__(229);

	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.forEach` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	/**
	 * The base implementation of `baseForIn` and `baseForOwn` which iterates
	 * over `object` properties returned by `keysFunc` invoking `iteratee` for
	 * each property. Iteratee functions may exit iteration early by explicitly
	 * returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `_.forOwn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return baseFor(object, iteratee, keys);
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    var length = collection ? getLength(collection) : 0;
	    if (!isLength(length)) {
	      return eachFunc(collection, iteratee);
	    }
	    var index = fromRight ? length : -1,
	        iterable = toObject(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * Creates a base function for `_.forIn` or `_.forInRight`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var iterable = toObject(object),
	        props = keysFunc(object),
	        length = props.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      var key = props[index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = baseEach;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(230),
	    isArguments = __webpack_require__(231),
	    isArray = __webpack_require__(232);

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keys;


/***/ },
/* 230 */
/***/ function(module, exports) {

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = getNative;


/***/ },
/* 231 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isArguments;


/***/ },
/* 232 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = isArray;


/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * A specialized version of `baseCallback` which only supports `this` binding
	 * and specifying the number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function bindCallback(func, thisArg, argCount) {
	  if (typeof func != 'function') {
	    return identity;
	  }
	  if (thisArg === undefined) {
	    return func;
	  }
	  switch (argCount) {
	    case 1: return function(value) {
	      return func.call(thisArg, value);
	    };
	    case 3: return function(value, index, collection) {
	      return func.call(thisArg, value, index, collection);
	    };
	    case 4: return function(accumulator, value, index, collection) {
	      return func.call(thisArg, accumulator, value, index, collection);
	    };
	    case 5: return function(value, other, key, object, source) {
	      return func.call(thisArg, value, other, key, object, source);
	    };
	  }
	  return function() {
	    return func.apply(thisArg, arguments);
	  };
	}

	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = bindCallback;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseAssign = __webpack_require__(235),
	    createAssigner = __webpack_require__(237),
	    keys = __webpack_require__(229);

	/**
	 * A specialized version of `_.assign` for customizing assigned values without
	 * support for argument juggling, multiple sources, and `this` binding `customizer`
	 * functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 */
	function assignWith(object, source, customizer) {
	  var index = -1,
	      props = keys(source),
	      length = props.length;

	  while (++index < length) {
	    var key = props[index],
	        value = object[key],
	        result = customizer(value, source[key], key, object, source);

	    if ((result === result ? (result !== value) : (value === value)) ||
	        (value === undefined && !(key in object))) {
	      object[key] = result;
	    }
	  }
	  return object;
	}

	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object. Subsequent sources overwrite property assignments of previous sources.
	 * If `customizer` is provided it is invoked to produce the assigned values.
	 * The `customizer` is bound to `thisArg` and invoked with five arguments:
	 * (objectValue, sourceValue, key, object, source).
	 *
	 * **Note:** This method mutates `object` and is based on
	 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
	 *
	 * @static
	 * @memberOf _
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {*} [thisArg] The `this` binding of `customizer`.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	 * // => { 'user': 'fred', 'age': 40 }
	 *
	 * // using a customizer callback
	 * var defaults = _.partialRight(_.assign, function(value, other) {
	 *   return _.isUndefined(value) ? other : value;
	 * });
	 *
	 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	 * // => { 'user': 'barney', 'age': 36 }
	 */
	var assign = createAssigner(function(object, source, customizer) {
	  return customizer
	    ? assignWith(object, source, customizer)
	    : baseAssign(object, source);
	});

	module.exports = assign;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseCopy = __webpack_require__(236),
	    keys = __webpack_require__(229);

	/**
	 * The base implementation of `_.assign` without support for argument juggling,
	 * multiple sources, and `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return source == null
	    ? object
	    : baseCopy(source, keys(source), object);
	}

	module.exports = baseAssign;


/***/ },
/* 236 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property names to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @returns {Object} Returns `object`.
	 */
	function baseCopy(source, props, object) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];
	    object[key] = source[key];
	  }
	  return object;
	}

	module.exports = baseCopy;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var bindCallback = __webpack_require__(233),
	    isIterateeCall = __webpack_require__(238),
	    restParam = __webpack_require__(239);

	/**
	 * Creates a function that assigns properties of source object(s) to a given
	 * destination object.
	 *
	 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return restParam(function(object, sources) {
	    var index = -1,
	        length = object == null ? 0 : sources.length,
	        customizer = length > 2 ? sources[length - 2] : undefined,
	        guard = length > 2 ? sources[2] : undefined,
	        thisArg = length > 1 ? sources[length - 1] : undefined;

	    if (typeof customizer == 'function') {
	      customizer = bindCallback(customizer, thisArg, 5);
	      length -= 2;
	    } else {
	      customizer = typeof thisArg == 'function' ? thisArg : undefined;
	      length -= (customizer ? 1 : 0);
	    }
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 238 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	      ? (isArrayLike(object) && isIndex(index, object.length))
	      : (type == 'string' && index in object)) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = isIterateeCall;


/***/ },
/* 239 */
/***/ function(module, exports) {

	/**
	 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as an array.
	 *
	 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.restParam(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function restParam(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        rest = Array(length);

	    while (++index < length) {
	      rest[index] = args[start + index];
	    }
	    switch (start) {
	      case 0: return func.call(this, rest);
	      case 1: return func.call(this, args[0], rest);
	      case 2: return func.call(this, args[0], args[1], rest);
	    }
	    var otherArgs = Array(start + 1);
	    index = -1;
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = rest;
	    return func.apply(this, otherArgs);
	  };
	}

	module.exports = restParam;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var extend = __webpack_require__(234);
	var uuid = __webpack_require__(241);

	var types = __webpack_require__(243);
	var helpers = __webpack_require__(244);
	var stanzaConstructor = __webpack_require__(256);


	function JXT() {
	    this._LOOKUP = {};
	    this._LOOKUP_EXT = {};
	    this._TAGS = {};
	    this._CB_DEFINITION = {};
	    this._CB_TAG = {};
	    this._ID = uuid.v4();
	    this.utils = extend({}, types, helpers);
	}

	JXT.prototype.use = function (init) {
	    if (!init['__JXT_LOADED_' + this._ID]) {
	        init(this);
	    }
	    init['__JXT_LOADED_' + this._ID] = true;
	    return this;
	};

	JXT.prototype.getDefinition = function (el, ns, required) {
	    var JXTClass = this._LOOKUP[ns + '|' + el];
	    if (required && !JXTClass) {
	        throw new Error('Could not find definition for <' + el + ' xmlns="' + ns + '" />');
	    }
	    return JXTClass;
	};

	JXT.prototype.getExtensions = function (el, ns) {
	    return this._LOOKUP_EXT[ns + '|' + el] || {};
	};

	JXT.prototype.withDefinition = function (el, ns, cb) {
	    var name = ns + '|' + el;
	    if (!this._CB_DEFINITION[name]) {
	        this._CB_DEFINITION[name] = [];
	    }
	    this._CB_DEFINITION[name].push(cb);

	    if (this._LOOKUP[name]) {
	        cb(this._LOOKUP[name]);
	    }
	};

	JXT.prototype.withTag = function (tag, cb) {
	    if (!this._CB_TAG[tag]) {
	        this._CB_TAG[tag] = [];
	    }
	    this._CB_TAG[tag].push(cb);

	    this.tagged(tag).forEach(function (stanza) {
	        cb(stanza);
	    });
	};

	JXT.prototype.tagged = function (tag) {
	    return this._TAGS[tag] || [];
	};

	JXT.prototype.build = function (xml) {
	    var JXTClass = this.getDefinition(xml.localName, xml.namespaceURI);
	    if (JXTClass) {
	        return new JXTClass(null, xml);
	    }
	};

	JXT.prototype.parse = function (str) {
	    var xml = helpers.parse(str);
	    if (!xml) {
	        return;
	    }
	    return this.build(xml);
	};

	JXT.prototype.extend = function (ParentJXT, ChildJXT, multiName, hideSingle) {
	    var parentName = ParentJXT.prototype._NS + '|' + ParentJXT.prototype._EL;
	    var name = ChildJXT.prototype._name;
	    var qName = ChildJXT.prototype._NS + '|' + ChildJXT.prototype._EL;

	    this._LOOKUP[qName] = ChildJXT;
	    if (!this._LOOKUP_EXT[qName]) {
	        this._LOOKUP_EXT[qName] = {};
	    }
	    if (!this._LOOKUP_EXT[parentName]) {
	        this._LOOKUP_EXT[parentName] = {};
	    }
	    this._LOOKUP_EXT[parentName][name] = ChildJXT;

	    if (!multiName || (multiName && !hideSingle)) {
	        this.add(ParentJXT, name, types.extension(ChildJXT));
	    }
	    if (multiName) {
	        this.add(ParentJXT, multiName, types.multiExtension(ChildJXT));
	    }
	};

	JXT.prototype.add = function (ParentJXT, fieldName, field) {
	    field.enumerable = true;
	    Object.defineProperty(ParentJXT.prototype, fieldName, field);
	};

	JXT.prototype.define = function (opts) {
	    var self = this;

	    var Stanza = stanzaConstructor(this, opts);

	    var ns = Stanza.prototype._NS;
	    var el = Stanza.prototype._EL;
	    var tags = Stanza.prototype._TAGS;

	    var name = ns + '|' + el;
	    this._LOOKUP[name] = Stanza;

	    tags.forEach(function (tag) {
	        if (!self._TAGS[tag]) {
	            self._TAGS[tag] = [];
	        }
	        self._TAGS[tag].push(Stanza);
	    });

	    var fieldNames = Object.keys(opts.fields || {});
	    fieldNames.forEach(function (fieldName) {
	        self.add(Stanza, fieldName, opts.fields[fieldName]);
	    });

	    if (this._CB_DEFINITION[name]) {
	        this._CB_DEFINITION[name].forEach(function (handler) {
	            handler(Stanza);
	        });
	    }

	    tags.forEach(function (tag) {
	        if (self._CB_TAG[tag]) {
	            self._CB_TAG[tag].forEach(function (handler) {
	                handler(Stanza);
	            });
	        }
	    });

	    return Stanza;
	};


	// Expose methods on the required module itself


	JXT.createRegistry = function () {
	    return new JXT();
	};

	extend(JXT, helpers);
	extend(JXT, types);

	// Compatibility shim for JXT 1.x

	var globalJXT = new JXT();

	JXT.define = globalJXT.define.bind(globalJXT);
	JXT.extend = globalJXT.extend.bind(globalJXT);
	JXT.add = globalJXT.add.bind(globalJXT);
	JXT.parse = globalJXT.parse.bind(globalJXT);
	JXT.build = globalJXT.build.bind(globalJXT);
	JXT.getExtensions = globalJXT.getExtensions.bind(globalJXT);
	JXT.getDefinition = globalJXT.getDefinition.bind(globalJXT);
	JXT.withDefinition = globalJXT.withDefinition.bind(globalJXT);
	JXT.withTag = globalJXT.withTag.bind(globalJXT);
	JXT.tagged = globalJXT.tagged.bind(globalJXT);

	JXT.getGlobalJXT = function () {
	    return globalJXT;
	};

	module.exports = JXT;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	// Unique ID creation requires a high quality random # generator.  We feature
	// detect to determine the best RNG source, normalizing to a function that
	// returns 128-bits of randomness, since that's what's usually required
	var _rng = __webpack_require__(242);

	// Maps for number <-> hex string conversion
	var _byteToHex = [];
	var _hexToByte = {};
	for (var i = 0; i < 256; i++) {
	  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	  _hexToByte[_byteToHex[i]] = i;
	}

	// **`parse()` - Parse a UUID into it's component bytes**
	function parse(s, buf, offset) {
	  var i = (buf && offset) || 0, ii = 0;

	  buf = buf || [];
	  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	    if (ii < 16) { // Don't overflow!
	      buf[i + ii++] = _hexToByte[oct];
	    }
	  });

	  // Zero out remaining bytes if string was short
	  while (ii < 16) {
	    buf[i + ii++] = 0;
	  }

	  return buf;
	}

	// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	function unparse(buf, offset) {
	  var i = offset || 0, bth = _byteToHex;
	  return  bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]];
	}

	// **`v1()` - Generate time-based UUID**
	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	// random #'s we need to init node and clockseq
	var _seedBytes = _rng();

	// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	var _nodeId = [
	  _seedBytes[0] | 0x01,
	  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	];

	// Per 4.2.2, randomize (14 bit) clockseq
	var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	// Previous uuid creation time
	var _lastMSecs = 0, _lastNSecs = 0;

	// See https://github.com/broofa/node-uuid for API details
	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || [];

	  options = options || {};

	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

	  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

	  // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock
	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

	  // Time since last uuid creation (in msecs)
	  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	  // Per 4.2.1.2, Bump clockseq on clock regression
	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  }

	  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval
	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  }

	  // Per 4.2.1.2 Throw error if too many uuids are requested
	  if (nsecs >= 10000) {
	    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	  }

	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq;

	  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	  msecs += 12219292800000;

	  // `time_low`
	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff;

	  // `time_mid`
	  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff;

	  // `time_high_and_version`
	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	  b[i++] = tmh >>> 16 & 0xff;

	  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	  b[i++] = clockseq >>> 8 | 0x80;

	  // `clock_seq_low`
	  b[i++] = clockseq & 0xff;

	  // `node`
	  var node = options.node || _nodeId;
	  for (var n = 0; n < 6; n++) {
	    b[i + n] = node[n];
	  }

	  return buf ? buf : unparse(b);
	}

	// **`v4()` - Generate random UUID**

	// See https://github.com/broofa/node-uuid for API details
	function v4(options, buf, offset) {
	  // Deprecated - 'format' argument, as supported in v1.2
	  var i = buf && offset || 0;

	  if (typeof(options) == 'string') {
	    buf = options == 'binary' ? new Array(16) : null;
	    options = null;
	  }
	  options = options || {};

	  var rnds = options.random || (options.rng || _rng)();

	  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	  rnds[6] = (rnds[6] & 0x0f) | 0x40;
	  rnds[8] = (rnds[8] & 0x3f) | 0x80;

	  // Copy bytes to buffer, if provided
	  if (buf) {
	    for (var ii = 0; ii < 16; ii++) {
	      buf[i + ii] = rnds[ii];
	    }
	  }

	  return buf || unparse(rnds);
	}

	// Export public API
	var uuid = v4;
	uuid.v1 = v1;
	uuid.v4 = v4;
	uuid.parse = parse;
	uuid.unparse = unparse;

	module.exports = uuid;


/***/ },
/* 242 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var rng;

	if (global.crypto && crypto.getRandomValues) {
	  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	  // Moderately fast, high quality
	  var _rnds8 = new Uint8Array(16);
	  rng = function whatwgRNG() {
	    crypto.getRandomValues(_rnds8);
	    return _rnds8;
	  };
	}

	if (!rng) {
	  // Math.random()-based (RNG)
	  //
	  // If all else fails, use Math.random().  It's fast, but is of unspecified
	  // quality.
	  var  _rnds = new Array(16);
	  rng = function() {
	    for (var i = 0, r; i < 16; i++) {
	      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
	      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	    }

	    return _rnds;
	  };
	}

	module.exports = rng;


	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var helpers = __webpack_require__(244);
	var extend = __webpack_require__(234);

	var find = helpers.find;
	var createElement = helpers.createElement;


	var field = exports.field = function (getter, setter) {
	    return function () {
	        var args = Array.prototype.slice.call(arguments);
	        return {
	            get: function () {
	                return getter.apply(null, [this.xml].concat(args));
	            },
	            set: function (value) {
	                setter.apply(null, ([this.xml].concat(args)).concat([value]));
	            }
	        };
	    };
	};

	exports.boolAttribute = field(
	    helpers.getBoolAttribute,
	    helpers.setBoolAttribute);

	exports.subAttribute = field(
	    helpers.getSubAttribute,
	    helpers.setSubAttribute);

	exports.boolSubAttribute = field(
	    helpers.getSubBoolAttribute,
	    helpers.setSubBoolAttribute);

	exports.text = field(
	    helpers.getText,
	    helpers.setText);

	exports.textSub = exports.subText = field(
	    helpers.getSubText,
	    helpers.setSubText);

	exports.multiTextSub = exports.multiSubText = field(
	    helpers.getMultiSubText,
	    helpers.setMultiSubText);

	exports.multiSubAttribute  = field(
	    helpers.getMultiSubAttribute,
	    helpers.setMultiSubAttribute);

	exports.langTextSub = exports.subLangText = field(
	    helpers.getSubLangText,
	    helpers.setSubLangText);

	exports.boolSub = field(
	    helpers.getBoolSub,
	    helpers.setBoolSub);

	exports.langAttribute = field(
	    function (xml) {
	        return xml.getAttributeNS(helpers.XML_NS, 'lang') || '';
	    },
	    function (xml, value) {
	        xml.setAttributeNS(helpers.XML_NS, 'lang', value);
	    }
	);

	exports.b64Text = field(
	    function (xml) {
	        if (xml.textContent && xml.textContent !== '=') {
	            return new Buffer(xml.textContent, 'base64');
	        }
	        return '';
	    },
	    function (xml, value) {
	        if (typeof value === 'string') {
	            var b64 = (new Buffer(value)).toString('base64');
	            xml.textContent = b64 || '=';
	        } else {
	            xml.textContent = '';
	        }
	    }
	);

	exports.dateAttribute = function (attr, now) {
	    return {
	        get: function () {
	            var data = helpers.getAttribute(this.xml, attr);
	            if (data) {
	                return new Date(data);
	            }
	            if (now) {
	                return new Date(Date.now());
	            }
	        },
	        set: function (value) {
	            if (!value) {
	                return;
	            }
	            if (typeof value !== 'string') {
	                value = value.toISOString();
	            }
	            helpers.setAttribute(this.xml, attr, value);
	        }
	    };
	};

	exports.dateSub = function (NS, sub, now) {
	    return {
	        get: function () {
	            var data = helpers.getSubText(this.xml, NS, sub);
	            if (data) {
	                return new Date(data);
	            }
	            if (now) {
	                return new Date(Date.now());
	            }
	        },
	        set: function (value) {
	            if (!value) {
	                return;
	            }
	            if (typeof value !== 'string') {
	                value = value.toISOString();
	            }
	            helpers.setSubText(this.xml, NS, sub, value);
	        }
	    };
	};

	exports.dateSubAttribute = function (NS, sub, attr, now) {
	    return {
	        get: function () {
	            var data = helpers.getSubAttribute(this.xml, NS, sub, attr);
	            if (data) {
	                return new Date(data);
	            }
	            if (now) {
	                return new Date(Date.now());
	            }
	        },
	        set: function (value) {
	            if (!value) {
	                return;
	            }
	            if (typeof value !== 'string') {
	                value = value.toISOString();
	            }
	            helpers.setSubAttribute(this.xml, NS, sub, attr, value);
	        }
	    };
	};

	exports.numberAttribute = function (attr, isFloat, defaultVal) {
	    return {
	        get: function () {
	            var parse = isFloat ? parseFloat : parseInt;
	            var data = helpers.getAttribute(this.xml, attr, '');
	            if (!data) {
	                return defaultVal;
	            }
	            var parsed = parse(data, 10);
	            if (isNaN(parsed)) {
	                return defaultVal;
	            }

	            return parsed;
	        },
	        set: function (value) {
	            helpers.setAttribute(this.xml, attr, value.toString());
	        }
	    };
	};

	exports.numberSub = function (NS, sub, isFloat, defaultVal) {
	    return {
	        get: function () {
	            var parse = isFloat ? parseFloat : parseInt;
	            var data = helpers.getSubText(this.xml, NS, sub, '');
	            if (!data) {
	                return defaultVal;
	            }

	            var parsed = parse(data, 10);
	            if (isNaN(parsed)) {
	                return defaultVal;
	            }

	            return parsed;
	        },
	        set: function (value) {
	            helpers.setSubText(this.xml, NS, sub, value.toString());
	        }
	    };
	};

	exports.attribute = function (name, defaultVal) {
	    return {
	        get: function () {
	            return helpers.getAttribute(this.xml, name, defaultVal);
	        },
	        set: function (value) {
	            helpers.setAttribute(this.xml, name, value);
	        }
	    };
	};

	exports.attributeNS = function (NS, name, defaultVal) {
	    return {
	        get: function () {
	            return helpers.getAttributeNS(this.xml, NS, name, defaultVal);
	        },
	        set: function (value) {
	            helpers.setAttributeNS(this.xml, NS, name, value);
	        }
	    };
	};

	exports.extension = function (ChildJXT) {
	    return {
	        get: function () {
	            var self = this;
	            var name = ChildJXT.prototype._name;
	            if (!this._extensions[name]) {
	                var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
	                if (!existing.length) {
	                    this._extensions[name] = new ChildJXT({}, null, self);
	                    this.xml.appendChild(this._extensions[name].xml);
	                } else {
	                    this._extensions[name] = new ChildJXT(null, existing[0], self);
	                }
	                this._extensions[name].parent = this;
	            }
	            return this._extensions[name];
	        },
	        set: function (value) {
	            if (value) {
	                var child = this[ChildJXT.prototype._name];
	                if (value === true) {
	                    value = {};
	                }
	                extend(child, value);
	            }
	        }
	    };
	};

	exports.multiExtension = function (ChildJXT) {
	    return {
	        get: function () {
	            var self = this;
	            var data = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
	            var results = [];

	            for (var i = 0, len = data.length; i < len; i++) {
	                results.push(new ChildJXT({}, data[i], self));
	            }

	            return results;
	        },
	        set: function (value) {
	            value = value || [];

	            var self = this;
	            var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

	            var i, len;
	            for (i = 0, len = existing.length; i < len; i++) {
	                self.xml.removeChild(existing[i]);
	            }

	            for (i = 0, len = value.length; i < len; i++) {
	                var content = new ChildJXT(value[i], null, self);
	                self.xml.appendChild(content.xml);
	            }
	        }
	    };
	};

	exports.enumSub = function (NS, enumValues) {
	    return {
	        get: function () {
	            var self = this;
	            var result = [];
	            enumValues.forEach(function (enumVal) {
	                var exists = find(self.xml, NS, enumVal);
	                if (exists.length) {
	                    result.push(exists[0].nodeName);
	                }
	            });
	            return result[0] || '';
	        },
	        set: function (value) {
	            var self = this;
	            var alreadyExists = false;

	            enumValues.forEach(function (enumVal) {
	                var elements = find(self.xml, NS, enumVal);
	                if (elements.length) {
	                    if (enumVal === value) {
	                        alreadyExists = true;
	                    } else {
	                        self.xml.removeChild(elements[0]);
	                    }
	                }
	            });

	            if (value && !alreadyExists) {
	                var condition = createElement(NS, value);
	                this.xml.appendChild(condition);
	            }
	        }
	    };
	};

	exports.subExtension = function (name, NS, sub, ChildJXT) {
	    return {
	        get: function () {
	            if (!this._extensions[name]) {
	                var wrapper = find(this.xml, NS, sub);
	                if (!wrapper.length) {
	                    wrapper= createElement(NS, sub, this._NS);
	                    this.xml.appendChild(wrapper);
	                } else {
	                    wrapper = wrapper[0];
	                }

	                var existing = find(wrapper, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
	                if (!existing.length) {
	                    this._extensions[name] = new ChildJXT({}, null, {xml: wrapper});
	                    wrapper.appendChild(this._extensions[name].xml);
	                } else {
	                    this._extensions[name] = new ChildJXT(null, existing[0], {xml: wrapper});
	                }
	                this._extensions[name].parent = this;
	            }
	            return this._extensions[name];
	        },
	        set: function (value) {
	            var wrapper = find(this.xml, NS, sub);
	            if (wrapper.length && !value) {
	                this.xml.removeChild(wrapper[0]);
	            }

	            if (value) {
	                var child = this[name];
	                if (value === true) {
	                    value = {};
	                }
	                extend(child, value);
	            }
	        }
	    };
	};

	exports.subMultiExtension = function (NS, sub, ChildJXT) {
	    return {
	        get: function () {
	            var self = this;
	            var results = [];
	            var existing = find(this.xml, NS, sub);
	            if (!existing.length) {
	                return results;
	            }
	            existing = existing[0];
	            var data = find(existing, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

	            data.forEach(function (xml) {
	                results.push(new ChildJXT({}, xml, self));
	            });
	            return results;
	        },
	        set: function (values) {
	            var self = this;
	            var existing = find(this.xml, NS, sub);
	            if (existing.length) {
	                self.xml.removeChild(existing[0]);
	            }

	            if (!values.length) {
	                return;
	            }

	            existing = createElement(NS, sub, this._NS);

	            values.forEach(function (value) {
	                var content = new ChildJXT(value, null, self);
	                existing.appendChild(content.xml);
	            });

	            self.xml.appendChild(existing);
	        }
	    };
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ltx = __webpack_require__(245);
	var DOMElement = __webpack_require__(255);

	var XML_NS = exports.XML_NS = 'http://www.w3.org/XML/1998/namespace';


	exports.parse = function (str) {
	    var xml = ltx.parse(str, {
	        Element: DOMElement
	    });
	    if (xml.nodeType !== 1) {
	        return;
	    }
	    return xml;
	};

	exports.createElement = function (NS, name, parentNS) {
	    var el = new DOMElement(name);
	    if (!parentNS || parentNS !== NS) {
	        exports.setAttribute(el, 'xmlns', NS);
	    }
	    return el;
	};

	var find = exports.find = function (xml, NS, selector) {
	    var results = [];
	    var children = xml.getElementsByTagName(selector);
	    for (var i = 0, len = children.length; i < len; i++) {
	        var child = children[i];
	        if (child.namespaceURI === NS && child.parentNode === xml) {
	            results.push(child);
	        }
	    }
	    return results;
	};

	exports.findOrCreate = function (xml, NS, selector) {
	    var existing = exports.find(xml, NS, selector);
	    if (existing.length) {
	        return existing[0];
	    } else {
	        var created = exports.createElement(NS, selector, xml.namespaceURI);
	        xml.appendChild(created);
	        return created;
	    }
	};

	exports.getAttribute = function (xml, attr, defaultVal) {
	    return xml.getAttribute(attr) || defaultVal || '';
	};

	exports.getAttributeNS = function (xml, NS, attr, defaultVal) {
	    return xml.getAttributeNS(NS, attr) || defaultVal || '';
	};

	exports.setAttribute = function (xml, attr, value, force) {
	    if (value || force) {
	        xml.setAttribute(attr, value);
	    } else {
	        xml.removeAttribute(attr);
	    }
	};

	exports.setAttributeNS = function (xml, NS, attr, value, force) {
	    if (value || force) {
	        xml.setAttributeNS(NS, attr, value);
	    } else {
	        xml.removeAttributeNS(NS, attr);
	    }
	};

	exports.getBoolAttribute = function (xml, attr, defaultVal) {
	    var val = xml.getAttribute(attr) || defaultVal || '';
	    return val === 'true' || val === '1';
	};

	exports.setBoolAttribute = function (xml, attr, value) {
	    if (value) {
	        xml.setAttribute(attr, '1');
	    } else {
	        xml.removeAttribute(attr);
	    }
	};

	exports.getSubAttribute = function (xml, NS, sub, attr, defaultVal) {
	    var subs = find(xml, NS, sub);
	    if (!subs) {
	        return '';
	    }

	    for (var i = 0; i < subs.length; i++) {
	        return subs[i].getAttribute(attr) || defaultVal || '';
	    }

	    return '';
	};

	exports.setSubAttribute = function (xml, NS, sub, attr, value) {
	    var subs = find(xml, NS, sub);
	    if (!subs.length) {
	        if (value) {
	            sub = exports.createElement(NS, sub, xml.namespaceURI);
	            sub.setAttribute(attr, value);
	            xml.appendChild(sub);
	        }
	    } else {
	        for (var i = 0; i < subs.length; i++) {
	            if (value) {
	                subs[i].setAttribute(attr, value);
	                return;
	            } else {
	                subs[i].removeAttribute(attr);
	            }
	        }
	    }
	};

	exports.getBoolSubAttribute = function (xml, NS, sub, attr, defaultVal) {
	    var val = xml.getSubAttribute(NS, sub, attr) || defaultVal || '';
	    return val === 'true' || val === '1';
	};

	exports.setBoolSubAttribute = function (xml, NS, sub, attr, value) {
	    value = value ? '1' : '';
	    exports.setSubAttribute(xml, NS, sub, attr, value);
	};

	exports.getText = function (xml) {
	    return xml.textContent;
	};

	exports.setText = function (xml, value) {
	    xml.textContent = value;
	};

	exports.getSubText = exports.getTextSub = function (xml, NS, element, defaultVal) {
	    var subs = find(xml, NS, element);

	    defaultVal = defaultVal || '';

	    if (!subs.length) {
	        return defaultVal;
	    }

	    return subs[0].textContent || defaultVal;
	};

	exports.setSubText = exports.setTextSub = function (xml, NS, element, value) {
	    var subs = find(xml, NS, element);
	    if (subs.length) {
	        for (var i = 0; i < subs.length; i++) {
	            xml.removeChild(subs[i]);
	        }
	    }

	    if (value) {
	        var sub = exports.createElement(NS, element, xml.namespaceURI);
	        if (value !== true) {
	            sub.textContent = value;
	        }
	        xml.appendChild(sub);
	    }
	};

	exports.getMultiSubText = function (xml, NS, element, extractor) {
	    var subs = find(xml, NS, element);
	    var results = [];

	    extractor = extractor || function (sub) {
	        return sub.textContent || '';
	    };

	    for (var i = 0; i < subs.length; i++) {
	        results.push(extractor(subs[i]));
	    }

	    return results;
	};

	exports.setMultiSubText = function (xml, NS, element, value, builder) {
	    var subs = find(xml, NS, element);
	    var values = [];
	    builder = builder || function (value) {
	        if (value) {
	            var sub = exports.createElement(NS, element, xml.namespaceURI);
	            sub.textContent = value;
	            xml.appendChild(sub);
	        }
	    };
	    if (typeof value === 'string') {
	        values = (value || '').split('\n');
	    } else {
	        values = value;
	    }

	    var i, len;
	    for(i = 0, len = subs.length; i < len; i++) {
	        xml.removeChild(subs[i]);
	    }

	    for(i = 0, len = values.length; i < len; i++) {
	        builder(values[i]);
	    }
	};

	exports.getMultiSubAttribute = function (xml, NS, element, attr) {
	    return exports.getMultiSubText(xml, NS, element, function (sub) {
	        return exports.getAttribute(sub, attr);
	    });
	};

	exports.setMultiSubAttribute = function (xml, NS, element, attr, value) {
	    exports.setMultiSubText(xml, NS, element, value, function (val) {
	        var sub = exports.createElement(NS, element, xml.namespaceURI);
	        exports.setAttribute(sub, attr, val);
	        xml.appendChild(sub);
	    });
	};

	exports.getSubLangText = function (xml, NS, element, defaultLang) {
	    var subs = find(xml, NS, element);
	    if (!subs.length) {
	        return {};
	    }

	    var lang, sub;
	    var results = {};
	    var langs = [];

	    for (var i = 0; i < subs.length; i++) {
	        sub = subs[i];
	        lang = sub.getAttributeNS(XML_NS, 'lang') || defaultLang;
	        langs.push(lang);
	        results[lang] = sub.textContent || '';
	    }

	    return results;
	};

	exports.setSubLangText = function (xml, NS, element, value, defaultLang) {
	    var sub, lang;
	    var subs = find(xml, NS, element);
	    if (subs.length) {
	        for (var i = 0; i < subs.length; i++) {
	            xml.removeChild(subs[i]);
	        }
	    }

	    if (typeof value === 'string') {
	        sub = exports.createElement(NS, element, xml.namespaceURI);
	        sub.textContent = value;
	        xml.appendChild(sub);
	    } else if (typeof value === 'object') {
	        for (lang in value) {
	            if (value.hasOwnProperty(lang)) {
	                sub = exports.createElement(NS, element, xml.namespaceURI);
	                if (lang !== defaultLang) {
	                    sub.setAttributeNS(XML_NS, 'lang', lang);
	                }
	                sub.textContent = value[lang];
	                xml.appendChild(sub);
	            }
	        }
	    }
	};

	exports.getBoolSub = function (xml, NS, element) {
	    var subs = find(xml, NS, element);
	    return !!subs.length;
	};

	exports.setBoolSub = function (xml, NS, element, value) {
	    var subs = find(xml, NS, element);
	    if (!subs.length) {
	        if (value) {
	            var sub = exports.createElement(NS, element, xml.namespaceURI);
	            xml.appendChild(sub);
	        }
	    } else {
	        for (var i = 0; i < subs.length; i++) {
	            if (value) {
	                return;
	            } else {
	                xml.removeChild(subs[i]);
	            }
	        }
	    }
	};


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var parse = __webpack_require__(246)
	var Parser = __webpack_require__(247)
	var escape = __webpack_require__(250)
	var Element = __webpack_require__(249)
	var equal = __webpack_require__(251)
	var createElement = __webpack_require__(253)
	var tag = __webpack_require__(254)

	exports = module.exports = tag

	exports.Element = Element

	exports.equal = equal.equal
	exports.nameEqual = equal.name
	exports.attrsEqual = equal.attrs
	exports.childrenEqual = equal.children

	exports.createElement = createElement

	exports.escapeXML = escape.escapeXML
	exports.unescapeXML = escape.unescapeXML
	exports.escapeXMLText = escape.escapeXMLText
	exports.unescapeXMLText = escape.unescapeXMLText

	exports.Parser = Parser
	exports.parse = parse

	exports.tag = tag


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var Parser = __webpack_require__(247)

	module.exports = function parse (data, options) {
	  var p
	  if (typeof options === 'function') {
	    p = new options() // eslint-disable-line
	  } else {
	    p = new Parser(options)
	  }

	  var result = null
	  var error = null

	  p.on('tree', function (tree) {
	    result = tree
	  })
	  p.on('error', function (e) {
	    error = e
	  })

	  p.write(data)
	  p.end()

	  if (error) {
	    throw error
	  } else {
	    return result
	  }
	}


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var EventEmitter = __webpack_require__(248).EventEmitter
	var inherits = __webpack_require__(199)
	var Element = __webpack_require__(249)
	var LtxParser = __webpack_require__(252)

	var Parser = function (options) {
	  EventEmitter.call(this)

	  var ParserInterface = this.Parser = (options && options.Parser) || this.DefaultParser
	  var ElementInterface = this.Element = (options && options.Element) || this.DefaultElement

	  this.parser = new ParserInterface()

	  var el
	  var self = this
	  this.parser.on('startElement', function (name, attrs) {
	    var child = new ElementInterface(name, attrs)
	    if (!el) {
	      el = child
	    } else {
	      el = el.cnode(child)
	    }
	  })
	  this.parser.on('endElement', function (name) {
	    if (!el) {
	      /* Err */
	    } else if (name === el.name) {
	      if (el.parent) {
	        el = el.parent
	      } else if (!self.tree) {
	        self.tree = el
	        el = undefined
	      }
	    }
	  })
	  this.parser.on('text', function (str) {
	    if (el) {
	      el.t(str)
	    }
	  })
	  this.parser.on('error', function (e) {
	    self.error = e
	    self.emit('error', e)
	  })
	}

	inherits(Parser, EventEmitter)

	Parser.prototype.DefaultParser = LtxParser

	Parser.prototype.DefaultElement = Element

	Parser.prototype.write = function (data) {
	  this.parser.write(data)
	}

	Parser.prototype.end = function (data) {
	  this.parser.end(data)

	  if (!this.error) {
	    if (this.tree) {
	      this.emit('tree', this.tree)
	    } else {
	      this.emit('error', new Error('Incomplete document'))
	    }
	  }
	}

	module.exports = Parser


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var escape = __webpack_require__(250)
	var escapeXML = escape.escapeXML
	var escapeXMLText = escape.escapeXMLText

	var equality = __webpack_require__(251)
	var equal = equality.equal
	var nameEqual = equality.name
	var attrsEqual = equality.attrs
	var childrenEqual = equality.children

	/**
	 * This cheap replica of DOM/Builder puts me to shame :-)
	 *
	 * Attributes are in the element.attrs object. Children is a list of
	 * either other Elements or Strings for text content.
	 **/
	function Element (name, attrs) {
	  this.name = name
	  this.parent = null
	  this.children = []
	  this.attrs = {}
	  this.setAttrs(attrs)
	}

	/* Accessors */

	/**
	 * if (element.is('message', 'jabber:client')) ...
	 **/
	Element.prototype.is = function (name, xmlns) {
	  return (this.getName() === name) &&
	  (!xmlns || (this.getNS() === xmlns))
	}

	/* without prefix */
	Element.prototype.getName = function () {
	  if (this.name.indexOf(':') >= 0) {
	    return this.name.substr(this.name.indexOf(':') + 1)
	  } else {
	    return this.name
	  }
	}

	/**
	 * retrieves the namespace of the current element, upwards recursively
	 **/
	Element.prototype.getNS = function () {
	  if (this.name.indexOf(':') >= 0) {
	    var prefix = this.name.substr(0, this.name.indexOf(':'))
	    return this.findNS(prefix)
	  }
	  return this.findNS()
	}

	/**
	 * find the namespace to the given prefix, upwards recursively
	 **/
	Element.prototype.findNS = function (prefix) {
	  if (!prefix) {
	    /* default namespace */
	    if (this.attrs.xmlns) {
	      return this.attrs.xmlns
	    } else if (this.parent) {
	      return this.parent.findNS()
	    }
	  } else {
	    /* prefixed namespace */
	    var attr = 'xmlns:' + prefix
	    if (this.attrs[attr]) {
	      return this.attrs[attr]
	    } else if (this.parent) {
	      return this.parent.findNS(prefix)
	    }
	  }
	}

	/**
	 * Recursiverly gets all xmlns defined, in the form of {url:prefix}
	 **/
	Element.prototype.getXmlns = function () {
	  var namespaces = {}

	  if (this.parent) {
	    namespaces = this.parent.getXmlns()
	  }

	  for (var attr in this.attrs) {
	    var m = attr.match('xmlns:?(.*)')
	    if (this.attrs.hasOwnProperty(attr) && m) {
	      namespaces[this.attrs[attr]] = m[1]
	    }
	  }
	  return namespaces
	}

	Element.prototype.setAttrs = function (attrs) {
	  if (typeof attrs === 'string') {
	    this.attrs.xmlns = attrs
	  } else if (attrs) {
	    Object.keys(attrs).forEach(function (key) {
	      this.attrs[key] = attrs[key]
	    }, this)
	  }
	}

	/**
	 * xmlns can be null, returns the matching attribute.
	 **/
	Element.prototype.getAttr = function (name, xmlns) {
	  if (!xmlns) {
	    return this.attrs[name]
	  }

	  var namespaces = this.getXmlns()

	  if (!namespaces[xmlns]) {
	    return null
	  }

	  return this.attrs[[namespaces[xmlns], name].join(':')]
	}

	/**
	 * xmlns can be null
	 **/
	Element.prototype.getChild = function (name, xmlns) {
	  return this.getChildren(name, xmlns)[0]
	}

	/**
	 * xmlns can be null
	 **/
	Element.prototype.getChildren = function (name, xmlns) {
	  var result = []
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    if (child.getName &&
	      (child.getName() === name) &&
	      (!xmlns || (child.getNS() === xmlns))) {
	      result.push(child)
	    }
	  }
	  return result
	}

	/**
	 * xmlns and recursive can be null
	 **/
	Element.prototype.getChildByAttr = function (attr, val, xmlns, recursive) {
	  return this.getChildrenByAttr(attr, val, xmlns, recursive)[0]
	}

	/**
	 * xmlns and recursive can be null
	 **/
	Element.prototype.getChildrenByAttr = function (attr, val, xmlns, recursive) {
	  var result = []
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    if (child.attrs &&
	      (child.attrs[attr] === val) &&
	      (!xmlns || (child.getNS() === xmlns))) {
	      result.push(child)
	    }
	    if (recursive && child.getChildrenByAttr) {
	      result.push(child.getChildrenByAttr(attr, val, xmlns, true))
	    }
	  }
	  if (recursive) {
	    result = [].concat.apply([], result)
	  }
	  return result
	}

	Element.prototype.getChildrenByFilter = function (filter, recursive) {
	  var result = []
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    if (filter(child)) {
	      result.push(child)
	    }
	    if (recursive && child.getChildrenByFilter) {
	      result.push(child.getChildrenByFilter(filter, true))
	    }
	  }
	  if (recursive) {
	    result = [].concat.apply([], result)
	  }
	  return result
	}

	Element.prototype.getText = function () {
	  var text = ''
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    if ((typeof child === 'string') || (typeof child === 'number')) {
	      text += child
	    }
	  }
	  return text
	}

	Element.prototype.getChildText = function (name, xmlns) {
	  var child = this.getChild(name, xmlns)
	  return child ? child.getText() : null
	}

	/**
	 * Return all direct descendents that are Elements.
	 * This differs from `getChildren` in that it will exclude text nodes,
	 * processing instructions, etc.
	 */
	Element.prototype.getChildElements = function () {
	  return this.getChildrenByFilter(function (child) {
	    return child instanceof Element
	  })
	}

	/* Builder */

	/** returns uppermost parent */
	Element.prototype.root = function () {
	  if (this.parent) {
	    return this.parent.root()
	  }
	  return this
	}
	Element.prototype.tree = Element.prototype.root

	/** just parent or itself */
	Element.prototype.up = function () {
	  if (this.parent) {
	    return this.parent
	  }
	  return this
	}

	Element.prototype._getElement = function (name, attrs) {
	  var element = new Element(name, attrs)
	  return element
	}

	/** create child node and return it */
	Element.prototype.c = function (name, attrs) {
	  return this.cnode(this._getElement(name, attrs))
	}

	Element.prototype.cnode = function (child) {
	  this.children.push(child)
	  if (typeof child === 'object') {
	    child.parent = this
	  }
	  return child
	}

	/** add text node and return element */
	Element.prototype.t = function (text) {
	  this.children.push(text)
	  return this
	}

	/* Manipulation */

	/**
	 * Either:
	 *   el.remove(childEl)
	 *   el.remove('author', 'urn:...')
	 */
	Element.prototype.remove = function (el, xmlns) {
	  var filter
	  if (typeof el === 'string') {
	    /* 1st parameter is tag name */
	    filter = function (child) {
	      return !(child.is &&
	      child.is(el, xmlns))
	    }
	  } else {
	    /* 1st parameter is element */
	    filter = function (child) {
	      return child !== el
	    }
	  }

	  this.children = this.children.filter(filter)

	  return this
	}

	/**
	 * To use in case you want the same XML data for separate uses.
	 * Please refrain from this practise unless you know what you are
	 * doing. Building XML with ltx is easy!
	 */
	Element.prototype.clone = function () {
	  var clone = this._getElement(this.name, this.attrs)
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    clone.cnode(child.clone ? child.clone() : child)
	  }
	  return clone
	}

	Element.prototype.text = function (val) {
	  if (val && this.children.length === 1) {
	    this.children[0] = val
	    return this
	  }
	  return this.getText()
	}

	Element.prototype.attr = function (attr, val) {
	  if (typeof val !== 'undefined' || val === null) {
	    if (!this.attrs) {
	      this.attrs = {}
	    }
	    this.attrs[attr] = val
	    return this
	  }
	  return this.attrs[attr]
	}

	/* Serialization */

	Element.prototype.toString = function () {
	  var s = ''
	  this.write(function (c) {
	    s += c
	  })
	  return s
	}

	Element.prototype.toJSON = function () {
	  return {
	    name: this.name,
	    attrs: this.attrs,
	    children: this.children.map(function (child) {
	      return child && child.toJSON ? child.toJSON() : child
	    })
	  }
	}

	Element.prototype._addChildren = function (writer) {
	  writer('>')
	  for (var i = 0; i < this.children.length; i++) {
	    var child = this.children[i]
	    /* Skip null/undefined */
	    if (child || (child === 0)) {
	      if (child.write) {
	        child.write(writer)
	      } else if (typeof child === 'string') {
	        writer(escapeXMLText(child))
	      } else if (child.toString) {
	        writer(escapeXMLText(child.toString(10)))
	      }
	    }
	  }
	  writer('</')
	  writer(this.name)
	  writer('>')
	}

	Element.prototype.write = function (writer) {
	  writer('<')
	  writer(this.name)
	  for (var k in this.attrs) {
	    var v = this.attrs[k]
	    if (v != null) { // === null || undefined
	      writer(' ')
	      writer(k)
	      writer('="')
	      if (typeof v !== 'string') {
	        v = v.toString()
	      }
	      writer(escapeXML(v))
	      writer('"')
	    }
	  }
	  if (this.children.length === 0) {
	    writer('/>')
	  } else {
	    this._addChildren(writer)
	  }
	}

	Element.prototype.nameEquals = function (el) {
	  return nameEqual(this, el)
	}

	Element.prototype.attrsEquals = function (el) {
	  return attrsEqual(this, el)
	}

	Element.prototype.childrenEquals = function (el) {
	  return childrenEqual(this, el)
	}

	Element.prototype.equals = function (el) {
	  return equal(this, el)
	}

	module.exports = Element


/***/ },
/* 250 */
/***/ function(module, exports) {

	'use strict'

	exports.escapeXML = function escapeXML (s) {
	  return s
	    .replace(/\&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&apos;')
	}

	exports.unescapeXML = function unescapeXML (s) {
	  return s
	    .replace(/\&(amp|#38);/g, '&')
	    .replace(/\&(lt|#60);/g, '<')
	    .replace(/\&(gt|#62);/g, '>')
	    .replace(/\&(quot|#34);/g, '"')
	    .replace(/\&(apos|#39);/g, "'")
	}

	exports.escapeXMLText = function escapeXMLText (s) {
	  return s
	    .replace(/\&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	}

	exports.unescapeXMLText = function unescapeXMLText (s) {
	  return s
	    .replace(/\&(amp|#38);/g, '&')
	    .replace(/\&(lt|#60);/g, '<')
	    .replace(/\&(gt|#62);/g, '>')
	}


/***/ },
/* 251 */
/***/ function(module, exports) {

	'use strict'

	function nameEqual (a, b) {
	  return a.name === b.name
	}

	function attrsEqual (a, b) {
	  var attrs = a.attrs
	  var keys = Object.keys(attrs)
	  var length = keys.length
	  if (length !== Object.keys(b.attrs).length) return false
	  for (var i = 0, l = length; i < l; i++) {
	    var key = keys[i]
	    var value = attrs[key]
	    if (value == null || b.attrs[key] == null) { // === null || undefined
	      if (value !== b.attrs[key]) return false
	    } else if (value.toString() !== b.attrs[key].toString()) {
	      return false
	    }
	  }
	  return true
	}

	function childrenEqual (a, b) {
	  var children = a.children
	  var length = children.length
	  if (length !== b.children.length) return false
	  for (var i = 0, l = length; i < l; i++) {
	    var child = children[i]
	    if (typeof child === 'string') {
	      if (child !== b.children[i]) return false
	    } else {
	      if (!child.equals(b.children[i])) return false
	    }
	  }
	  return true
	}

	function equal (a, b) {
	  if (!nameEqual(a, b)) return false
	  if (!attrsEqual(a, b)) return false
	  if (!childrenEqual(a, b)) return false
	  return true
	}

	module.exports.name = nameEqual
	module.exports.attrs = attrsEqual
	module.exports.children = childrenEqual
	module.exports.equal = equal


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var inherits = __webpack_require__(199)
	var EventEmitter = __webpack_require__(248).EventEmitter
	var unescapeXML = __webpack_require__(250).unescapeXML

	var STATE_TEXT = 0
	var STATE_IGNORE_TAG = 1
	var STATE_TAG_NAME = 2
	var STATE_TAG = 3
	var STATE_ATTR_NAME = 4
	var STATE_ATTR_EQ = 5
	var STATE_ATTR_QUOT = 6
	var STATE_ATTR_VALUE = 7

	var SaxLtx = module.exports = function SaxLtx () {
	  EventEmitter.call(this)

	  var state = STATE_TEXT
	  var remainder
	  var tagName
	  var attrs
	  var endTag
	  var selfClosing
	  var attrQuote
	  var recordStart = 0
	  var attrName

	  this._handleTagOpening = function (endTag, tagName, attrs) {
	    if (!endTag) {
	      this.emit('startElement', tagName, attrs)
	      if (selfClosing) {
	        this.emit('endElement', tagName)
	      }
	    } else {
	      this.emit('endElement', tagName)
	    }
	  }

	  this.write = function (data) {
	    if (typeof data !== 'string') {
	      data = data.toString()
	    }
	    var pos = 0

	    /* Anything from previous write()? */
	    if (remainder) {
	      data = remainder + data
	      pos += remainder.length
	      remainder = null
	    }

	    function endRecording () {
	      if (typeof recordStart === 'number') {
	        var recorded = data.slice(recordStart, pos)
	        recordStart = undefined
	        return recorded
	      }
	    }

	    for (; pos < data.length; pos++) {
	      var c = data.charCodeAt(pos)
	      // console.log("state", state, "c", c, data[pos])
	      switch (state) {
	        case STATE_TEXT:
	          if (c === 60 /* < */) {
	            var text = endRecording()
	            if (text) {
	              this.emit('text', unescapeXML(text))
	            }
	            state = STATE_TAG_NAME
	            recordStart = pos + 1
	            attrs = {}
	          }
	          break
	        case STATE_TAG_NAME:
	          if (c === 47 /* / */ && recordStart === pos) {
	            recordStart = pos + 1
	            endTag = true
	          } else if (c === 33 /* ! */ || c === 63 /* ? */) {
	            recordStart = undefined
	            state = STATE_IGNORE_TAG
	          } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
	            tagName = endRecording()
	            pos--
	            state = STATE_TAG
	          }
	          break
	        case STATE_IGNORE_TAG:
	          if (c === 62 /* > */) {
	            state = STATE_TEXT
	          }
	          break
	        case STATE_TAG:
	          if (c === 62 /* > */) {
	            this._handleTagOpening(endTag, tagName, attrs)
	            tagName = undefined
	            attrs = undefined
	            endTag = undefined
	            selfClosing = undefined
	            state = STATE_TEXT
	            recordStart = pos + 1
	          } else if (c === 47 /* / */) {
	            selfClosing = true
	          } else if (c > 32) {
	            recordStart = pos
	            state = STATE_ATTR_NAME
	          }
	          break
	        case STATE_ATTR_NAME:
	          if (c <= 32 || c === 61 /* = */) {
	            attrName = endRecording()
	            pos--
	            state = STATE_ATTR_EQ
	          }
	          break
	        case STATE_ATTR_EQ:
	          if (c === 61 /* = */) {
	            state = STATE_ATTR_QUOT
	          }
	          break
	        case STATE_ATTR_QUOT:
	          if (c === 34 /* " */ || c === 39 /* ' */) {
	            attrQuote = c
	            state = STATE_ATTR_VALUE
	            recordStart = pos + 1
	          }
	          break
	        case STATE_ATTR_VALUE:
	          if (c === attrQuote) {
	            var value = unescapeXML(endRecording())
	            attrs[attrName] = value
	            attrName = undefined
	            state = STATE_TAG
	          }
	          break
	      }
	    }

	    if (typeof recordStart === 'number' &&
	      recordStart <= data.length) {
	      remainder = data.slice(recordStart)
	      recordStart = 0
	    }
	  }
	  /*
	  var origEmit = this.emit
	  this.emit = function() {
	    console.log('ltx', arguments)
	    origEmit.apply(this, arguments)
	  }
	  */
	}
	inherits(SaxLtx, EventEmitter)

	SaxLtx.prototype.end = function (data) {
	  if (data) {
	    this.write(data)
	  }

	  /* Uh, yeah */
	  this.write = function () {}
	}


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	// JSX compatible

	var Element = __webpack_require__(249)

	module.exports = function createElement (name, attrs /*, child1, child2, ...*/) {
	  var el = new Element(name, attrs)

	  var children = Array.prototype.slice.call(arguments, 2)

	  children.forEach(function (child) {
	    el.cnode(child)
	  })
	  return el
	}


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var escape = __webpack_require__(250).escapeXML
	var parse = __webpack_require__(246)

	module.exports = function tag (/* [literals], ...substitutions */) {
	  var literals = arguments[0]
	  var substitutions = Array.prototype.slice.call(arguments, 1)

	  var str = ''

	  for (var i = 0; i < substitutions.length; i++) {
	    str += literals[i]
	    str += escape(substitutions[i])
	  }
	  str += literals[literals.length - 1]

	  return parse(str)
	}


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var inherits = __webpack_require__(199)
	var Element = __webpack_require__(249)

	function DOMElement (name, attrs) {
	  Element.call(this, name, attrs)

	  this.nodeType = 1
	  this.nodeName = this.localName
	}

	inherits(DOMElement, Element)

	DOMElement.prototype._getElement = function (name, attrs) {
	  var element = new DOMElement(name, attrs)
	  return element
	}

	Object.defineProperty(DOMElement.prototype, 'localName', {
	  get: function () {
	    return this.getName()
	  }
	})

	Object.defineProperty(DOMElement.prototype, 'namespaceURI', {
	  get: function () {
	    return this.getNS()
	  }
	})

	Object.defineProperty(DOMElement.prototype, 'parentNode', {
	  get: function () {
	    return this.parent
	  }
	})

	Object.defineProperty(DOMElement.prototype, 'childNodes', {
	  get: function () {
	    return this.children
	  }
	})

	Object.defineProperty(DOMElement.prototype, 'textContent', {
	  get: function () {
	    return this.getText()
	  },
	  set: function (value) {
	    this.children.push(value)
	  }
	})

	DOMElement.prototype.getElementsByTagName = function (name) {
	  return this.getChildren(name)
	}

	DOMElement.prototype.getAttribute = function (name) {
	  return this.getAttr(name)
	}

	DOMElement.prototype.setAttribute = function (name, value) {
	  this.attr(name, value)
	}

	DOMElement.prototype.getAttributeNS = function (ns, name) {
	  if (ns === 'http://www.w3.org/XML/1998/namespace') {
	    return this.getAttr(['xml', name].join(':'))
	  }
	  return this.getAttr(name, ns)
	}

	DOMElement.prototype.setAttributeNS = function (ns, name, value) {
	  var prefix
	  if (ns === 'http://www.w3.org/XML/1998/namespace') {
	    prefix = 'xml'
	  } else {
	    var nss = this.getXmlns()
	    prefix = nss[ns] || ''
	  }
	  if (prefix) {
	    this.attr([prefix, name].join(':'), value)
	  }
	}

	DOMElement.prototype.removeAttribute = function (name) {
	  this.attr(name, null)
	}

	DOMElement.prototype.removeAttributeNS = function (ns, name) {
	  var prefix
	  if (ns === 'http://www.w3.org/XML/1998/namespace') {
	    prefix = 'xml'
	  } else {
	    var nss = this.getXmlns()
	    prefix = nss[ns] || ''
	  }
	  if (prefix) {
	    this.attr([prefix, name].join(':'), null)
	  }
	}

	DOMElement.prototype.appendChild = function (el) {
	  this.cnode(el)
	}

	DOMElement.prototype.removeChild = function (el) {
	  this.remove(el)
	}

	DOMElement.createElement = function (name, attrs /*, child1, child2, ...*/) {
	  var el = new DOMElement(name, attrs)

	  var children = Array.prototype.slice.call(arguments, 2)

	  children.forEach(function (child) {
	    el.appendChild(child)
	  })
	  return el
	}

	module.exports = DOMElement


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(244);
	var extend = __webpack_require__(234);


	var EXCLUDE = {
	    constructor: true,
	    parent: true,
	    prototype: true,
	    toJSON: true,
	    toString: true,
	    xml: true
	};


	module.exports = function (JXT, opts) {
	    function Stanza(data, xml, parent) {
	        var self = this;

	        var parentNode = (xml || {}).parentNode || (parent || {}).xml;
	        var parentNS = (parentNode || {}).namespaceURI;

	        self.xml = xml || helpers.createElement(self._NS, self._EL, parentNS);

	        Object.keys(self._PREFIXES).forEach(function (prefix) {
	            var namespace = self._PREFIXES[prefix];
	            self.xml.setAttribute('xmlns:' + prefix, namespace);
	        });

	        self._extensions = {};

	        for (var i = 0, len = self.xml.childNodes.length; i < len; i++) {
	            var child = self.xml.childNodes[i];
	            var ChildJXT = JXT.getDefinition(child.localName, child.namespaceURI);
	            if (ChildJXT !== undefined) {
	                var name = ChildJXT.prototype._name;
	                self._extensions[name] = new ChildJXT(null, child);
	                self._extensions[name].parent = self;
	            }
	        }

	        extend(self, data);

	        if (opts.init) {
	            opts.init.apply(self, [data]);
	        }

	        return self;
	    }


	    Stanza.prototype._name = opts.name;
	    Stanza.prototype._eventname = opts.eventName;
	    Stanza.prototype._NS = opts.namespace;
	    Stanza.prototype._EL = opts.element || opts.name;
	    Stanza.prototype._PREFIXES = opts.prefixes || {};
	    Stanza.prototype._TAGS = opts.tags || [];

	    Stanza.prototype.toString = function () {
	        return this.xml.toString();
	    };

	    Stanza.prototype.toJSON = function () {
	        var prop;
	        var result = {};

	        for (prop in this._extensions) {
	            if (this._extensions[prop].toJSON && prop[0] !== '_') {
	                result[prop] = this._extensions[prop].toJSON();
	            }
	        }

	        for (prop in this) {
	            var allowedName = !EXCLUDE[prop] && prop[0] !== '_';
	            var isExtensionName = JXT.getExtensions(this._EL, this._NS)[prop];

	            if (allowedName && !isExtensionName) {
	                var val = this[prop];
	                if (typeof val === 'function') {
	                    continue;
	                }
	                var type = Object.prototype.toString.call(val);
	                if (type.indexOf('Object') >= 0) {
	                    if (Object.keys(val).length > 0) {
	                        result[prop] = val;
	                    }
	                } else if (type.indexOf('Array') >= 0) {
	                    if (val.length > 0) {
	                        var vals = [];
	                        var len = val.length;
	                        for (var n = 0; n < len; n++) {
	                            var nval = val[n];
	                            if (typeof nval !== 'undefined') {
	                                if (nval.toJSON !== undefined) {
	                                    vals.push(nval.toJSON());
	                                } else {
	                                    vals.push(nval);
	                                }
	                            }
	                        }
	                        result[prop] = vals;
	                    }
	                } else if (val !== undefined && val !== false && val !== '') {
	                    result[prop] = val;
	                }
	            }
	        }

	        return result;
	    };

	    return Stanza;
	};


/***/ },
/* 257 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console, process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.10.2
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};

	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");

	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};

	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    if (schedule.isStatic) {
	        schedule = function(fn) { setTimeout(fn, 0); };
	    }
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = new Async();
	module.exports.firstLineError = firstLineError;

	},{"./queue.js":28,"./schedule.js":31,"./util.js":38}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();

	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};

	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);

	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function() {
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};

	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;

	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};

	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;

	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};

	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};

	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};

	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};

	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);

	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};

	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;

	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};

	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};

	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};

	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};

	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};

	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }

	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }

	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }

	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }

	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();

	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}

	return CapturedTrace;
	};

	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;

	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}

	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);

	    if (retfilter === errorObj) return retfilter;

	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}

	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundValue();
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);

	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};

	return CatchFilter;
	};

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};

	function createContext() {
	    if (isDebugging()) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}

	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;

	return createContext;
	};

	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));

	if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0) debugging = false;

	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}

	Promise.prototype._ignoreRejections = function() {
	    this._unsetRejectionIsUnhandled();
	    this._bitField = this._bitField | 16777216;
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 16777216) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};

	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};

	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};

	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};

	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};

	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};

	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};

	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}

	return function() {
	    return debugging;
	};
	};

	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;

	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	var returnUndefined = function() {};
	var throwUndefined = function() {
	    throw undefined;
	};

	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};


	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value === undefined) return this.then(returnUndefined);

	    if (isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    } else if (value instanceof Promise) {
	        value._ignoreRejections();
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (reason === undefined) return this.then(throwUndefined);

	    if (isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};

	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};

	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};

	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}

	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};

	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;

	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}

	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue())
	                    : handler();

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }

	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}

	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue(), value)
	                    : handler(value);

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}

	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();

	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };

	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};

	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};

	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};

	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }

	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };

	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };

	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};

	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var callback = this._callback;
	        var receiver = this._promise._boundValue();
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }

	    }
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}

	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	    return map(this, fn, options, null).promise();
	};

	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};


	};

	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};

	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback =
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};

	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};

	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);

	};

	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};

	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;

	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};


	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }

	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};

	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};

	var util = _dereq_("./util.js");

	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);

	var UNDEFINED_BINDING = {};
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};

	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }

	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }

	    var callbackIndex = target._addCallbacks(didFulfill,
	                                             didReject,
	                                             didProgress,
	                                             ret,
	                                             receiver,
	                                             getDomain());

	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }

	    return ret;
	};

	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};

	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};

	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};

	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};

	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};

	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};

	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};

	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};

	Promise.prototype._boundValue = function() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	};

	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this._progressHandler0 =
	                domain === null ? progress : domain.bind(progress);
	        }
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this[base + 2] =
	                domain === null ? progress : domain.bind(progress);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};

	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};

	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundValue(), value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();

	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};

	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};

	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};

	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};

	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;

	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);

	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    this._clearCallbackDataAtIndex(index);

	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }

	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};

	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};

	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};

	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};

	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};

	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};

	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};

	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();

	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }

	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};

	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);

	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          

	};

	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._ignoreRejections();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};

	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};


	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};

	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;

	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }

	        promise = null;
	    };
	}


	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}

	PromiseResolver._nodebackForPromise = nodebackForPromise;

	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};

	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};

	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};

	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};

	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};

	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};

	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};

	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};

	module.exports = PromiseResolver;

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";

	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            util.notEnumerableProp,
	            INTERNAL
	        );
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key, fn, suffix);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}

	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};


	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");

	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};

	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};

	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;

	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};

	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._init = function () {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};

	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];

	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;

	    var callback = this._callback;
	    var receiver = this._promise._boundValue();
	    var ret;

	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();

	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }

	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }

	    this._resolve(isEach ? preservedValues : this._accum);
	};

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};

	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var util = _dereq_("./util");
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            window.navigator.standalone)) {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;

	},{"./util":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};

	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};

	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}

	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};

	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};

	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};

	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};

	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};

	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};

	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};

	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};

	Promise.prototype._value = function() {
	    return this._settledValue;
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};

	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};


	Promise.PromiseInspection = PromiseInspection;
	};

	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function getThen(obj) {
	    return obj.then;
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolveFromThenable(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }

	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }

	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};

	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;

	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    
	    var err;
	    if(!util.isPrimitive(message) && (message instanceof Error)) {
	        err = message;
	    } else {
	        if (typeof message !== "string") {
	            message = "operation timed out";
	        }
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};

	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};

	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}

	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};

	};

	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;

	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }

	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }

	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = spreadArgs
	                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};

	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }

	})();

	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return !isPrimitive(value);
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);

	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];

	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };

	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];

	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);

	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();

	if (ret.isNode) ret.toFastProperties(process);

	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;

	},{"./es5.js":14}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196), __webpack_require__(189), (function() { return this; }()), __webpack_require__(219).setImmediate))

/***/ },
/* 259 */
/***/ function(module, exports) {

	'use strict';

	var MAX_SEQ = Math.pow(2, 32);


	function mod(v, n) {
	    return ((v % n) + n) % n;
	}


	function StreamManagement(client) {
	    this.client = client;
	    this.id = false;
	    this.allowResume = true;
	    this.started = false;
	    this.inboundStarted = false;
	    this.outboundStarted = false;
	    this.lastAck = 0;
	    this.handled = 0;
	    this.windowSize = 1;
	    this.unacked = [];
	    this.pendingAck = false;

	    var NS = 'urn:xmpp:sm:3';
	    this.stanzas = {
	        Enable: client.stanzas.getDefinition('enable', NS),
	        Resume: client.stanzas.getDefinition('resume', NS),
	        Ack: client.stanzas.getDefinition('a', NS),
	        Request: client.stanzas.getDefinition('r', NS)
	    };
	}

	StreamManagement.prototype = {
	    constructor: {
	        value: StreamManagement
	    },
	    enable: function () {
	        var enable = new this.stanzas.Enable();
	        enable.resume = this.allowResume;
	        this.client.send(enable);
	        this.handled = 0;
	        this.outboundStarted = true;
	    },
	    resume: function () {
	        var resume = new this.stanzas.Resume({
	            h: this.handled,
	            previd: this.id
	        });
	        this.client.send(resume);
	        this.outboundStarted = true;
	    },
	    enabled: function (resp) {
	        this.id = resp.id;
	        this.handled = 0;
	        this.inboundStarted = true;
	    },
	    resumed: function (resp) {
	        this.id = resp.previd;
	        if (resp.h) {
	            this.process(resp, true);
	        }
	        this.inboundStarted = true;
	    },
	    failed: function () {
	        this.inboundStarted = false;
	        this.outboundStarted = false;
	        this.id = false;
	        this.lastAck = 0;
	        this.handled = 0;
	        this.unacked = [];
	    },
	    ack: function () {
	        this.client.send(new this.stanzas.Ack({
	            h: this.handled
	        }));
	    },
	    request: function () {
	        this.pendingAck = true;
	        this.client.send(new this.stanzas.Request());
	    },
	    process: function (ack, resend) {
	        var self = this;
	        var numAcked = mod(ack.h - this.lastAck, MAX_SEQ);

	        this.pendingAck = false;

	        for (var i = 0; i < numAcked && this.unacked.length > 0; i++) {
	            this.client.emit('stanza:acked', this.unacked.shift());
	        }
	        this.lastAck = ack.h;

	        if (resend) {
	            var resendUnacked = this.unacked;
	            this.unacked = [];
	            resendUnacked.forEach(function (stanza) {
	                self.client.send(stanza);
	            });
	        }

	        if (this.needAck()) {
	            this.request();
	        }
	    },
	    track: function (stanza) {
	        var name = stanza._name;
	        var acceptable = {
	            message: true,
	            presence: true,
	            iq: true
	        };

	        if (this.outboundStarted && acceptable[name]) {
	            this.unacked.push(stanza);
	            if (this.needAck()) {
	                this.request();
	            }
	        }
	    },
	    handle: function () {
	        if (this.inboundStarted) {
	            this.handled = mod(this.handled + 1, MAX_SEQ);
	        }
	    },
	    needAck: function () {
	        return !this.pendingAck && this.unacked.length >= this.windowSize;
	    }
	};

	Object.defineProperties(StreamManagement.prototype, {
	    started: {
	        get: function () {
	            return this.outboundStarted && this.inboundStarted;
	        },
	        set: function (value) {
	            if (!value) {
	                this.outboundStarted = false;
	                this.inboundStarted = false;
	            }
	        }
	    }
	});

	module.exports = StreamManagement;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var async = __webpack_require__(261);
	var request = __webpack_require__(262);

	var JXT = __webpack_require__(240).createRegistry();

	JXT.use(__webpack_require__(270));


	module.exports = function (opts, cb) {
	    if (typeof opts === 'string') {
	        opts = {host: opts};
	    }

	    var config = {
	        ssl: true,
	        json: true,
	        xrd: true
	    };

	    for (var prop in opts) {
	        config[prop] = opts[prop];
	    }

	    var scheme = config.ssl ? 'https://' : 'http://';

	    async.parallel([
	        function (done) {
	            request(scheme + config.host + '/.well-known/host-meta.json', function (err, req, body) {
	                if (err) {
	                    return done(null);
	                }

	                var data;
	                try {
	                    data = JSON.parse(body);
	                } catch (e) {
	                    data = null;
	                }
	                return done(data);
	            });
	        },
	        function (done) {
	            request(scheme + config.host + '/.well-known/host-meta', function (err, req, body) {
	                if (err) {
	                    return done(null);
	                }

	                var xrd = JXT.parse(body);
	                return done(xrd.toJSON());
	            });
	        }
	    ], function (result) {
	        if (result) {
	            cb(null, result);
	        } else {
	            cb('no-host-meta');
	        }
	    });
	};


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, console) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	/*jshint onevar: false, indent:4 */
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {

	    var async = {};

	    // global on the server, window in the browser
	    var root, previous_async;

	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }

	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };

	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }

	    //// cross-browser compatiblity functions ////

	    var _toString = Object.prototype.toString;

	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };

	    var _each = function (arr, iterator) {
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };

	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };

	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };

	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };

	    //// exported async module functions ////

	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = function (fn) {
	              // not a direct alias for IE10 compatibility
	              setImmediate(fn);
	            };
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }

	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(done) );
	        });
	        function done(err) {
	          if (err) {
	              callback(err);
	              callback = function () {};
	          }
	          else {
	              completed += 1;
	              if (completed >= arr.length) {
	                  callback();
	              }
	          }
	        }
	    };
	    async.forEach = async.each;

	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback();
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;

	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;

	    var _eachLimit = function (limit) {

	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;

	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }

	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };


	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };


	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        if (!callback) {
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err) {
	                    callback(err);
	                });
	            });
	        } else {
	            var results = [];
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err, v) {
	                    results[x.index] = v;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };

	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };

	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;

	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;

	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;

	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);

	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);

	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;

	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;

	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };

	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length
	        if (!remainingTasks) {
	            return callback();
	        }

	        var results = {};

	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            remainingTasks--
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };

	        addListener(function () {
	            if (!remainingTasks) {
	                var theCallback = callback;
	                // prevent final callback from calling itself if it errors
	                callback = function () {};

	                theCallback(null, results);
	            }
	        });

	        _each(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };

	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var attempts = [];
	        // Use defaults if times not passed
	        if (typeof times === 'function') {
	            callback = task;
	            task = times;
	            times = DEFAULT_TIMES;
	        }
	        // Make sure times is a number
	        times = parseInt(times, 10) || DEFAULT_TIMES;
	        var wrappedTask = function(wrappedCallback, wrappedResults) {
	            var retryAttempt = function(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            };
	            while (times) {
	                attempts.push(retryAttempt(task, !(times-=1)));
	            }
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || callback)(data.err, data.result);
	            });
	        }
	        // If a callback is passed, run this as a controll flow
	        return callback ? wrappedTask() : wrappedTask
	    };

	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (!_isArray(tasks)) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };

	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };

	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };

	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };

	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };

	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };

	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };

	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);

	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };

	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (test.apply(null, args)) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };

	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };

	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (!test.apply(null, args)) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };

	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };

	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }

	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }

	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            kill: function () {
	              q.drain = null;
	              q.tasks = [];
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                if (q.paused === true) { return; }
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= q.concurrency; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    };

	    async.priorityQueue = function (worker, concurrency) {

	        function _compareTasks(a, b){
	          return a.priority - b.priority;
	        };

	        function _binarySearch(sequence, item, compare) {
	          var beg = -1,
	              end = sequence.length - 1;
	          while (beg < end) {
	            var mid = beg + ((end - beg + 1) >>> 1);
	            if (compare(item, sequence[mid]) >= 0) {
	              beg = mid;
	            } else {
	              end = mid - 1;
	            }
	          }
	          return beg;
	        }

	        function _insert(q, data, priority, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  priority: priority,
	                  callback: typeof callback === 'function' ? callback : null
	              };

	              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }

	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);

	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	          _insert(q, data, priority, callback);
	        };

	        // Remove unshift function
	        delete q.unshift;

	        return q;
	    };

	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];

	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            drained: true,
	            push: function (data, callback) {
	                if (!_isArray(data)) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    cargo.drained = false;
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain && !cargo.drained) cargo.drain();
	                    cargo.drained = true;
	                    return;
	                }

	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0, tasks.length);

	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });

	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;

	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });

	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };

	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/

	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };

	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };

	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };

	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };

	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };

	    async.compose = function (/* functions... */) {
	      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };

	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);

	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };

	    // Node.js
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }

	}());

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(189), __webpack_require__(219).setImmediate, __webpack_require__(196)))

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var window = __webpack_require__(263)
	var once = __webpack_require__(264)
	var isFunction = __webpack_require__(265)
	var parseHeaders = __webpack_require__(266)
	var xtend = __webpack_require__(269)

	module.exports = createXHR
	createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
	createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

	forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
	    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
	        options = initParams(uri, options, callback)
	        options.method = method.toUpperCase()
	        return _createXHR(options)
	    }
	})

	function forEachArray(array, iterator) {
	    for (var i = 0; i < array.length; i++) {
	        iterator(array[i])
	    }
	}

	function isEmpty(obj){
	    for(var i in obj){
	        if(obj.hasOwnProperty(i)) return false
	    }
	    return true
	}

	function initParams(uri, options, callback) {
	    var params = uri

	    if (isFunction(options)) {
	        callback = options
	        if (typeof uri === "string") {
	            params = {uri:uri}
	        }
	    } else {
	        params = xtend(options, {uri: uri})
	    }

	    params.callback = callback
	    return params
	}

	function createXHR(uri, options, callback) {
	    options = initParams(uri, options, callback)
	    return _createXHR(options)
	}

	function _createXHR(options) {
	    var callback = options.callback
	    if(typeof callback === "undefined"){
	        throw new Error("callback argument missing")
	    }
	    callback = once(callback)

	    function readystatechange() {
	        if (xhr.readyState === 4) {
	            loadFunc()
	        }
	    }

	    function getBody() {
	        // Chrome with requestType=blob throws errors arround when even testing access to responseText
	        var body = undefined

	        if (xhr.response) {
	            body = xhr.response
	        } else if (xhr.responseType === "text" || !xhr.responseType) {
	            body = xhr.responseText || xhr.responseXML
	        }

	        if (isJson) {
	            try {
	                body = JSON.parse(body)
	            } catch (e) {}
	        }

	        return body
	    }

	    var failureResponse = {
	                body: undefined,
	                headers: {},
	                statusCode: 0,
	                method: method,
	                url: uri,
	                rawRequest: xhr
	            }

	    function errorFunc(evt) {
	        clearTimeout(timeoutTimer)
	        if(!(evt instanceof Error)){
	            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
	        }
	        evt.statusCode = 0
	        callback(evt, failureResponse)
	    }

	    // will load the data & process the response in a special response object
	    function loadFunc() {
	        if (aborted) return
	        var status
	        clearTimeout(timeoutTimer)
	        if(options.useXDR && xhr.status===undefined) {
	            //IE8 CORS GET successful response doesn't have a status field, but body is fine
	            status = 200
	        } else {
	            status = (xhr.status === 1223 ? 204 : xhr.status)
	        }
	        var response = failureResponse
	        var err = null

	        if (status !== 0){
	            response = {
	                body: getBody(),
	                statusCode: status,
	                method: method,
	                headers: {},
	                url: uri,
	                rawRequest: xhr
	            }
	            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
	                response.headers = parseHeaders(xhr.getAllResponseHeaders())
	            }
	        } else {
	            err = new Error("Internal XMLHttpRequest Error")
	        }
	        callback(err, response, response.body)

	    }

	    var xhr = options.xhr || null

	    if (!xhr) {
	        if (options.cors || options.useXDR) {
	            xhr = new createXHR.XDomainRequest()
	        }else{
	            xhr = new createXHR.XMLHttpRequest()
	        }
	    }

	    var key
	    var aborted
	    var uri = xhr.url = options.uri || options.url
	    var method = xhr.method = options.method || "GET"
	    var body = options.body || options.data || null
	    var headers = xhr.headers = options.headers || {}
	    var sync = !!options.sync
	    var isJson = false
	    var timeoutTimer

	    if ("json" in options) {
	        isJson = true
	        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
	        if (method !== "GET" && method !== "HEAD") {
	            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
	            body = JSON.stringify(options.json)
	        }
	    }

	    xhr.onreadystatechange = readystatechange
	    xhr.onload = loadFunc
	    xhr.onerror = errorFunc
	    // IE9 must have onprogress be set to a unique function.
	    xhr.onprogress = function () {
	        // IE must die
	    }
	    xhr.ontimeout = errorFunc
	    xhr.open(method, uri, !sync, options.username, options.password)
	    //has to be after open
	    if(!sync) {
	        xhr.withCredentials = !!options.withCredentials
	    }
	    // Cannot set timeout with sync request
	    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
	    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
	    if (!sync && options.timeout > 0 ) {
	        timeoutTimer = setTimeout(function(){
	            aborted=true//IE9 may still call readystatechange
	            xhr.abort("timeout")
	            var e = new Error("XMLHttpRequest timeout")
	            e.code = "ETIMEDOUT"
	            errorFunc(e)
	        }, options.timeout )
	    }

	    if (xhr.setRequestHeader) {
	        for(key in headers){
	            if(headers.hasOwnProperty(key)){
	                xhr.setRequestHeader(key, headers[key])
	            }
	        }
	    } else if (options.headers && !isEmpty(options.headers)) {
	        throw new Error("Headers cannot be set on an XDomainRequest object")
	    }

	    if ("responseType" in options) {
	        xhr.responseType = options.responseType
	    }

	    if ("beforeSend" in options &&
	        typeof options.beforeSend === "function"
	    ) {
	        options.beforeSend(xhr)
	    }

	    xhr.send(body)

	    return xhr


	}

	function noop() {}


/***/ },
/* 263 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {
	    module.exports = window;
	} else if (typeof global !== "undefined") {
	    module.exports = global;
	} else if (typeof self !== "undefined"){
	    module.exports = self;
	} else {
	    module.exports = {};
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 264 */
/***/ function(module, exports) {

	module.exports = once

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var called = false
	  return function () {
	    if (called) return
	    called = true
	    return fn.apply(this, arguments)
	  }
	}


/***/ },
/* 265 */
/***/ function(module, exports) {

	module.exports = isFunction

	var toString = Object.prototype.toString

	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(267)
	  , forEach = __webpack_require__(268)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }

	module.exports = function (headers) {
	  if (!headers)
	    return {}

	  var result = {}

	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))

	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )

	  return result
	}

/***/ },
/* 267 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;

	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}

	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};

	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(265)

	module.exports = forEach

	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty

	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }

	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}

	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}

	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}

	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 269 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var jxt = __webpack_require__(240);
	var NS = 'http://docs.oasis-open.org/ns/xri/xrd-1.0';


	module.exports = function (registry) {
	    var Properties = {
	        get: function () {
	            var results = {};
	            var props = jxt.find(this.xml, NS, 'Property');
	    
	            for (var i = 0, len = props.length; i < len; i++) {
	                var property = props[i];
	                var type = jxt.getAttribute(property, 'type');
	                results[type] = property.textContent;
	            }
	    
	            return results;
	        }
	    };
	    
	    var XRD = registry.define({
	        name: 'xrd',
	        namespace: NS,
	        element: 'XRD',
	        fields: {
	            subject: jxt.subText(NS, 'Subject'),
	            expires: jxt.dateSub(NS, 'Expires'),
	            aliases: jxt.multiSubText(NS, 'Alias'),
	            properties: Properties
	        }
	    });
	    
	    
	    var Link = registry.define({
	        name: '_xrdlink',
	        namespace: NS,
	        element: 'Link',
	        fields: {
	            rel: jxt.attribute('rel'),
	            href: jxt.attribute('href'),
	            type: jxt.attribute('type'),
	            template: jxt.attribute('template'),
	            titles: jxt.subLangText(NS, 'Title', 'default'),
	            properties: Properties
	        }
	    });
	    
	    registry.extend(XRD, Link, 'links');

	    return XRD;
	};


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports,
	            module,
	            __webpack_require__(272));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports',
	            'module',
	            './lib/factory'], factory);
	  }
	}(this, function(exports, module, Factory) {
	  
	  exports = module.exports = Factory;
	  exports.Factory = Factory;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports, module);
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports', 'module'], factory);
	  }
	}(this, function(exports, module) {
	  
	  /**
	   * `Factory` constructor.
	   *
	   * @api public
	   */
	  function Factory() {
	    this._mechs = [];
	  }
	  
	  /**
	   * Utilize the given `mech` with optional `name`, overridding the mechanism's
	   * default name.
	   *
	   * Examples:
	   *
	   *     factory.use(FooMechanism);
	   *
	   *     factory.use('XFOO', FooMechanism);
	   *
	   * @param {String|Mechanism} name
	   * @param {Mechanism} mech
	   * @return {Factory} for chaining
	   * @api public
	   */
	  Factory.prototype.use = function(name, mech) {
	    if (!mech) {
	      mech = name;
	      name = mech.prototype.name;
	    }
	    this._mechs.push({ name: name, mech: mech });
	    return this;
	  };
	  
	  /**
	   * Create a new mechanism from supported list of `mechs`.
	   *
	   * If no mechanisms are supported, returns `null`.
	   *
	   * Examples:
	   *
	   *     var mech = factory.create(['FOO', 'BAR']);
	   *
	   * @param {Array} mechs
	   * @return {Mechanism}
	   * @api public
	   */
	  Factory.prototype.create = function(mechs) {
	    for (var i = 0, len = this._mechs.length; i < len; i++) {
	      for (var j = 0, jlen = mechs.length; j < jlen; j++) {
	        var entry = this._mechs[i];
	        if (entry.name == mechs[j]) {
	          return new entry.mech();
	        }
	      }
	    }
	    return null;
	  };

	  exports = module.exports = Factory;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports,
	            module,
	            __webpack_require__(274));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports',
	            'module',
	            './lib/mechanism'], factory);
	  }
	}(this, function(exports, module, Mechanism) {

	  exports = module.exports = Mechanism;
	  exports.Mechanism = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports, module);
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports', 'module'], factory);
	  }
	}(this, function(exports, module) {

	  /**
	   * EXTERNAL `Mechanism` constructor.
	   *
	   * This class implements the EXTERNAL SASL mechanism.
	   *
	   * The EXTERNAL SASL mechanism provides support for authentication using
	   * credentials established by external means. 
	   *
	   * References:
	   *  - [RFC 4422](http://tools.ietf.org/html/rfc4422)
	   *
	   * @api public
	   */
	  function Mechanism() {
	  }
	  
	  Mechanism.prototype.name = 'EXTERNAL';
	  Mechanism.prototype.clientFirst = true;
	  
	  /**
	   * Encode a response using given credential.
	   *
	   * Options:
	   *  - `authzid`   authorization identity (optional)
	   *
	   * @param {Object} cred
	   * @api public
	   */
	  Mechanism.prototype.response = function(cred) {
	    return cred.authzid || '';
	  };
	  
	  /**
	   * Decode a challenge issued by the server.
	   *
	   * @param {String} chal
	   * @api public
	   */
	  Mechanism.prototype.challenge = function(chal) {
	  };

	  exports = module.exports = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var bitops = __webpack_require__(276);
	var utils = __webpack_require__(307);

	var RESP = {};
	var CLIENT_KEY = 'Client Key';
	var SERVER_KEY = 'Server Key';


	function Mechanism(options) {
	    options = options || {};
	    this._genNonce = options.genNonce || utils.genNonce;
	    this._stage = 'initial';
	}

	// Conform to the SASL lib's expectations
	Mechanism.Mechanism = Mechanism;


	Mechanism.prototype.name = 'SCRAM-SHA-1';
	Mechanism.prototype.clientFirst = true;


	Mechanism.prototype.response = function (cred) {
	    return RESP[this._stage](this, cred);
	};

	Mechanism.prototype.challenge = function (chal) {
	    var values = utils.parse(chal);

	    this._salt = new Buffer(values.s || '', 'base64');
	    this._iterationCount = parseInt(values.i, 10);
	    this._nonce = values.r;
	    this._verifier = values.v;
	    this._error = values.e;
	    this._challenge = chal;

	    return this;
	};


	RESP.initial = function (mech, cred) {
	    mech._cnonce = mech._genNonce();

	    var authzid = '';
	    if (cred.authzid) {
	        authzid = 'a=' + utils.saslname(cred.authzid);
	    }

	    mech._gs2Header = 'n,' + authzid + ',';

	    var nonce = 'r=' + mech._cnonce;
	    var username = 'n=' + utils.saslname(cred.username || '');

	    mech._clientFirstMessageBare = username + ',' + nonce;
	    var result = mech._gs2Header + mech._clientFirstMessageBare;

	    mech._stage = 'challenge';

	    return result;
	};


	RESP.challenge = function (mech, cred) {
	    var gs2Header = new Buffer(mech._gs2Header).toString('base64');

	    mech._clientFinalMessageWithoutProof = 'c=' + gs2Header + ',r=' + mech._nonce;

	    var saltedPassword, clientKey, serverKey;

	    // If our cached salt is the same, we can reuse cached credentials to speed
	    // up the hashing process.
	    if (cred.salt && Buffer.compare(cred.salt, mech._salt) === 0) {
	        if (cred.clientKey && cred.serverKey) {
	            clientKey = cred.clientKey;
	            serverKey = cred.serverKey;
	        } else if (cred.saltedPassword) {
	            saltedPassword = cred.saltedPassword;
	            clientKey = bitops.HMAC(saltedPassword, CLIENT_KEY);
	            serverKey = bitops.HMAC(saltedPassword, SERVER_KEY);
	        }
	    } else {
	        saltedPassword = bitops.Hi(cred.password || '', mech._salt, mech._iterationCount);
	        clientKey = bitops.HMAC(saltedPassword, CLIENT_KEY);
	        serverKey = bitops.HMAC(saltedPassword, SERVER_KEY);
	    }

	    var storedKey = bitops.H(clientKey);
	    var authMessage = mech._clientFirstMessageBare + ',' +
	                      mech._challenge + ',' +
	                      mech._clientFinalMessageWithoutProof;
	    var clientSignature = bitops.HMAC(storedKey, authMessage);

	    var clientProof = bitops.XOR(clientKey, clientSignature).toString('base64');

	    mech._serverSignature = bitops.HMAC(serverKey, authMessage);

	    var result = mech._clientFinalMessageWithoutProof + ',p=' + clientProof;

	    mech._stage = 'final';

	    mech.cache = {
	        salt: mech._salt,
	        saltedPassword: saltedPassword,
	        clientKey: clientKey,
	        serverKey: serverKey
	    };

	    return result;
	};

	RESP.final = function () {
	    // TODO: Signal errors
	    return '';
	};



	module.exports = Mechanism;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(277);
	var createHmac = __webpack_require__(305);
	var xor = __webpack_require__(306);


	exports.XOR = xor;

	exports.H = function (text) {
	    return createHash('sha1').update(text).digest();
	};

	exports.HMAC = function (key, msg) {
	    return createHmac('sha1', key).update(msg).digest();
	};

	exports.Hi = function (text, salt, iterations) {
	    var ui1 = exports.HMAC(text, Buffer.concat([salt, new Buffer([0, 0, 0, 1], 'binary')]));
	    var ui = ui1;
	    for (var i = 0; i < iterations - 1; i++) {
	        ui1 = exports.HMAC(text, ui1);
	        ui = exports.XOR(ui, ui1);
	    }

	    return ui;
	};


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	var inherits = __webpack_require__(199)
	var md5 = __webpack_require__(278)
	var rmd160 = __webpack_require__(280)
	var sha = __webpack_require__(281)

	var Base = __webpack_require__(289)

	function HashNoConstructor(hash) {
	  Base.call(this, 'digest')

	  this._hash = hash
	  this.buffers = []
	}

	inherits(HashNoConstructor, Base)

	HashNoConstructor.prototype._update = function (data) {
	  this.buffers.push(data)
	}

	HashNoConstructor.prototype._final = function () {
	  var buf = Buffer.concat(this.buffers)
	  var r = this._hash(buf)
	  this.buffers = null

	  return r
	}

	function Hash(hash) {
	  Base.call(this, 'digest')

	  this._hash = hash
	}

	inherits(Hash, Base)

	Hash.prototype._update = function (data) {
	  this._hash.update(data)
	}

	Hash.prototype._final = function () {
	  return this._hash.digest()
	}

	module.exports = function createHash (alg) {
	  alg = alg.toLowerCase()
	  if ('md5' === alg) return new HashNoConstructor(md5)
	  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

	  return new Hash(sha(alg))
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(279);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	exports.hash = hash;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// constants table
	var zl = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	]

	var zr = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	]

	var sl = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	]

	var sr = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	]

	var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
	var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

	function bytesToWords (bytes) {
	  var words = []
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32)
	  }
	  return words
	}

	function wordsToBytes (words) {
	  var bytes = []
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
	  }
	  return bytes
	}

	function processBlock (H, M, offset) {
	  // swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i
	    var M_offset_i = M[offset_i]

	    // Swap
	    M[offset_i] = (
	      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
	      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
	    )
	  }

	  // Working variables
	  var al, bl, cl, dl, el
	  var ar, br, cr, dr, er

	  ar = al = H[0]
	  br = bl = H[1]
	  cr = cl = H[2]
	  dr = dl = H[3]
	  er = el = H[4]

	  // computation
	  var t
	  for (i = 0; i < 80; i += 1) {
	    t = (al + M[offset + zl[i]]) | 0
	    if (i < 16) {
	      t += f1(bl, cl, dl) + hl[0]
	    } else if (i < 32) {
	      t += f2(bl, cl, dl) + hl[1]
	    } else if (i < 48) {
	      t += f3(bl, cl, dl) + hl[2]
	    } else if (i < 64) {
	      t += f4(bl, cl, dl) + hl[3]
	    } else {// if (i<80) {
	      t += f5(bl, cl, dl) + hl[4]
	    }
	    t = t | 0
	    t = rotl(t, sl[i])
	    t = (t + el) | 0
	    al = el
	    el = dl
	    dl = rotl(cl, 10)
	    cl = bl
	    bl = t

	    t = (ar + M[offset + zr[i]]) | 0
	    if (i < 16) {
	      t += f5(br, cr, dr) + hr[0]
	    } else if (i < 32) {
	      t += f4(br, cr, dr) + hr[1]
	    } else if (i < 48) {
	      t += f3(br, cr, dr) + hr[2]
	    } else if (i < 64) {
	      t += f2(br, cr, dr) + hr[3]
	    } else {// if (i<80) {
	      t += f1(br, cr, dr) + hr[4]
	    }

	    t = t | 0
	    t = rotl(t, sr[i])
	    t = (t + er) | 0
	    ar = er
	    er = dr
	    dr = rotl(cr, 10)
	    cr = br
	    br = t
	  }

	  // intermediate hash value
	  t = (H[1] + cl + dr) | 0
	  H[1] = (H[2] + dl + er) | 0
	  H[2] = (H[3] + el + ar) | 0
	  H[3] = (H[4] + al + br) | 0
	  H[4] = (H[0] + bl + cr) | 0
	  H[0] = t
	}

	function f1 (x, y, z) {
	  return ((x) ^ (y) ^ (z))
	}

	function f2 (x, y, z) {
	  return (((x) & (y)) | ((~x) & (z)))
	}

	function f3 (x, y, z) {
	  return (((x) | (~(y))) ^ (z))
	}

	function f4 (x, y, z) {
	  return (((x) & (z)) | ((y) & (~(z))))
	}

	function f5 (x, y, z) {
	  return ((x) ^ ((y) | (~(z))))
	}

	function rotl (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function ripemd160 (message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

	  if (typeof message === 'string') {
	    message = new Buffer(message, 'utf8')
	  }

	  var m = bytesToWords(message)

	  var nBitsLeft = message.length * 8
	  var nBitsTotal = message.length * 8

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
	  )

	  for (var i = 0; i < m.length; i += 16) {
	    processBlock(H, m, i)
	  }

	  // swap endian
	  for (i = 0; i < 5; i++) {
	    // shortcut
	    var H_i = H[i]

	    // Swap
	    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
	      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
	  }

	  var digestbytes = wordsToBytes(H)
	  return new Buffer(digestbytes)
	}

	module.exports = ripemd160

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function SHA (algorithm) {
	  algorithm = algorithm.toLowerCase()

	  var Algorithm = exports[algorithm]
	  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

	  return new Algorithm()
	}

	exports.sha = __webpack_require__(282)
	exports.sha1 = __webpack_require__(284)
	exports.sha224 = __webpack_require__(285)
	exports.sha256 = __webpack_require__(286)
	exports.sha384 = __webpack_require__(287)
	exports.sha512 = __webpack_require__(288)


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
	 * in FIPS PUB 180-1
	 * This source code is derived from sha1.js of the same repository.
	 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
	 * operation was added.
	 */

	var inherits = __webpack_require__(199)
	var Hash = __webpack_require__(283)

	var K = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	]

	var W = new Array(80)

	function Sha () {
	  this.init()
	  this._w = W

	  Hash.call(this, 64, 56)
	}

	inherits(Sha, Hash)

	Sha.prototype.init = function () {
	  this._a = 0x67452301
	  this._b = 0xefcdab89
	  this._c = 0x98badcfe
	  this._d = 0x10325476
	  this._e = 0xc3d2e1f0

	  return this
	}

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha.prototype._update = function (M) {
	  var W = this._w

	  var a = this._a | 0
	  var b = this._b | 0
	  var c = this._c | 0
	  var d = this._d | 0
	  var e = this._e | 0

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
	  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20)
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

	    e = d
	    d = c
	    c = rotl30(b)
	    b = a
	    a = t
	  }

	  this._a = (a + this._a) | 0
	  this._b = (b + this._b) | 0
	  this._c = (c + this._c) | 0
	  this._d = (d + this._d) | 0
	  this._e = (e + this._e) | 0
	}

	Sha.prototype._hash = function () {
	  var H = new Buffer(20)

	  H.writeInt32BE(this._a | 0, 0)
	  H.writeInt32BE(this._b | 0, 4)
	  H.writeInt32BE(this._c | 0, 8)
	  H.writeInt32BE(this._d | 0, 12)
	  H.writeInt32BE(this._e | 0, 16)

	  return H
	}

	module.exports = Sha

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// prototype class for hash functions
	function Hash (blockSize, finalSize) {
	  this._block = new Buffer(blockSize)
	  this._finalSize = finalSize
	  this._blockSize = blockSize
	  this._len = 0
	  this._s = 0
	}

	Hash.prototype.update = function (data, enc) {
	  if (typeof data === 'string') {
	    enc = enc || 'utf8'
	    data = new Buffer(data, enc)
	  }

	  var l = this._len += data.length
	  var s = this._s || 0
	  var f = 0
	  var buffer = this._block

	  while (s < l) {
	    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	    var ch = (t - f)

	    for (var i = 0; i < ch; i++) {
	      buffer[(s % this._blockSize) + i] = data[i + f]
	    }

	    s += ch
	    f += ch

	    if ((s % this._blockSize) === 0) {
	      this._update(buffer)
	    }
	  }
	  this._s = s

	  return this
	}

	Hash.prototype.digest = function (enc) {
	  // Suppose the length of the message M, in bits, is l
	  var l = this._len * 8

	  // Append the bit 1 to the end of the message
	  this._block[this._len % this._blockSize] = 0x80

	  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	  this._block.fill(0, this._len % this._blockSize + 1)

	  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	    this._update(this._block)
	    this._block.fill(0)
	  }

	  // to this append the block which is equal to the number l written in binary
	  // TODO: handle case where l is > Math.pow(2, 29)
	  this._block.writeInt32BE(l, this._blockSize - 4)

	  var hash = this._update(this._block) || this._hash()

	  return enc ? hash.toString(enc) : hash
	}

	Hash.prototype._update = function () {
	  throw new Error('_update must be implemented by subclass')
	}

	module.exports = Hash

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(199)
	var Hash = __webpack_require__(283)

	var K = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	]

	var W = new Array(80)

	function Sha1 () {
	  this.init()
	  this._w = W

	  Hash.call(this, 64, 56)
	}

	inherits(Sha1, Hash)

	Sha1.prototype.init = function () {
	  this._a = 0x67452301
	  this._b = 0xefcdab89
	  this._c = 0x98badcfe
	  this._d = 0x10325476
	  this._e = 0xc3d2e1f0

	  return this
	}

	function rotl1 (num) {
	  return (num << 1) | (num >>> 31)
	}

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha1.prototype._update = function (M) {
	  var W = this._w

	  var a = this._a | 0
	  var b = this._b | 0
	  var c = this._c | 0
	  var d = this._d | 0
	  var e = this._e | 0

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
	  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20)
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

	    e = d
	    d = c
	    c = rotl30(b)
	    b = a
	    a = t
	  }

	  this._a = (a + this._a) | 0
	  this._b = (b + this._b) | 0
	  this._c = (c + this._c) | 0
	  this._d = (d + this._d) | 0
	  this._e = (e + this._e) | 0
	}

	Sha1.prototype._hash = function () {
	  var H = new Buffer(20)

	  H.writeInt32BE(this._a | 0, 0)
	  H.writeInt32BE(this._b | 0, 4)
	  H.writeInt32BE(this._c | 0, 8)
	  H.writeInt32BE(this._d | 0, 12)
	  H.writeInt32BE(this._e | 0, 16)

	  return H
	}

	module.exports = Sha1

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(199)
	var Sha256 = __webpack_require__(286)
	var Hash = __webpack_require__(283)

	var W = new Array(64)

	function Sha224 () {
	  this.init()

	  this._w = W // new Array(64)

	  Hash.call(this, 64, 56)
	}

	inherits(Sha224, Sha256)

	Sha224.prototype.init = function () {
	  this._a = 0xc1059ed8
	  this._b = 0x367cd507
	  this._c = 0x3070dd17
	  this._d = 0xf70e5939
	  this._e = 0xffc00b31
	  this._f = 0x68581511
	  this._g = 0x64f98fa7
	  this._h = 0xbefa4fa4

	  return this
	}

	Sha224.prototype._hash = function () {
	  var H = new Buffer(28)

	  H.writeInt32BE(this._a, 0)
	  H.writeInt32BE(this._b, 4)
	  H.writeInt32BE(this._c, 8)
	  H.writeInt32BE(this._d, 12)
	  H.writeInt32BE(this._e, 16)
	  H.writeInt32BE(this._f, 20)
	  H.writeInt32BE(this._g, 24)

	  return H
	}

	module.exports = Sha224

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(199)
	var Hash = __webpack_require__(283)

	var K = [
	  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	]

	var W = new Array(64)

	function Sha256 () {
	  this.init()

	  this._w = W // new Array(64)

	  Hash.call(this, 64, 56)
	}

	inherits(Sha256, Hash)

	Sha256.prototype.init = function () {
	  this._a = 0x6a09e667
	  this._b = 0xbb67ae85
	  this._c = 0x3c6ef372
	  this._d = 0xa54ff53a
	  this._e = 0x510e527f
	  this._f = 0x9b05688c
	  this._g = 0x1f83d9ab
	  this._h = 0x5be0cd19

	  return this
	}

	function ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
	}

	function sigma1 (x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
	}

	function gamma0 (x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
	}

	function gamma1 (x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
	}

	Sha256.prototype._update = function (M) {
	  var W = this._w

	  var a = this._a | 0
	  var b = this._b | 0
	  var c = this._c | 0
	  var d = this._d | 0
	  var e = this._e | 0
	  var f = this._f | 0
	  var g = this._g | 0
	  var h = this._h | 0

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
	  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

	  for (var j = 0; j < 64; ++j) {
	    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
	    var T2 = (sigma0(a) + maj(a, b, c)) | 0

	    h = g
	    g = f
	    f = e
	    e = (d + T1) | 0
	    d = c
	    c = b
	    b = a
	    a = (T1 + T2) | 0
	  }

	  this._a = (a + this._a) | 0
	  this._b = (b + this._b) | 0
	  this._c = (c + this._c) | 0
	  this._d = (d + this._d) | 0
	  this._e = (e + this._e) | 0
	  this._f = (f + this._f) | 0
	  this._g = (g + this._g) | 0
	  this._h = (h + this._h) | 0
	}

	Sha256.prototype._hash = function () {
	  var H = new Buffer(32)

	  H.writeInt32BE(this._a, 0)
	  H.writeInt32BE(this._b, 4)
	  H.writeInt32BE(this._c, 8)
	  H.writeInt32BE(this._d, 12)
	  H.writeInt32BE(this._e, 16)
	  H.writeInt32BE(this._f, 20)
	  H.writeInt32BE(this._g, 24)
	  H.writeInt32BE(this._h, 28)

	  return H
	}

	module.exports = Sha256

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(199)
	var SHA512 = __webpack_require__(288)
	var Hash = __webpack_require__(283)

	var W = new Array(160)

	function Sha384 () {
	  this.init()
	  this._w = W

	  Hash.call(this, 128, 112)
	}

	inherits(Sha384, SHA512)

	Sha384.prototype.init = function () {
	  this._ah = 0xcbbb9d5d
	  this._bh = 0x629a292a
	  this._ch = 0x9159015a
	  this._dh = 0x152fecd8
	  this._eh = 0x67332667
	  this._fh = 0x8eb44a87
	  this._gh = 0xdb0c2e0d
	  this._hh = 0x47b5481d

	  this._al = 0xc1059ed8
	  this._bl = 0x367cd507
	  this._cl = 0x3070dd17
	  this._dl = 0xf70e5939
	  this._el = 0xffc00b31
	  this._fl = 0x68581511
	  this._gl = 0x64f98fa7
	  this._hl = 0xbefa4fa4

	  return this
	}

	Sha384.prototype._hash = function () {
	  var H = new Buffer(48)

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset)
	    H.writeInt32BE(l, offset + 4)
	  }

	  writeInt64BE(this._ah, this._al, 0)
	  writeInt64BE(this._bh, this._bl, 8)
	  writeInt64BE(this._ch, this._cl, 16)
	  writeInt64BE(this._dh, this._dl, 24)
	  writeInt64BE(this._eh, this._el, 32)
	  writeInt64BE(this._fh, this._fl, 40)

	  return H
	}

	module.exports = Sha384

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(199)
	var Hash = __webpack_require__(283)

	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	]

	var W = new Array(160)

	function Sha512 () {
	  this.init()
	  this._w = W

	  Hash.call(this, 128, 112)
	}

	inherits(Sha512, Hash)

	Sha512.prototype.init = function () {
	  this._ah = 0x6a09e667
	  this._bh = 0xbb67ae85
	  this._ch = 0x3c6ef372
	  this._dh = 0xa54ff53a
	  this._eh = 0x510e527f
	  this._fh = 0x9b05688c
	  this._gh = 0x1f83d9ab
	  this._hh = 0x5be0cd19

	  this._al = 0xf3bcc908
	  this._bl = 0x84caa73b
	  this._cl = 0xfe94f82b
	  this._dl = 0x5f1d36f1
	  this._el = 0xade682d1
	  this._fl = 0x2b3e6c1f
	  this._gl = 0xfb41bd6b
	  this._hl = 0x137e2179

	  return this
	}

	function Ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x, xl) {
	  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
	}

	function sigma1 (x, xl) {
	  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
	}

	function Gamma0 (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
	}

	function Gamma0l (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
	}

	function Gamma1 (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
	}

	function Gamma1l (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
	}

	function getCarry (a, b) {
	  return (a >>> 0) < (b >>> 0) ? 1 : 0
	}

	Sha512.prototype._update = function (M) {
	  var W = this._w

	  var ah = this._ah | 0
	  var bh = this._bh | 0
	  var ch = this._ch | 0
	  var dh = this._dh | 0
	  var eh = this._eh | 0
	  var fh = this._fh | 0
	  var gh = this._gh | 0
	  var hh = this._hh | 0

	  var al = this._al | 0
	  var bl = this._bl | 0
	  var cl = this._cl | 0
	  var dl = this._dl | 0
	  var el = this._el | 0
	  var fl = this._fl | 0
	  var gl = this._gl | 0
	  var hl = this._hl | 0

	  for (var i = 0; i < 32; i += 2) {
	    W[i] = M.readInt32BE(i * 4)
	    W[i + 1] = M.readInt32BE(i * 4 + 4)
	  }
	  for (; i < 160; i += 2) {
	    var xh = W[i - 15 * 2]
	    var xl = W[i - 15 * 2 + 1]
	    var gamma0 = Gamma0(xh, xl)
	    var gamma0l = Gamma0l(xl, xh)

	    xh = W[i - 2 * 2]
	    xl = W[i - 2 * 2 + 1]
	    var gamma1 = Gamma1(xh, xl)
	    var gamma1l = Gamma1l(xl, xh)

	    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	    var Wi7h = W[i - 7 * 2]
	    var Wi7l = W[i - 7 * 2 + 1]

	    var Wi16h = W[i - 16 * 2]
	    var Wi16l = W[i - 16 * 2 + 1]

	    var Wil = (gamma0l + Wi7l) | 0
	    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
	    Wil = (Wil + gamma1l) | 0
	    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
	    Wil = (Wil + Wi16l) | 0
	    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

	    W[i] = Wih
	    W[i + 1] = Wil
	  }

	  for (var j = 0; j < 160; j += 2) {
	    Wih = W[j]
	    Wil = W[j + 1]

	    var majh = maj(ah, bh, ch)
	    var majl = maj(al, bl, cl)

	    var sigma0h = sigma0(ah, al)
	    var sigma0l = sigma0(al, ah)
	    var sigma1h = sigma1(eh, el)
	    var sigma1l = sigma1(el, eh)

	    // t1 = h + sigma1 + ch + K[j] + W[j]
	    var Kih = K[j]
	    var Kil = K[j + 1]

	    var chh = Ch(eh, fh, gh)
	    var chl = Ch(el, fl, gl)

	    var t1l = (hl + sigma1l) | 0
	    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
	    t1l = (t1l + chl) | 0
	    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
	    t1l = (t1l + Kil) | 0
	    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
	    t1l = (t1l + Wil) | 0
	    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

	    // t2 = sigma0 + maj
	    var t2l = (sigma0l + majl) | 0
	    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

	    hh = gh
	    hl = gl
	    gh = fh
	    gl = fl
	    fh = eh
	    fl = el
	    el = (dl + t1l) | 0
	    eh = (dh + t1h + getCarry(el, dl)) | 0
	    dh = ch
	    dl = cl
	    ch = bh
	    cl = bl
	    bh = ah
	    bl = al
	    al = (t1l + t2l) | 0
	    ah = (t1h + t2h + getCarry(al, t1l)) | 0
	  }

	  this._al = (this._al + al) | 0
	  this._bl = (this._bl + bl) | 0
	  this._cl = (this._cl + cl) | 0
	  this._dl = (this._dl + dl) | 0
	  this._el = (this._el + el) | 0
	  this._fl = (this._fl + fl) | 0
	  this._gl = (this._gl + gl) | 0
	  this._hl = (this._hl + hl) | 0

	  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
	  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
	  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
	  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
	  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
	  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
	  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
	  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
	}

	Sha512.prototype._hash = function () {
	  var H = new Buffer(64)

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset)
	    H.writeInt32BE(l, offset + 4)
	  }

	  writeInt64BE(this._ah, this._al, 0)
	  writeInt64BE(this._bh, this._bl, 8)
	  writeInt64BE(this._ch, this._cl, 16)
	  writeInt64BE(this._dh, this._dl, 24)
	  writeInt64BE(this._eh, this._el, 32)
	  writeInt64BE(this._fh, this._fl, 40)
	  writeInt64BE(this._gh, this._gl, 48)
	  writeInt64BE(this._hh, this._hl, 56)

	  return H
	}

	module.exports = Sha512

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(290).Transform
	var inherits = __webpack_require__(199)
	var StringDecoder = __webpack_require__(298).StringDecoder
	module.exports = CipherBase
	inherits(CipherBase, Transform)
	function CipherBase (hashMode) {
	  Transform.call(this)
	  this.hashMode = typeof hashMode === 'string'
	  if (this.hashMode) {
	    this[hashMode] = this._finalOrDigest
	  } else {
	    this.final = this._finalOrDigest
	  }
	  this._decoder = null
	  this._encoding = null
	}
	CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	  if (typeof data === 'string') {
	    data = new Buffer(data, inputEnc)
	  }
	  var outData = this._update(data)
	  if (this.hashMode) {
	    return this
	  }
	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc)
	  }
	  return outData
	}

	CipherBase.prototype.setAutoPadding = function () {}

	CipherBase.prototype.getAuthTag = function () {
	  throw new Error('trying to get auth tag in unsupported state')
	}

	CipherBase.prototype.setAuthTag = function () {
	  throw new Error('trying to set auth tag in unsupported state')
	}

	CipherBase.prototype.setAAD = function () {
	  throw new Error('trying to set aad in unsupported state')
	}

	CipherBase.prototype._transform = function (data, _, next) {
	  var err
	  try {
	    if (this.hashMode) {
	      this._update(data)
	    } else {
	      this.push(this._update(data))
	    }
	  } catch (e) {
	    err = e
	  } finally {
	    next(err)
	  }
	}
	CipherBase.prototype._flush = function (done) {
	  var err
	  try {
	    this.push(this._final())
	  } catch (e) {
	    err = e
	  } finally {
	    done(err)
	  }
	}
	CipherBase.prototype._finalOrDigest = function (outputEnc) {
	  var outData = this._final() || new Buffer('')
	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc, true)
	  }
	  return outData
	}

	CipherBase.prototype._toString = function (value, enc, final) {
	  if (!this._decoder) {
	    this._decoder = new StringDecoder(enc)
	    this._encoding = enc
	  }
	  if (this._encoding !== enc) {
	    throw new Error('can\'t switch encodings')
	  }
	  var out = this._decoder.write(value)
	  if (final) {
	    out += this._decoder.end()
	  }
	  return out
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(248).EventEmitter;
	var inherits = __webpack_require__(199);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(291);
	Stream.Writable = __webpack_require__(301);
	Stream.Duplex = __webpack_require__(302);
	Stream.Transform = __webpack_require__(303);
	Stream.PassThrough = __webpack_require__(304);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(292);
	exports.Stream = __webpack_require__(290);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(297);
	exports.Duplex = __webpack_require__(296);
	exports.Transform = __webpack_require__(299);
	exports.PassThrough = __webpack_require__(300);


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(293);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(205).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(248).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(290);

	/*<replacement>*/
	var util = __webpack_require__(294);
	util.inherits = __webpack_require__(199);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(295);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(296);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(298).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(296);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(298).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(189)))

/***/ },
/* 293 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 295 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(294);
	util.inherits = __webpack_require__(199);
	/*</replacement>*/

	var Readable = __webpack_require__(292);
	var Writable = __webpack_require__(297);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(189)))

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(205).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(294);
	util.inherits = __webpack_require__(199);
	/*</replacement>*/

	var Stream = __webpack_require__(290);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(296);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(296);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(189)))

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(205).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(296);

	/*<replacement>*/
	var util = __webpack_require__(294);
	util.inherits = __webpack_require__(199);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(299);

	/*<replacement>*/
	var util = __webpack_require__(294);
	util.inherits = __webpack_require__(199);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(297)


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(296)


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(299)


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(300)


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	var createHash = __webpack_require__(277);
	var inherits = __webpack_require__(199)

	var Transform = __webpack_require__(290).Transform

	var ZEROS = new Buffer(128)
	ZEROS.fill(0)

	function Hmac(alg, key) {
	  Transform.call(this)
	  alg = alg.toLowerCase()
	  if (typeof key === 'string') {
	    key = new Buffer(key)
	  }

	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

	  this._alg = alg
	  this._key = key

	  if (key.length > blocksize) {
	    key = createHash(alg).update(key).digest()

	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, ZEROS], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	inherits(Hmac, Transform)

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)

	  return this
	}

	Hmac.prototype._transform = function (data, _, next) {
	  this._hash.update(data)

	  next()
	}

	Hmac.prototype._flush = function (next) {
	  this.push(this.digest())

	  next()
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()

	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}

	module.exports = function createHmac(alg, key) {
	  return new Hmac(alg, key)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = xor

	function xor(a, b) {
	  if (!Buffer.isBuffer(a)) a = new Buffer(a)
	  if (!Buffer.isBuffer(b)) b = new Buffer(b)
	  var res = []
	  if (a.length > b.length) {
	    for (var i = 0; i < b.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  } else {
	    for (var i = 0; i < a.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  }
	  return new Buffer(res);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var randomBytes = __webpack_require__(308);


	exports.parse = function (chal) {
	    var dtives = {};
	    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
	    for (var i = 0, len = tokens.length; i < len; i++) {
	        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
	        if (dtiv) {
	            dtives[dtiv[1]] = dtiv[2];
	        }
	    }
	    return dtives;
	};

	exports.saslname = function (name) {
	    var escaped = [];
	    var curr = '';
	    for (var i = 0; i < name.length; i++) {
	        curr = name[i];
	        if (curr === ',') {
	            escaped.push('=2C');
	        } else if (curr === '=') {
	            escaped.push('=3D');
	        } else {
	            escaped.push(curr);
	        }
	    }
	    return escaped.join('');
	};

	exports.genNonce = function (len) {
	    return randomBytes((len || 32) / 2).toString('hex');
	};


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer, process) {'use strict'

	function oldBrowser () {
	  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
	}

	var crypto = global.crypto || global.msCrypto

	if (crypto && crypto.getRandomValues) {
	  module.exports = randomBytes
	} else {
	  module.exports = oldBrowser
	}

	function randomBytes (size, cb) {
	  // phantomjs needs to throw
	  if (size > 65536) throw new Error('requested too many random bytes')
	  // in case browserify  isn't using the Uint8Array version
	  var rawBytes = new global.Uint8Array(size)

	  // This will not work in older browsers.
	  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	  if (size > 0) {  // getRandomValues fails on IE if size == 0
	    crypto.getRandomValues(rawBytes)
	  }
	  // phantomjs doesn't like a buffer being passed here
	  var bytes = new Buffer(rawBytes.buffer)

	  if (typeof cb === 'function') {
	    return process.nextTick(function () {
	      cb(null, bytes)
	    })
	  }

	  return bytes
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(205).Buffer, __webpack_require__(189)))

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var randomBytes = __webpack_require__(308);
	var createHash = __webpack_require__(277);


	function parse(chal) {
	    var dtives = {};
	    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
	    for (var i = 0, len = tokens.length; i < len; i++) {
	        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
	        if (dtiv) {
	            dtives[dtiv[1]] = dtiv[2];
	        }
	    }
	    return dtives;
	}

	function genNonce() {
	    return randomBytes(16).toString('hex');
	}



	function Mechanism(options) {
	    options = options || {};
	    this._genNonce = options.genNonce || genNonce;
	}

	// Conform to the SASL lib's expectations
	Mechanism.Mechanism = Mechanism;


	Mechanism.prototype.name = 'DIGEST-MD5';
	Mechanism.prototype.clientFirst = false;


	Mechanism.prototype.response = function(cred) {
	    if (this._completed) {
	        return undefined;
	    }

	    var uri = cred.serviceType + '/' + cred.host;

	    if (cred.serviceName && cred.host !== cred.serviceName) {
	        uri += '/' + cred.serviceName;
	    }

	    var realm = cred.realm || this._realm || '';
	    var cnonce = this._genNonce();
	    var nc = '00000001';
	    var qop = 'auth';

	    var str = '';
	    str += 'username="' + cred.username + '"';
	    if (realm) {
	        str += ',realm="' + realm + '"';
	    }
	    str += ',nonce="' + this._nonce + '"';
	    str += ',cnonce="' + cnonce + '"';
	    str += ',nc=' + nc;
	    str += ',qop=' + qop;
	    str += ',digest-uri="' + uri + '"';
	  
	    var base = createHash('md5').update(cred.username)
	                                .update(':')
	                                .update(realm)
	                                .update(':')
	                                .update(cred.password)
	                                .digest();

	    var ha1 = createHash('md5').update(base)
	                               .update(':')
	                               .update(this._nonce)
	                               .update(':')
	                               .update(cnonce);


	    if (cred.authzid) {
	        ha1.update(':').update(cred.authzid);
	    }

	    ha1 = ha1.digest('hex');
	  
	    var ha2 = createHash('md5').update('AUTHENTICATE:')
	                               .update(uri);
	    
	    if (qop === 'auth-int' || qop === 'auth-conf') {
	        ha2.update(':00000000000000000000000000000000');
	    }

	    ha2 = ha2.digest('hex');
	  
	    var digest = createHash('md5').update(ha1)
	                                  .update(':')
	                                  .update(this._nonce)
	                                  .update(':')
	                                  .update(nc)
	                                  .update(':')
	                                  .update(cnonce)
	                                  .update(':')
	                                  .update(qop)
	                                  .update(':')
	                                  .update(ha2)
	                                  .digest('hex');

	    str += ',response=' + digest;
	  
	    if (this._charset === 'utf-8') {
	        str += ',charset=utf-8';
	    }
	    if (cred.authzid) {
	        str += 'authzid="' + cred.authzid + '"';
	    }
	  
	    return str;
	};

	Mechanism.prototype.challenge = function(chal) {
	    var dtives = parse(chal);

	    this._completed = !!dtives.rspauth;

	    this._realm = dtives.realm;
	    this._nonce = dtives.nonce;
	    this._qop = (dtives.qop || 'auth').split(',');
	    this._stale = dtives.stale;
	    this._maxbuf = parseInt(dtives.maxbuf) || 65536;
	    this._charset = dtives.charset;
	    this._algo = dtives.algorithm;
	    this._cipher = dtives.cipher;
	    if (this._cipher) {
	        this._cipher.split(',');
	    }

	    return this;
	};



	module.exports = Mechanism;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports,
	            module,
	            __webpack_require__(311));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports',
	            'module',
	            './lib/mechanism'], factory);
	  }
	}(this, function(exports, module, Mechanism) {

	  exports = module.exports = Mechanism;
	  exports.Mechanism = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports, module);
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports', 'module'], factory);
	  }
	}(this, function(exports, module) {

	  /**
	   * X-OAUTH2 `Mechanism` constructor.
	   *
	   * This class implements the X-OAUTH2 SASL mechanism.
	   *
	   * The X-OAUTH2 SASL mechanism provides support for using OAuth 2.0 access
	   * tokens for authentication.  This mechanism is defined by Google and
	   * implemented in Google Talk.
	   *
	   * References:
	   *  - [OAuth 2.0 Authorization](https://developers.google.com/talk/jep_extensions/oauth)
	   *  - [XMPP Handshake Flow](https://developers.google.com/cloud-print/docs/rawxmpp)
	   *
	   * @api public
	   */
	  function Mechanism() {
	  }
	  
	  Mechanism.prototype.name = 'X-OAUTH2';
	  Mechanism.prototype.clientFirst = true;
	  
	  /**
	   * Encode a response using given credential.
	   *
	   * Options:
	   *  - `username`
	   *  - `token`
	   *
	   * @param {Object} cred
	   * @api public
	   */
	  Mechanism.prototype.response = function(cred) {
	    var str = '';
	    str += '\0';
	    str += cred.username;
	    str += '\0';
	    str += cred.token;
	    return str;
	  };
	  
	  /**
	   * Decode a challenge issued by the server.
	   *
	   * @param {String} chal
	   * @api public
	   */
	  Mechanism.prototype.challenge = function(chal) {
	  };

	  exports = module.exports = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports,
	            module,
	            __webpack_require__(313));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports',
	            'module',
	            './lib/mechanism'], factory);
	  }
	}(this, function(exports, module, Mechanism) {

	  exports = module.exports = Mechanism;
	  exports.Mechanism = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports, module);
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports', 'module'], factory);
	  }
	}(this, function(exports, module) {

	  /**
	   * PLAIN `Mechanism` constructor.
	   *
	   * This class implements the PLAIN SASL mechanism.
	   *
	   * The PLAIN SASL mechanism provides support for exchanging a clear-text
	   * username and password.  This mechanism should not be used without adequate
	   * security provided by an underlying transport layer. 
	   *
	   * References:
	   *  - [RFC 4616](http://tools.ietf.org/html/rfc4616)
	   *
	   * @api public
	   */
	  function Mechanism() {
	  }
	  
	  Mechanism.prototype.name = 'PLAIN';
	  Mechanism.prototype.clientFirst = true;
	  
	  /**
	   * Encode a response using given credential.
	   *
	   * Options:
	   *  - `username`
	   *  - `password`
	   *  - `authzid`   authorization identity (optional)
	   *
	   * @param {Object} cred
	   * @api public
	   */
	  Mechanism.prototype.response = function(cred) {
	    var str = '';
	    str += cred.authzid || '';
	    str += '\0';
	    str += cred.username;
	    str += '\0';
	    str += cred.password;
	    return str;
	  };
	  
	  /**
	   * Decode a challenge issued by the server.
	   *
	   * @param {String} chal
	   * @return {Mechanism} for chaining
	   * @api public
	   */
	  Mechanism.prototype.challenge = function(chal) {
	    return this;
	  };

	  exports = module.exports = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports,
	            module,
	            __webpack_require__(315));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports',
	            'module',
	            './lib/mechanism'], factory);
	  }
	}(this, function(exports, module, Mechanism) {

	  exports = module.exports = Mechanism;
	  exports.Mechanism = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function(root, factory) {
	  if (true) {
	    // CommonJS
	    factory(exports, module);
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD
	    define(['exports', 'module'], factory);
	  }
	}(this, function(exports, module) {

	  /**
	   * ANONYMOUS `Mechanism` constructor.
	   *
	   * This class implements the ANONYMOUS SASL mechanism.
	   *
	   * The ANONYMOUS SASL mechanism provides support for permitting anonymous
	   * access to various services
	   *
	   * References:
	   *  - [RFC 4505](http://tools.ietf.org/html/rfc4505)
	   *
	   * @api public
	   */
	  function Mechanism() {
	  }
	  
	  Mechanism.prototype.name = 'ANONYMOUS';
	  Mechanism.prototype.clientFirst = true;
	  
	  /**
	   * Encode a response using optional trace information.
	   *
	   * Options:
	   *  - `trace`  trace information (optional)
	   *
	   * @param {Object} cred
	   * @api public
	   */
	  Mechanism.prototype.response = function(cred) {
	    return cred.trace || '';
	  };
	  
	  /**
	   * Decode a challenge issued by the server.
	   *
	   * @param {String} chal
	   * @api public
	   */
	  Mechanism.prototype.challenge = function(chal) {
	  };

	  exports = module.exports = Mechanism;
	  
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _shortcuts = __webpack_require__(317);

	var _shortcuts2 = _interopRequireDefault(_shortcuts);

	var _types = __webpack_require__(324);

	var _types2 = _interopRequireDefault(_types);

	exports['default'] = function (JXT) {

	    JXT.use(_types2['default']);
	    JXT.use(_shortcuts2['default']);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=index.js.map

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var VERSION = {
	    client: _xmppConstants.Namespace.CLIENT,
	    server: _xmppConstants.Namespace.SERVER,
	    component: _xmppConstants.Namespace.COMPONENT
	};

	exports['default'] = function (JXT) {

	    // ----------------------------------------------------------------
	    // Shortcuts for common extension calls
	    // ----------------------------------------------------------------

	    JXT.extendMessage = function (JXTClass, multiName) {
	        var _this = this;

	        this.withMessage(function (Message) {

	            _this.extend(Message, JXTClass, multiName);
	        });
	    };

	    JXT.extendPresence = function (JXTClass, multiName) {
	        var _this2 = this;

	        this.withPresence(function (Presence) {

	            _this2.extend(Presence, JXTClass, multiName);
	        });
	    };

	    JXT.extendIQ = function (JXTClass, multiName) {
	        var _this3 = this;

	        this.withIQ(function (IQ) {

	            _this3.extend(IQ, JXTClass, multiName);
	        });
	    };

	    JXT.extendStreamFeatures = function (JXTClass) {
	        var _this4 = this;

	        this.withStreamFeatures(function (StreamFeatures) {

	            _this4.extend(StreamFeatures, JXTClass);
	        });
	    };

	    JXT.extendPubsubItem = function (JXTClass) {
	        var _this5 = this;

	        this.withPubsubItem(function (PubsubItem) {

	            _this5.extend(PubsubItem, JXTClass);
	        });
	    };

	    // ----------------------------------------------------------------
	    // Shortcuts for common withDefinition calls
	    // ----------------------------------------------------------------

	    JXT.withIQ = function (cb) {

	        this.withDefinition('iq', _xmppConstants.Namespace.CLIENT, cb);
	        this.withDefinition('iq', _xmppConstants.Namespace.COMPONENT, cb);
	    };

	    JXT.withMessage = function (cb) {

	        this.withDefinition('message', _xmppConstants.Namespace.CLIENT, cb);
	        this.withDefinition('message', _xmppConstants.Namespace.COMPONENT, cb);
	    };

	    JXT.withPresence = function (cb) {

	        this.withDefinition('presence', _xmppConstants.Namespace.CLIENT, cb);
	        this.withDefinition('presence', _xmppConstants.Namespace.COMPONENT, cb);
	    };

	    JXT.withStreamFeatures = function (cb) {

	        this.withDefinition('features', _xmppConstants.Namespace.STREAM, cb);
	    };

	    JXT.withStanzaError = function (cb) {

	        this.withDefinition('error', _xmppConstants.Namespace.CLIENT, cb);
	        this.withDefinition('error', _xmppConstants.Namespace.COMPONENT, cb);
	    };

	    JXT.withDataForm = function (cb) {

	        this.withDefinition('x', _xmppConstants.Namespace.DATAFORM, cb);
	    };

	    JXT.withPubsubItem = function (cb) {

	        this.withDefinition('item', _xmppConstants.Namespace.PUBSUB, cb);
	        this.withDefinition('item', _xmppConstants.Namespace.PUBSUB_EVENT, cb);
	    };

	    // ----------------------------------------------------------------
	    // Shortcuts for common getDefinition calls
	    // ----------------------------------------------------------------

	    JXT.getMessage = function () {
	        var version = arguments[0] === undefined ? 'client' : arguments[0];

	        return this.getDefinition('message', VERSION[version]);
	    };

	    JXT.getPresence = function () {
	        var version = arguments[0] === undefined ? 'client' : arguments[0];

	        return this.getDefinition('presence', VERSION[version]);
	    };

	    JXT.getIQ = function () {
	        var version = arguments[0] === undefined ? 'client' : arguments[0];

	        return this.getDefinition('iq', VERSION[version]);
	    };

	    JXT.getStreamError = function () {

	        return this.getDefinition('error', _xmppConstants.Namespace.STREAM);
	    };

	    // For backward compatibility
	    JXT.getIq = JXT.getIQ;
	    JXT.withIq = JXT.withIQ;
	};

	module.exports = exports['default'];
	//# sourceMappingURL=shortcuts.js.map

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    Namespace: __webpack_require__(319),
	    MUC: __webpack_require__(320),
	    PubSub: __webpack_require__(321),
	    Jingle: __webpack_require__(322),
	    Presence: __webpack_require__(323)
	};


/***/ },
/* 319 */
/***/ function(module, exports) {

	module.exports = {
	// ================================================================
	// RFCS
	// ================================================================

	// RFC 6120
	    BIND: 'urn:ietf:params:xml:ns:xmpp-bind',
	    CLIENT: 'jabber:client',
	    SASL: 'urn:ietf:params:xml:ns:xmpp-sasl',
	    SERVER: 'jabber:server',
	    SESSION: 'urn:ietf:params:xml:ns:xmpp-session',
	    STANZA_ERROR: 'urn:ietf:params:xml:ns:xmpp-stanzas',
	    STREAM: 'http://etherx.jabber.org/streams',
	    STREAM_ERROR: 'urn:ietf:params:xml:ns:xmpp-streams',

	// RFC 6121
	    ROSTER: 'jabber:iq:roster',
	    ROSTER_VERSIONING: 'urn:xmpp:features:rosterver',
	    SUBSCRIPTION_PREAPPROVAL: 'urn:xmpp:features:pre-approval',

	// RFC 7395
	    FRAMING: 'urn:ietf:params:xml:ns:xmpp-framing',

	// ================================================================
	// XEPS
	// ================================================================

	// XEP-0004
	    DATAFORM: 'jabber:x:data',

	// XEP-0009
	    RPC: 'jabber:iq:rpc',

	// XEP-0012
	    LAST_ACTIVITY: 'jabber:iq:last',

	// XEP-0016
	    PRIVACY: 'jabber:iq:privacy',

	// XEP-0030
	    DISCO_INFO: 'http://jabber.org/protocol/disco#info',
	    DISCO_ITEMS: 'http://jabber.org/protocol/disco#items',

	// XEP-0033
	    ADDRESS: 'http://jabber.org/protocol/address',

	// XEP-0045
	    MUC: 'http://jabber.org/protocol/muc',
	    MUC_ADMIN: 'http://jabber.org/protocol/muc#admin',
	    MUC_OWNER: 'http://jabber.org/protocol/muc#owner',
	    MUC_USER: 'http://jabber.org/protocol/muc#user',

	// XEP-0047
	    IBB: 'http://jabber.org/protocol/ibb',

	// XEP-0048
	    BOOKMARKS: 'storage:bookmarks',

	// XEP-0049
	    PRIVATE: 'jabber:iq:private',

	// XEP-0050
	    ADHOC_COMMANDS: 'http://jabber.org/protocol/commands',

	// XEP-0054
	    VCARD_TEMP: 'vcard-temp',

	// XEP-0055
	    SEARCH: 'jabber:iq:search',

	// XEP-0059
	    RSM: 'http://jabber.org/protocol/rsm',

	// XEP-0060
	    PUBSUB: 'http://jabber.org/protocol/pubsub',
	    PUBSUB_ERRORS: 'http://jabber.org/protocol/pubsub#errors',
	    PUBSUB_EVENT: 'http://jabber.org/protocol/pubsub#event',
	    PUBSUB_OWNER: 'http://jabber.org/protocol/pubsub#owner',

	// XEP-0065
	    SOCKS5: 'http://jabber.org/protocol/bytestreams',

	// XEP-0066
	    OOB: 'jabber:x:oob',

	// XEP-0070
	    HTTP_AUTH: 'http://jabber.org/protocol/http-auth',

	// XEP-0071
	    XHTML_IM: 'http://jabber.org/protocol/xhtml-im',

	// XEP-0077
	    REGISTER: 'jabber:iq:register',

	// XEP-0079
	    AMP: 'http://jabber.org/protocol/amp',

	// XEP-0080
	    GEOLOC: 'http://jabber.org/protocol/geoloc',

	// XEP-0083
	    ROSTER_DELIMITER: 'roster:delimiter',

	// XEP-0084
	    AVATAR_DATA: 'urn:xmpp:avatar:data',
	    AVATAR_METADATA: 'urn:xmpp:avatar:metadata',

	// XEP-0085
	    CHAT_STATES: 'http://jabber.org/protocol/chatstates',

	// XEP-0092
	    VERSION: 'jabber:iq:version',

	// XEP-0107
	    MOOD: 'http://jabber.org/protocol/mood',

	// XEP-0108
	    ACTIVITY: 'http://jabber.org/protocol/activity',

	// XEP-0114
	    COMPONENT: 'jabber:component:accept',

	// XEP-0115
	    CAPS: 'http://jabber.org/protocol/caps',

	// XEP-0118
	    TUNE: 'http://jabber.org/protocol/tune',

	// XEP-0122
	    DATAFORM_VALIDATION: 'http://jabber.org/protocol/xdata-validate',

	// XEP-0124
	    BOSH: 'http://jabber.org/protocol/httpbind',

	// XEP-0131
	    SHIM: 'http://jabber.org/protocol/shim',

	// XEP-0138
	    COMPRESSION: 'http://jabber.org/features/compress',

	// XEP-0141
	    DATAFORM_LAYOUT: 'http://jabber.org/protocol/xdata-layout',

	// XEP-0144
	    ROSTER_EXCHANGE: 'http://jabber.org/protocol/rosterx',

	// XEP-0145
	    ROSTER_NOTES: 'storage:rosternotes',

	// XEP-0152
	    REACH_0: 'urn:xmpp:reach:0',

	// XEP-0153
	    VCARD_TEMP_UPDATE: 'vcard-temp:x:update',

	// XEP-0158
	    CAPTCHA: 'urn:xmpp:captcha',

	// XEP-0166
	    JINGLE_1: 'urn:xmpp:jingle:1',
	    JINGLE_ERRORS_1: 'urn:xmpp:jingle:errors:1',

	// XEP-0167
	    JINGLE_RTP_1: 'urn:xmpp:jingle:apps:rtp:1',
	    JINGLE_RTP_ERRORS_1: 'urn:xmpp:jingle:apps:rtp:errors:1',
	    JINGLE_RTP_INFO_1: 'urn:xmpp:jingle:apps:rtp:info:1',

	// XEP-0171
	    LANG_TRANS: 'urn:xmpp:langtrans',
	    LANG_TRANS_ITEMS: 'urn:xmpp:langtrans:items',

	// XEP-0172
	    NICK: 'http://jabber.org/protocol/nick',

	// XEP-0176
	    JINGLE_ICE_UDP_1: 'urn:xmpp:jingle:transports:ice-udp:1',

	// XEP-0177
	    JINGLE_RAW_UDP_1: 'urn:xmpp:jingle:transports:raw-udp:1',

	// XEP-0184
	    RECEIPTS: 'urn:xmpp:receipts',

	// XEP-0186
	    INVISIBLE_0: 'urn:xmpp:invisible:0',

	// XEP-0191
	    BLOCKING: 'urn:xmpp:blocking',

	// XEP-0198
	    SMACKS_3: 'urn:xmpp:sm:3',

	// XEP-0199
	    PING: 'urn:xmpp:ping',

	// XEP-0202
	    TIME: 'urn:xmpp:time',

	// XEP-0203
	    DELAY: 'urn:xmpp:delay',

	// XEP-0206
	    BOSH_XMPP: 'urn:xmpp:xbosh',

	// XEP-0215
	    DISCO_EXTERNAL_1: 'urn:xmpp:extdisco:1',

	// XEP-0221
	    DATAFORM_MEDIA: 'urn:xmpp:media-element',

	// XEP-0224
	    ATTENTION_0: 'urn:xmpp:attention:0',

	// XEP-0231
	    BOB: 'urn:xmpp:bob',

	// XEP-0234
	    FILE_TRANSFER_3: 'urn:xmpp:jingle:apps:file-transfer:3',
	    FILE_TRANSFER_4: 'urn:xmpp:jingle:apps:file-transfer:4',

	// XEP-0249
	    MUC_DIRECT_INVITE: 'jabber:x:conference',

	// XEP-0258
	    SEC_LABEL_0: 'urn:xmpp:sec-label:0',
	    SEC_LABEL_CATALOG_2: 'urn:xmpp:sec-label:catalog:2',
	    SEC_LABEL_ESS_0: 'urn:xmpp:sec-label:ess:0',

	// XEP-0260
	    JINGLE_SOCKS5_1: 'urn:xmpp:jingle:transports:s5b:1',

	// XEP-0261
	    JINGLE_IBB_1: 'urn:xmpp:jingle:transports:ibb:1',

	// XEP-0262
	    JINGLE_RTP_ZRTP_1: 'urn:xmpp:jingle:apps:rtp:zrtp:1',

	// XEP-0264
	    THUMBS_0: 'urn:xmpp:thumbs:0',
	    THUMBS_1: 'urn:xmpp:thumbs:1',

	// XEP-0276
	    DECLOAKING_0: 'urn:xmpp:decloaking:0',

	// XEP-0280
	    CARBONS_2: 'urn:xmpp:carbons:2',

	// XEP-0293
	    JINGLE_RTP_RTCP_FB_0: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',

	// XEP-0294
	    JINGLE_RTP_HDREXT_0: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',

	// XEP-0297
	    FORWARD_0: 'urn:xmpp:forward:0',

	// XEP-0300
	    HASHES_1: 'urn:xmpp:hashes:1',

	// XEP-0301
	    RTT_0: 'urn:xmpp:rtt:0',

	// XEP-0307
	    MUC_UNIQUE: 'http://jabber.org/protocol/muc#unique',

	// XEP-308
	    CORRECTION_0: 'urn:xmpp:message-correct:0',

	// XEP-0310
	    PSA: 'urn:xmpp:psa',

	// XEP-0313
	    MAM_TMP: 'urn:xmpp:mam:tmp',
	    MAM_0: 'urn:xmpp:mam:0',

	// XEP-0317
	    HATS_0: 'urn:xmpp:hats:0',

	// XEP-0319
	    IDLE_1: 'urn:xmpp:idle:1',

	// XEP-0320
	    JINGLE_DTLS_0: 'urn:xmpp:jingle:apps:dtls:0',

	// XEP-0328
	    JID_PREP_0: 'urn:xmpp:jidprep:0',

	// XEP-0334
	    HINTS: 'urn:xmpp:hints',

	// XEP-0335
	    JSON_0: 'urn:xmpp:json:0',

	// XEP-0337
	    EVENTLOG: 'urn:xmpp:eventlog',

	// XEP-0338
	    JINGLE_GROUPING_0: 'urn:xmpp:jingle:apps:grouping:0',

	// XEP-0339
	    JINGLE_RTP_SSMA_0: 'urn:xmpp:jingle:apps:rtp:ssma:0',

	// XEP-0340
	    COLIBRI: 'http://jitsi.org/protocol/colibri',

	// XEP-0343
	    DTLS_SCTP_1: 'urn:xmpp:jingle:transports:dtls-sctp:1',

	// XEP-0352
	    CSI: 'urn:xmpp:csi',

	// XEP-0353
	    JINGLE_MSG_INITIATE_0: 'urn:xmpp:jingle:jingle-message:0',

	// XEP-0357
	    PUSH_0: 'urn:xmpp:push:0',

	// XEP-0358
	    JINGLE_PUB_1: 'urn:xmpp:jinglepub:1'
	};


/***/ },
/* 320 */
/***/ function(module, exports) {

	module.exports = {
	    Status: {
	        REALJID_PUBLIC: '100',
	        AFFILIATION_CHANGED: '101',
	        UNAVAILABLE_SHOWN: '102',
	        UNAVAILABLE_NOT_SHOWN: '103',
	        CONFIGURATION_CHANGED: '104',
	        SELF_PRESENCE: '110',
	        LOGGING_ENABLED: '170',
	        LOGGING_DISABLED: '171',
	        NON_ANONYMOUS: '172',
	        SEMI_ANONYMOUS: '173',
	        FULLY_ANONYMOUS: '174',
	        ROOM_CREATED: '201',
	        NICK_ASSIGNED: '210',
	        BANNED: '301',
	        NEW_NICK: '303',
	        KICKED: '307',
	        REMOVED_AFFILIATION: '321',
	        REMOVED_MEMBERSHIP: '322',
	        REMOVED_SHUTDOWN: '332'
	    },
	    Affiliation: {
	        ADMIN: 'admin',
	        MEMBER: 'member',
	        NONE: 'none',
	        OUTCAST: 'outcast',
	        OWNER: 'owner'
	    },
	    Role: {
	        MODERATOR: 'moderator',
	        NONE: 'none',
	        PARTICIPANT: 'participant',
	        VISITOR: 'visitor'
	    }
	};


/***/ },
/* 321 */
/***/ function(module, exports) {

	module.exports = {
	    Affiliation: {
	        MEMBER: 'member',
	        NONE: 'none',
	        OUTCAST: 'outcast',
	        OWNER: 'owner',
	        PUBLISHER: 'publisher',
	        PUBLISH_ONLY: 'publish-only'
	    },
	    Subscription: {
	        NONE: 'none',
	        PENDING: 'pending',
	        UNCONFIGURED: 'unconfigured',
	        SUBSCRIBED: 'subscribed'
	    },
	    AccessModel: {
	        OPEN: 'open',
	        PRESENCE: 'presence',
	        ROSTER: 'roster',
	        AUTHORIZE: 'authorize',
	        WHITELIST: 'whitelist'
	    },
	    Condition: {
	        CONFLICT: 'conflict'
	    }
	};


/***/ },
/* 322 */
/***/ function(module, exports) {

	module.exports = {
	    Action: {
	        CONTENT_ACCEPT: 'content-accept',
	        CONTENT_ADD: 'content-add',
	        CONTENT_MODIFY: 'content-modify',
	        CONTENT_REJECT: 'content-reject',
	        CONTENT_REMOVE: 'content-remove',
	        DESCRIPTION_INFO: 'description-info',
	        SECURITY_INFO: 'security-info',
	        SESSION_ACCEPT: 'session-accept',
	        SESSION_INFO: 'session-info',
	        SESSION_INITIATE: 'session-initiate',
	        SESSION_TERMINATE: 'session-terminate',
	        TRANSPORT_ACCEPT: 'transport-accept',
	        TRANSPORT_INFO: 'transport-info',
	        TRANSPORT_REJECT: 'transport-reject',
	        TRANSPORT_REPLACE: 'transport-replace'
	    },
	    Reason: {
	        ALTERNATIVE_SESSION: 'alernative-session',
	        BUSY: 'busy',
	        CANCEL: 'cancel',
	        CONNECTIVITY_ERROR: 'connectivity-error',
	        DECLINE: 'decline',
	        EXPIRED: 'expired',
	        FAILED_APPLICATION: 'failed-application',
	        FAILED_TRANSPORT: 'failed-transport',
	        GENERAL_ERROR: 'general-error',
	        GONE: 'gone',
	        INCOMPATIBLE_PARAMETERS: 'incompatible-parameters',
	        MEDIA_ERROR: 'media-error',
	        SECURITY_ERROR: 'security-error',
	        SUCCESS: 'success',
	        TIMEOUT: 'timeout',
	        UNSUPPORTED_APPLICATIONS: 'unsupported-applications',
	        UNSUPPORTED_TRANSPORTS: 'unsupported-transports'
	    },
	    Condition: {
	        OUT_OF_ORDER: 'out-of-order',
	        TIE_BREAK: 'tie-break',
	        UNKNOWN_SESSION: 'unknown-session',
	        UNSUPPORTED_INFO: 'unsupported-info'
	    }
	};


/***/ },
/* 323 */
/***/ function(module, exports) {

	module.exports = {
	    Type: {
	        SUBSCRIBE: 'subscribe',
	        SUBSCRIBED: 'subscribed',
	        UNSUBSCRIBE: 'unsubscribe',
	        UNSUBSCRIBED: 'unsubscribed',
	        PROBE: 'probe',
	        UNAVAILABLE: 'unavailable'
	    },
	    Show: {
	        CHAT: 'chat',
	        AWAY: 'away',
	        DO_NOT_DISTURB: 'dnd',
	        EXTENDED_AWAY: 'xa'
	    }
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppJid = __webpack_require__(222);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    Utils.jidAttribute = function (attr, prepped) {

	        return {
	            get: function get() {

	                var jid = new _xmppJid.JID(Utils.getAttribute(this.xml, attr));
	                if (prepped) {
	                    jid.prepped = true;
	                }
	                return jid;
	            },
	            set: function set(value) {

	                Utils.setAttribute(this.xml, attr, (value || '').toString());
	            }
	        };
	    };

	    Utils.jidSub = function (NS, sub, prepped) {

	        return {
	            get: function get() {

	                var jid = new _xmppJid.JID(Utils.getSubText(this.xml, NS, sub));
	                if (prepped) {
	                    jid.prepped = true;
	                }
	                return jid;
	            },
	            set: function set(value) {

	                Utils.setSubText(this.xml, NS, sub, (value || '').toString());
	            }
	        };
	    };

	    Utils.tzoSub = Utils.field(function (xml, NS, sub, defaultVal) {

	        var hrs = undefined,
	            min = undefined,
	            split = undefined;
	        var sign = -1;
	        var formatted = Utils.getSubText(xml, NS, sub);

	        if (!formatted) {
	            return defaultVal;
	        }

	        if (formatted.charAt(0) === '-') {
	            sign = 1;
	            formatted = formatted.slice(1);
	        }

	        split = formatted.split(':');
	        hrs = parseInt(split[0], 10);
	        min = parseInt(split[1], 10);
	        return (hrs * 60 + min) * sign;
	    }, function (xml, NS, sub, value) {

	        var hrs = undefined,
	            min = undefined;
	        var formatted = '-';
	        if (typeof value === 'number') {
	            if (value < 0) {
	                value = -value;
	                formatted = '+';
	            }
	            hrs = value / 60;
	            min = value % 60;
	            formatted += (hrs < 10 ? '0' : '') + hrs + ':' + (min < 10 ? '0' : '') + min;
	        } else {
	            formatted = value;
	        }
	        Utils.setSubText(xml, NS, sub, formatted);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=types.js.map

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(326)['default'];

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _avatar = __webpack_require__(327);

	var _avatar2 = _interopRequireDefault(_avatar);

	var _bind = __webpack_require__(328);

	var _bind2 = _interopRequireDefault(_bind);

	var _blocking = __webpack_require__(329);

	var _blocking2 = _interopRequireDefault(_blocking);

	var _bob = __webpack_require__(330);

	var _bob2 = _interopRequireDefault(_bob);

	var _bookmarks = __webpack_require__(331);

	var _bookmarks2 = _interopRequireDefault(_bookmarks);

	var _bosh = __webpack_require__(332);

	var _bosh2 = _interopRequireDefault(_bosh);

	var _carbons = __webpack_require__(333);

	var _carbons2 = _interopRequireDefault(_carbons);

	var _command = __webpack_require__(334);

	var _command2 = _interopRequireDefault(_command);

	var _csi = __webpack_require__(335);

	var _csi2 = _interopRequireDefault(_csi);

	var _dataforms = __webpack_require__(336);

	var _dataforms2 = _interopRequireDefault(_dataforms);

	var _delayed = __webpack_require__(337);

	var _delayed2 = _interopRequireDefault(_delayed);

	var _disco = __webpack_require__(338);

	var _disco2 = _interopRequireDefault(_disco);

	var _error = __webpack_require__(339);

	var _error2 = _interopRequireDefault(_error);

	var _extdisco = __webpack_require__(340);

	var _extdisco2 = _interopRequireDefault(_extdisco);

	var _file = __webpack_require__(341);

	var _file2 = _interopRequireDefault(_file);

	var _file3 = __webpack_require__(342);

	var _file32 = _interopRequireDefault(_file3);

	var _forwarded = __webpack_require__(343);

	var _forwarded2 = _interopRequireDefault(_forwarded);

	var _framing = __webpack_require__(344);

	var _framing2 = _interopRequireDefault(_framing);

	var _geoloc = __webpack_require__(345);

	var _geoloc2 = _interopRequireDefault(_geoloc);

	var _hash = __webpack_require__(346);

	var _hash2 = _interopRequireDefault(_hash);

	var _hats = __webpack_require__(347);

	var _hats2 = _interopRequireDefault(_hats);

	var _iceUdp = __webpack_require__(348);

	var _iceUdp2 = _interopRequireDefault(_iceUdp);

	var _ibb = __webpack_require__(349);

	var _ibb2 = _interopRequireDefault(_ibb);

	var _iq = __webpack_require__(350);

	var _iq2 = _interopRequireDefault(_iq);

	var _jidprep = __webpack_require__(365);

	var _jidprep2 = _interopRequireDefault(_jidprep);

	var _jingle = __webpack_require__(366);

	var _jingle2 = _interopRequireDefault(_jingle);

	var _json = __webpack_require__(367);

	var _json2 = _interopRequireDefault(_json);

	var _logging = __webpack_require__(368);

	var _logging2 = _interopRequireDefault(_logging);

	var _mam = __webpack_require__(369);

	var _mam2 = _interopRequireDefault(_mam);

	var _message = __webpack_require__(370);

	var _message2 = _interopRequireDefault(_message);

	var _mood = __webpack_require__(371);

	var _mood2 = _interopRequireDefault(_mood);

	var _muc = __webpack_require__(372);

	var _muc2 = _interopRequireDefault(_muc);

	var _nick = __webpack_require__(373);

	var _nick2 = _interopRequireDefault(_nick);

	var _oob = __webpack_require__(374);

	var _oob2 = _interopRequireDefault(_oob);

	var _ping = __webpack_require__(375);

	var _ping2 = _interopRequireDefault(_ping);

	var _presence = __webpack_require__(376);

	var _presence2 = _interopRequireDefault(_presence);

	var _private = __webpack_require__(377);

	var _private2 = _interopRequireDefault(_private);

	var _psa = __webpack_require__(378);

	var _psa2 = _interopRequireDefault(_psa);

	var _pubsub = __webpack_require__(379);

	var _pubsub2 = _interopRequireDefault(_pubsub);

	var _pubsubError = __webpack_require__(380);

	var _pubsubError2 = _interopRequireDefault(_pubsubError);

	var _pubsubEvents = __webpack_require__(381);

	var _pubsubEvents2 = _interopRequireDefault(_pubsubEvents);

	var _pubsubOwner = __webpack_require__(382);

	var _pubsubOwner2 = _interopRequireDefault(_pubsubOwner);

	var _push = __webpack_require__(383);

	var _push2 = _interopRequireDefault(_push);

	var _reach = __webpack_require__(384);

	var _reach2 = _interopRequireDefault(_reach);

	var _register = __webpack_require__(385);

	var _register2 = _interopRequireDefault(_register);

	var _roster = __webpack_require__(386);

	var _roster2 = _interopRequireDefault(_roster);

	var _rsm = __webpack_require__(387);

	var _rsm2 = _interopRequireDefault(_rsm);

	var _rtp = __webpack_require__(388);

	var _rtp2 = _interopRequireDefault(_rtp);

	var _rtt = __webpack_require__(389);

	var _rtt2 = _interopRequireDefault(_rtt);

	var _sasl = __webpack_require__(390);

	var _sasl2 = _interopRequireDefault(_sasl);

	var _session = __webpack_require__(391);

	var _session2 = _interopRequireDefault(_session);

	var _shim = __webpack_require__(392);

	var _shim2 = _interopRequireDefault(_shim);

	var _sm = __webpack_require__(393);

	var _sm2 = _interopRequireDefault(_sm);

	var _stream = __webpack_require__(394);

	var _stream2 = _interopRequireDefault(_stream);

	var _streamError = __webpack_require__(395);

	var _streamError2 = _interopRequireDefault(_streamError);

	var _streamFeatures = __webpack_require__(396);

	var _streamFeatures2 = _interopRequireDefault(_streamFeatures);

	var _time = __webpack_require__(397);

	var _time2 = _interopRequireDefault(_time);

	var _tune = __webpack_require__(398);

	var _tune2 = _interopRequireDefault(_tune);

	var _vcard = __webpack_require__(399);

	var _vcard2 = _interopRequireDefault(_vcard);

	var _version = __webpack_require__(400);

	var _version2 = _interopRequireDefault(_version);

	var _visibility = __webpack_require__(401);

	var _visibility2 = _interopRequireDefault(_visibility);

	exports['default'] = function (JXT) {

	    JXT.use(_avatar2['default']);
	    JXT.use(_bind2['default']);
	    JXT.use(_blocking2['default']);
	    JXT.use(_bob2['default']);
	    JXT.use(_bookmarks2['default']);
	    JXT.use(_bosh2['default']);
	    JXT.use(_carbons2['default']);
	    JXT.use(_command2['default']);
	    JXT.use(_csi2['default']);
	    JXT.use(_dataforms2['default']);
	    JXT.use(_delayed2['default']);
	    JXT.use(_disco2['default']);
	    JXT.use(_error2['default']);
	    JXT.use(_extdisco2['default']);
	    JXT.use(_file2['default']);
	    JXT.use(_file32['default']);
	    JXT.use(_forwarded2['default']);
	    JXT.use(_framing2['default']);
	    JXT.use(_geoloc2['default']);
	    JXT.use(_hash2['default']);
	    JXT.use(_hats2['default']);
	    JXT.use(_iceUdp2['default']);
	    JXT.use(_ibb2['default']);
	    JXT.use(_iq2['default']);
	    JXT.use(_jidprep2['default']);
	    JXT.use(_jingle2['default']);
	    JXT.use(_json2['default']);
	    JXT.use(_logging2['default']);
	    JXT.use(_mam2['default']);
	    JXT.use(_message2['default']);
	    JXT.use(_mood2['default']);
	    JXT.use(_muc2['default']);
	    JXT.use(_nick2['default']);
	    JXT.use(_oob2['default']);
	    JXT.use(_ping2['default']);
	    JXT.use(_presence2['default']);
	    JXT.use(_private2['default']);
	    JXT.use(_psa2['default']);
	    JXT.use(_pubsub2['default']);
	    JXT.use(_pubsubError2['default']);
	    JXT.use(_pubsubEvents2['default']);
	    JXT.use(_pubsubOwner2['default']);
	    JXT.use(_push2['default']);
	    JXT.use(_reach2['default']);
	    JXT.use(_register2['default']);
	    JXT.use(_roster2['default']);
	    JXT.use(_rsm2['default']);
	    JXT.use(_rtp2['default']);
	    JXT.use(_rtt2['default']);
	    JXT.use(_sasl2['default']);
	    JXT.use(_session2['default']);
	    JXT.use(_shim2['default']);
	    JXT.use(_sm2['default']);
	    JXT.use(_stream2['default']);
	    JXT.use(_streamError2['default']);
	    JXT.use(_streamFeatures2['default']);
	    JXT.use(_time2['default']);
	    JXT.use(_tune2['default']);
	    JXT.use(_vcard2['default']);
	    JXT.use(_version2['default']);
	    JXT.use(_visibility2['default']);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=index.js.map

/***/ },
/* 326 */
/***/ function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(326)['default'];

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _lodashForeach = __webpack_require__(226);

	var _lodashForeach2 = _interopRequireDefault(_lodashForeach);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Avatar = JXT.define({
	        name: 'avatar',
	        namespace: _xmppConstants.Namespace.AVATAR_METADATA,
	        element: 'info',
	        fields: {
	            id: Utils.attribute('id'),
	            bytes: Utils.attribute('bytes'),
	            height: Utils.attribute('height'),
	            width: Utils.attribute('width'),
	            type: Utils.attribute('type', 'image/png'),
	            url: Utils.attribute('url')
	        }
	    });

	    var avatars = {
	        get: function get() {

	            var metadata = Utils.find(this.xml, _xmppConstants.Namespace.AVATAR_METADATA, 'metadata');
	            var results = [];
	            if (metadata.length) {
	                var _avatars = Utils.find(metadata[0], _xmppConstants.Namespace.AVATAR_METADATA, 'info');
	                (0, _lodashForeach2['default'])(_avatars, function (info) {

	                    results.push(new Avatar({}, info));
	                });
	            }
	            return results;
	        },
	        set: function set(value) {

	            var metadata = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.AVATAR_METADATA, 'metadata');
	            Utils.setAttribute(metadata, 'xmlns', _xmppConstants.Namespace.AVATAR_METADATA);
	            (0, _lodashForeach2['default'])(value, function (info) {

	                var avatar = new Avatar(info);
	                metadata.appendChild(avatar.xml);
	            });
	        }
	    };

	    JXT.withPubsubItem(function (Item) {

	        JXT.add(Item, 'avatars', avatars);
	        JXT.add(Item, 'avatarData', Utils.textSub(_xmppConstants.Namespace.AVATAR_DATA, 'data'));
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=avatar.js.map

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Bind = JXT.define({
	        name: 'bind',
	        namespace: _xmppConstants.Namespace.BIND,
	        element: 'bind',
	        fields: {
	            resource: Utils.textSub(_xmppConstants.Namespace.BIND, 'resource'),
	            jid: Utils.jidSub(_xmppConstants.Namespace.BIND, 'jid')
	        }
	    });

	    JXT.extendIQ(Bind);
	    JXT.extendStreamFeatures(Bind);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=bind.js.map

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _xmppJid = __webpack_require__(222);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var jidList = {
	        get: function get() {

	            var result = [];
	            var items = types.find(this.xml, _xmppConstants.Namespace.BLOCKING, 'item');
	            if (!items.length) {
	                return result;
	            }

	            items.forEach(function (item) {

	                result.push(new _xmppJid.JID(types.getAttribute(item, 'jid', '')));
	            });

	            return result;
	        },
	        set: function set(values) {

	            var self = this;
	            values.forEach(function (value) {

	                var item = types.createElement(_xmppConstants.Namespace.BLOCKING, 'item', _xmppConstants.Namespace.BLOCKING);
	                types.setAttribute(item, 'jid', value.toString());
	                self.xml.appendChild(item);
	            });
	        }
	    };

	    var Block = JXT.define({
	        name: 'block',
	        namespace: _xmppConstants.Namespace.BLOCKING,
	        element: 'block',
	        fields: {
	            jids: jidList
	        }
	    });

	    var Unblock = JXT.define({
	        name: 'unblock',
	        namespace: _xmppConstants.Namespace.BLOCKING,
	        element: 'unblock',
	        fields: {
	            jids: jidList
	        }
	    });

	    var BlockList = JXT.define({
	        name: 'blockList',
	        namespace: _xmppConstants.Namespace.BLOCKING,
	        element: 'blocklist',
	        fields: {
	            jids: jidList
	        }
	    });

	    JXT.extendIQ(Block);
	    JXT.extendIQ(Unblock);
	    JXT.extendIQ(BlockList);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=blocking.js.map

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var BOB = JXT.define({
	        name: 'bob',
	        namespace: _xmppConstants.Namespace.BOB,
	        element: 'data',
	        fields: {
	            cid: Utils.attribute('cid'),
	            maxAge: Utils.numberAttribute('max-age'),
	            type: Utils.attribute('type'),
	            data: Utils.text()
	        }
	    });

	    JXT.extendIQ(BOB);
	    JXT.extendMessage(BOB);
	    JXT.extendPresence(BOB);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=bob.js.map

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Conference = JXT.define({
	        name: '_conference',
	        namespace: _xmppConstants.Namespace.BOOKMARKS,
	        element: 'conference',
	        fields: {
	            name: Utils.attribute('name'),
	            autoJoin: Utils.boolAttribute('autojoin'),
	            jid: Utils.jidAttribute('jid'),
	            nick: Utils.textSub(_xmppConstants.Namespace.BOOKMARKS, 'nick')
	        }
	    });

	    var Bookmarks = JXT.define({
	        name: 'bookmarks',
	        namespace: _xmppConstants.Namespace.BOOKMARKS,
	        element: 'storage'
	    });

	    JXT.extend(Bookmarks, Conference, 'conferences');

	    JXT.withDefinition('query', _xmppConstants.Namespace.PRIVATE, function (PrivateStorage) {

	        JXT.extend(PrivateStorage, Bookmarks);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=bookmarks.js.map

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: 'bosh',
	        namespace: _xmppConstants.Namespace.BOSH,
	        element: 'body',
	        prefixes: {
	            xmpp: _xmppConstants.Namespace.BOSH_XMPP
	        },
	        fields: {
	            accept: Utils.attribute('accept'),
	            ack: Utils.numberAttribute('ack'),
	            authid: Utils.attribute('authid'),
	            charsets: Utils.attribute('charsets'),
	            condition: Utils.attribute('condition'),
	            content: Utils.attribute('content'),
	            from: Utils.jidAttribute('from', true),
	            hold: Utils.numberAttribute('hold'),
	            inactivity: Utils.numberAttribute('inactivity'),
	            key: Utils.attribute('key'),
	            maxpause: Utils.numberAttribute('maxpause'),
	            newKey: Utils.attribute('newkey'),
	            pause: Utils.numberAttribute('pause'),
	            polling: Utils.numberAttribute('polling'),
	            resport: Utils.numberAttribute('report'),
	            requests: Utils.numberAttribute('requests'),
	            rid: Utils.numberAttribute('rid'),
	            sid: Utils.attribute('sid'),
	            stream: Utils.attribute('stream'),
	            time: Utils.attribute('time'),
	            to: Utils.jidAttribute('to', true),
	            type: Utils.attribute('type'),
	            ver: Utils.attribute('ver'),
	            wait: Utils.numberAttribute('wait'),
	            uri: Utils.textSub(_xmppConstants.Namespace.BOSH, 'uri'),
	            lang: Utils.langAttribute(),
	            // These three should be using namespaced attributes, but browsers are stupid
	            // when it comes to serializing attributes with namespaces
	            version: Utils.attribute('xmpp:version', '1.0'),
	            restart: Utils.attribute('xmpp:restart'),
	            restartLogic: Utils.boolAttribute('xmpp:restartLogic'),
	            payload: {
	                get: function get() {

	                    var results = [];
	                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
	                        var obj = JXT.build(this.xml.childNodes[i]);
	                        if (obj !== undefined) {
	                            results.push(obj);
	                        }
	                    }
	                    return results;
	                },
	                set: function set(values) {
	                    var _this = this;

	                    values.forEach(function (types) {

	                        _this.xml.appendChild(types.xml);
	                    });
	                }
	            }
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=bosh.js.map

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Sent = JXT.define({
	        name: 'carbonSent',
	        eventName: 'carbon:sent',
	        namespace: _xmppConstants.Namespace.CARBONS_2,
	        element: 'sent'
	    });

	    var Received = JXT.define({
	        name: 'carbonReceived',
	        eventName: 'carbon:received',
	        namespace: _xmppConstants.Namespace.CARBONS_2,
	        element: 'received'
	    });

	    var Private = JXT.define({
	        name: 'carbonPrivate',
	        eventName: 'carbon:private',
	        namespace: _xmppConstants.Namespace.CARBONS_2,
	        element: 'private'
	    });

	    var Enable = JXT.define({
	        name: 'enableCarbons',
	        namespace: _xmppConstants.Namespace.CARBONS_2,
	        element: 'enable'
	    });

	    var Disable = JXT.define({
	        name: 'disableCarbons',
	        namespace: _xmppConstants.Namespace.CARBONS_2,
	        element: 'disable'
	    });

	    JXT.withDefinition('forwarded', _xmppConstants.Namespace.FORWARD_0, function (Forwarded) {

	        JXT.extend(Sent, Forwarded);
	        JXT.extend(Received, Forwarded);
	    });

	    JXT.extendMessage(Sent);
	    JXT.extendMessage(Received);
	    JXT.extendMessage(Private);
	    JXT.extendIQ(Enable);
	    JXT.extendIQ(Disable);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=carbons.js.map

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var ACTIONS = ['next', 'prev', 'complete', 'cancel'];

	var CONDITIONS = ['bad-action', 'bad-locale', 'bad-payload', 'bad-sessionid', 'malformed-action', 'session-expired'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Command = JXT.define({
	        name: 'command',
	        namespace: _xmppConstants.Namespace.ADHOC_COMMANDS,
	        element: 'command',
	        fields: {
	            action: Utils.attribute('action'),
	            node: Utils.attribute('node'),
	            sessionid: Utils.attribute('sessionid'),
	            status: Utils.attribute('status'),
	            execute: Utils.subAttribute(_xmppConstants.Namespace.ADHOC_COMMANDS, 'actions', 'execute'),
	            actions: {
	                get: function get() {

	                    var result = [];
	                    var actionSet = Utils.find(this.xml, _xmppConstants.Namespace.ADHOC_COMMANDS, 'actions');
	                    if (!actionSet.length) {
	                        return [];
	                    }
	                    ACTIONS.forEach(function (action) {

	                        var existing = Utils.find(actionSet[0], _xmppConstants.Namespace.ADHOC_COMMANDS, action);
	                        if (existing.length) {
	                            result.push(action);
	                        }
	                    });
	                    return result;
	                },
	                set: function set(values) {

	                    var actionSet = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.ADHOC_COMMANDS, 'actions');
	                    for (var i = 0, len = actionSet.childNodes.length; i < len; i++) {
	                        actionSet.removeChild(actionSet.childNodes[i]);
	                    }
	                    values.forEach(function (value) {

	                        actionSet.appendChild(Utils.createElement(_xmppConstants.Namespace.ADHOC_COMMANDS, value.toLowerCase(), _xmppConstants.Namespace.ADHOC_COMMANDS));
	                    });
	                }
	            }
	        }
	    });

	    var Note = JXT.define({
	        name: '_commandNote',
	        namespace: _xmppConstants.Namespace.ADHOC_COMMANDS,
	        element: 'note',
	        fields: {
	            type: Utils.attribute('type'),
	            value: Utils.text()
	        }
	    });

	    JXT.extend(Command, Note, 'notes');

	    JXT.extendIQ(Command);

	    JXT.withStanzaError(function (StanzaError) {

	        JXT.add(StanzaError, 'adhocCommandCondition', Utils.enumSub(_xmppConstants.Namespace.ADHOC_COMMANDS, CONDITIONS));
	    });

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(Command, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=command.js.map

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var CSIFeature = JXT.define({
	        name: 'clientStateIndication',
	        namespace: _xmppConstants.Namespace.CSI,
	        element: 'csi'
	    });

	    JXT.define({
	        name: 'csiActive',
	        eventName: 'csi:active',
	        namespace: _xmppConstants.Namespace.CSI,
	        element: 'active',
	        topLevel: true
	    });

	    JXT.define({
	        name: 'csiInactive',
	        eventName: 'csi:inactive',
	        namespace: _xmppConstants.Namespace.CSI,
	        element: 'inactive',
	        topLevel: true
	    });

	    JXT.extendStreamFeatures(CSIFeature);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=csi.js.map

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _xmppJid = __webpack_require__(222);

	var SINGLE_FIELDS = ['text-single', 'text-private', 'list-single', 'jid-single'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Field = JXT.define({
	        name: '_field',
	        namespace: _xmppConstants.Namespace.DATAFORM,
	        element: 'field',
	        init: function init(data) {

	            this._type = (data || {}).type || this.type;
	        },
	        fields: {
	            type: {
	                get: function get() {

	                    return Utils.getAttribute(this.xml, 'type', 'text-single');
	                },
	                set: function set(value) {

	                    this._type = value;
	                    Utils.setAttribute(this.xml, 'type', value);
	                }
	            },
	            name: Utils.attribute('var'),
	            desc: Utils.textSub(_xmppConstants.Namespace.DATAFORM, 'desc'),
	            required: Utils.boolSub(_xmppConstants.Namespace.DATAFORM, 'required'),
	            label: Utils.attribute('label'),
	            value: {
	                get: function get() {

	                    var vals = Utils.getMultiSubText(this.xml, _xmppConstants.Namespace.DATAFORM, 'value');
	                    if (this._type === 'boolean') {
	                        return vals[0] === '1' || vals[0] === 'true';
	                    }
	                    if (vals.length > 1) {
	                        if (this._type === 'text-multi') {
	                            return vals.join('\n');
	                        }

	                        if (this._type === 'jid-multi') {
	                            return vals.map(function (jid) {

	                                return new _xmppJid.JID(jid);
	                            });
	                        }

	                        return vals;
	                    }
	                    if (SINGLE_FIELDS.indexOf(this._type) >= 0) {
	                        if (this._type === 'jid-single') {
	                            return new _xmppJid.JID(vals[0]);
	                        }
	                        return vals[0];
	                    }

	                    return vals;
	                },
	                set: function set(value) {

	                    if (this._type === 'boolean' || value === true || value === false) {
	                        var truthy = value === true || value === 'true' || value === '1';
	                        var sub = Utils.createElement(_xmppConstants.Namespace.DATAFORM, 'value', _xmppConstants.Namespace.DATAFORM);
	                        sub.textContent = truthy ? '1' : '0';
	                        this.xml.appendChild(sub);
	                    } else {
	                        if (this._type === 'text-multi' && typeof value === 'string') {
	                            value = value.split('\n');
	                        }
	                        Utils.setMultiSubText(this.xml, _xmppConstants.Namespace.DATAFORM, 'value', value, (function (val) {

	                            var sub = Utils.createElement(_xmppConstants.Namespace.DATAFORM, 'value', _xmppConstants.Namespace.DATAFORM);
	                            sub.textContent = val;
	                            this.xml.appendChild(sub);
	                        }).bind(this));
	                    }
	                }
	            }
	        }
	    });

	    var Option = JXT.define({
	        name: '_formoption',
	        namespace: _xmppConstants.Namespace.DATAFORM,
	        element: 'option',
	        fields: {
	            label: Utils.attribute('label'),
	            value: Utils.textSub(_xmppConstants.Namespace.DATAFORM, 'value')
	        }
	    });

	    var Item = JXT.define({
	        name: '_formitem',
	        namespace: _xmppConstants.Namespace.DATAFORM,
	        element: 'item'
	    });

	    var Media = JXT.define({
	        name: 'media',
	        element: 'media',
	        namespace: _xmppConstants.Namespace.DATAFORM_MEDIA,
	        fields: {
	            height: Utils.numberAttribute('height'),
	            width: Utils.numberAttribute('width')
	        }
	    });

	    var MediaURI = JXT.define({
	        name: '_mediaURI',
	        element: 'uri',
	        namespace: _xmppConstants.Namespace.DATAFORM_MEDIA,
	        fields: {
	            uri: Utils.text(),
	            type: Utils.attribute('type')
	        }
	    });

	    var Validation = JXT.define({
	        name: 'validation',
	        element: 'validate',
	        namespace: _xmppConstants.Namespace.DATAFORM_VALIDATION,
	        fields: {
	            dataType: Utils.attribute('datatype'),
	            basic: Utils.boolSub(_xmppConstants.Namespace.DATAFORM_VALIDATION, 'basic'),
	            open: Utils.boolSub(_xmppConstants.Namespace.DATAFORM_VALIDATION, 'open'),
	            regex: Utils.textSub(_xmppConstants.Namespace.DATAFORM_VALIDATION, 'regex')
	        }
	    });

	    var Range = JXT.define({
	        name: 'range',
	        element: 'range',
	        namespace: _xmppConstants.Namespace.DATAFORM_VALIDATION,
	        fields: {
	            min: Utils.attribute('min'),
	            max: Utils.attribute('max')
	        }
	    });

	    var ListRange = JXT.define({
	        name: 'select',
	        element: 'list-range',
	        namespace: _xmppConstants.Namespace.DATAFORM_VALIDATION,
	        fields: {
	            min: Utils.numberAttribute('min'),
	            max: Utils.numberAttribute('max')
	        }
	    });

	    var layoutContents = {
	        get: function get() {

	            var result = [];
	            for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
	                var child = this.xml.childNodes[i];
	                if (child.namespaceURI !== _xmppConstants.Namespace.DATAFORM_LAYOUT) {
	                    continue;
	                }

	                switch (child.localName) {
	                    case 'text':
	                        result.push({
	                            text: child.textContent
	                        });
	                        break;
	                    case 'fieldref':
	                        result.push({
	                            field: child.getAttribute('var')
	                        });
	                        break;
	                    case 'reportedref':
	                        result.push({
	                            reported: true
	                        });
	                        break;
	                    case 'section':
	                        result.push({
	                            section: new Section(null, child, this).toJSON()
	                        });
	                        break;
	                }
	            }

	            return result;
	        },
	        set: function set(values) {

	            for (var i = 0, len = values.length; i < len; i++) {
	                var value = values[i];
	                if (value.text) {
	                    var text = Utils.createElement(_xmppConstants.Namespace.DATAFORM_LAYOUT, 'text', _xmppConstants.Namespace.DATAFORM_LAYOUT);
	                    text.textContent = value.text;
	                    this.xml.appendChild(text);
	                }
	                if (value.field) {
	                    var field = Utils.createElement(_xmppConstants.Namespace.DATAFORM_LAYOUT, 'fieldref', _xmppConstants.Namespace.DATAFORM_LAYOUT);
	                    field.setAttribute('var', value.field);
	                    this.xml.appendChild(field);
	                }
	                if (value.reported) {
	                    this.xml.appendChild(Utils.createElement(_xmppConstants.Namespace.DATAFORM_LAYOUT, 'reportedref', _xmppConstants.Namespace.DATAFORM_LAYOUT));
	                }
	                if (value.section) {
	                    var sectionXML = Utils.createElement(_xmppConstants.Namespace.DATAFORM_LAYOUT, 'section', _xmppConstants.Namespace.DATAFORM_LAYOUT);
	                    this.xml.appendChild(sectionXML);

	                    var section = new Section(null, sectionXML);
	                    section.label = value.section.label;
	                    section.contents = value.section.contents;
	                }
	            }
	        }
	    };

	    var Section = JXT.define({
	        name: '_section',
	        element: 'section',
	        namespace: _xmppConstants.Namespace.DATAFORM_LAYOUT,
	        fields: {
	            label: Utils.attribute('label'),
	            contents: layoutContents
	        }
	    });

	    var Page = JXT.define({
	        name: '_page',
	        element: 'page',
	        namespace: _xmppConstants.Namespace.DATAFORM_LAYOUT,
	        fields: {
	            label: Utils.attribute('label'),
	            contents: layoutContents
	        }
	    });

	    var DataForm = JXT.define({
	        name: 'form',
	        namespace: _xmppConstants.Namespace.DATAFORM,
	        element: 'x',
	        init: function init() {

	            // Propagate reported field types to items

	            if (!this.reportedFields.length) {
	                return;
	            }

	            var fieldTypes = {};
	            this.reportedFields.forEach(function (reported) {

	                fieldTypes[reported.name] = reported.type;
	            });
	            this.items.forEach(function (item) {

	                item.fields.forEach(function (field) {

	                    field.type = field._type = fieldTypes[field.name];
	                });
	            });
	        },
	        fields: {
	            title: Utils.textSub(_xmppConstants.Namespace.DATAFORM, 'title'),
	            instructions: Utils.multiTextSub(_xmppConstants.Namespace.DATAFORM, 'instructions'),
	            type: Utils.attribute('type', 'form'),
	            reportedFields: Utils.subMultiExtension(_xmppConstants.Namespace.DATAFORM, 'reported', Field)
	        }
	    });

	    JXT.extend(DataForm, Field, 'fields');
	    JXT.extend(DataForm, Item, 'items');
	    JXT.extend(DataForm, Page, 'layout');

	    JXT.extend(Field, Media);
	    JXT.extend(Field, Validation);
	    JXT.extend(Field, Option, 'options');

	    JXT.extend(Item, Field, 'fields');

	    JXT.extend(Media, MediaURI, 'uris');
	    JXT.extend(Validation, Range);
	    JXT.extend(Validation, ListRange);

	    JXT.extendMessage(DataForm);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=dataforms.js.map

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var DelayedDelivery = JXT.define({
	        name: 'delay',
	        namespace: _xmppConstants.Namespace.DELAY,
	        element: 'delay',
	        fields: {
	            from: Utils.jidAttribute('from'),
	            stamp: Utils.dateAttribute('stamp'),
	            reason: Utils.text()
	        }
	    });

	    JXT.extendMessage(DelayedDelivery);
	    JXT.extendPresence(DelayedDelivery);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=delayed.js.map

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var DiscoCaps = JXT.define({
	        name: 'caps',
	        namespace: _xmppConstants.Namespace.CAPS,
	        element: 'c',
	        fields: {
	            ver: Utils.attribute('ver'),
	            node: Utils.attribute('node'),
	            hash: Utils.attribute('hash'),
	            ext: Utils.attribute('ext')
	        }
	    });

	    var DiscoInfo = JXT.define({
	        name: 'discoInfo',
	        namespace: _xmppConstants.Namespace.DISCO_INFO,
	        element: 'query',
	        fields: {
	            node: Utils.attribute('node'),
	            features: Utils.multiSubAttribute(_xmppConstants.Namespace.DISCO_INFO, 'feature', 'var')
	        }
	    });

	    var DiscoIdentity = JXT.define({
	        name: '_discoIdentity',
	        namespace: _xmppConstants.Namespace.DISCO_INFO,
	        element: 'identity',
	        fields: {
	            category: Utils.attribute('category'),
	            type: Utils.attribute('type'),
	            name: Utils.attribute('name'),
	            lang: Utils.langAttribute()
	        }
	    });

	    var DiscoItems = JXT.define({
	        name: 'discoItems',
	        namespace: _xmppConstants.Namespace.DISCO_ITEMS,
	        element: 'query',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var DiscoItem = JXT.define({
	        name: '_discoItem',
	        namespace: _xmppConstants.Namespace.DISCO_ITEMS,
	        element: 'item',
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            node: Utils.attribute('node'),
	            name: Utils.attribute('name')
	        }
	    });

	    JXT.extend(DiscoItems, DiscoItem, 'items');
	    JXT.extend(DiscoInfo, DiscoIdentity, 'identities');

	    JXT.extendIQ(DiscoInfo);
	    JXT.extendIQ(DiscoItems);
	    JXT.extendPresence(DiscoCaps);
	    JXT.extendStreamFeatures(DiscoCaps);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(DiscoInfo, DataForm, 'extensions');
	    });

	    JXT.withDefinition('set', _xmppConstants.Namespace.RSM, function (RSM) {

	        JXT.extend(DiscoItems, RSM);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=disco.js.map

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['bad-request', 'conflict', 'feature-not-implemented', 'forbidden', 'gone', 'internal-server-error', 'item-not-found', 'jid-malformed', 'not-acceptable', 'not-allowed', 'not-authorized', 'payment-required', 'recipient-unavailable', 'redirect', 'registration-required', 'remote-server-not-found', 'remote-server-timeout', 'resource-constraint', 'service-unavailable', 'subscription-required', 'undefined-condition', 'unexpected-request'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var StanzaError = JXT.define({
	        name: 'error',
	        namespace: _xmppConstants.Namespace.CLIENT,
	        element: 'error',
	        fields: {
	            lang: {
	                get: function get() {

	                    return (this.parent || {}).lang || '';
	                }
	            },
	            condition: Utils.enumSub(_xmppConstants.Namespace.STANZA_ERROR, CONDITIONS),
	            gone: {
	                get: function get() {

	                    return Utils.getSubText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'gone');
	                },
	                set: function set(value) {

	                    this.condition = 'gone';
	                    Utils.setSubText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'gone', value);
	                }
	            },
	            redirect: {
	                get: function get() {

	                    return Utils.getSubText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'redirect');
	                },
	                set: function set(value) {

	                    this.condition = 'redirect';
	                    Utils.setSubText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'redirect', value);
	                }
	            },
	            code: Utils.attribute('code'),
	            type: Utils.attribute('type'),
	            by: Utils.jidAttribute('by'),
	            $text: {
	                get: function get() {

	                    return Utils.getSubLangText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'text', this.lang);
	                }
	            },
	            text: {
	                get: function get() {

	                    var text = this.$text;
	                    return text[this.lang] || '';
	                },
	                set: function set(value) {

	                    Utils.setSubLangText(this.xml, _xmppConstants.Namespace.STANZA_ERROR, 'text', value, this.lang);
	                }
	            }
	        }
	    });

	    JXT.extendMessage(StanzaError);
	    JXT.extendPresence(StanzaError);
	    JXT.extendIQ(StanzaError);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=error.js.map

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Services = exports.Services = JXT.define({
	        name: 'services',
	        namespace: _xmppConstants.Namespace.DISCO_EXTERNAL_1,
	        element: 'services',
	        fields: {
	            type: Utils.attribute('type')
	        }
	    });

	    var Credentials = exports.Credentials = JXT.define({
	        name: 'credentials',
	        namespace: _xmppConstants.Namespace.DISCO_EXTERNAL_1,
	        element: 'credentials'
	    });

	    var Service = JXT.define({
	        name: 'service',
	        namespace: _xmppConstants.Namespace.DISCO_EXTERNAL_1,
	        element: 'service',
	        fields: {
	            host: Utils.attribute('host'),
	            port: Utils.attribute('port'),
	            transport: Utils.attribute('transport'),
	            type: Utils.attribute('type'),
	            username: Utils.attribute('username'),
	            password: Utils.attribute('password')
	        }
	    });

	    JXT.extend(Services, Service, 'services');
	    JXT.extend(Credentials, Service);

	    JXT.extendIQ(Services);
	    JXT.extendIQ(Credentials);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(Service, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=extdisco.js.map

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var FT_NS = _xmppConstants.Namespace.FILE_TRANSFER_4;

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var File = JXT.define({
	        name: 'file',
	        namespace: FT_NS,
	        element: 'file',
	        fields: {
	            name: Utils.textSub(FT_NS, 'name'),
	            description: Utils.textSub(FT_NS, 'desc'),
	            mediaType: Utils.textSub(FT_NS, 'media-type'),
	            size: Utils.numberSub(FT_NS, 'size'),
	            date: Utils.dateSub(FT_NS, 'date')
	        }
	    });

	    var Range = JXT.define({
	        name: 'range',
	        namespace: FT_NS,
	        element: 'range',
	        fields: {
	            offset: Utils.numberAttribute('offset'),
	            length: Utils.numberAttribute('length')
	        }
	    });

	    var FileTransfer = JXT.define({
	        name: '_' + FT_NS,
	        namespace: FT_NS,
	        element: 'description',
	        tags: ['jingle-application'],
	        fields: {
	            applicationType: { value: FT_NS }
	        }
	    });

	    var Received = JXT.define({
	        name: '_{' + FT_NS + '}received',
	        namespace: FT_NS,
	        element: 'received',
	        tags: ['jingle-info'],
	        fields: {
	            infoType: { value: '{' + FT_NS + '}received' },
	            creator: Utils.attribute('creator'),
	            name: Utils.attribute('name')
	        }
	    });

	    var Checksum = JXT.define({
	        name: '_{' + FT_NS + '}checksum',
	        namespace: FT_NS,
	        element: 'checksum',
	        tags: ['jingle-info'],
	        fields: {
	            infoType: { value: '{' + FT_NS + '}checksum' },
	            creator: Utils.attribute('creator'),
	            name: Utils.attribute('name')
	        }
	    });

	    JXT.extend(File, Range);
	    JXT.extend(Checksum, File);
	    JXT.extend(FileTransfer, File);

	    JXT.withDefinition('hash', _xmppConstants.Namespace.HASHES_1, function (Hash) {

	        JXT.extend(File, Hash, 'hashes');
	        JXT.extend(Range, Hash, 'hashes');
	    });

	    JXT.withDefinition('content', _xmppConstants.Namespace.JINGLE_1, function (Content) {

	        JXT.extend(Content, FileTransfer);
	    });

	    JXT.withDefinition('jingle', _xmppConstants.Namespace.JINGLE_1, function (Jingle) {

	        JXT.extend(Jingle, Received);
	        JXT.extend(Jingle, Checksum);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=file.js.map

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var FT_NS = _xmppConstants.Namespace.FILE_TRANSFER_3;

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var File = JXT.define({
	        name: '_file',
	        namespace: FT_NS,
	        element: 'file',
	        fields: {
	            name: Utils.textSub(FT_NS, 'name'),
	            desc: Utils.textSub(FT_NS, 'desc'),
	            size: Utils.numberSub(FT_NS, 'size'),
	            date: Utils.dateSub(FT_NS, 'date')
	        }
	    });

	    var Range = JXT.define({
	        name: 'range',
	        namespace: FT_NS,
	        element: 'range',
	        fields: {
	            offset: Utils.numberAttribute('offset')
	        }
	    });

	    var Thumbnail = JXT.define({
	        name: 'thumbnail',
	        namespace: _xmppConstants.Namespace.THUMBS_0,
	        element: 'thumbnail',
	        fields: {
	            cid: Utils.attribute('cid'),
	            mimeType: Utils.attribute('mime-type'),
	            width: Utils.numberAttribute('width'),
	            height: Utils.numberAttribute('height')
	        }
	    });

	    var FileTransfer = JXT.define({
	        name: '_filetransfer',
	        namespace: FT_NS,
	        element: 'description',
	        tags: ['jingle-application'],
	        fields: {
	            applicationType: { value: 'filetransfer' },
	            offer: Utils.subExtension('offer', FT_NS, 'offer', File),
	            request: Utils.subExtension('request', FT_NS, 'request', File)
	        }
	    });

	    JXT.extend(File, Range);
	    JXT.extend(File, Thumbnail);

	    JXT.withDefinition('hash', _xmppConstants.Namespace.HASHES_1, function (Hash) {

	        JXT.extend(File, Hash, 'hashes');
	    });

	    JXT.withDefinition('content', _xmppConstants.Namespace.JINGLE_1, function (Content) {

	        JXT.extend(Content, FileTransfer);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=file3.js.map

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Forwarded = JXT.define({
	        name: 'forwarded',
	        namespace: _xmppConstants.Namespace.FORWARD_0,
	        element: 'forwarded'
	    });

	    JXT.extendIQ(Forwarded);
	    JXT.extendPresence(Forwarded);

	    JXT.withMessage(function (Message) {

	        JXT.extend(Message, Forwarded);
	        JXT.extend(Forwarded, Message);
	    });

	    JXT.withDefinition('delay', _xmppConstants.Namespace.DELAY, function (Delayed) {

	        JXT.extend(Forwarded, Delayed);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=forwarded.js.map

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: 'openStream',
	        namespace: _xmppConstants.Namespace.FRAMING,
	        element: 'open',
	        topLevel: true,
	        fields: {
	            lang: Utils.langAttribute(),
	            id: Utils.attribute('id'),
	            version: Utils.attribute('version', '1.0'),
	            to: Utils.jidAttribute('to', true),
	            from: Utils.jidAttribute('from', true)
	        }
	    });

	    JXT.define({
	        name: 'closeStream',
	        namespace: _xmppConstants.Namespace.FRAMING,
	        element: 'close',
	        topLevel: true,
	        fields: {
	            seeOtherURI: Utils.attribute('see-other-uri')
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=framing.js.map

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var GeoLoc = JXT.define({
	        name: 'geoloc',
	        namespace: _xmppConstants.Namespace.GEOLOC,
	        element: 'geoloc',
	        fields: {
	            accuracy: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'accuracy', true),
	            altitude: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'alt', true),
	            area: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'area'),
	            heading: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'bearing', true),
	            bearing: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'bearing', true),
	            building: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'building'),
	            country: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'country'),
	            countrycode: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'countrycode'),
	            datum: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'datum'),
	            description: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'description'),
	            error: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'error', true),
	            floor: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'floor'),
	            latitude: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'lat', true),
	            locality: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'locality'),
	            longitude: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'lon', true),
	            postalcode: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'postalcode'),
	            region: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'region'),
	            room: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'room'),
	            speed: Utils.numberSub(_xmppConstants.Namespace.GEOLOC, 'speed', true),
	            street: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'street'),
	            text: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'text'),
	            timestamp: Utils.dateSub(_xmppConstants.Namespace.GEOLOC, 'timestamp'),
	            tzo: Utils.tzoSub(_xmppConstants.Namespace.GEOLOC, 'tzo'),
	            uri: Utils.textSub(_xmppConstants.Namespace.GEOLOC, 'uri')
	        }
	    });

	    JXT.extendPubsubItem(GeoLoc);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=geoloc.js.map

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    JXT.define({
	        name: 'hash',
	        namespace: _xmppConstants.Namespace.HASHES_1,
	        element: 'hash',
	        fields: {
	            algo: JXT.utils.attribute('algo'),
	            value: JXT.utils.text()
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=hash.js.map

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Hat = JXT.define({
	        name: '_hat',
	        namespace: _xmppConstants.Namespace.HATS_0,
	        element: 'hat',
	        fields: {
	            lang: JXT.utils.langAttribute(),
	            name: JXT.utils.attribute('name'),
	            displayName: JXT.utils.attribute('displayName')
	        }
	    });

	    JXT.withPresence(function (Presence) {

	        JXT.add(Presence, 'hats', JXT.utils.subMultiExtension(_xmppConstants.Namespace.HATS_0, 'hats', Hat));
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=hats.js.map

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var ICE = JXT.define({
	        name: '_iceUdp',
	        namespace: _xmppConstants.Namespace.JINGLE_ICE_UDP_1,
	        element: 'transport',
	        tags: ['jingle-transport'],
	        fields: {
	            transportType: { value: 'iceUdp' },
	            pwd: Utils.attribute('pwd'),
	            ufrag: Utils.attribute('ufrag')
	        }
	    });

	    var RemoteCandidate = JXT.define({
	        name: 'remoteCandidate',
	        namespace: _xmppConstants.Namespace.JINGLE_ICE_UDP_1,
	        element: 'remote-candidate',
	        fields: {
	            component: Utils.attribute('component'),
	            ip: Utils.attribute('ip'),
	            port: Utils.attribute('port')
	        }
	    });

	    var Candidate = JXT.define({
	        name: '_iceUdpCandidate',
	        namespace: _xmppConstants.Namespace.JINGLE_ICE_UDP_1,
	        element: 'candidate',
	        fields: {
	            component: Utils.attribute('component'),
	            foundation: Utils.attribute('foundation'),
	            generation: Utils.attribute('generation'),
	            id: Utils.attribute('id'),
	            ip: Utils.attribute('ip'),
	            network: Utils.attribute('network'),
	            port: Utils.attribute('port'),
	            priority: Utils.attribute('priority'),
	            protocol: Utils.attribute('protocol'),
	            relAddr: Utils.attribute('rel-addr'),
	            relPort: Utils.attribute('rel-port'),
	            tcpType: Utils.attribute('tcptype'),
	            type: Utils.attribute('type')
	        }
	    });

	    var Fingerprint = JXT.define({
	        name: '_iceFingerprint',
	        namespace: _xmppConstants.Namespace.JINGLE_DTLS_0,
	        element: 'fingerprint',
	        fields: {
	            hash: Utils.attribute('hash'),
	            setup: Utils.attribute('setup'),
	            value: Utils.text(),
	            required: Utils.boolAttribute('required')
	        }
	    });

	    var SctpMap = JXT.define({
	        name: '_sctpMap',
	        namespace: _xmppConstants.Namespace.DTLS_SCTP_1,
	        element: 'sctpmap',
	        fields: {
	            number: Utils.attribute('number'),
	            protocol: Utils.attribute('protocol'),
	            streams: Utils.attribute('streams')
	        }
	    });

	    JXT.extend(ICE, Candidate, 'candidates');
	    JXT.extend(ICE, RemoteCandidate);
	    JXT.extend(ICE, Fingerprint, 'fingerprints');
	    JXT.extend(ICE, SctpMap, 'sctp');

	    JXT.withDefinition('content', _xmppConstants.Namespace.JINGLE_1, function (Content) {

	        JXT.extend(Content, ICE);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=iceUdp.js.map

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var NS_IBB = 'http://jabber.org/protocol/ibb';
	var NS_JIBB = 'urn:xmpp:jingle:transports:ibb:1';

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var IBB = {
	        get: function get() {

	            var data = Utils.find(this.xml, NS_IBB, 'data');
	            if (data.length) {
	                data = data[0];
	                return {
	                    action: 'data',
	                    sid: Utils.getAttribute(data, 'sid'),
	                    seq: parseInt(Utils.getAttribute(data, 'seq') || '0', 10),
	                    data: new Buffer(Utils.getText(data), 'base64')
	                };
	            }

	            var open = Utils.find(this.xml, NS_IBB, 'open');
	            if (open.length) {
	                open = open[0];
	                var ack = Utils.getAttribute(open, 'stanza');
	                if (ack === 'message') {
	                    ack = false;
	                } else {
	                    ack = true;
	                }

	                return {
	                    action: 'open',
	                    sid: Utils.getAttribute(open, 'sid'),
	                    blockSize: Utils.getAttribute(open, 'block-size'),
	                    ack: ack
	                };
	            }

	            var close = Utils.find(this.xml, NS_IBB, 'close');
	            if (close.length) {
	                return {
	                    action: 'close',
	                    sid: Utils.getAttribute(close[0], 'sid')
	                };
	            }
	        },
	        set: function set(value) {

	            if (value.action === 'data') {
	                var data = Utils.createElement(NS_IBB, 'data');
	                Utils.setAttribute(data, 'sid', value.sid);
	                Utils.setAttribute(data, 'seq', value.seq.toString());
	                Utils.setText(data, value.data.toString('base64'));
	                this.xml.appendChild(data);
	            }

	            if (value.action === 'open') {
	                var _open = Utils.createElement(NS_IBB, 'open');
	                Utils.setAttribute(_open, 'sid', value.sid);
	                Utils.setAttribute(_open, 'block-size', (value.blockSize || '4096').toString());
	                if (value.ack === false) {
	                    Utils.setAttribute(_open, 'stanza', 'message');
	                } else {
	                    Utils.setAttribute(_open, 'stanza', 'iq');
	                }
	                this.xml.appendChild(_open);
	            }

	            if (value.action === 'close') {
	                var _close = Utils.createElement(NS_IBB, 'close');
	                Utils.setAttribute(_close, 'sid', value.sid);
	                this.xml.appendChild(_close);
	            }
	        }
	    };

	    var JingleIBB = JXT.define({
	        name: '_' + NS_JIBB,
	        namespace: NS_JIBB,
	        element: 'transport',
	        tags: ['jingle-transport'],
	        fields: {
	            transportType: {
	                value: NS_JIBB
	            },
	            sid: Utils.attribute('sid'),
	            blockSize: Utils.numberAttribute('block-size'),
	            ack: {
	                get: function get() {
	                    var value = Utils.getAttribute(this.xml, 'stanza');
	                    if (value === 'message') {
	                        return false;
	                    }
	                    return true;
	                },
	                set: function set(value) {
	                    if (value.ack === false) {
	                        Utils.setAttribute(this.xml, 'stanza', 'message');
	                    } else {
	                        Utils.setAttribute(this.xml, 'stanza', 'iq');
	                    }
	                }
	            }
	        }
	    });

	    JXT.withDefinition('content', _xmppConstants.Namespace.JINGLE_1, function (Content) {

	        JXT.extend(Content, JingleIBB);
	    });

	    JXT.withIQ(function (IQ) {

	        JXT.add(IQ, 'ibb', IBB);
	    });

	    JXT.withMessage(function (Message) {

	        JXT.add(Message, 'ibb', IBB);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=ibb.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$assign = __webpack_require__(351)['default'];

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var internals = {};

	internals.defineIQ = function (JXT, name, namespace) {

	    var Utils = JXT.utils;

	    var IQ = JXT.define({
	        name: name,
	        namespace: namespace,
	        element: 'iq',
	        topLevel: true,
	        fields: {
	            lang: Utils.langAttribute(),
	            id: Utils.attribute('id'),
	            to: Utils.jidAttribute('to', true),
	            from: Utils.jidAttribute('from', true),
	            type: Utils.attribute('type')
	        }
	    });

	    var _toJSON = IQ.prototype.toJSON;

	    _Object$assign(IQ.prototype, {
	        toJSON: function toJSON() {

	            var result = _toJSON.call(this);
	            result.resultReply = this.resultReply;
	            result.errorReply = this.errorReply;
	            return result;
	        },

	        resultReply: function resultReply(data) {

	            data = data || {};
	            data.to = this.from;
	            data.id = this.id;
	            data.type = 'result';
	            return new IQ(data);
	        },

	        errorReply: function errorReply(data) {

	            data = data || {};
	            data.to = this.from;
	            data.id = this.id;
	            data.type = 'error';
	            return new IQ(data);
	        }
	    });
	};

	exports['default'] = function (JXT) {

	    internals.defineIQ(JXT, 'iq', _xmppConstants.Namespace.CLIENT);
	    internals.defineIQ(JXT, 'serverIQ', _xmppConstants.Namespace.SERVER);
	    internals.defineIQ(JXT, 'componentIQ', _xmppConstants.Namespace.COMPONENT);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=iq.js.map

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(352), __esModule: true };

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(353);
	module.exports = __webpack_require__(356).Object.assign;

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(354);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(359)});

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(355)
	  , core      = __webpack_require__(356)
	  , ctx       = __webpack_require__(357)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ },
/* 355 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 356 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(358);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 358 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(213)
	  , toObject = __webpack_require__(360)
	  , IObject  = __webpack_require__(362);

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(364)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(361);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 361 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(363);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 363 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 364 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _xmppJid = __webpack_require__(222);

	exports['default'] = function (JXT) {

	    JXT.withIQ(function (IQ) {

	        JXT.add(IQ, 'jidPrep', {
	            get: function get() {

	                var data = JXT.utils.getSubText(this.xml, _xmppConstants.Namespace.JID_PREP_0, 'jid');
	                if (data) {
	                    var jid = new _xmppJid.JID(data);
	                    jid.prepped = true;
	                    return jid;
	                }
	            },
	            set: function set(value) {

	                JXT.utils.setSubText(this.xml, _xmppConstants.Namespace.JID_PREP_0, 'jid', (value || '').toString());
	            }
	        });
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=jidprep.js.map

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['out-of-order', 'tie-break', 'unknown-session', 'unsupported-info'];
	var REASONS = ['alternative-session', 'busy', 'cancel', 'connectivity-error', 'decline', 'expired', 'failed-application', 'failed-transport', 'general-error', 'gone', 'incompatible-parameters', 'media-error', 'security-error', 'success', 'timeout', 'unsupported-applications', 'unsupported-transports'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Jingle = JXT.define({
	        name: 'jingle',
	        namespace: _xmppConstants.Namespace.JINGLE_1,
	        element: 'jingle',
	        fields: {
	            action: Utils.attribute('action'),
	            initiator: Utils.attribute('initiator'),
	            responder: Utils.attribute('responder'),
	            sid: Utils.attribute('sid'),
	            info: {
	                get: function get() {

	                    var opts = JXT.tagged('jingle-info').map(function (Info) {

	                        return Info.prototype._name;
	                    });
	                    for (var i = 0, len = opts.length; i < len; i++) {
	                        if (this._extensions[opts[i]]) {
	                            return this._extensions[opts[i]];
	                        }
	                    }
	                    if (Utils.getAttribute(this.xml, 'action') === 'session-info') {
	                        if (this.xml.children.length === 0) {
	                            return {
	                                infoType: 'ping'
	                            };
	                        }
	                        return {
	                            infoType: 'unknown'
	                        };
	                    }
	                },
	                set: function set(value) {

	                    if (value.infoType === 'ping') {
	                        return;
	                    }

	                    var ext = '_' + value.infoType;
	                    this[ext] = value;
	                }
	            }
	        }
	    });

	    var Content = JXT.define({
	        name: '_jingleContent',
	        namespace: _xmppConstants.Namespace.JINGLE_1,
	        element: 'content',
	        fields: {
	            creator: Utils.attribute('creator'),
	            disposition: Utils.attribute('disposition', 'session'),
	            name: Utils.attribute('name'),
	            senders: Utils.attribute('senders', 'both'),
	            application: {
	                get: function get() {

	                    var opts = JXT.tagged('jingle-application').map(function (Description) {

	                        return Description.prototype._name;
	                    });
	                    for (var i = 0, len = opts.length; i < len; i++) {
	                        if (this._extensions[opts[i]]) {
	                            return this._extensions[opts[i]];
	                        }
	                    }
	                },
	                set: function set(value) {

	                    var ext = '_' + value.applicationType;
	                    this[ext] = value;
	                }
	            },
	            transport: {
	                get: function get() {

	                    var opts = JXT.tagged('jingle-transport').map(function (Transport) {

	                        return Transport.prototype._name;
	                    });
	                    for (var i = 0, len = opts.length; i < len; i++) {
	                        if (this._extensions[opts[i]]) {
	                            return this._extensions[opts[i]];
	                        }
	                    }
	                },
	                set: function set(value) {

	                    var ext = '_' + value.transportType;
	                    this[ext] = value;
	                }
	            },
	            security: {
	                get: function get() {

	                    var opts = JXT.tagged('jingle-security').map(function (Info) {

	                        return Security.prototype._name;
	                    });
	                    for (var i = 0, len = opts.length; i < len; i++) {
	                        if (this._extensions[opts[i]]) {
	                            return this._extensions[opts[i]];
	                        }
	                    }
	                },
	                set: function set(value) {

	                    var ext = '_' + value.securityType;
	                    this[ext] = value;
	                }
	            }
	        }
	    });

	    var Reason = JXT.define({
	        name: 'reason',
	        namespace: _xmppConstants.Namespace.JINGLE_1,
	        element: 'reason',
	        fields: {
	            condition: Utils.enumSub(_xmppConstants.Namespace.JINGLE_1, REASONS),
	            alternativeSession: {
	                get: function get() {

	                    return Utils.getSubText(this.xml, _xmppConstants.Namespace.JINGLE_1, 'alternative-session');
	                },
	                set: function set(value) {

	                    this.condition = 'alternative-session';
	                    Utils.setSubText(this.xml, _xmppConstants.Namespace.JINGLE_1, 'alternative-session', value);
	                }
	            },
	            text: Utils.textSub(_xmppConstants.Namespace.JINGLE_1, 'text')
	        }
	    });

	    JXT.extend(Jingle, Content, 'contents');
	    JXT.extend(Jingle, Reason);

	    JXT.extendIQ(Jingle);

	    JXT.withStanzaError(function (StanzaError) {

	        JXT.add(StanzaError, 'jingleCondition', Utils.enumSub(_xmppConstants.Namespace.JINGLE_ERRORS_1, CONDITIONS));
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=jingle.js.map

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var JSONExtension = {
	        get: function get() {

	            var data = JXT.utils.getSubText(this.xml, _xmppConstants.Namespace.JSON_0, 'json');
	            if (data) {
	                return JSON.parse(data);
	            }
	        },
	        set: function set(value) {

	            value = JSON.stringify(value);
	            if (value) {
	                JXT.utils.setSubText(this.xml, _xmppConstants.Namespace.JSON_0, 'json', value);
	            }
	        }
	    };

	    JXT.withMessage(function (Message) {

	        JXT.add(Message, 'json', JSONExtension);
	    });

	    JXT.withPubsubItem(function (Item) {

	        JXT.add(Item, 'json', JSONExtension);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=json.js.map

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Log = JXT.define({
	        name: 'log',
	        namespace: _xmppConstants.Namespace.EVENTLOG,
	        element: 'log',
	        fields: {
	            id: Utils.attribute('id'),
	            timestamp: Utils.dateAttribute('timestamp'),
	            type: Utils.attribute('type'),
	            level: Utils.attribute('level'),
	            object: Utils.attribute('object'),
	            subject: Utils.attribute('subject'),
	            facility: Utils.attribute('facility'),
	            module: Utils.attribute('module'),
	            message: Utils.textSub(_xmppConstants.Namespace.EVENTLOG, 'message'),
	            stackTrace: Utils.textSub(_xmppConstants.Namespace.EVENTLOG, 'stackTrace')
	        }
	    });

	    var Tag = JXT.define({
	        name: '_logtag',
	        namespace: _xmppConstants.Namespace.EVENTLOG,
	        element: 'tag',
	        fields: {
	            name: Utils.attribute('name'),
	            value: Utils.attribute('value'),
	            type: Utils.attribute('type')
	        }
	    });

	    JXT.extend(Log, Tag, 'tags');

	    JXT.extendMessage(Log);
	    JXT.extendPubsubItem(Log);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=logging.js.map

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _xmppJid = __webpack_require__(222);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var MAMQuery = JXT.define({
	        name: 'mam',
	        namespace: _xmppConstants.Namespace.MAM_0,
	        element: 'query',
	        fields: {
	            queryid: Utils.attribute('queryid')
	        }
	    });

	    var Result = JXT.define({
	        name: 'mamItem',
	        namespace: _xmppConstants.Namespace.MAM_0,
	        element: 'result',
	        fields: {
	            queryid: Utils.attribute('queryid'),
	            id: Utils.attribute('id')
	        }
	    });

	    var Fin = JXT.define({
	        name: 'mamResult',
	        namespace: _xmppConstants.Namespace.MAM_0,
	        element: 'fin',
	        fields: {
	            queryid: Utils.attribute('queryid'),
	            complete: Utils.boolAttribute('complete'),
	            stable: Utils.boolAttribute('stable')
	        }
	    });

	    var Prefs = JXT.define({
	        name: 'mamPrefs',
	        namespace: _xmppConstants.Namespace.MAM_0,
	        element: 'prefs',
	        fields: {
	            defaultCondition: Utils.attribute('default'),
	            always: {
	                get: function get() {

	                    var results = [];
	                    var container = Utils.find(this.xml, _xmppConstants.Namespace.MAM_0, 'always');
	                    if (container.length === 0) {
	                        return results;
	                    }
	                    container = container[0];
	                    var jids = Utils.getMultiSubText(container, _xmppConstants.Namespace.MAM_0, 'jid');
	                    jids.forEach(function (jid) {

	                        results.push(new _xmppJid.JID(jid.textContent));
	                    });
	                    return results;
	                },
	                set: function set(value) {

	                    if (value.length > 0) {
	                        var container = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.MAM_0, 'always');
	                        Utils.setMultiSubText(container, _xmppConstants.Namespace.MAM_0, 'jid', value);
	                    }
	                }
	            },
	            never: {
	                get: function get() {

	                    var results = [];
	                    var container = Utils.find(this.xml, _xmppConstants.Namespace.MAM_0, 'always');
	                    if (container.length === 0) {
	                        return results;
	                    }
	                    container = container[0];
	                    var jids = Utils.getMultiSubText(container, _xmppConstants.Namespace.MAM_0, 'jid');
	                    jids.forEach(function (jid) {

	                        results.push(new _xmppJid.JID(jid.textContent));
	                    });
	                    return results;
	                },
	                set: function set(value) {

	                    if (value.length > 0) {
	                        var container = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.MAM_0, 'never');
	                        Utils.setMultiSubText(container, _xmppConstants.Namespace.MAM_0, 'jid', value);
	                    }
	                }
	            }
	        }
	    });

	    JXT.extendMessage(Result);
	    JXT.extendMessage(Fin);

	    JXT.extendIQ(MAMQuery);
	    JXT.extendIQ(Prefs);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(MAMQuery, DataForm);
	    });

	    JXT.withDefinition('forwarded', _xmppConstants.Namespace.FORWARD_0, function (Forwarded) {

	        JXT.extend(Result, Forwarded);
	    });

	    JXT.withDefinition('set', _xmppConstants.Namespace.RSM, function (RSM) {

	        JXT.extend(MAMQuery, RSM);
	        JXT.extend(Fin, RSM);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=mam.js.map

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var internals = {};

	internals.defineMessage = function (JXT, name, namespace) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: name,
	        namespace: namespace,
	        element: 'message',
	        topLevel: true,
	        fields: {
	            lang: Utils.langAttribute(),
	            id: Utils.attribute('id'),
	            to: Utils.jidAttribute('to', true),
	            from: Utils.jidAttribute('from', true),
	            type: Utils.attribute('type', 'normal'),
	            thread: Utils.textSub(namespace, 'thread'),
	            parentThread: Utils.subAttribute(namespace, 'thread', 'parent'),
	            subject: Utils.textSub(namespace, 'subject'),
	            $body: {
	                get: function getBody$() {

	                    return Utils.getSubLangText(this.xml, namespace, 'body', this.lang);
	                }
	            },
	            body: {
	                get: function getBody() {

	                    var bodies = this.$body;
	                    return bodies[this.lang] || '';
	                },
	                set: function setBody(value) {

	                    Utils.setSubLangText(this.xml, namespace, 'body', value, this.lang);
	                }
	            },
	            attention: Utils.boolSub(_xmppConstants.Namespace.ATTENTION_0, 'attention'),
	            chatState: Utils.enumSub(_xmppConstants.Namespace.CHAT_STATES, ['active', 'composing', 'paused', 'inactive', 'gone']),
	            replace: Utils.subAttribute(_xmppConstants.Namespace.CORRECTION_0, 'replace', 'id'),
	            requestReceipt: Utils.boolSub(_xmppConstants.Namespace.RECEIPTS, 'request'),
	            receipt: Utils.subAttribute(_xmppConstants.Namespace.RECEIPTS, 'received', 'id')
	        }
	    });
	};

	exports['default'] = function (JXT) {

	    internals.defineMessage(JXT, 'message', _xmppConstants.Namespace.CLIENT);
	    internals.defineMessage(JXT, 'serverMessage', _xmppConstants.Namespace.SERVER);
	    internals.defineMessage(JXT, 'componentMessage', _xmppConstants.Namespace.COMPONENT);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=message.js.map

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var MOODS = ['afraid', 'amazed', 'amorous', 'angry', 'annoyed', 'anxious', 'aroused', 'ashamed', 'bored', 'brave', 'calm', 'cautious', 'cold', 'confident', 'confused', 'contemplative', 'contented', 'cranky', 'crazy', 'creative', 'curious', 'dejected', 'depressed', 'disappointed', 'disgusted', 'dismayed', 'distracted', 'embarrassed', 'envious', 'excited', 'flirtatious', 'frustrated', 'grateful', 'grieving', 'grumpy', 'guilty', 'happy', 'hopeful', 'hot', 'humbled', 'humiliated', 'hungry', 'hurt', 'impressed', 'in_awe', 'in_love', 'indignant', 'interested', 'intoxicated', 'invincible', 'jealous', 'lonely', 'lucky', 'mean', 'moody', 'nervous', 'neutral', 'offended', 'outraged', 'playful', 'proud', 'relaxed', 'relieved', 'remorseful', 'restless', 'sad', 'sarcastic', 'serious', 'shocked', 'shy', 'sick', 'sleepy', 'spontaneous', 'stressed', 'strong', 'surprised', 'thankful', 'thirsty', 'tired', 'undefined', 'weak', 'worried'];

	exports['default'] = function (JXT) {

	    var Mood = JXT.define({
	        name: 'mood',
	        namespace: _xmppConstants.Namespace.MOOD,
	        element: 'mood',
	        fields: {
	            text: JXT.utils.textSub(_xmppConstants.Namespace.MOOD, 'text'),
	            value: JXT.utils.enumSub(_xmppConstants.Namespace.MOOD, MOODS)
	        }
	    });

	    JXT.extendMessage(Mood);
	    JXT.extendPubsubItem(Mood);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=mood.js.map

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	function proxy(child, field) {

	    return {
	        get: function get() {

	            if (this._extensions[child]) {
	                return this[child][field];
	            }
	        },
	        set: function set(value) {

	            this[child][field] = value;
	        }
	    };
	}

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var UserItem = JXT.define({
	        name: '_mucUserItem',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'item',
	        fields: {
	            affiliation: Utils.attribute('affiliation'),
	            nick: Utils.attribute('nick'),
	            jid: Utils.jidAttribute('jid'),
	            role: Utils.attribute('role'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_USER, 'reason')
	        }
	    });

	    var UserActor = JXT.define({
	        name: '_mucUserActor',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'actor',
	        fields: {
	            nick: Utils.attribute('nick'),
	            jid: Utils.jidAttribute('jid')
	        }
	    });

	    var Destroyed = JXT.define({
	        name: 'destroyed',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'destroy',
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_USER, 'reason')
	        }
	    });

	    var Invite = JXT.define({
	        name: 'invite',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'invite',
	        fields: {
	            to: Utils.jidAttribute('to'),
	            from: Utils.jidAttribute('from'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_USER, 'reason'),
	            thread: Utils.subAttribute(_xmppConstants.Namespace.MUC_USER, 'continue', 'thread'),
	            'continue': Utils.boolSub(_xmppConstants.Namespace.MUC_USER, 'continue')
	        }
	    });

	    var Decline = JXT.define({
	        name: 'decline',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'decline',
	        fields: {
	            to: Utils.jidAttribute('to'),
	            from: Utils.jidAttribute('from'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_USER, 'reason')
	        }
	    });

	    var AdminItem = JXT.define({
	        name: '_mucAdminItem',
	        namespace: _xmppConstants.Namespace.MUC_ADMIN,
	        element: 'item',
	        fields: {
	            affiliation: Utils.attribute('affiliation'),
	            nick: Utils.attribute('nick'),
	            jid: Utils.jidAttribute('jid'),
	            role: Utils.attribute('role'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_ADMIN, 'reason')
	        }
	    });

	    var AdminActor = JXT.define({
	        name: 'actor',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'actor',
	        fields: {
	            nick: Utils.attribute('nick'),
	            jid: Utils.jidAttribute('jid')
	        }
	    });

	    var Destroy = JXT.define({
	        name: 'destroy',
	        namespace: _xmppConstants.Namespace.MUC_OWNER,
	        element: 'destroy',
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            password: Utils.textSub(_xmppConstants.Namespace.MUC_OWNER, 'password'),
	            reason: Utils.textSub(_xmppConstants.Namespace.MUC_OWNER, 'reason')
	        }
	    });

	    var MUC = JXT.define({
	        name: 'muc',
	        namespace: _xmppConstants.Namespace.MUC_USER,
	        element: 'x',
	        fields: {
	            affiliation: proxy('_mucUserItem', 'affiliation'),
	            nick: proxy('_mucUserItem', 'nick'),
	            jid: proxy('_mucUserItem', 'jid'),
	            role: proxy('_mucUserItem', 'role'),
	            actor: proxy('_mucUserItem', '_mucUserActor'),
	            reason: proxy('_mucUserItem', 'reason'),
	            password: Utils.textSub(_xmppConstants.Namespace.MUC_USER, 'password'),
	            codes: {
	                get: function get() {

	                    return Utils.getMultiSubText(this.xml, _xmppConstants.Namespace.MUC_USER, 'status', function (sub) {

	                        return Utils.getAttribute(sub, 'code');
	                    });
	                },
	                set: function set(value) {

	                    var self = this;
	                    Utils.setMultiSubText(this.xml, _xmppConstants.Namespace.MUC_USER, 'status', value, function (val) {

	                        var child = Utils.createElement(_xmppConstants.Namespace.MUC_USER, 'status', _xmppConstants.Namespace.MUC_USER);
	                        Utils.setAttribute(child, 'code', val);
	                        self.xml.appendChild(child);
	                    });
	                }
	            }
	        }
	    });

	    var MUCAdmin = JXT.define({
	        name: 'mucAdmin',
	        namespace: _xmppConstants.Namespace.MUC_ADMIN,
	        element: 'query',
	        fields: {
	            affiliation: proxy('_mucAdminItem', 'affiliation'),
	            nick: proxy('_mucAdminItem', 'nick'),
	            jid: proxy('_mucAdminItem', 'jid'),
	            role: proxy('_mucAdminItem', 'role'),
	            actor: proxy('_mucAdminItem', '_mucAdminActor'),
	            reason: proxy('_mucAdminItem', 'reason')
	        }
	    });

	    var MUCOwner = JXT.define({
	        name: 'mucOwner',
	        namespace: _xmppConstants.Namespace.MUC_OWNER,
	        element: 'query'
	    });

	    var MUCJoin = JXT.define({
	        name: 'joinMuc',
	        namespace: _xmppConstants.Namespace.MUC,
	        element: 'x',
	        fields: {
	            password: Utils.textSub(_xmppConstants.Namespace.MUC, 'password'),
	            history: {
	                get: function get() {

	                    var result = {};
	                    var hist = Utils.find(this.xml, _xmppConstants.Namespace.MUC, 'history');

	                    if (!hist.length) {
	                        return {};
	                    }
	                    hist = hist[0];

	                    var maxchars = hist.getAttribute('maxchars') || '';
	                    var maxstanzas = hist.getAttribute('maxstanzas') || '';
	                    var seconds = hist.getAttribute('seconds') || '';
	                    var since = hist.getAttribute('since') || '';

	                    if (maxchars) {
	                        result.maxchars = parseInt(maxchars, 10);
	                    }
	                    if (maxstanzas) {
	                        result.maxstanzas = parseInt(maxstanzas, 10);
	                    }
	                    if (seconds) {
	                        result.seconds = parseInt(seconds, 10);
	                    }
	                    if (since) {
	                        result.since = new Date(since);
	                    }
	                },
	                set: function set(opts) {

	                    var existing = Utils.find(this.xml, _xmppConstants.Namespace.MUC, 'history');
	                    if (existing.length) {
	                        for (var i = 0; i < existing.length; i++) {
	                            this.xml.removeChild(existing[i]);
	                        }
	                    }

	                    var hist = Utils.createElement(_xmppConstants.Namespace.MUC, 'history', _xmppConstants.Namespace.MUC);
	                    this.xml.appendChild(hist);

	                    if (opts.maxchars) {
	                        hist.setAttribute('maxchars', '' + opts.maxchars);
	                    }
	                    if (opts.maxstanzas) {
	                        hist.setAttribute('maxstanzas', '' + opts.maxstanzas);
	                    }
	                    if (opts.seconds) {
	                        hist.setAttribute('seconds', '' + opts.seconds);
	                    }
	                    if (opts.since) {
	                        hist.setAttribute('since', opts.since.toISOString());
	                    }
	                }
	            }
	        }
	    });

	    var DirectInvite = JXT.define({
	        name: 'mucInvite',
	        namespace: _xmppConstants.Namespace.MUC_DIRECT_INVITE,
	        element: 'x',
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            password: Utils.attribute('password'),
	            reason: Utils.attribute('reason'),
	            thread: Utils.attribute('thread'),
	            'continue': Utils.boolAttribute('continue')
	        }
	    });

	    JXT.extend(UserItem, UserActor);
	    JXT.extend(MUC, UserItem);
	    JXT.extend(MUC, Invite, 'invites');
	    JXT.extend(MUC, Decline);
	    JXT.extend(MUC, Destroyed);
	    JXT.extend(AdminItem, AdminActor);
	    JXT.extend(MUCAdmin, AdminItem, 'items');
	    JXT.extend(MUCOwner, Destroy);

	    JXT.extendPresence(MUC);
	    JXT.extendPresence(MUCJoin);

	    JXT.extendMessage(MUC);
	    JXT.extendMessage(DirectInvite);

	    JXT.withIQ(function (IQ) {

	        JXT.add(IQ, 'mucUnique', Utils.textSub(_xmppConstants.Namespace.MUC_UNIQUE, 'unique'));
	        JXT.extend(IQ, MUCAdmin);
	        JXT.extend(IQ, MUCOwner);
	    });

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(MUCOwner, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=muc.js.map

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var nick = JXT.utils.textSub(_xmppConstants.Namespace.NICK, 'nick');

	    JXT.withPubsubItem(function (Item) {

	        JXT.add(Item, 'nick', nick);
	    });

	    JXT.withPresence(function (Presence) {

	        JXT.add(Presence, 'nick', nick);
	    });

	    JXT.withMessage(function (Message) {

	        JXT.add(Message, 'nick', nick);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=nick.js.map

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var OOB = JXT.define({
	        name: 'oob',
	        element: 'x',
	        namespace: _xmppConstants.Namespace.OOB,
	        fields: {
	            url: JXT.utils.textSub(_xmppConstants.Namespace.OOB, 'url'),
	            desc: JXT.utils.textSub(_xmppConstants.Namespace.OOB, 'desc')
	        }
	    });

	    JXT.extendMessage(OOB, 'oobURIs');
	};

	module.exports = exports['default'];
	//# sourceMappingURL=oob.js.map

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Ping = JXT.define({
	        name: 'ping',
	        namespace: _xmppConstants.Namespace.PING,
	        element: 'ping'
	    });

	    JXT.extendIQ(Ping);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=ping.js.map

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var internals = {};

	internals.definePresence = function (JXT, name, namespace) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: name,
	        namespace: namespace,
	        element: 'presence',
	        topLevel: true,
	        fields: {
	            lang: Utils.langAttribute(),
	            id: Utils.attribute('id'),
	            to: Utils.jidAttribute('to', true),
	            from: Utils.jidAttribute('from', true),
	            priority: Utils.numberSub(namespace, 'priority', false, 0),
	            show: Utils.textSub(namespace, 'show'),
	            type: {
	                get: function get() {

	                    return Utils.getAttribute(this.xml, 'type', 'available');
	                },
	                set: function set(value) {

	                    if (value === 'available') {
	                        value = false;
	                    }
	                    Utils.setAttribute(this.xml, 'type', value);
	                }
	            },
	            $status: {
	                get: function get() {

	                    return Utils.getSubLangText(this.xml, namespace, 'status', this.lang);
	                }
	            },
	            status: {
	                get: function get() {

	                    var statuses = this.$status;
	                    return statuses[this.lang] || '';
	                },
	                set: function set(value) {

	                    Utils.setSubLangText(this.xml, namespace, 'status', value, this.lang);
	                }
	            },
	            idleSince: Utils.dateSubAttribute(_xmppConstants.Namespace.IDLE_1, 'idle', 'since'),
	            decloak: Utils.subAttribute(_xmppConstants.Namespace.DECLOAK_0, 'decloak', 'reason'),
	            avatarId: {
	                get: function get() {

	                    var update = Utils.find(this.xml, _xmppConstants.Namespace.VCARD_TEMP_UPDATE, 'x');
	                    if (!update.length) {
	                        return '';
	                    }
	                    return Utils.getSubText(update[0], _xmppConstants.Namespace.VCARD_TEMP_UPDATE, 'photo');
	                },
	                set: function set(value) {

	                    var update = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.VCARD_TEMP_UPDATE, 'x');

	                    if (value === '') {
	                        Utils.setBoolSub(update, _xmppConstants.Namespace.VCARD_TEMP_UPDATE, 'photo', true);
	                    } else if (value === true) {
	                        return;
	                    } else if (value) {
	                        Utils.setSubText(update, _xmppConstants.Namespace.VCARD_TEMP_UPDATE, 'photo', value);
	                    } else {
	                        this.xml.removeChild(update);
	                    }
	                }
	            }
	        }
	    });
	};

	exports['default'] = function (JXT) {

	    internals.definePresence(JXT, 'presence', _xmppConstants.Namespace.CLIENT);
	    internals.definePresence(JXT, 'serverPresence', _xmppConstants.Namespace.SERVER);
	    internals.definePresence(JXT, 'componentPresence', _xmppConstants.Namespace.COMPONENT);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=presence.js.map

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var PrivateStorage = JXT.define({
	        name: 'privateStorage',
	        namespace: _xmppConstants.Namespace.PRIVATE,
	        element: 'query'
	    });

	    JXT.extendIQ(PrivateStorage);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=private.js.map

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['server-unavailable', 'connection-paused'];

	exports['default'] = function (JXT) {

	    var PSA = JXT.define({
	        name: 'state',
	        namespace: _xmppConstants.Namespace.PSA,
	        element: 'state-annotation',
	        fields: {
	            from: JXT.utils.jidAttribute('from'),
	            condition: JXT.utils.enumSub(_xmppConstants.Namespace.PSA, CONDITIONS),
	            description: JXT.utils.textSub(_xmppConstants.Namespace.PSA, 'description')
	        }
	    });

	    JXT.extendPresence(PSA);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=psa.js.map

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Pubsub = JXT.define({
	        name: 'pubsub',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'pubsub',
	        fields: {
	            create: {
	                get: function get() {
	                    var node = Utils.getSubAttribute(this.xml, _xmppConstants.Namespace.PUBSUB, 'create', 'node');
	                    if (node) {
	                        return node;
	                    }
	                    return Utils.getBoolSub(this.xml, _xmppConstants.Namespace.PUBSUB, 'create');
	                },
	                set: function set(value) {
	                    if (value === true || !value) {
	                        Utils.setBoolSub(this.xml, _xmppConstants.Namespace.PUBSUB, 'create', value);
	                    } else {
	                        Utils.setSubAttribute(this.xml, _xmppConstants.Namespace.PUBSUB, 'create', 'node', value);
	                    }
	                }
	            },
	            publishOptions: {
	                get: function get() {

	                    var DataForm = JXT.getDefinition('x', _xmppConstants.Namespace.DATAFORM);
	                    var conf = Utils.find(this.xml, _xmppConstants.Namespace.PUBSUB, 'publish-options');
	                    if (conf.length && conf[0].childNodes.length) {
	                        return new DataForm({}, conf[0].childNodes[0]);
	                    }
	                },
	                set: function set(value) {

	                    var DataForm = JXT.getDefinition('x', _xmppConstants.Namespace.DATAFORM);
	                    var conf = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.PUBSUB, 'publish-options');
	                    if (value) {
	                        var form = new DataForm(value);
	                        conf.appendChild(form.xml);
	                    }
	                }
	            }
	        }
	    });

	    var Configure = JXT.define({
	        name: 'config',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'configure'
	    });

	    var Subscribe = JXT.define({
	        name: 'subscribe',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'subscribe',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid')
	        }
	    });

	    var Subscription = JXT.define({
	        name: 'subscription',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'subscription',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid'),
	            subid: Utils.attribute('subid'),
	            type: Utils.attribute('subscription'),
	            configurable: Utils.boolSub('subscribe-options'),
	            configurationRequired: {
	                get: function get() {

	                    var options = Utils.find(this.xml, _xmppConstants.Namespace.PUBSUB, 'subscribe-options');
	                    if (options.length) {
	                        return Utils.getBoolSub(options[0], _xmppConstants.Namespace.PUBSUB, 'required');
	                    }
	                    return false;
	                }
	            }
	        }
	    });

	    var Subscriptions = JXT.define({
	        name: 'subscriptions',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'subscriptions',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid')
	        }
	    });

	    var Affiliation = JXT.define({
	        name: 'affiliation',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'affiliation',
	        fields: {
	            node: Utils.attribute('node'),
	            type: Utils.attribute('affiliation')
	        }
	    });

	    var Affiliations = JXT.define({
	        name: 'affiliations',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'affiliations',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var SubscriptionOptions = JXT.define({
	        name: 'subscriptionOptions',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'options',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid'),
	            subid: Utils.attribute('subid')
	        }
	    });

	    var Unsubscribe = JXT.define({
	        name: 'unsubscribe',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'unsubscribe',
	        fields: {
	            node: Utils.attribute('node'),
	            subid: Utils.attribute('subid'),
	            jid: Utils.jidAttribute('jid')
	        }
	    });

	    var Publish = JXT.define({
	        name: 'publish',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'publish',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var Retract = JXT.define({
	        name: 'retract',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'retract',
	        fields: {
	            node: Utils.attribute('node'),
	            notify: Utils.boolAttribute('notify'),
	            id: Utils.subAttribute(_xmppConstants.Namespace.PUBSUB, 'item', 'id')
	        }
	    });

	    var Retrieve = JXT.define({
	        name: 'retrieve',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'items',
	        fields: {
	            node: Utils.attribute('node'),
	            max: Utils.attribute('max_items')
	        }
	    });

	    var Item = JXT.define({
	        name: 'item',
	        namespace: _xmppConstants.Namespace.PUBSUB,
	        element: 'item',
	        fields: {
	            id: Utils.attribute('id')
	        }
	    });

	    JXT.extend(Pubsub, Configure);
	    JXT.extend(Pubsub, Subscribe);
	    JXT.extend(Pubsub, Unsubscribe);
	    JXT.extend(Pubsub, Publish);
	    JXT.extend(Pubsub, Retract);
	    JXT.extend(Pubsub, Retrieve);
	    JXT.extend(Pubsub, Subscription);
	    JXT.extend(Pubsub, SubscriptionOptions);
	    JXT.extend(Pubsub, Subscriptions);
	    JXT.extend(Pubsub, Affiliations);

	    JXT.extend(Publish, Item, 'items');
	    JXT.extend(Retrieve, Item, 'items');

	    JXT.extend(Subscriptions, Subscription, 'list');
	    JXT.extend(Affiliations, Affiliation, 'list');

	    JXT.extendIQ(Pubsub);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(SubscriptionOptions, DataForm);
	        JXT.extend(Item, DataForm);
	        JXT.extend(Configure, DataForm);
	    });

	    JXT.withDefinition('set', _xmppConstants.Namespace.RSM, function (RSM) {

	        JXT.extend(Pubsub, RSM);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=pubsub.js.map

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['closed-node', 'configuration-required', 'invalid-jid', 'invalid-options', 'invalid-payload', 'invalid-subid', 'item-forbidden', 'item-required', 'jid-required', 'max-items-exceeded', 'max-nodes-exceeded', 'nodeid-required', 'not-in-roster-group', 'not-subscribed', 'payload-too-big', 'payload-required', 'pending-subscription', 'presence-subscription-required', 'subid-required', 'too-many-subscriptions', 'unsupported', 'unsupported-access-model'];

	exports['default'] = function (JXT) {

	    JXT.withStanzaError(function (StanzaError) {

	        JXT.add(StanzaError, 'pubsubCondition', JXT.utils.enumSub(_xmppConstants.Namespace.PUBSUB_ERRORS, CONDITIONS));
	        JXT.add(StanzaError, 'pubsubUnsupportedFeature', {
	            get: function get() {
	                return JXT.utils.getSubAttribute(this.xml, _xmppConstants.Namespace.PUBSUB_ERRORS, 'unsupported', 'feature');
	            },
	            set: function set(value) {
	                if (value) {
	                    this.pubsubCondition = 'unsupported';
	                }
	                JXT.utils.setSubAttribute(this.xml, _xmppConstants.Namespace.PUBSUB_ERRORS, 'unsupported', 'feature', value);
	            }
	        });
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=pubsubError.js.map

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Event = JXT.define({
	        name: 'event',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'event'
	    });

	    var EventPurge = JXT.define({
	        name: 'purged',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'purge',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var EventDelete = JXT.define({
	        name: 'deleted',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'delete',
	        fields: {
	            node: Utils.attribute('node'),
	            redirect: Utils.subAttribute(_xmppConstants.Namespace.PUBSUB_EVENT, 'redirect', 'uri')
	        }
	    });

	    var EventSubscription = JXT.define({
	        name: 'subscriptionChanged',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'subscription',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid'),
	            type: Utils.attribute('subscription'),
	            subid: Utils.attribute('subid'),
	            expiry: {
	                get: function get() {

	                    var text = Utils.getAttribute(this.xml, 'expiry');
	                    if (text === 'presence') {
	                        return text;
	                    } else if (text) {
	                        return new Date(text);
	                    }
	                },
	                set: function set(value) {

	                    if (!value) {
	                        return;
	                    }

	                    if (typeof value !== 'string') {
	                        value = value.toISOString();
	                    }

	                    Utils.setAttribute(this.xml, 'expiry', value);
	                }
	            }
	        }
	    });

	    var EventConfiguration = JXT.define({
	        name: 'configurationChanged',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'configuration',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var EventItems = JXT.define({
	        name: 'updated',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'items',
	        fields: {
	            node: Utils.attribute('node'),
	            retracted: {
	                get: function get() {

	                    var results = [];
	                    var retracted = Utils.find(this.xml, _xmppConstants.Namespace.PUBSUB_EVENT, 'retract');

	                    retracted.forEach(function (xml) {

	                        results.push(xml.getAttribute('id'));
	                    });
	                    return results;
	                },
	                set: function set(value) {

	                    var self = this;
	                    value.forEach(function (id) {

	                        var retracted = Utils.createElement(_xmppConstants.Namespace.PUBSUB_EVENT, 'retract', _xmppConstants.Namespace.PUBSUB_EVENT);
	                        retracted.setAttribute('id', id);
	                        this.xml.appendChild(retracted);
	                    });
	                }
	            }
	        }
	    });

	    var EventItem = JXT.define({
	        name: '_eventItem',
	        namespace: _xmppConstants.Namespace.PUBSUB_EVENT,
	        element: 'item',
	        fields: {
	            id: Utils.attribute('id'),
	            node: Utils.attribute('node'),
	            publisher: Utils.jidAttribute('publisher')
	        }
	    });

	    JXT.extend(EventItems, EventItem, 'published');

	    JXT.extend(Event, EventItems);
	    JXT.extend(Event, EventSubscription);
	    JXT.extend(Event, EventConfiguration);
	    JXT.extend(Event, EventDelete);
	    JXT.extend(Event, EventPurge);

	    JXT.extendMessage(Event);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(EventConfiguration, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=pubsubEvents.js.map

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var PubsubOwner = JXT.define({
	        name: 'pubsubOwner',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'pubsub',
	        fields: {
	            purge: Utils.subAttribute(_xmppConstants.Namespace.PUBSUB_OWNER, 'purge', 'node'),
	            del: Utils.subAttribute(_xmppConstants.Namespace.PUBSUB_OWNER, 'delete', 'node'),
	            redirect: {
	                get: function get() {

	                    var del = Utils.find(this.xml, _xmppConstants.Namespace.PUBSUB_OWNER, 'delete');
	                    if (del.length) {
	                        return Utils.getSubAttribute(del[0], _xmppConstants.Namespace.PUBSUB_OWNER, 'redirect', 'uri');
	                    }
	                    return '';
	                },
	                set: function set(value) {

	                    var del = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.PUBSUB_OWNER, 'delete');
	                    Utils.setSubAttribute(del, _xmppConstants.Namespace.PUBSUB_OWNER, 'redirect', 'uri', value);
	                }
	            }
	        }
	    });

	    var Subscription = JXT.define({
	        name: 'subscription',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'subscription',
	        fields: {
	            node: Utils.attribute('node'),
	            jid: Utils.jidAttribute('jid'),
	            subid: Utils.attribute('subid'),
	            type: Utils.attribute('subscription'),
	            configurable: Utils.boolSub('subscribe-options'),
	            configurationRequired: {
	                get: function get() {

	                    var options = Utils.find(this.xml, _xmppConstants.Namespace.PUBSUB_OWNER, 'subscribe-options');
	                    if (options.length) {
	                        return Utils.getBoolSub(options[0], _xmppConstants.Namespace.PUBSUB_OWNER, 'required');
	                    }
	                    return false;
	                }
	            }
	        }
	    });

	    var Subscriptions = JXT.define({
	        name: 'subscriptions',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'subscriptions',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var Affiliation = JXT.define({
	        name: 'affiliation',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'affiliation',
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            type: Utils.attribute('affiliation')
	        }
	    });

	    var Affiliations = JXT.define({
	        name: 'affiliations',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'affiliations',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    var Configure = JXT.define({
	        name: 'config',
	        namespace: _xmppConstants.Namespace.PUBSUB_OWNER,
	        element: 'configure',
	        fields: {
	            node: Utils.attribute('node')
	        }
	    });

	    JXT.extend(PubsubOwner, Configure);
	    JXT.extend(PubsubOwner, Subscriptions);
	    JXT.extend(PubsubOwner, Affiliations);

	    JXT.extend(Subscriptions, Subscription, 'list');
	    JXT.extend(Affiliations, Affiliation, 'list');

	    JXT.extendIQ(PubsubOwner);

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(Configure, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=pubsubOwner.js.map

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Enable = JXT.define({
	        name: 'enablePush',
	        element: 'enable',
	        namespace: _xmppConstants.Namespace.PUSH_0,
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            node: Utils.attribute('node')
	        }
	    });

	    var Disable = JXT.define({
	        name: 'disablePush',
	        element: 'disable',
	        namespace: _xmppConstants.Namespace.PUSH_0,
	        fields: {
	            jid: Utils.jidAttribute('jid'),
	            node: Utils.attribute('node')
	        }
	    });

	    var Notification = JXT.define({
	        name: 'pushNotification',
	        element: 'notification',
	        namespace: _xmppConstants.Namespace.PUSH_0
	    });

	    JXT.withDataForm(function (DataForm) {
	        JXT.extend(Notification, DataForm);
	        JXT.extend(Enable, DataForm);
	    });

	    JXT.extendIQ(Enable);
	    JXT.extendIQ(Disable);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=push.js.map

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(326)['default'];

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var _lodashForeach = __webpack_require__(226);

	var _lodashForeach2 = _interopRequireDefault(_lodashForeach);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var ReachURI = JXT.define({
	        name: '_reachAddr',
	        namespace: _xmppConstants.Namespace.REACH_0,
	        element: 'addr',
	        fields: {
	            uri: Utils.attribute('uri'),
	            $desc: {
	                get: function get() {

	                    return Utils.getSubLangText(this.xml, _xmppConstants.Namespace.REACH_0, 'desc', this.lang);
	                }
	            },
	            desc: {
	                get: function get() {

	                    var descs = this.$desc;
	                    return descs[this.lang] || '';
	                },
	                set: function set(value) {

	                    Utils.setSubLangText(this.xml, _xmppConstants.Namespace.REACH_0, 'desc', value, this.lang);
	                }
	            }
	        }
	    });

	    var reachability = {
	        get: function get() {

	            var reach = Utils.find(this.xml, _xmppConstants.Namespace.REACH_0, 'reach');
	            var results = [];
	            if (reach.length) {
	                var addrs = Utils.find(reach[0], _xmppConstants.Namespace.REACH_0, 'addr');
	                (0, _lodashForeach2['default'])(addrs, function (addr) {

	                    results.push(new ReachURI({}, addr));
	                });
	            }
	            return results;
	        },
	        set: function set(value) {

	            var reach = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.REACH_0, 'reach');
	            Utils.setAttribute(reach, 'xmlns', _xmppConstants.Namespace.REACH_0);
	            (0, _lodashForeach2['default'])(value, function (info) {

	                var addr = new ReachURI(info);
	                reach.appendChild(addr.xml);
	            });
	        }
	    };

	    JXT.withPubsubItem(function (Item) {

	        JXT.add(Item, 'reach', reachability);
	    });

	    JXT.withPresence(function (Presence) {

	        JXT.add(Presence, 'reach', reachability);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=reach.js.map

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Register = JXT.define({
	        name: 'register',
	        namespace: _xmppConstants.Namespace.REGISTER,
	        element: 'query',
	        fields: {
	            instructions: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'instructions'),
	            registered: Utils.boolSub(_xmppConstants.Namespace.REGISTER, 'registered'),
	            remove: Utils.boolSub(_xmppConstants.Namespace.REGISTER, 'remove'),
	            username: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'username'),
	            nick: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'nick'),
	            password: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'password'),
	            name: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'name'),
	            first: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'first'),
	            last: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'last'),
	            email: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'email'),
	            address: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'address'),
	            city: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'city'),
	            state: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'state'),
	            zip: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'zip'),
	            phone: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'phone'),
	            url: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'url'),
	            date: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'date'),
	            misc: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'misc'),
	            text: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'text'),
	            key: Utils.textSub(_xmppConstants.Namespace.REGISTER, 'key')
	        }
	    });

	    JXT.extendIQ(Register);

	    JXT.withDefinition('x', _xmppConstants.Namespace.OOB, function (OOB) {

	        JXT.extend(Register, OOB);
	    });

	    JXT.withDataForm(function (DataForm) {

	        JXT.extend(Register, DataForm);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=register.js.map

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Roster = JXT.define({
	        name: 'roster',
	        namespace: _xmppConstants.Namespace.ROSTER,
	        element: 'query',
	        fields: {
	            ver: {
	                get: function get() {

	                    return Utils.getAttribute(this.xml, 'ver');
	                },
	                set: function set(value) {

	                    var force = value === '';
	                    Utils.setAttribute(this.xml, 'ver', value, force);
	                }
	            }
	        }
	    });

	    var RosterItem = JXT.define({
	        name: '_rosterItem',
	        namespace: _xmppConstants.Namespace.ROSTER,
	        element: 'item',
	        fields: {
	            jid: Utils.jidAttribute('jid', true),
	            name: Utils.attribute('name'),
	            subscription: Utils.attribute('subscription', 'none'),
	            subscriptionRequested: {
	                get: function get() {

	                    var ask = Utils.getAttribute(this.xml, 'ask');
	                    return ask === 'subscribe';
	                }
	            },
	            preApproved: Utils.boolAttribute(_xmppConstants.Namespace.ROSTER, 'approved'),
	            groups: Utils.multiTextSub(_xmppConstants.Namespace.ROSTER, 'group')
	        }
	    });

	    JXT.extend(Roster, RosterItem, 'items');

	    JXT.extendIQ(Roster);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=roster.js.map

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: 'rsm',
	        namespace: _xmppConstants.Namespace.RSM,
	        element: 'set',
	        fields: {
	            after: Utils.textSub(_xmppConstants.Namespace.RSM, 'after'),
	            before: {
	                get: function get() {

	                    return Utils.getSubText(this.xml, _xmppConstants.Namespace.RSM, 'before');
	                },
	                set: function set(value) {

	                    if (value === true) {
	                        Utils.findOrCreate(this.xml, _xmppConstants.Namespace.RSM, 'before');
	                    } else {
	                        Utils.setSubText(this.xml, _xmppConstants.Namespace.RSM, 'before', value);
	                    }
	                }
	            },
	            count: Utils.numberSub(_xmppConstants.Namespace.RSM, 'count', false, 0),
	            first: Utils.textSub(_xmppConstants.Namespace.RSM, 'first'),
	            firstIndex: Utils.subAttribute(_xmppConstants.Namespace.RSM, 'first', 'index'),
	            index: Utils.textSub(_xmppConstants.Namespace.RSM, 'index'),
	            last: Utils.textSub(_xmppConstants.Namespace.RSM, 'last'),
	            max: Utils.textSub(_xmppConstants.Namespace.RSM, 'max')
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=rsm.js.map

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Feedback = {
	        get: function get() {

	            var existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb');
	            var result = [];
	            existing.forEach(function (xml) {

	                result.push({
	                    type: Utils.getAttribute(xml, 'type'),
	                    subtype: Utils.getAttribute(xml, 'subtype')
	                });
	            });
	            existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb-trr-int');
	            existing.forEach(function (xml) {

	                result.push({
	                    type: Utils.getAttribute(xml, 'type'),
	                    value: Utils.getAttribute(xml, 'value')
	                });
	            });
	            return result;
	        },
	        set: function set(values) {

	            var self = this;
	            var existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb');
	            existing.forEach(function (item) {

	                self.xml.removeChild(item);
	            });
	            existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb-trr-int');
	            existing.forEach(function (item) {

	                self.xml.removeChild(item);
	            });

	            values.forEach(function (value) {

	                var fb = undefined;
	                if (value.type === 'trr-int') {
	                    fb = Utils.createElement(_xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb-trr-int', _xmppConstants.Namespace.JINGLE_RTP_1);
	                    Utils.setAttribute(fb, 'type', value.type);
	                    Utils.setAttribute(fb, 'value', value.value);
	                } else {
	                    fb = Utils.createElement(_xmppConstants.Namespace.JINGLE_RTP_RTCP_FB_0, 'rtcp-fb', _xmppConstants.Namespace.JINGLE_RTP_1);
	                    Utils.setAttribute(fb, 'type', value.type);
	                    Utils.setAttribute(fb, 'subtype', value.subtype);
	                }
	                self.xml.appendChild(fb);
	            });
	        }
	    };

	    var Bandwidth = JXT.define({
	        name: 'bandwidth',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_1,
	        element: 'bandwidth',
	        fields: {
	            type: Utils.attribute('type'),
	            bandwidth: Utils.text()
	        }
	    });

	    var RTP = JXT.define({
	        name: '_rtp',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_1,
	        element: 'description',
	        tags: ['jingle-application'],
	        fields: {
	            applicationType: { value: 'rtp' },
	            media: Utils.attribute('media'),
	            ssrc: Utils.attribute('ssrc'),
	            mux: Utils.boolSub(_xmppConstants.Namespace.JINGLE_RTP_1, 'rtcp-mux'),
	            encryption: {
	                get: function get() {

	                    var enc = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_1, 'encryption');
	                    if (!enc.length) {
	                        return [];
	                    }
	                    enc = enc[0];

	                    var self = this;
	                    var data = Utils.find(enc, _xmppConstants.Namespace.JINGLE_RTP_1, 'crypto');
	                    var results = [];

	                    data.forEach(function (xml) {

	                        results.push(new Crypto({}, xml, self).toJSON());
	                    });
	                    return results;
	                },
	                set: function set(values) {

	                    var enc = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_1, 'encryption');
	                    if (enc.length) {
	                        this.xml.removeChild(enc);
	                    }

	                    if (!values.length) {
	                        return;
	                    }

	                    Utils.setBoolSubAttribute(this.xml, _xmppConstants.Namespace.JINGLE_RTP_1, 'encryption', 'required', true);
	                    enc = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_1, 'encryption')[0];

	                    var self = this;
	                    values.forEach(function (value) {

	                        var content = new Crypto(value, null, self);
	                        enc.appendChild(content.xml);
	                    });
	                }
	            },
	            feedback: Feedback,
	            headerExtensions: {
	                get: function get() {

	                    var existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_HDREXT_0, 'rtp-hdrext');
	                    var result = [];
	                    existing.forEach(function (xml) {

	                        result.push({
	                            id: Utils.getAttribute(xml, 'id'),
	                            uri: Utils.getAttribute(xml, 'uri'),
	                            senders: Utils.getAttribute(xml, 'senders')
	                        });
	                    });
	                    return result;
	                },
	                set: function set(values) {

	                    var self = this;
	                    var existing = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_HDREXT_0, 'rtp-hdrext');
	                    existing.forEach(function (item) {

	                        self.xml.removeChild(item);
	                    });

	                    values.forEach(function (value) {

	                        var hdr = Utils.createElement(_xmppConstants.Namespace.JINGLE_RTP_HDREXT_0, 'rtp-hdrext', _xmppConstants.Namespace.JINGLE_RTP_1);
	                        Utils.setAttribute(hdr, 'id', value.id);
	                        Utils.setAttribute(hdr, 'uri', value.uri);
	                        Utils.setAttribute(hdr, 'senders', value.senders);
	                        self.xml.appendChild(hdr);
	                    });
	                }
	            }
	        }
	    });

	    var PayloadType = JXT.define({
	        name: '_payloadType',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_1,
	        element: 'payload-type',
	        fields: {
	            channels: Utils.attribute('channels'),
	            clockrate: Utils.attribute('clockrate'),
	            id: Utils.attribute('id'),
	            maxptime: Utils.attribute('maxptime'),
	            name: Utils.attribute('name'),
	            ptime: Utils.attribute('ptime'),
	            feedback: Feedback,
	            parameters: {
	                get: function get() {

	                    var result = [];
	                    var params = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_1, 'parameter');
	                    params.forEach(function (param) {

	                        result.push({
	                            key: Utils.getAttribute(param, 'name'),
	                            value: Utils.getAttribute(param, 'value')
	                        });
	                    });
	                    return result;
	                },
	                set: function set(values) {

	                    var self = this;
	                    values.forEach(function (value) {

	                        var param = Utils.createElement(_xmppConstants.Namespace.JINGLE_RTP_1, 'parameter');
	                        Utils.setAttribute(param, 'name', value.key);
	                        Utils.setAttribute(param, 'value', value.value);
	                        self.xml.appendChild(param);
	                    });
	                }
	            }
	        }
	    });

	    var Crypto = JXT.define({
	        name: 'crypto',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_1,
	        element: 'crypto',
	        fields: {
	            cipherSuite: Utils.attribute('crypto-suite'),
	            keyParams: Utils.attribute('key-params'),
	            sessionParams: Utils.attribute('session-params'),
	            tag: Utils.attribute('tag')
	        }
	    });

	    var ContentGroup = JXT.define({
	        name: '_group',
	        namespace: _xmppConstants.Namespace.JINGLE_GROUPING_0,
	        element: 'group',
	        fields: {
	            semantics: Utils.attribute('semantics'),
	            contents: Utils.multiSubAttribute(_xmppConstants.Namespace.JINGLE_GROUPING_0, 'content', 'name')
	        }
	    });

	    var SourceGroup = JXT.define({
	        name: '_sourceGroup',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_SSMA_0,
	        element: 'ssrc-group',
	        fields: {
	            semantics: Utils.attribute('semantics'),
	            sources: Utils.multiSubAttribute(_xmppConstants.Namespace.JINGLE_RTP_SSMA_0, 'source', 'ssrc')
	        }
	    });

	    var Source = JXT.define({
	        name: '_source',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_SSMA_0,
	        element: 'source',
	        fields: {
	            ssrc: Utils.attribute('ssrc'),
	            parameters: {
	                get: function get() {

	                    var result = [];
	                    var params = Utils.find(this.xml, _xmppConstants.Namespace.JINGLE_RTP_SSMA_0, 'parameter');
	                    params.forEach(function (param) {

	                        result.push({
	                            key: Utils.getAttribute(param, 'name'),
	                            value: Utils.getAttribute(param, 'value')
	                        });
	                    });
	                    return result;
	                },
	                set: function set(values) {

	                    var self = this;
	                    values.forEach(function (value) {

	                        var param = Utils.createElement(_xmppConstants.Namespace.JINGLE_RTP_SSMA_0, 'parameter');
	                        Utils.setAttribute(param, 'name', value.key);
	                        Utils.setAttribute(param, 'value', value.value);
	                        self.xml.appendChild(param);
	                    });
	                }
	            }
	        }
	    });

	    var Mute = JXT.define({
	        name: 'mute',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_INFO_1,
	        element: 'mute',
	        fields: {
	            creator: Utils.attribute('creator'),
	            name: Utils.attribute('name')
	        }
	    });

	    var Unmute = JXT.define({
	        name: 'unmute',
	        namespace: _xmppConstants.Namespace.JINGLE_RTP_INFO_1,
	        element: 'unmute',
	        fields: {
	            creator: Utils.attribute('creator'),
	            name: Utils.attribute('name')
	        }
	    });

	    JXT.extend(RTP, Bandwidth);
	    JXT.extend(RTP, PayloadType, 'payloads');
	    JXT.extend(RTP, Source, 'sources');
	    JXT.extend(RTP, SourceGroup, 'sourceGroups');

	    JXT.withDefinition('content', _xmppConstants.Namespace.JINGLE_1, function (Content) {

	        JXT.extend(Content, RTP);
	    });

	    JXT.withDefinition('jingle', _xmppConstants.Namespace.JINGLE_1, function (Jingle) {

	        JXT.extend(Jingle, Mute);
	        JXT.extend(Jingle, Unmute);
	        JXT.extend(Jingle, ContentGroup, 'groups');
	        JXT.add(Jingle, 'ringing', Utils.boolSub(_xmppConstants.Namespace.JINGLE_RTP_INFO_1, 'ringing'));
	        JXT.add(Jingle, 'hold', Utils.boolSub(_xmppConstants.Namespace.JINGLE_RTP_INFO_1, 'hold'));
	        JXT.add(Jingle, 'active', Utils.boolSub(_xmppConstants.Namespace.JINGLE_RTP_INFO_1, 'active'));
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=rtp.js.map

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var TYPE_MAP = {
	    insert: 't',
	    erase: 'e',
	    wait: 'w'
	};

	var ACTION_MAP = {
	    t: 'insert',
	    e: 'erase',
	    w: 'wait'
	};

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var RTT = JXT.define({
	        name: 'rtt',
	        namespace: _xmppConstants.Namespace.RTT_0,
	        element: 'rtt',
	        fields: {
	            id: Utils.attribute('id'),
	            event: Utils.attribute('event', 'edit'),
	            seq: Utils.numberAttribute('seq'),
	            actions: {
	                get: function get() {

	                    var results = [];
	                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
	                        var child = this.xml.childNodes[i];
	                        var _name = child.localName;
	                        var action = {};

	                        if (child.namespaceURI !== _xmppConstants.Namespace.RTT_0) {
	                            continue;
	                        }

	                        if (ACTION_MAP[_name]) {
	                            action.type = ACTION_MAP[_name];
	                        } else {
	                            continue;
	                        }

	                        var pos = Utils.getAttribute(child, 'p');
	                        if (pos) {
	                            action.pos = parseInt(pos, 10);
	                        }

	                        var n = Utils.getAttribute(child, 'n');
	                        if (n) {
	                            action.num = parseInt(n, 10);
	                        }

	                        var t = Utils.getText(child);
	                        if (t && _name === 't') {
	                            action.text = t;
	                        }

	                        results.push(action);
	                    }

	                    return results;
	                },
	                set: function set(actions) {

	                    var self = this;

	                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
	                        this.xml.removeChild(this.xml.childNodes[i]);
	                    }

	                    actions.forEach(function (action) {

	                        if (!TYPE_MAP[action.type]) {
	                            return;
	                        }

	                        var child = Utils.createElement(_xmppConstants.Namespace.RTT_0, TYPE_MAP[action.type], _xmppConstants.Namespace.RTT_0);

	                        if (action.pos !== undefined) {
	                            Utils.setAttribute(child, 'p', action.pos.toString());
	                        }

	                        if (action.num) {
	                            Utils.setAttribute(child, 'n', action.num.toString());
	                        }

	                        if (action.text) {
	                            Utils.setText(child, action.text);
	                        }

	                        self.xml.appendChild(child);
	                    });
	                }
	            }
	        }
	    });

	    JXT.extendMessage(RTT);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=rtt.js.map

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['aborted', 'account-disabled', 'credentials-expired', 'encryption-required', 'incorrect-encoding', 'invalid-authzid', 'invalid-mechanism', 'malformed-request', 'mechanism-too-weak', 'not-authorized', 'temporary-auth-failure'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Mechanisms = JXT.define({
	        name: 'sasl',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'mechanisms',
	        fields: {
	            mechanisms: Utils.multiTextSub(_xmppConstants.Namespace.SASL, 'mechanism')
	        }
	    });

	    JXT.define({
	        name: 'saslAuth',
	        eventName: 'sasl:auth',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'auth',
	        topLevel: true,
	        fields: {
	            value: Utils.text(),
	            mechanism: Utils.attribute('mechanism')
	        }
	    });

	    JXT.define({
	        name: 'saslChallenge',
	        eventName: 'sasl:challenge',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'challenge',
	        topLevel: true,
	        fields: {
	            value: Utils.text()
	        }
	    });

	    JXT.define({
	        name: 'saslResponse',
	        eventName: 'sasl:response',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'response',
	        topLevel: true,
	        fields: {
	            value: Utils.text()
	        }
	    });

	    JXT.define({
	        name: 'saslAbort',
	        eventName: 'sasl:abort',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'abort',
	        topLevel: true
	    });

	    JXT.define({
	        name: 'saslSuccess',
	        eventName: 'sasl:success',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'success',
	        topLevel: true,
	        fields: {
	            value: Utils.text()
	        }
	    });

	    JXT.define({
	        name: 'saslFailure',
	        eventName: 'sasl:failure',
	        namespace: _xmppConstants.Namespace.SASL,
	        element: 'failure',
	        topLevel: true,
	        fields: {
	            lang: {
	                get: function get() {

	                    return this._lang || '';
	                },
	                set: function set(value) {

	                    this._lang = value;
	                }
	            },
	            condition: Utils.enumSub(_xmppConstants.Namespace.SASL, CONDITIONS),
	            $text: {
	                get: function get() {

	                    return Utils.getSubLangText(this.xml, _xmppConstants.Namespace.SASL, 'text', this.lang);
	                }
	            },
	            text: {
	                get: function get() {

	                    var text = this.$text;
	                    return text[this.lang] || '';
	                },
	                set: function set(value) {

	                    Utils.setSubLangText(this.xml, _xmppConstants.Namespace.SASL, 'text', value, this.lang);
	                }
	            }
	        }
	    });

	    JXT.extendStreamFeatures(Mechanisms);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=sasl.js.map

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Session = JXT.define({
	        name: 'session',
	        namespace: _xmppConstants.Namespace.SESSION,
	        element: 'session',
	        fields: {
	            required: JXT.utils.boolSub(_xmppConstants.Namespace.SESSION, 'required'),
	            optional: JXT.utils.boolSub(_xmppConstants.Namespace.SESSION, 'optional')
	        }
	    });

	    JXT.extendIQ(Session);
	    JXT.extendStreamFeatures(Session);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=session.js.map

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var SHIM = {
	        get: function get() {

	            var headerSet = Utils.find(this.xml, _xmppConstants.Namespace.SHIM, 'headers');
	            if (headerSet.length) {
	                return Utils.getMultiSubText(headerSet[0], _xmppConstants.Namespace.SHIM, 'header', function (header) {

	                    var name = Utils.getAttribute(header, 'name');
	                    if (name) {
	                        return {
	                            name: name,
	                            value: Utils.getText(header)
	                        };
	                    }
	                });
	            }
	            return [];
	        },
	        set: function set(values) {

	            var headerSet = Utils.findOrCreate(this.xml, _xmppConstants.Namespace.SHIM, 'headers');
	            JXT.setMultiSubText(headerSet, _xmppConstants.Namespace.SHIM, 'header', values, function (val) {

	                var header = Utils.createElement(_xmppConstants.Namespace.SHIM, 'header', _xmppConstants.Namespace.SHIM);
	                Utils.setAttribute(header, 'name', val.name);
	                Utils.setText(header, val.value);
	                headerSet.appendChild(header);
	            });
	        }
	    };

	    JXT.withMessage(function (Message) {

	        JXT.add(Message, 'headers', SHIM);
	    });

	    JXT.withPresence(function (Presence) {

	        JXT.add(Presence, 'headers', SHIM);
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=shim.js.map

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var SMFeature = JXT.define({
	        name: 'streamManagement',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'sm'
	    });

	    JXT.define({
	        name: 'smEnable',
	        eventName: 'stream:management:enable',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'enable',
	        topLevel: true,
	        fields: {
	            resume: Utils.boolAttribute('resume')
	        }
	    });

	    JXT.define({
	        name: 'smEnabled',
	        eventName: 'stream:management:enabled',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'enabled',
	        topLevel: true,
	        fields: {
	            id: Utils.attribute('id'),
	            resume: Utils.boolAttribute('resume')
	        }
	    });

	    JXT.define({
	        name: 'smResume',
	        eventName: 'stream:management:resume',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'resume',
	        topLevel: true,
	        fields: {
	            h: Utils.numberAttribute('h', false, 0),
	            previd: Utils.attribute('previd')
	        }
	    });

	    JXT.define({
	        name: 'smResumed',
	        eventName: 'stream:management:resumed',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'resumed',
	        topLevel: true,
	        fields: {
	            h: Utils.numberAttribute('h', false, 0),
	            previd: Utils.attribute('previd')
	        }
	    });

	    JXT.define({
	        name: 'smFailed',
	        eventName: 'stream:management:failed',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'failed',
	        topLevel: true
	    });

	    JXT.define({
	        name: 'smAck',
	        eventName: 'stream:management:ack',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'a',
	        topLevel: true,
	        fields: {
	            h: Utils.numberAttribute('h', false, 0)
	        }
	    });

	    JXT.define({
	        name: 'smRequest',
	        eventName: 'stream:management:request',
	        namespace: _xmppConstants.Namespace.SMACKS_3,
	        element: 'r',
	        topLevel: true
	    });

	    JXT.extendStreamFeatures(SMFeature);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=sm.js.map

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: 'stream',
	        namespace: _xmppConstants.Namespace.STREAM,
	        element: 'stream',
	        fields: {
	            lang: Utils.langAttribute(),
	            id: Utils.attribute('id'),
	            version: Utils.attribute('version', '1.0'),
	            to: Utils.jidAttribute('to', true),
	            from: Utils.jidAttribute('from', true)
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=stream.js.map

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	var CONDITIONS = ['bad-format', 'bad-namespace-prefix', 'conflict', 'connection-timeout', 'host-gone', 'host-unknown', 'improper-addressing', 'internal-server-error', 'invalid-from', 'invalid-namespace', 'invalid-xml', 'not-authorized', 'not-well-formed', 'policy-violation', 'remote-connection-failed', 'reset', 'resource-constraint', 'restricted-xml', 'see-other-host', 'system-shutdown', 'undefined-condition', 'unsupported-encoding', 'unsupported-feature', 'unsupported-stanza-type', 'unsupported-version'];

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    JXT.define({
	        name: 'streamError',
	        namespace: _xmppConstants.Namespace.STREAM,
	        element: 'error',
	        topLevel: true,
	        fields: {
	            lang: {
	                get: function get() {

	                    return this._lang || '';
	                },
	                set: function set(value) {

	                    this._lang = value;
	                }
	            },
	            condition: Utils.enumSub(_xmppConstants.Namespace.STREAM_ERROR, CONDITIONS),
	            seeOtherHost: {
	                get: function get() {

	                    return Utils.getSubText(this.xml, _xmppConstants.Namespace.STREAM_ERROR, 'see-other-host');
	                },
	                set: function set(value) {

	                    this.condition = 'see-other-host';
	                    Utils.setSubText(this.xml, _xmppConstants.Namespace.STREAM_ERROR, 'see-other-host', value);
	                }
	            },
	            $text: {
	                get: function get() {

	                    return Utils.getSubLangText(this.xml, _xmppConstants.Namespace.STREAM_ERROR, 'text', this.lang);
	                }
	            },
	            text: {
	                get: function get() {

	                    var text = this.$text;
	                    return text[this.lang] || '';
	                },
	                set: function set(value) {

	                    Utils.setSubLangText(this.xml, _xmppConstants.Namespace.STREAM_ERROR, 'text', value, this.lang);
	                }
	            }
	        }
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=streamError.js.map

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var StreamFeatures = JXT.define({
	        name: 'streamFeatures',
	        namespace: _xmppConstants.Namespace.STREAM,
	        element: 'features',
	        topLevel: true
	    });

	    var RosterVerFeature = JXT.define({
	        name: 'rosterVersioning',
	        namespace: _xmppConstants.Namespace.ROSTER_VERSIONING,
	        element: 'ver'
	    });

	    var SubscriptionPreApprovalFeature = JXT.define({
	        name: 'subscriptionPreApproval',
	        namespace: _xmppConstants.Namespace.SUBSCRIPTION_PREAPPROVAL,
	        element: 'sub'
	    });

	    JXT.extendStreamFeatures(RosterVerFeature);
	    JXT.extendStreamFeatures(SubscriptionPreApprovalFeature);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=streamFeatures.js.map

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var EntityTime = JXT.define({
	        name: 'time',
	        namespace: _xmppConstants.Namespace.TIME,
	        element: 'time',
	        fields: {
	            utc: JXT.utils.dateSub(_xmppConstants.Namespace.TIME, 'utc'),
	            tzo: JXT.utils.tzoSub(_xmppConstants.Namespace.TIME, 'tzo', 0)
	        }
	    });

	    JXT.extendIQ(EntityTime);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=time.js.map

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var Tune = JXT.define({
	        name: 'tune',
	        namespace: _xmppConstants.Namespace.TUNE,
	        element: 'tune',
	        fields: {
	            artist: Utils.textSub(_xmppConstants.Namespace.TUNE, 'artist'),
	            length: Utils.numberSub(_xmppConstants.Namespace.TUNE, 'length'),
	            rating: Utils.numberSub(_xmppConstants.Namespace.TUNE, 'rating'),
	            source: Utils.textSub(_xmppConstants.Namespace.TUNE, 'source'),
	            title: Utils.textSub(_xmppConstants.Namespace.TUNE, 'title'),
	            track: Utils.textSub(_xmppConstants.Namespace.TUNE, 'track'),
	            uri: Utils.textSub(_xmppConstants.Namespace.TUNE, 'uri')
	        }
	    });

	    JXT.extendPubsubItem(Tune);
	    JXT.extendMessage(Tune);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=tune.js.map

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Utils = JXT.utils;

	    var VCardTemp = JXT.define({
	        name: 'vCardTemp',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'vCard',
	        fields: {
	            role: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'ROLE'),
	            website: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'URL'),
	            title: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'TITLE'),
	            description: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'DESC'),
	            fullName: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'FN'),
	            birthday: Utils.dateSub(_xmppConstants.Namespace.VCARD_TEMP, 'BDAY'),
	            nicknames: Utils.multiTextSub(_xmppConstants.Namespace.VCARD_TEMP, 'NICKNAME'),
	            jids: Utils.multiTextSub(_xmppConstants.Namespace.VCARD_TEMP, 'JABBERID')
	        }
	    });

	    var Email = JXT.define({
	        name: '_email',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'EMAIL',
	        fields: {
	            email: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'USERID'),
	            home: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'HOME'),
	            work: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'WORK'),
	            preferred: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'PREF')
	        }
	    });

	    var PhoneNumber = JXT.define({
	        name: '_tel',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'TEL',
	        fields: {
	            number: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'NUMBER'),
	            home: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'HOME'),
	            work: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'WORK'),
	            mobile: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'CELL'),
	            preferred: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'PREF')
	        }
	    });

	    var Address = JXT.define({
	        name: '_address',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'ADR',
	        fields: {
	            street: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'STREET'),
	            street2: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'EXTADD'),
	            country: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'CTRY'),
	            city: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'LOCALITY'),
	            region: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'REGION'),
	            postalCode: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'PCODE'),
	            pobox: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'POBOX'),
	            home: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'HOME'),
	            work: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'WORK'),
	            preferred: Utils.boolSub(_xmppConstants.Namespace.VCARD_TEMP, 'PREF')
	        }
	    });

	    var Organization = JXT.define({
	        name: 'organization',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'ORG',
	        fields: {
	            name: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'ORGNAME'),
	            unit: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'ORGUNIT')
	        }
	    });

	    var Name = JXT.define({
	        name: 'name',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'N',
	        fields: {
	            family: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'FAMILY'),
	            given: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'GIVEN'),
	            middle: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'MIDDLE'),
	            prefix: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'PREFIX'),
	            suffix: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'SUFFIX')
	        }
	    });

	    var Photo = JXT.define({
	        name: 'photo',
	        namespace: _xmppConstants.Namespace.VCARD_TEMP,
	        element: 'PHOTO',
	        fields: {
	            type: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'TYPE'),
	            data: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'BINVAL'),
	            url: Utils.textSub(_xmppConstants.Namespace.VCARD_TEMP, 'EXTVAL')
	        }
	    });

	    JXT.extend(VCardTemp, Email, 'emails');
	    JXT.extend(VCardTemp, Address, 'addresses');
	    JXT.extend(VCardTemp, PhoneNumber, 'phoneNumbers');
	    JXT.extend(VCardTemp, Organization);
	    JXT.extend(VCardTemp, Name);
	    JXT.extend(VCardTemp, Photo);

	    JXT.extendIQ(VCardTemp);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=vcard.js.map

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    var Version = JXT.define({
	        name: 'version',
	        namespace: _xmppConstants.Namespace.VERSION,
	        element: 'query',
	        fields: {
	            name: JXT.utils.textSub(_xmppConstants.Namespace.VERSION, 'name'),
	            version: JXT.utils.textSub(_xmppConstants.Namespace.VERSION, 'version'),
	            os: JXT.utils.textSub(_xmppConstants.Namespace.VERSION, 'os')
	        }
	    });

	    JXT.extendIQ(Version);
	};

	module.exports = exports['default'];
	//# sourceMappingURL=version.js.map

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _xmppConstants = __webpack_require__(318);

	exports['default'] = function (JXT) {

	    JXT.withIQ(function (IQ) {

	        JXT.add(IQ, 'visible', JXT.utils.boolSub(_xmppConstants.Namespace.INVISIBLE_0, 'visible'));
	        JXT.add(IQ, 'invisible', JXT.utils.boolSub(_xmppConstants.Namespace.INVISIBLE_0, 'invisible'));
	    });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=visibility.js.map

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var async = __webpack_require__(218);


	module.exports = function (client) {

	    client.features = {
	        negotiated: {},
	        order: [],
	        handlers: {}
	    };

	    client.registerFeature = function (name, priority, handler) {
	        this.features.order.push({
	            priority: priority,
	            name: name
	        });
	        this.features.order.sort(function (a, b) {
	            if (a.priority < b.priority) {
	                return -1;
	            }
	            if (a.priority > b.priority) {
	                return 1;
	            }
	            return 0;
	        });
	        this.features.handlers[name] = handler.bind(client);
	    };

	    client.on('streamFeatures', function (features) {
	        var series = [];
	        var negotiated = client.features.negotiated;
	        var handlers = client.features.handlers;

	        client.features.order.forEach(function (feature) {
	            var name = feature.name;
	            if (features[name] && handlers[name] && !negotiated[name]) {
	                series.push(function (cb) {
	                    if (!negotiated[name]) {
	                        handlers[name](features, cb);
	                    } else {
	                        cb();
	                    }
	                });
	            }
	        });

	        async.series(series, function (cmd, msg) {
	            if (cmd === 'restart') {
	                client.transport.restart();
	            } else if (cmd === 'disconnect') {
	                client.emit('stream:error', {
	                    condition: 'policy-violation',
	                    text: 'Failed to negotiate stream features: ' + msg
	                });
	                client.disconnect();
	            }
	        });
	    });
	};


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';


	var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';


	module.exports = function (client, stanzas) {

	    var Auth = stanzas.getDefinition('auth', NS);
	    var Response = stanzas.getDefinition('response', NS);
	    var Abort = stanzas.getDefinition('abort', NS);

	    client.registerFeature('sasl', 100, function (features, cb) {
	        var self = this;

	        var mech = self.SASLFactory.create(features.sasl.mechanisms);
	        if (!mech) {
	            self.releaseGroup('sasl');
	            self.emit('auth:failed');
	            return cb('disconnect', 'authentication failed');
	        }

	        self.on('sasl:success', 'sasl', function () {
	            self.features.negotiated.sasl = true;
	            self.releaseGroup('sasl');
	            self.emit('auth:success', self.config.credentials);
	            cb('restart');
	        });

	        self.on('sasl:challenge', 'sasl', function (challenge) {
	            mech.challenge(new Buffer(challenge.value, 'base64').toString());
	            return self.getCredentials(function (err, credentials) {
	                if (err) {
	                    return self.send(new Abort());
	                }

	                var resp = mech.response(credentials);
	                if (resp || resp === '') {
	                    self.send(new Response({
	                        value: new Buffer(resp).toString('base64')
	                    }));
	                } else {
	                    self.send(new Response());
	                }

	                if (mech.cache) {
	                    Object.keys(mech.cache).forEach(function (key) {
	                        if (!mech.cache[key]) {
	                            return;
	                        }

	                        self.config.credentials[key] = new Buffer(mech.cache[key]);
	                    });

	                    self.emit('credentials:update', self.config.credentials);
	                }
	            });
	        });

	        self.on('sasl:failure', 'sasl', function () {
	            self.releaseGroup('sasl');
	            self.emit('auth:failed');
	            cb('disconnect', 'authentication failed');
	        });

	        self.on('sasl:abort', 'sasl', function () {
	            self.releaseGroup('sasl');
	            self.emit('auth:failed');
	            cb('disconnect', 'authentication failed');
	        });

	        var auth = {
	            mechanism: mech.name
	        };

	        if (mech.clientFirst) {
	            return self.getCredentials(function (err, credentials) {
	                if (err) {
	                    return self.send(new Abort());
	                }

	                auth.value = new Buffer(mech.response(credentials)).toString('base64');
	                self.send(new Auth(auth));
	            });
	        }
	        
	        self.send(new Auth(auth));
	    });

	    client.on('disconnected', function () {
	        client.features.negotiated.sasl = false;
	    });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 404 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client, stanzas, config) {

	    var smacks = function (features, cb) {
	        var self = this;

	        if (!config.useStreamManagement) {
	            return cb();
	        }

	        self.on('stream:management:enabled', 'sm', function (enabled) {
	            self.sm.enabled(enabled);
	            self.features.negotiated.streamManagement = true;
	            self.releaseGroup('sm');
	            cb();
	        });

	        self.on('stream:management:resumed', 'sm', function (resumed) {
	            self.sm.resumed(resumed);
	            self.features.negotiated.streamManagement = true;
	            self.features.negotiated.bind = true;
	            self.sessionStarted = true;
	            self.releaseGroup('sm');
	            cb('break'); // Halt further processing of stream features
	        });

	        self.on('stream:management:failed', 'sm', function () {
	            self.sm.failed();
	            self.emit('session:end');
	            self.releaseGroup('session');
	            self.releaseGroup('sm');
	            cb();
	        });

	        if (!self.sm.id) {
	            if (self.features.negotiated.bind) {
	                self.sm.enable();
	            } else {
	                self.releaseGroup('sm');
	                cb();
	            }
	        } else if (self.sm.id && self.sm.allowResume) {
	            self.sm.resume();
	        } else {
	            self.releaseGroup('sm');
	            cb();
	        }
	    };

	    client.on('disconnected', function () {
	        client.features.negotiated.streamManagement = false;
	    });

	    client.registerFeature('streamManagement', 200, smacks);
	    client.registerFeature('streamManagement', 500, smacks);
	};


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var JID = __webpack_require__(222).JID;


	module.exports = function (client, stanzas, config) {

	    client.registerFeature('bind', 300, function (features, cb) {
	        var self = this;

	        self.sendIq({
	            type: 'set',
	            bind: {
	                resource: config.resource
	            }
	        }, function (err, resp) {
	            if (err) {
	                self.emit('session:error', err);
	                return cb('disconnect', 'JID binding failed');
	            }

	            self.features.negotiated.bind = true;
	            self.jid = new JID(resp.bind.jid);
	            self.emit('session:bound', self.jid);

	            var canStartSession = !features.session || (features.session && features.session.optional);
	            if (!self.sessionStarted && canStartSession) {
	                self.sessionStarted = true;
	                self.emit('session:started', self.jid);
	            }
	            return cb();
	        });
	    });

	    client.on('disconnected', function () {
	        client.sessionStarted = false;
	        client.features.negotiated.bind = false;
	    });
	};


/***/ },
/* 406 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.registerFeature('session', 1000, function (features, cb) {
	        var self = this;

	        if (features.session.optional || self.sessionStarted) {
	            self.features.negotiated.session = true;
	            return cb();
	        }

	        self.sendIq({
	            type: 'set',
	            session: {}
	        }, function (err) {
	            if (err) {
	                return cb('disconnect', 'session request failed');
	            }

	            self.features.negotiated.session = true;
	            if (!self.sessionStarted) {
	                self.sessionStarted = true;
	                self.emit('session:started', self.jid);
	            }
	            cb();
	        });
	    });

	    client.on('disconnected', function () {
	        client.sessionStarted = false;
	        client.features.negotiated.session = false;
	    });
	};


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var WSConnection = __webpack_require__(408);


	module.exports = function (client) {

	    client.transports.websocket = WSConnection;
	};


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var util = __webpack_require__(197);
	var WildEmitter = __webpack_require__(257);
	var async = __webpack_require__(218);

	var WS = (__webpack_require__(409) && __webpack_require__(409).Client) ?
	                                       __webpack_require__(409).Client :
	                                       window.WebSocket;

	var WS_OPEN = 1;



	function WSConnection(sm, stanzas) {
	    var self = this;

	    WildEmitter.call(this);

	    self.sm = sm;
	    self.closing = false;

	    self.stanzas = {
	        Open: stanzas.getDefinition('open', 'urn:ietf:params:xml:ns:xmpp-framing', true),
	        Close: stanzas.getDefinition('close', 'urn:ietf:params:xml:ns:xmpp-framing', true),
	        StreamError: stanzas.getStreamError()
	    };

	    self.sendQueue = async.queue(function (data, cb) {
	        if (self.conn) {
	            if (typeof data !== 'string') {
	                data = data.toString();
	            }

	            data = new Buffer(data, 'utf8').toString();

	            self.emit('raw:outgoing', data);
	            if (self.conn.readyState === WS_OPEN) {
	                self.conn.send(data);
	            }
	        }
	        cb();
	    }, 1);

	    self.on('connected', function () {
	        self.send(self.startHeader());
	    });

	    self.on('raw:incoming', function (data) {
	        var stanzaObj, err;

	        data = data.trim();
	        if (data === '') {
	            return;
	        }

	        try {
	            stanzaObj = stanzas.parse(data);
	        } catch (e) {
	            err = new this.stanzas.StreamError({
	                condition: 'invalid-xml'
	            });
	            self.emit('stream:error', err, e);
	            self.send(err);
	            return self.disconnect();
	        }

	        if (stanzaObj._name === 'openStream') {
	            self.hasStream = true;
	            self.stream = stanzaObj;
	            return self.emit('stream:start', stanzaObj.toJSON());
	        }
	        if (stanzaObj._name === 'closeStream') {
	            self.emit('stream:end');
	            return self.disconnect();
	        }

	        if (!stanzaObj.lang && self.stream) {
	            stanzaObj.lang = self.stream.lang;
	        }

	        self.emit('stream:data', stanzaObj);
	    });
	}

	util.inherits(WSConnection, WildEmitter);

	WSConnection.prototype.connect = function (opts) {
	    var self = this;

	    self.config = opts;

	    self.hasStream = false;
	    self.closing = false;

	    self.conn = new WS(opts.wsURL, 'xmpp');
	    self.conn.onerror = function (e) {
	        e.preventDefault();
	        self.emit('disconnected', self);
	    };

	    self.conn.onclose = function () {
	        self.emit('disconnected', self);
	    };

	    self.conn.onopen = function () {
	        self.sm.started = false;
	        self.emit('connected', self);
	    };

	    self.conn.onmessage = function (wsMsg) {
	        self.emit('raw:incoming', new Buffer(wsMsg.data, 'utf8').toString());
	    };

/*	TODO Replace websockets with REST+SSE

		self.sseRecconnecting = false;

		self._xhr = new XMLHttpRequest();
		self.conn = new EventSource("/rest/sse");

		console.log("WSConnection.prototype.connect", self.conn);

		self.conn.addEventListener('error', function (e) {
			console.log("EventSource error", e);  
		    e.preventDefault();
		    self.emit('disconnected', self);
		    self.sseRecconnecting = true;
		});

		self.conn.addEventListener('open', function () {
			console.log("EventSource connected");
		    self.sm.started = false;
		    self.emit('connected', self);

		    if (self.sseRecconnecting) window.location = "/apps";
		});

		self.conn.addEventListener('chatapi.xmpp', function (wsMsg) {
		if (wsMsg.data.indexOf("<presence") > -1) console.log("chatapi.xmpp", wsMsg.data);
		    self.emit('raw:incoming', new Buffer(wsMsg.data, 'utf8').toString());
		});

		self.conn.send = function(data) {
			//console.log("self.conn.send", data);    
			self._xhr.open("POST", window.location.protocol + '//' + window.location.host + "/rest/api/restapi/v1/chat/xmpp?t="+(new Date()).getTime());
			self._xhr.setRequestHeader("authorization", SERVER_CONFIG.authorization);	
			self._xhr.send(data)       
		}  
*/		

	};

	WSConnection.prototype.startHeader = function () {
	    return new this.stanzas.Open({
	        version: this.config.version || '1.0',
	        lang: this.config.lang || 'en',
	        to: this.config.server
	    });
	};

	WSConnection.prototype.closeHeader = function () {
	    return new this.stanzas.Close();
	};

	WSConnection.prototype.disconnect = function () {
	    if (this.conn && !this.closing && this.hasStream) {
	        this.closing = true;
	        this.send(this.closeHeader());
	    } else {
	        this.hasStream = false;
	        this.stream = undefined;
	        if (this.conn.readyState === WS_OPEN) {
	            this.conn.close();
	        }
	        this.conn = undefined;
	    }
	};

	WSConnection.prototype.restart = function () {
	    var self = this;
	    self.hasStream = false;
	    self.send(this.startHeader());
	};

	WSConnection.prototype.send = function (data) {
	    this.sendQueue.push(data);
	};


	module.exports = WSConnection;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 409 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var OldWSConnection = __webpack_require__(411);


	module.exports = function (client) {

	    client.transports['old-websocket'] = OldWSConnection;
	};


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var each = __webpack_require__(226);

	var WSConnection = __webpack_require__(408);
	var util = __webpack_require__(197);



	function OldWSConnection(sm, stanzas) {
	    WSConnection.call(this, sm, stanzas);

	    var self = this;


	    function wrap(data) {
	        return [self.streamStart, data, self.streamEnd].join('');
	    }


	    self.on('connected', function () {
	        self.streamStart = '<stream:stream xmlns:stream="http://etherx.jabber.org/streams">';
	        self.streamEnd = '</stream:stream>';
	    });

	    self.off('raw:incoming');
	    self.on('raw:incoming', function (data) {
	        var streamData, ended, err;

	        data = data.trim();
	        data = data.replace(/^(\s*<\?.*\?>\s*)*/, '');
	        if (data === '') {
	            return;
	        }

	        if (data.match(self.streamEnd)) {
	            return self.disconnect();
	        } else if (self.hasStream) {
	            try {
	                streamData = stanzas.parse(wrap(data));
	            } catch (e) {
	                err = new this.stanzas.StreamError({
	                    condition: 'invalid-xml'
	                });
	                self.emit('stream:error', err, e);
	                self.send(err);
	                return self.disconnect();
	            }
	        } else {
	            // Inspect start of stream element to get NS prefix name
	            var parts = data.match(/^<(\S+:)?(\S+) /);
	            self.streamStart = data;
	            self.streamEnd = '</' + (parts[1] || '') + parts[2] + '>';

	            ended = false;
	            try {
	                streamData = stanzas.parse(data + self.streamEnd);
	            } catch (e) {
	                try {
	                    streamData = stanzas.parse(data);
	                    ended = true;
	                } catch (e2) {
	                    err = new this.stanzas.StreamError({
	                        condition: 'invalid-xml'
	                    });
	                    self.emit('stream:error', err, e2);
	                    self.send(err);
	                    return self.disconnect();
	                }
	            }

	            self.hasStream = true;
	            self.stream = streamData;
	            self.emit('stream:start', streamData);
	        }

	        each(streamData._extensions, function (stanzaObj) {
	            if (!stanzaObj.lang && self.stream) {
	                stanzaObj.lang = self.stream.lang;
	            }

	            self.emit('stream:data', stanzaObj);
	        });

	        if (ended) {
	            self.emit('stream:end');
	        }
	    });
	}

	util.inherits(OldWSConnection, WSConnection);


	OldWSConnection.prototype.startHeader = function () {
	    return [
	        '<stream:stream',
	        'xmlns:stream="http://etherx.jabber.org/streams"',
	        'xmlns="jabber:client"',
	        'version="' + (this.config.version || '1.0') + '"',
	        'xml:lang="' + (this.config.lang || 'en') + '"',
	        'to="' + this.config.server + '">'
	    ].join(' ');
	};

	OldWSConnection.prototype.closeHeader = function () {
	    return '</stream:stream>';
	};


	module.exports = OldWSConnection;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BOSHConnection = __webpack_require__(413);


	module.exports = function (client) {

	    client.transports.bosh = BOSHConnection;
	};


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	var extend = __webpack_require__(234);
	var filter = __webpack_require__(414);

	var util = __webpack_require__(197);
	var BPromise = __webpack_require__(258);
	var request = BPromise.promisify(__webpack_require__(262));

	var WildEmitter = __webpack_require__(257);


	function ConnectionError() {}
	util.inherits(ConnectionError, Error);


	function retryRequest(opts, timeout, allowedRetries, retries) {
	    retries = retries || 0;

	    var req = request(opts).cancellable().timeout((timeout || 20) * 1000);

	    return req.spread(function (req, body) {
	        if (req.statusCode < 200 || req.statusCode >= 400) {
	            throw new ConnectionError('HTTP Status Error');
	        }
	        return body;
	    }).catch(BPromise.TimeoutError, function () {
	        throw new ConnectionError('Dead Connection, exceeded timeout limit');
	    }).catch(function () {
	        if (retries < allowedRetries) {
	            return BPromise.delay(100).then(function () {
	                return retryRequest(opts, timeout, allowedRetries, retries + 1);
	            });
	        } else {
	            throw new ConnectionError('Dead Connection, exceeded retry limit');
	        }
	    });
	}


	function BOSHConnection(sm, stanzas) {
	    var self = this;

	    WildEmitter.call(this);

	    self.sm = sm;

	    self.stanzas = {
	        BOSH: stanzas.getDefinition('body', 'http://jabber.org/protocol/httpbind'),
	        StreamError: stanzas.getStreamError()
	    };

	    self.sendQueue = [];
	    self.requests = [];
	    self.maxRequests = 2;
	    self.sid = '';

	    self.on('raw:incoming', function (data) {
	        data = data.trim();
	        if (data === '') {
	            return;
	        }

	        var bosh, err;

	        try {
	            bosh = stanzas.parse(data, self.stanzas.BOSH);
	        } catch (e) {
	            err = new self.stanzas.StreamError({
	                condition: 'invalid-xml'
	            });
	            self.emit('stream:error', err, e);
	            self.send(err);
	            return self.disconnect();
	        }

	        if (!self.hasStream) {
	            self.hasStream = true;
	            self.stream = {
	                id: bosh.sid,
	                lang: bosh.lang || 'en',
	                version: bosh.version || '1.0',
	                to: bosh.to,
	                from: bosh.from
	            };
	            self.sid = bosh.sid;
	            self.maxRequests = bosh.requests;
	        }

	        var payload = bosh.payload;
	        payload.forEach(function (stanzaObj) {
	            if (!stanzaObj.lang) {
	                stanzaObj.lang = self.stream.lang;
	            }

	            self.emit('stream:data', stanzaObj);
	        });

	        if (bosh.type === 'terminate') {
	            self.rid = undefined;
	            self.sid = undefined;
	            self.emit('bosh:terminate', bosh);
	            self.emit('stream:end');
	            self.emit('disconnected', self);
	        }
	    });
	}

	util.inherits(BOSHConnection, WildEmitter);

	BOSHConnection.prototype.connect = function (opts) {
	    var self = this;

	    self.config = extend({
	        rid: Math.ceil(Math.random() * 9999999999),
	        wait: 30,
	        maxRetries: 5
	    }, opts);

	    self.hasStream = false;
	    self.sm.started = false;
	    self.url = opts.boshURL;

	    self.sid = self.config.sid;
	    self.rid = self.config.rid;

	    self.requests = [];

	    self.rid++;
	    self.request(new self.stanzas.BOSH({
	        version: self.config.version || '1.0',
	        to: self.config.server,
	        lang: self.config.lang || 'en',
	        wait: self.config.wait,
	        ver: '1.6',
	        hold: 1
	    }));
	};

	BOSHConnection.prototype.disconnect = function () {
	    if (this.hasStream) {
	        this.rid++;
	        this.request(new this.stanzas.BOSH({
	            type: 'terminate'
	        }));
	    } else {
	        this.requests.forEach(function (ticket) {
	            ticket.request.cancel();
	        });
	        this.stream = undefined;
	        this.sid = undefined;
	        this.rid = undefined;
	        this.emit('disconnected', this);
	    }
	};

	BOSHConnection.prototype.restart = function () {
	    var self = this;
	    self.rid++;
	    self.request(new self.stanzas.BOSH({
	        to: self.config.server,
	        lang: self.config.lang || 'en',
	        restart: 'true'
	    }));
	};

	BOSHConnection.prototype.send = function (data) {
	    var self = this;
	    if (self.hasStream) {
	        self.sendQueue.push(data);
	        process.nextTick(self.longPoll.bind(self));
	    }
	};

	BOSHConnection.prototype.longPoll = function () {
	    var canReceive = this.requests.length === 0;
	    var canSend = this.sendQueue.length > 0 && this.requests.length < this.maxRequests;

	    if (!this.sid || (!canReceive && !canSend)) {
	        return;
	    }

	    var stanzas = this.sendQueue;
	    this.sendQueue = [];
	    this.rid++;

	    this.request(new this.stanzas.BOSH({
	        payload: stanzas
	    }));
	};

	BOSHConnection.prototype.request = function (bosh) {
	    var self = this;

	    var ticket = {id: self.rid, request: null};
	    bosh.rid = self.rid;
	    bosh.sid = self.sid;

	    var body = new Buffer(bosh.toString(), 'utf8').toString();

	    self.emit('raw:outgoing', body);

	    self.requests.push(ticket);

	    var req = retryRequest({
	        uri: self.url,
	        body: body,
	        method: 'POST',
	        strictSSL: true
	    }, self.config.wait * 1.5, this.config.maxRetries);

	    ticket.request = req;

	    return req.then(function (body) {
	        self.emit('raw:incoming', new Buffer(body, 'utf8').toString());
	    }).catch(ConnectionError, function (err) {
	        self.hasStream = false;
	        var serr = new self.stanzas.StreamError({
	            condition: 'connection-timeout'
	        });
	        self.emit('stream:error', serr, err);
	        self.disconnect();
	    }).catch(BPromise.CancellationError, function () {
	        return; // We only cancel on manual disconnect, so let things die silently
	    }).finally(function () {
	        self.requests = filter(self.requests, function (item) {
	            return item.id !== ticket.id;
	        });
	        if (bosh.type !== 'terminate') {
	            // Delay next auto-request by two ticks since we're likely
	            // to send data anyway next tick.
	            process.nextTick(function () {
	                process.nextTick(self.longPoll.bind(self));
	            });
	        }
	    });
	};

	module.exports = BOSHConnection;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(189), __webpack_require__(205).Buffer))

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var arrayFilter = __webpack_require__(415),
	    baseCallback = __webpack_require__(416),
	    baseFilter = __webpack_require__(420),
	    isArray = __webpack_require__(232);

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `predicate` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `predicate` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias select
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [predicate=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `predicate`.
	 * @returns {Array} Returns the new filtered array.
	 * @example
	 *
	 * _.filter([4, 5, 6], function(n) {
	 *   return n % 2 == 0;
	 * });
	 * // => [4, 6]
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // using the `_.matches` callback shorthand
	 * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	 * // => ['barney']
	 *
	 * // using the `_.matchesProperty` callback shorthand
	 * _.pluck(_.filter(users, 'active', false), 'user');
	 * // => ['fred']
	 *
	 * // using the `_.property` callback shorthand
	 * _.pluck(_.filter(users, 'active'), 'user');
	 * // => ['barney']
	 */
	function filter(collection, predicate, thisArg) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  predicate = baseCallback(predicate, thisArg, 3);
	  return func(collection, predicate);
	}

	module.exports = filter;


/***/ },
/* 415 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * A specialized version of `_.filter` for arrays without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseIsEqual = __webpack_require__(417),
	    bindCallback = __webpack_require__(233),
	    isArray = __webpack_require__(232),
	    pairs = __webpack_require__(419);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}

	/**
	 * The base implementation of `_.callback` which supports specifying the
	 * number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function baseCallback(func, thisArg, argCount) {
	  var type = typeof func;
	  if (type == 'function') {
	    return thisArg === undefined
	      ? func
	      : bindCallback(func, thisArg, argCount);
	  }
	  if (func == null) {
	    return identity;
	  }
	  if (type == 'object') {
	    return baseMatches(func);
	  }
	  return thisArg === undefined
	    ? property(func)
	    : baseMatchesProperty(func, thisArg);
	}

	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * The base implementation of `_.isMatch` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} matchData The propery names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = toObject(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.matches` which does not clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    var key = matchData[0][0],
	        value = matchData[0][1];

	    return function(object) {
	      if (object == null) {
	        return false;
	      }
	      return object[key] === value && (value !== undefined || (key in toObject(object)));
	    };
	  }
	  return function(object) {
	    return baseIsMatch(object, matchData);
	  };
	}

	/**
	 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to compare.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  var isArr = isArray(path),
	      isCommon = isKey(path) && isStrictComparable(srcValue),
	      pathKey = (path + '');

	  path = toPath(path);
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    var key = pathKey;
	    object = toObject(object);
	    if ((isArr || !isCommon) && !(key in object)) {
	      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	      if (object == null) {
	        return false;
	      }
	      key = last(path);
	      object = toObject(object);
	    }
	    return object[key] === srcValue
	      ? (srcValue !== undefined || (key in object))
	      : baseIsEqual(srcValue, object[key], undefined, true);
	  };
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  var pathKey = (path + '');
	  path = toPath(path);
	  return function(object) {
	    return baseGet(object, path, pathKey);
	  };
	}

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  start = start == null ? 0 : (+start || 0);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : (+end || 0);
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * Gets the propery names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = pairs(object),
	      length = result.length;

	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	    return true;
	  }
	  if (isArray(value)) {
	    return false;
	  }
	  var result = !reIsDeepProp.test(value);
	  return result || (object != null && value in toObject(object));
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * Creates a function that returns the property value at `path` on a
	 * given object.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': { 'c': 2 } } },
	 *   { 'a': { 'b': { 'c': 1 } } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b.c'));
	 * // => [2, 1]
	 *
	 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}

	module.exports = baseCallback;


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var isArray = __webpack_require__(232),
	    isTypedArray = __webpack_require__(418),
	    keys = __webpack_require__(229);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/**
	 * A specialized version of `_.some` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.isEqual` without support for `this` binding
	 * `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = objToString.call(object);
	    if (objTag == argsTag) {
	      objTag = objectTag;
	    } else if (objTag != objectTag) {
	      objIsArr = isTypedArray(object);
	    }
	  }
	  if (!othIsArr) {
	    othTag = objToString.call(other);
	    if (othTag == argsTag) {
	      othTag = objectTag;
	    } else if (othTag != objectTag) {
	      othIsArr = isTypedArray(other);
	    }
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && !(objIsArr || objIsObj)) {
	    return equalByTag(object, other, objTag);
	  }
	  if (!isLoose) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  // For more information on detecting circular references see https://es5.github.io/#JO.
	  stackA || (stackA = []);
	  stackB || (stackB = []);

	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == object) {
	      return stackB[length] == other;
	    }
	  }
	  // Add `object` and `other` to the stack of traversed objects.
	  stackA.push(object);
	  stackB.push(other);

	  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	  stackA.pop();
	  stackB.pop();

	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing arrays.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var index = -1,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	    return false;
	  }
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index],
	        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	    if (result !== undefined) {
	      if (result) {
	        continue;
	      }
	      return false;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (isLoose) {
	      if (!arraySome(other, function(othValue) {
	            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	          })) {
	        return false;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} value The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag) {
	  switch (tag) {
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	      return +object == +other;

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object)
	        ? other != +other
	        : object == +other;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings primitives and string
	      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	      return object == (other + '');
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isLoose) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  var skipCtor = isLoose;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key],
	        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	      return false;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (!skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = baseIsEqual;


/***/ },
/* 418 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.5 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	module.exports = isTypedArray;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var keys = __webpack_require__(229);

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates a two dimensional array of the key-value pairs for `object`,
	 * e.g. `[[key1, value1], [key2, value2]]`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the new array of key-value pairs.
	 * @example
	 *
	 * _.pairs({ 'barney': 36, 'fred': 40 });
	 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	 */
	function pairs(object) {
	  object = toObject(object);

	  var index = -1,
	      props = keys(object),
	      length = props.length,
	      result = Array(length);

	  while (++index < length) {
	    var key = props[index];
	    result[index] = [key, object[key]];
	  }
	  return result;
	}

	module.exports = pairs;


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseEach = __webpack_require__(228);

	/**
	 * The base implementation of `_.filter` without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	module.exports = baseFilter;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function (client) {
	    // We always need this one first
	    client.use(__webpack_require__(422));

	    client.use(__webpack_require__(430));
	    client.use(__webpack_require__(431));
	    client.use(__webpack_require__(432));
	    client.use(__webpack_require__(433));
	    client.use(__webpack_require__(434));
	    client.use(__webpack_require__(435));
	    client.use(__webpack_require__(436));
	    client.use(__webpack_require__(437));
	    client.use(__webpack_require__(438));
	    client.use(__webpack_require__(439));
	    client.use(__webpack_require__(440));
	    client.use(__webpack_require__(441));
	    client.use(__webpack_require__(442));
	    client.use(__webpack_require__(443));
	    client.use(__webpack_require__(444));
	    client.use(__webpack_require__(445));
	    client.use(__webpack_require__(446));
	    client.use(__webpack_require__(447));
	    client.use(__webpack_require__(448));
	    client.use(__webpack_require__(449));
	    client.use(__webpack_require__(450));
	    client.use(__webpack_require__(483));
	    client.use(__webpack_require__(484));
	    client.use(__webpack_require__(485));
	    client.use(__webpack_require__(486));
	    client.use(__webpack_require__(487));
	    client.use(__webpack_require__(488));
	    client.use(__webpack_require__(489));
	    client.use(__webpack_require__(490));
	    client.use(__webpack_require__(491));
	    client.use(__webpack_require__(492));
	    client.use(__webpack_require__(493));
	    client.use(__webpack_require__(494));
	    client.use(__webpack_require__(495));
	    client.use(__webpack_require__(496));
	    client.use(__webpack_require__(497));
	    client.use(__webpack_require__(498));
	    client.use(__webpack_require__(499));
	    client.use(__webpack_require__(500));
	    client.use(__webpack_require__(501));
	    client.use(__webpack_require__(502));
	    client.use(__webpack_require__(503));
	};


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var each = __webpack_require__(226);
	var unique = __webpack_require__(423);

	var JID = __webpack_require__(222).JID;
	var hashes = __webpack_require__(428);


	function generateVerString(info, hash) {
	    var S = '';
	    var features = info.features.sort();
	    var identities = [];
	    var formTypes = {};
	    var formOrder = [];

	    each(info.identities, function (identity) {
	        identities.push([
	            identity.category || '',
	            identity.type || '',
	            identity.lang || '',
	            identity.name || ''
	        ].join('/'));
	    });

	    identities.sort();

	    var idLen = identities.length;
	    var featureLen = features.length;

	    identities = unique(identities, true);
	    features = unique(features, true);

	    if (featureLen !== features.length || idLen !== identities.length) {
	        return false;
	    }


	    S += identities.join('<') + '<';
	    S += features.join('<') + '<';


	    var illFormed = false;
	    each(info.extensions, function (ext) {
	        var fields = ext.fields;
	        for (var i = 0, len = fields.length; i < len; i++) {
	            if (fields[i].name === 'FORM_TYPE' && fields[i].type === 'hidden') {
	                var name = fields[i].value;
	                if (formTypes[name]) {
	                    illFormed = true;
	                    return;
	                }
	                formTypes[name] = ext;
	                formOrder.push(name);
	                return;
	            }
	        }
	    });
	    if (illFormed) {
	        return false;
	    }

	    formOrder.sort();

	    each(formOrder, function (name) {
	        var ext = formTypes[name];
	        var fields = {};
	        var fieldOrder = [];

	        S += '<' + name;

	        each(ext.fields, function (field) {
	            var fieldName = field.name;
	            if (fieldName !== 'FORM_TYPE') {
	                var values = field.value || '';
	                if (typeof values !== 'object') {
	                    values = values.split('\n');
	                }
	                fields[fieldName] = values.sort();
	                fieldOrder.push(fieldName);
	            }
	        });

	        fieldOrder.sort();

	        each(fieldOrder, function (fieldName) {
	            S += '<' + fieldName;
	            each(fields[fieldName], function (val) {
	                S += '<' + val;
	            });
	        });
	    });

	    var ver = hashes.createHash(hash).update(new Buffer(S, 'utf8')).digest('base64');
	    var padding = 4 - ver.length % 4;
	    if (padding === 4) {
	        padding = 0;
	    }

	    for (var i = 0; i < padding; i++) {
	        ver += '=';
	    }
	    return ver;
	}

	function verifyVerString(info, hash, check) {
	    var computed = generateVerString(info, hash);
	    return computed && computed === check;
	}


	function Disco() {
	    this.features = {};
	    this.identities = {};
	    this.extensions = {};
	    this.items = {};
	    this.caps = {};
	}

	Disco.prototype = {
	    constructor: {
	        value: Disco
	    },
	    addFeature: function (feature, node) {
	        node = node || '';
	        if (!this.features[node]) {
	            this.features[node] = [];
	        }
	        this.features[node].push(feature);
	    },
	    addIdentity: function (identity, node) {
	        node = node || '';
	        if (!this.identities[node]) {
	            this.identities[node] = [];
	        }
	        this.identities[node].push(identity);
	    },
	    addItem: function (item, node) {
	        node = node || '';
	        if (!this.items[node]) {
	            this.items[node] = [];
	        }
	        this.items[node].push(item);
	    },
	    addExtension: function (form, node) {
	        node = node || '';
	        if (!this.extensions[node]) {
	            this.extensions[node] = [];
	        }
	        this.extensions[node].push(form);
	    }
	};

	module.exports = function (client) {

	    client.disco = new Disco(client);

	    client.disco.addFeature('http://jabber.org/protocol/disco#info');
	    client.disco.addFeature('http://jabber.org/protocol/disco#items');
	    client.disco.addIdentity({
	        category: 'client',
	        type: 'web'
	    });

	    client.registerFeature('caps', 100, function (features, cb) {
	        this.emit('disco:caps', {
	            from: new JID(client.jid.domain || client.config.server),
	            caps: features.caps
	        });
	        this.features.negotiated.caps = true;
	        cb();
	    });

	    client.getDiscoInfo = function (jid, node, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            discoInfo: {
	                node: node
	            }
	        }, cb);
	    };

	    client.getDiscoItems = function (jid, node, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            discoItems: {
	                node: node
	            }
	        }, cb);
	    };

	    client.updateCaps = function () {
	        var node = this.config.capsNode || 'https://stanza.io';
	        var data = JSON.parse(JSON.stringify({
	            identities: this.disco.identities[''],
	            features: this.disco.features[''],
	            extensions: this.disco.extensions['']
	        }));

	        var ver = generateVerString(data, 'sha-1');

	        this.disco.caps = {
	            node: node,
	            hash: 'sha-1',
	            ver: ver
	        };

	        node = node + '#' + ver;
	        this.disco.features[node] = data.features;
	        this.disco.identities[node] = data.identities;
	        this.disco.extensions[node] = data.extensions;

	        return client.getCurrentCaps();
	    };

	    client.getCurrentCaps = function () {
	        var caps = client.disco.caps;
	        if (!caps.ver) {
	            return {ver: null, discoInfo: null};
	        }

	        var node = caps.node + '#' + caps.ver;
	        return {
	            ver: caps.ver,
	            discoInfo: {
	                identities: client.disco.identities[node],
	                features: client.disco.features[node],
	                extensions: client.disco.extensions[node]
	            }
	        };
	    };

	    client.on('presence', function (pres) {
	        if (pres.caps) {
	            client.emit('disco:caps', pres);
	        }
	    });

	    client.on('iq:get:discoInfo', function (iq) {
	        var node = iq.discoInfo.node || '';
	        var reportedNode = iq.discoInfo.node || '';

	        if (node === client.disco.caps.node + '#' + client.disco.caps.ver) {
	            reportedNode = node;
	            node = '';
	        }

	        client.sendIq(iq.resultReply({
	            discoInfo: {
	                node: reportedNode,
	                identities: client.disco.identities[node] || [],
	                features: client.disco.features[node] || [],
	                extensions: client.disco.extensions[node] || []
	            }
	        }));
	    });

	    client.on('iq:get:discoItems', function (iq) {
	        var node = iq.discoItems.node;
	        client.sendIq(iq.resultReply({
	            discoItems: {
	                node: node,
	                items: client.disco.items[node] || []
	            }
	        }));
	    });

	    client.verifyVerString = verifyVerString;
	    client.generateVerString = generateVerString;

	    // Ensure we always have some caps data
	    client.updateCaps();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.2.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseCallback = __webpack_require__(416),
	    baseUniq = __webpack_require__(424),
	    isIterateeCall = __webpack_require__(238);

	/**
	 * An implementation of `_.uniq` optimized for sorted arrays without support
	 * for callback shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 */
	function sortedUniq(array, iteratee) {
	  var seen,
	      index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];

	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;

	    if (!index || seen !== computed) {
	      seen = computed;
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurence of each element
	 * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	 * for sorted arrays. If an iteratee function is provided it is invoked for
	 * each element in the array to generate the criterion by which uniqueness
	 * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index, array).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias unique
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {boolean} [isSorted] Specify the array is sorted.
	 * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 *
	 * // using `isSorted`
	 * _.uniq([1, 1, 2], true);
	 * // => [1, 2]
	 *
	 * // using an iteratee function
	 * _.uniq([1, 2.5, 1.5, 2], function(n) {
	 *   return this.floor(n);
	 * }, Math);
	 * // => [1, 2.5]
	 *
	 * // using the `_.property` callback shorthand
	 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }, { 'x': 2 }]
	 */
	function uniq(array, isSorted, iteratee, thisArg) {
	  var length = array ? array.length : 0;
	  if (!length) {
	    return [];
	  }
	  if (isSorted != null && typeof isSorted != 'boolean') {
	    thisArg = iteratee;
	    iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	    isSorted = false;
	  }
	  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
	  return (isSorted)
	    ? sortedUniq(array, iteratee)
	    : baseUniq(array, iteratee);
	}

	module.exports = uniq;


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseIndexOf = __webpack_require__(425),
	    cacheIndexOf = __webpack_require__(426),
	    createCache = __webpack_require__(427);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniq` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The function invoked per iteration.
	 * @returns {Array} Returns the new duplicate-value-free array.
	 */
	function baseUniq(array, iteratee) {
	  var index = -1,
	      indexOf = baseIndexOf,
	      length = array.length,
	      isCommon = true,
	      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	      seen = isLarge ? createCache() : null,
	      result = [];

	  if (seen) {
	    indexOf = cacheIndexOf;
	    isCommon = false;
	  } else {
	    isLarge = false;
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value, index, array) : value;

	    if (isCommon && value === value) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (indexOf(seen, computed, 0) < 0) {
	      if (iteratee || isLarge) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseUniq;


/***/ },
/* 425 */
/***/ function(module, exports) {

	/**
	 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * The base implementation of `_.indexOf` without support for binary searches.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return indexOfNaN(array, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * Gets the index at which the first occurrence of `NaN` is found in `array`.
	 * If `fromRight` is provided elements of `array` are iterated from right to left.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	 */
	function indexOfNaN(array, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 0 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    var other = array[index];
	    if (other !== other) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseIndexOf;


/***/ },
/* 426 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Checks if `value` is in `cache` mimicking the return signature of
	 * `_.indexOf` by returning `0` if the value is found, else `-1`.
	 *
	 * @private
	 * @param {Object} cache The cache to search.
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `0` if `value` is found, else `-1`.
	 */
	function cacheIndexOf(cache, value) {
	  var data = cache.data,
	      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	  return result ? 0 : -1;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = cacheIndexOf;


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(230);

	/** Native method references. */
	var Set = getNative(global, 'Set');

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeCreate = getNative(Object, 'create');

	/**
	 *
	 * Creates a cache object to store unique values.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var length = values ? values.length : 0;

	  this.data = { 'hash': nativeCreate(null), 'set': new Set };
	  while (length--) {
	    this.push(values[length]);
	  }
	}

	/**
	 * Adds `value` to the cache.
	 *
	 * @private
	 * @name push
	 * @memberOf SetCache
	 * @param {*} value The value to cache.
	 */
	function cachePush(value) {
	  var data = this.data;
	  if (typeof value == 'string' || isObject(value)) {
	    data.set.add(value);
	  } else {
	    data.hash[value] = true;
	  }
	}

	/**
	 * Creates a `Set` cache object to optimize linear searches of large arrays.
	 *
	 * @private
	 * @param {Array} [values] The values to cache.
	 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	 */
	function createCache(values) {
	  return (nativeCreate && Set) ? new SetCache(values) : null;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	// Add functions to the `Set` cache.
	SetCache.prototype.push = cachePush;

	module.exports = createCache;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	var createHash = __webpack_require__(277);
	var createHmac = __webpack_require__(305);
	var getHashes = __webpack_require__(429);

	var mapping = {
	    md2: 'md2',
	    md5: 'md5',
	    'sha-1': 'sha1',
	    'sha-224': 'sha224',
	    'sha-256': 'sha256',
	    'sha-384': 'sha384',
	    'sha-512': 'sha512'
	};

	var names = Object.keys(mapping);


	exports.getHashes = function () {
	    var result = [];
	    var available = getHashes();
	    for (var i = 0, len = names.length; i < len; i++) {
	        if (available.indexOf(mapping[names[i]]) >= 0) {
	            result.push(names[i]);
	        }
	    }
	    return result;
	};

	exports.createHash = function (algorithm) {
	    algorithm = algorithm.toLowerCase();
	    if (mapping[algorithm]) {
	        algorithm = mapping[algorithm];
	    }
	    return createHash(algorithm);
	};

	exports.createHmac = function (algorithm, key) {
	    algorithm = algorithm.toLowerCase();
	    if (mapping[algorithm]) {
	        algorithm = mapping[algorithm];
	    }
	    return createHmac(algorithm, key);
	};


/***/ },
/* 429 */
/***/ function(module, exports) {

	module.exports = function () {
	    return ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'];
	};


/***/ },
/* 430 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:attention:0');


	    client.getAttention = function (jid, opts) {
	        opts = opts || {};
	        opts.to = jid;
	        opts.type = 'headline';
	        opts.attention = true;
	        client.sendMessage(opts);
	    };

	    client.on('message', function (msg) {
	        if (msg.attention) {
	            client.emit('attention', msg);
	        }
	    });
	};


/***/ },
/* 431 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:avatar:metadata+notify');

	    client.on('pubsub:event', function (msg) {
	        if (!msg.event.updated) {
	            return;
	        }
	        if (msg.event.updated.node !== 'urn:xmpp:avatar:metadata') {
	            return;
	        }

	        client.emit('avatar', {
	            jid: msg.from,
	            source: 'pubsub',
	            avatars: msg.event.updated.published[0].avatars
	        });
	    });

	    client.on('presence', function (pres) {
	        if (pres.avatarId) {
	            client.emit('avatar', {
	                jid: pres.from,
	                source: 'vcard',
	                avatars: [{
	                    id: pres.avatarId
	                }]
	            });
	        }
	    });

	    client.publishAvatar = function (id, data, cb) {
	        return this.publish('', 'urn:xmpp:avatar:data', {
	            id: id,
	            avatarData: data
	        }, cb);
	    };

	    client.useAvatars = function (info, cb) {
	        return this.publish('', 'urn:xmpp:avatar:metadata', {
	            id: 'current',
	            avatars: info
	        }, cb);
	    };

	    client.getAvatar = function (jid, id, cb) {
	        return this.getItem(jid, 'urn:xmpp:avatar:data', id, cb);
	    };
	};


/***/ },
/* 432 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:blocking');

	    client.block = function (jid, cb) {
	        return client.sendIq({
	            type: 'set',
	            block: {
	                jids: [jid]
	            }
	        }, cb);
	    };

	    client.unblock = function (jid, cb) {
	        return client.sendIq({
	            type: 'set',
	            unblock: {
	                jids: [jid]
	            }
	        }, cb);
	    };

	    client.getBlocked = function (cb) {
	        return client.sendIq({
	            type: 'get',
	            blockList: true
	        }, cb);
	    };

	    client.on('iq:set:block', function (iq) {
	        client.emit('block', {
	            jids: iq.block.jids || []
	        });
	        client.sendIq(iq.resultReply());
	    });

	    client.on('iq:set:unblock', function (iq) {
	        client.emit('unblock', {
	            jids: iq.unblock.jids || []
	        });
	        client.sendIq(iq.resultReply());
	    });
	};


/***/ },
/* 433 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:bob');

	    client.getBits = function (jid, cid, cb) {
	        return client.sendIq({
	            to: jid,
	            type: 'get',
	            bob: {
	                cid: cid
	            }
	        }, cb);
	    };
	};


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var extend = __webpack_require__(234);
	var filter = __webpack_require__(414);

	var JID = __webpack_require__(222).JID;


	module.exports = function (client) {

	    client.getBookmarks = function (cb) {
	        return this.getPrivateData({bookmarks: true}, cb);
	    };

	    client.setBookmarks = function (opts, cb) {
	        return this.setPrivateData({bookmarks: opts}, cb);
	    };

	    client.addBookmark = function (bookmark, cb) {
	        bookmark.jid = new JID(bookmark.jid);

	        return this.getBookmarks().then(function (res) {
	            var bookmarks = res.privateStorage.bookmarks.conferences || [];
	            var existing = filter(bookmarks, function (bm) {
	                return bm.jid.bare === bookmark.jid.bare;
	            });

	            if (existing.length) {
	                extend(existing[0], bookmark);
	            } else {
	                bookmarks.push(bookmark);
	            }

	            return client.setBookmarks({conferences: bookmarks});
	        }).nodeify(cb);
	    };

	    client.removeBookmark = function (jid, cb) {
	        jid = new JID(jid);
	        return this.getBookmarks().then(function (res) {
	            var bookmarks = res.privateStorage.bookmarks.conferences || [];
	            bookmarks = filter(bookmarks, function (bm) {
	                return jid.bare !== bm.jid.bare;
	            });
	            return client.setBookmarks({conferences: bookmarks});
	        }).nodeify(cb);
	    };
	};


/***/ },
/* 435 */
/***/ function(module, exports) {

	'use strict';



	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:carbons:2');

	    client.enableCarbons = function (cb) {
	        return this.sendIq({
	            type: 'set',
	            enableCarbons: true
	        }, cb);
	    };

	    client.disableCarbons = function (cb) {
	        return this.sendIq({
	            type: 'set',
	            disableCarbons: true
	        }, cb);
	    };

	    client.on('message', function (msg) {
	        if (msg.carbonSent) {
	            return client.emit('carbon:sent', msg);
	        }
	        if (msg.carbonReceived) {
	            return client.emit('carbon:received', msg);
	        }
	    });

	    client.on('carbon:*', function (name, carbon) {
	        var dir = name.split(':')[1];

	        if (carbon.from.bare !== client.jid.bare) {
	            return;
	        }

	        var msg, delay;
	        if (dir === 'received') {
	            msg = carbon.carbonReceived.forwarded.message;
	            delay = carbon.carbonReceived.forwarded.delay;
	        } else {
	            msg = carbon.carbonSent.forwarded.message;
	            delay = carbon.carbonSent.forwarded.delay;
	        }

	        if (!msg.delay) {
	            if (delay) {
	                msg.delay.stamp = delay.stamp;
	            } else {
	                msg.delay = {
	                    stamp: new Date(Date.now())
	                };
	            }
	        }

	        msg.carbon = true;

	        // Treat the carbon copied message however we would
	        // have originally treated it ourself.
	        if (msg.from.bare === client.jid.bare) {
	            client.emit('message:sent', msg);
	        } else {
	            client.emit('message', msg);
	        }
	    });
	};


/***/ },
/* 436 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('http://jabber.org/protocol/chatstates');

	    client.on('message', function (msg) {
	        if (msg.chatState) {
	            client.emit('chat:state', {
	                to: msg.to,
	                from: msg.from,
	                chatState: msg.chatState
	            });
	            client.emit('chatState', {
	                to: msg.to,
	                from: msg.from,
	                chatState: msg.chatState
	            });
	        }
	    });
	};


/***/ },
/* 437 */
/***/ function(module, exports) {

	'use strict';


	var NS = 'http://jabber.org/protocol/commands';


	module.exports = function (client) {

	    client.disco.addFeature(NS);
	    client.disco.addItem({
	        name: 'Ad-Hoc Commands',
	        node: NS
	    });


	    client.getCommands = function (jid, cb) {
	        return client.getDiscoItems(jid, NS, cb);
	    };
	};


/***/ },
/* 438 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:message-correct:0');

	    client.on('message', function (msg) {
	        if (msg.replace) {
	            client.emit('replace', msg);
	            client.emit('replace:' + msg.id, msg);
	        }
	    });
	};


/***/ },
/* 439 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client, stanzas) {

	    var Active = stanzas.getDefinition('active', 'urn:xmpp:csi');
	    var Inactive = stanzas.getDefinition('inactive', 'urn:xmpp:csi');


	    client.registerFeature('clientStateIndication', 400, function (features, cb) {
	        this.features.negotiated.clientStateIndication = true;
	        cb();
	    });

	    client.markActive = function () {
	        if (this.features.negotiated.clientStateIndication) {
	            this.send(new Active());
	        }
	    };

	    client.markInactive = function () {
	        if (this.features.negotiated.clientStateIndication) {
	            this.send(new Inactive());
	        }
	    };
	};


/***/ },
/* 440 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('jabber:x:data');
	    client.disco.addFeature('urn:xmpp:media-element');
	    client.disco.addFeature('http://jabber.org/protocol/xdata-validate');
	    client.disco.addFeature('http://jabber.org/protocol/xdata-layout');

	    client.on('message', function (msg) {
	        if (msg.form) {
	            client.emit('dataform', msg);
	        }
	    });
	};


/***/ },
/* 441 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:delay');
	};


/***/ },
/* 442 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('jid\\20escaping');
	};


/***/ },
/* 443 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:extdisco:1');

	    client.getServices = function (jid, type, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            services: {
	                type: type
	            }
	        }, cb);
	    };

	    client.getServiceCredentials = function (jid, host, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            credentials: {
	                service: {
	                    host: host
	                }
	            }
	        }, cb);
	    };
	};


/***/ },
/* 444 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:forward:0');
	};


/***/ },
/* 445 */
/***/ function(module, exports) {

	'use strict';



	module.exports = function (client) {

	    client.disco.addFeature('http://jabber.org/protocol/geoloc');
	    client.disco.addFeature('http://jabber.org/protocol/geoloc+notify');

	    client.on('pubsub:event', function (msg) {
	        if (!msg.event.updated) {
	            return;
	        }
	        if (msg.event.updated.node !== 'http://jabber.org/protocol/geoloc') {
	            return;
	        }

	        client.emit('geoloc', {
	            jid: msg.from,
	            geoloc: msg.event.updated.published[0].geoloc
	        });
	    });

	    client.publishGeoLoc = function (data, cb) {
	        return this.publish('', 'http://jabber.org/protocol/geoloc', {
	            geoloc: data
	        }, cb);
	    };
	};


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hashes = __webpack_require__(428);


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:hashes:1');

	    var names = hashes.getHashes();
	    names.forEach(function (name) {
	        client.disco.addFeature('urn:xmpp:hash-function-text-names:' + name);
	    });
	};


/***/ },
/* 447 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:idle:1');
	};


/***/ },
/* 448 */
/***/ function(module, exports) {

	'use strict';



	module.exports = function (client) {

	    client.goInvisible = function (cb) {
	        return this.sendIq({
	            type: 'set',
	            invisible: true
	        }, cb);
	    };

	    client.goVisible = function (cb) {
	        return this.sendIq({
	            type: 'set',
	            visible: true
	        }, cb);
	    };
	};


/***/ },
/* 449 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.prepJID = function (jid, cb) {
	        return client.sendIq({
	            to: client.jid.domain,
	            type: 'get',
	            jidPrep: jid
	        }, cb);
	    };
	};


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Jingle = __webpack_require__(451);


	module.exports = function (client) {

	    var jingle = client.jingle = new Jingle();

	    jingle.capabilities.forEach(function (cap) {
	        client.disco.addFeature(cap);
	    });

	    var mappedEvents = [
	        'outgoing', 'incoming', 'accepted', 'terminated',
	        'ringing', 'mute', 'unmute', 'hold', 'resumed'
	    ];
	    mappedEvents.forEach(function (event) {
	        jingle.on(event, function (session, arg1) {
	            client.emit('jingle:' + event, session, arg1);
	        });
	    });

	    jingle.on('createdSession', function (session) {
	        client.emit('jingle:created', session);
	    });

	    jingle.on('peerStreamAdded', function (session, stream) {
	        client.emit('jingle:remotestream:added', session, stream);
	    });

	    jingle.on('peerStreamRemoved', function (session, stream) {
	        client.emit('jingle:remotestream:removed', session, stream);
	    });

	    jingle.on('send', function (data) {
	        client.sendIq(data, function (err) {
	            if (err) {
	                client.emit('jingle:error', err);
	            }
	        });
	    });

	    client.on('session:bound', function (jid) {
	        jingle.jid = jid;
	        jingle.selfID = jid.full;
	    });

	    client.on('iq:set:jingle', function (data) {
	        jingle.process(data);
	    });

	    client.on('unavailable', function (pres) {
	        var peer = pres.from.full;
	        jingle.endPeerSessions(peer, true);
	    });

	    client.discoverICEServers = function (cb) {
	        return this.getServices(client.config.server).then(function (res) {
	            var services = res.services.services;
	            var discovered = [];

	            for (var i = 0; i < services.length; i++) {
	                var service = services[i];
	                var ice = {};
	                if (service.type === 'stun' || service.type === 'stuns') {
	                    ice.url = service.type + ':' + service.host;
	                    if (service.port) {
	                        ice.url += ':' + service.port;
	                    }
	                    discovered.push(ice);
	                    client.jingle.addICEServer(ice);
	                } else if (service.type === 'turn' || service.type === 'turns') {
	                    ice.url = service.type + ':' + service.host;
	                    if (service.port) {
	                        ice.url += ':' + service.port;
	                    }
	                    if (service.transport && service.transport !== 'udp') {
	                        ice.url += '?transport=' + service.transport;
	                    }

	                    if (service.username) {
	                        ice.username = service.username;
	                    }
	                    if (service.password) {
	                        ice.credential = service.password;
	                    }
	                    discovered.push(ice);
	                    client.jingle.addICEServer(ice);
	                }
	            }

	            return discovered;
	        }).nodeify(cb);
	    };
	};


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var util = __webpack_require__(197);
	var intersect = __webpack_require__(452);
	var WildEmitter = __webpack_require__(453);
	var webrtc = __webpack_require__(454);

	var BaseSession = __webpack_require__(455);
	var MediaSession = __webpack_require__(458);
	var FileSession = __webpack_require__(479);


	function SessionManager(conf) {
	    WildEmitter.call(this);

	    conf = conf || {};

	    this.jid = conf.jid;
	    this.selfID = conf.selfID || (this.jid && this.jid.full) || this.jid || '';

	    this.sessions = {};
	    this.peers = {};

	    this.prepareSession = conf.prepareSession || function (opts) {
	        if (opts.applicationTypes.indexOf('rtp') >= 0) {
	            return new MediaSession(opts);
	        }
	        if (opts.applicationTypes.indexOf('filetransfer') >= 0) {
	            return new FileSession(opts);
	        }
	    };

	    this.performTieBreak = conf.performTieBreak || function (sess, req) {
	        var applicationTypes= req.jingle.contents.map(function (content) {
	            if (content.application) {
	                return content.application.applicationType;
	            }
	        });

	        var matching = intersect(sess.pendingApplicationTypes, applicationTypes);

	        return matching.length > 0;
	    };

	    this.screenSharingSupport = webrtc.screenSharing;

	    this.capabilities = [
	        'urn:xmpp:jingle:1'
	    ];
	    if (webrtc.support) {
	        this.capabilities = [
	            'urn:xmpp:jingle:1',
	            'urn:xmpp:jingle:apps:rtp:1',
	            'urn:xmpp:jingle:apps:rtp:audio',
	            'urn:xmpp:jingle:apps:rtp:video',
	            'urn:xmpp:jingle:apps:rtp:rtcb-fb:0',
	            'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
	            'urn:xmpp:jingle:apps:rtp:ssma:0',
	            'urn:xmpp:jingle:apps:dtls:0',
	            'urn:xmpp:jingle:apps:grouping:0',
	            'urn:xmpp:jingle:apps:file-transfer:3',
	            'urn:xmpp:jingle:transports:ice-udp:1',
	            'urn:xmpp:jingle:transports.dtls-sctp:1',
	            'urn:ietf:rfc:3264',
	            'urn:ietf:rfc:5576',
	            'urn:ietf:rfc:5888'
	        ];
	    }

	    this.config = {
	        debug: false,
	        peerConnectionConfig: {
	            iceServers: conf.iceServers || [{'url': 'stun:stun.l.google.com:19302'}]
	        },
	        peerConnectionConstraints: {
	            optional: [
	                {DtlsSrtpKeyAgreement: true},
	                {RtpDataChannels: false}
	            ]
	        },
	        media: {
	            audio: true,
	            video: true
	        }
	    };

	    for (var item in conf) {
	        this.config[item] = conf[item];
	    }

	    this.iceServers = this.config.peerConnectionConfig.iceServers;
	}


	util.inherits(SessionManager, WildEmitter);


	SessionManager.prototype.addICEServer = function (server) {
	    // server == {
	    //    url: '',
	    //    [username: '',]
	    //    [credential: '']
	    // }
	    if (typeof server === 'string') {
	        server = {url: server};
	    }
	    this.iceServers.push(server);
	};

	SessionManager.prototype.addSession = function (session) {
	    var self = this;

	    var sid = session.sid;
	    var peer = session.peerID;

	    this.sessions[sid] = session;
	    if (!this.peers[peer]) {
	        this.peers[peer] = [];
	    }

	    this.peers[peer].push(session);

	    // Automatically clean up tracked sessions
	    session.on('terminated', function () {
	        var peers = self.peers[peer] || [];
	        if (peers.length) {
	            peers.splice(peers.indexOf(session), 1);
	        }
	        delete self.sessions[sid];
	    });

	    // Proxy session events
	    session.on('*', function (name, data, extraData, extraData2) {
	        // Listen for when we actually try to start a session to
	        // trigger the outgoing event.
	        if (name === 'send') {
	            var action = data.jingle && data.jingle.action;
	            if (session.isInitiator && action === 'session-initiate') {
	                self.emit('outgoing', session);
	            }
	        }

	        if (self.config.debug && (name === 'log:debug' || name === 'log:error')) {
	            console.log('Jingle:', data, extraData, extraData2);
	        }

	        // Don't proxy change:* events, since those don't apply to
	        // the session manager itself.
	        if (name.indexOf('change') === 0) {
	            return;
	        }

	        self.emit(name, data, extraData, extraData2);
	    });

	    this.emit('createdSession', session);

	    return session;
	};

	SessionManager.prototype.createMediaSession = function (peer, sid, stream) {
	    var session = new MediaSession({
	        sid: sid,
	        peer: peer,
	        initiator: true,
	        stream: stream,
	        parent: this,
	        iceServers: this.iceServers,
	        constraints: this.config.peerConnectionConstraints
	    });

	    this.addSession(session);

	    return session;
	};

	SessionManager.prototype.createFileTransferSession = function (peer, sid) {
	    var session = new FileSession({
	        sid: sid,
	        peer: peer,
	        initiator: true,
	        parent: this
	    });

	    this.addSession(session);

	    return session;
	};

	SessionManager.prototype.endPeerSessions = function (peer, reason, silent) {
	    peer = peer.full || peer;

	    var sessions = this.peers[peer] || [];
	    delete this.peers[peer];

	    sessions.forEach(function (session) {
	        session.end(reason || 'gone', silent);
	    });
	};

	SessionManager.prototype.endAllSessions = function (reason, silent) {
	    var self = this;
	    Object.keys(this.peers).forEach(function (peer) {
	        self.endPeerSessions(peer, reason, silent);
	    });
	};

	SessionManager.prototype._createIncomingSession = function (meta, req) {
	    var session;

	    if (this.prepareSession) {
	        session = this.prepareSession(meta, req);
	    }

	    // Fallback to a generic session type, which can
	    // only be used to end the session.

	    if (!session) {
	        session = new BaseSession(meta);
	    }

	    this.addSession(session);

	    return session;
	};

	SessionManager.prototype._sendError = function (to, id, data) {
	    if (!data.type) {
	        data.type = 'cancel';
	    }
	    this.emit('send', {
	        to: to,
	        id: id,
	        type: 'error',
	        error: data
	    });
	};

	SessionManager.prototype._log = function (level, message) {
	    this.emit('log:' + level, message);
	};

	SessionManager.prototype.process = function (req) {
	    var self = this;

	    // Extract the request metadata that we need to verify
	    var sid = !!req.jingle ? req.jingle.sid : null;
	    var session = this.sessions[sid] || null;
	    var rid = req.id;
	    var sender = req.from.full || req.from;


	    if (req.type === 'error') {
	        var isTieBreak = req.error && req.error.jingleCondition === 'tie-break';
	        if (session && session.pending && isTieBreak) {
	            return session.end('alternative-session', true);
	        } else {
	            if (session) {
	                session.pendingAction = false;
	            }
	            return this.emit('error', req);
	        }
	    }

	    if (req.type === 'result') {
	        if (session) {
	            session.pendingAction = false;
	        }
	        return;
	    }

	    var action = req.jingle.action;
	    var contents = req.jingle.contents || [];

	    var applicationTypes = contents.map(function (content) {
	        if (content.application) {
	            return content.application.applicationType;
	        }
	    });
	    var transportTypes = contents.map(function (content) {
	        if (content.transport) {
	            return content.transport.transportType;
	        }
	    });


	    // Now verify that we are allowed to actually process the
	    // requested action

	    if (action !== 'session-initiate') {
	        // Can't modify a session that we don't have.
	        if (!session) {
	            this._log('error', 'Unknown session', sid);
	            return this._sendError(sender, rid, {
	                condition: 'item-not-found',
	                jingleCondition: 'unknown-session'
	            });
	        }

	        // Check if someone is trying to hijack a session.
	        if (session.peerID !== sender || session.ended) {
	            this._log('error', 'Session has ended, or action has wrong sender');
	            return this._sendError(sender, rid, {
	                condition: 'item-not-found',
	                jingleCondition: 'unknown-session'
	            });
	        }

	        // Can't accept a session twice
	        if (action === 'session-accept' && !session.pending) {
	            this._log('error', 'Tried to accept session twice', sid);
	            return this._sendError(sender, rid, {
	                condition: 'unexpected-request',
	                jingleCondition: 'out-of-order'
	            });
	        }

	        // Can't process two requests at once, need to tie break
	        if (action !== 'session-terminate' && action === session.pendingAction) {
	            this._log('error', 'Tie break during pending request');
	            if (session.isInitiator) {
	                return this._sendError(sender, rid, {
	                    condition: 'conflict',
	                    jingleCondition: 'tie-break'
	                });
	            }
	        }
	    } else if (session) {
	        // Don't accept a new session if we already have one.
	        if (session.peerID !== sender) {
	            this._log('error', 'Duplicate sid from new sender');
	            return this._sendError(sender, rid, {
	                condition: 'service-unavailable'
	            });
	        }

	        // Check if we need to have a tie breaker because both parties
	        // happened to pick the same random sid.
	        if (session.pending) {
	            if (this.selfID > session.peerID && this.performTieBreak(session, req)) {
	                this._log('error', 'Tie break new session because of duplicate sids');
	                return this._sendError(sender, rid, {
	                    condition: 'conflict',
	                    jingleCondition: 'tie-break'
	                });
	            }
	        } else {
	            // The other side is just doing it wrong.
	            this._log('error', 'Someone is doing this wrong');
	            return this._sendError(sender, rid, {
	                condition: 'unexpected-request',
	                jingleCondition: 'out-of-order'
	            });
	        }
	    } else if (this.peers[sender] && this.peers[sender].length) {
	        // Check if we need to have a tie breaker because we already have
	        // a different session with this peer that is using the requested
	        // content application types.
	        for (var i = 0, len = this.peers[sender].length; i < len; i++) {
	            var sess = this.peers[sender][i];
	            if (sess && sess.pending && sess.sid > sid && this.performTieBreak(sess, req)) {
	                this._log('info', 'Tie break session-initiate');
	                return this._sendError(sender, rid, {
	                    condition: 'conflict',
	                    jingleCondition: 'tie-break'
	                });
	            }
	        }
	    }

	    // We've now weeded out invalid requests, so we can process the action now.

	    if (action === 'session-initiate') {
	        if (!contents.length) {
	            return self._sendError(sender, rid, {
	                condition: 'bad-request'
	            });
	        }

	        session = this._createIncomingSession({
	            sid: sid,
	            peer: req.from,
	            peerID: sender,
	            initiator: false,
	            parent: this,
	            applicationTypes: applicationTypes,
	            transportTypes: transportTypes,
	            iceServers: this.iceServers,
	            constraints: this.config.peerConnectionConstraints
	        }, req);
	    }

	    session.process(action, req.jingle, function (err) {
	        if (err) {
	            self._log('error', 'Could not process request', req, err);
	            self._sendError(sender, rid, err);
	        } else {
	            self.emit('send', {
	                to: sender,
	                id: rid,
	                type: 'result',
	            });

	            // Wait for the initial action to be processed before emitting
	            // the session for the user to accept/reject.
	            if (action === 'session-initiate') {
	                self.emit('incoming', session);
	            }
	        }
	    });
	};


	module.exports = SessionManager;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 452 */
/***/ function(module, exports) {

	module.exports = intersect;

	function intersect (a, b) {
	  var res = [];
	  for (var i = 0; i < a.length; i++) {
	    if (indexOf(b, a[i]) > -1) res.push(a[i]);
	  }
	  return res;
	}

	intersect.big = function(a, b) {
	  var ret = [];
	  var temp = {};
	  
	  for (var i = 0; i < b.length; i++) {
	    temp[b[i]] = true;
	  }
	  for (var i = 0; i < a.length; i++) {
	    if (temp[a[i]]) ret.push(a[i]);
	  }
	  
	  return ret;
	}

	function indexOf(arr, el) {
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i] === el) return i;
	  }
	  return -1;
	}


/***/ },
/* 453 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 454 */
/***/ function(module, exports) {

	// created by @HenrikJoreteg
	var prefix;
	var version;

	if (window.mozRTCPeerConnection || navigator.mozGetUserMedia) {
	    prefix = 'moz';
	    version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
	} else if (window.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
	    prefix = 'webkit';
	    version = navigator.userAgent.match(/Chrom(e|ium)/) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
	}

	var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
	var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
	var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
	var MediaStream = window.webkitMediaStream || window.MediaStream;
	var screenSharing = window.location.protocol === 'https:' &&
	    ((prefix === 'webkit' && version >= 26) ||
	     (prefix === 'moz' && version >= 33))
	var AudioContext = window.AudioContext || window.webkitAudioContext;
	var videoEl = document.createElement('video');
	var supportVp8 = videoEl && videoEl.canPlayType && videoEl.canPlayType('video/webm; codecs="vp8", vorbis') === "probably";
	var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia;

	// export support flags and constructors.prototype && PC
	module.exports = {
	    prefix: prefix,
	    browserVersion: version,
	    support: !!PC && supportVp8 && !!getUserMedia,
	    // new support style
	    supportRTCPeerConnection: !!PC,
	    supportVp8: supportVp8,
	    supportGetUserMedia: !!getUserMedia,
	    supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
	    supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
	    supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
	    supportScreenSharing: !!screenSharing,
	    // old deprecated style. Dont use this anymore
	    dataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
	    webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
	    mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
	    screenSharing: !!screenSharing,
	    // constructors
	    AudioContext: AudioContext,
	    PeerConnection: PC,
	    SessionDescription: SessionDescription,
	    IceCandidate: IceCandidate,
	    MediaStream: MediaStream,
	    getUserMedia: getUserMedia
	};


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(197);
	var uuid = __webpack_require__(241);
	var async = __webpack_require__(218);
	var extend = __webpack_require__(456);
	var WildEmitter = __webpack_require__(457);


	var ACTIONS = {
	    'content-accept': 'onContentAccept',
	    'content-add': 'onContentAdd',
	    'content-modify': 'onConentModify',
	    'content-reject': 'onContentReject',
	    'content-remove': 'onContentRemove',
	    'description-info': 'onDescriptionInfo',
	    'security-info': 'onSecurityInfo',
	    'session-accept': 'onSessionAccept',
	    'session-info': 'onSessionInfo',
	    'session-initiate': 'onSessionInitiate',
	    'session-terminate': 'onSessionTerminate',
	    'transport-accept': 'onTransportAccept',
	    'transport-info': 'onTransportInfo',
	    'transport-reject': 'onTransportReject',
	    'transport-replace': 'onTransportReplace',

	    // Unstandardized actions: might go away anytime without notice
	    'source-add': 'onSourceAdd',
	    'source-remove': 'onSourceRemove'
	};


	function JingleSession(opts) {
	    WildEmitter.call(this);

	    var self = this;

	    this.sid = opts.sid || uuid.v4();
	    this.peer = opts.peer;
	    this.peerID = opts.peerID || this.peer.full || this.peer;
	    this.isInitiator = opts.initiator || false;
	    this.parent = opts.parent;
	    this.state = 'starting';
	    this.connectionState = 'starting';

	    // We track the intial pending description types in case
	    // of the need for a tie-breaker.
	    this.pendingApplicationTypes = opts.applicationTypes || [];

	    this.pendingAction = false;

	    // Here is where we'll ensure that all actions are processed
	    // in order, even if a particular action requires async handling.
	    this.processingQueue = async.queue(function (task, next) {
	        if (self.ended) {
	            // Don't process anything once the session has been ended
	            return next();
	        }

	        var action = task.action;
	        var changes = task.changes;
	        var cb = task.cb;

	        self._log('debug', action);

	        if (!ACTIONS[action]) {
	            self._log('error', 'Invalid action: ' + action);
	            cb({condition: 'bad-request'});
	            return next();
	        }

	        self[ACTIONS[action]](changes, function (err, result) {
	            cb(err, result);
	            return next();
	        });
	    });
	}


	util.inherits(JingleSession, WildEmitter);

	// We don't know how to handle any particular content types,
	// so no actions are supported.
	Object.keys(ACTIONS).forEach(function (action) {
	    var method = ACTIONS[action];
	    JingleSession.prototype[method] = function (changes, cb) {
	        this._log('error', 'Unsupported action: ' + action);
	        cb();
	    };
	});

	// Provide some convenience properties for checking
	// the session's state.
	Object.defineProperties(JingleSession.prototype, {
	    state: {
	        get: function () {
	            return this._sessionState;
	        },
	        set: function (value) {
	            if (value !== this._sessionState) {
	                var prev = this._sessionState;
	                this._log('info', 'Changing session state to: ' + value);
	                this._sessionState = value;
	                this.emit('change:sessionState', this, value);
	                this.emit('change:' + value, this, true);
	                if (prev) {
	                    this.emit('change:' + prev, this, false);
	                }
	            }
	        }
	    },
	    connectionState: {
	        get: function () {
	            return this._connectionState;
	        },
	        set: function (value) {
	            if (value !== this._connectionState) {
	                var prev = this._connectionState;
	                this._log('info', 'Changing connection state to: ' + value);
	                this._connectionState = value;
	                this.emit('change:connectionState', this, value);
	                this.emit('change:' + value, this, true);
	                if (prev) {
	                    this.emit('change:' + prev, this, false);
	                }
	            }
	        }
	    },
	    starting: {
	        get: function () {
	            return this._sessionState === 'starting';
	        }
	    },
	    pending: {
	        get: function () {
	            return this._sessionState === 'pending';
	        }
	    },
	    active: {
	        get: function () {
	            return this._sessionState === 'active';
	        }
	    },
	    ended: {
	        get: function () {
	            return this._sessionState === 'ended';
	        }
	    },
	    connected: {
	        get: function () {
	            return this._connectionState === 'connected';
	        }
	    },
	    connecting: {
	        get: function () {
	            return this._connectionState === 'connecting';
	        }
	    },
	    disconnected: {
	        get: function () {
	            return this._connectionState === 'disconnected';
	        }
	    },
	    interrupted: {
	        get: function () {
	            return this._connectionState === 'interrupted';
	        }
	    }
	});

	JingleSession.prototype = extend(JingleSession.prototype, {
	    _log: function (level, message) {
	        message = this.sid + ': ' + message;
	        this.emit('log:' + level, message);
	    },
	    
	    send: function (action, data) {
	        data = data || {};
	        data.sid = this.sid;
	        data.action = action;

	        var requirePending = {
	            'session-inititate': true,
	            'session-accept': true,
	            'content-add': true,
	            'content-remove': true,
	            'content-reject': true,
	            'content-accept': true,
	            'content-modify': true,
	            'transport-replace': true,
	            'transport-reject': true,
	            'transport-accept': true,
	            'source-add': true,
	            'source-remove': true
	        };

	        if (requirePending[action]) {
	            this.pendingAction = action;
	        } else {
	            this.pendingAction = false;
	        }

	        this.emit('send', {
	            to: this.peer,
	            type: 'set',
	            jingle: data
	        });
	    },
	    
	    process: function (action, changes, cb) {
	        this.processingQueue.push({
	            action: action,
	            changes: changes,
	            cb: cb
	        });
	    },
	    
	    start: function () {
	        this._log('error', 'Can not start base sessions');
	        this.end('unsupported-applications', true);
	    },
	    
	    accept: function () {
	        this._log('error', 'Can not accept base sessions');
	        this.end('unsupported-applications');
	    },
	    
	    cancel: function () {
	        this.end('cancel');
	    },
	    
	    decline: function () {
	        this.end('decline');
	    },
	    
	    end: function (reason, silent) {
	        this.state = 'ended';

	        this.processingQueue.kill();

	        if (!reason) {
	            reason = 'success';
	        }

	        if (typeof reason === 'string') {
	            reason = {
	                condition: reason
	            };
	        }
	    
	        if (!silent) {
	            this.send('session-terminate', {
	                reason: reason
	            });
	        }
	    
	        this.emit('terminated', this, reason);
	    },

	    onSessionTerminate: function (changes, cb) {
	        this.end(changes.reason, true);
	        cb();
	    },

	    // It is mandatory to reply to a session-info action with 
	    // an unsupported-info error if the info isn't recognized.
	    //
	    // However, a session-info action with no associated payload
	    // is acceptable (works like a ping).
	    onSessionInfo: function (changes, cb) {
	        var okKeys = {
	            sid: true,
	            action: true,
	            initiator: true,
	            responder: true
	        };

	        var unknownPayload = false;
	        Object.keys(changes).forEach(function (key) {
	            if (!okKeys[key]) {
	                unknownPayload = true;
	            }
	        });

	        if (unknownPayload) {
	            cb({
	                type: 'modify',
	                condition: 'feature-not-implemented',
	                jingleCondition: 'unsupported-info'
	            });
	        } else {
	            cb();
	        }
	    },

	    // It is mandatory to reply to a description-info action with 
	    // an unsupported-info error if the info isn't recognized.
	    onDescriptionInfo: function (changes, cb) {
	        cb({
	            type: 'modify',
	            condition: 'feature-not-implemented',
	            jingleCondition: 'unsupported-info'
	        });
	    },

	    // It is mandatory to reply to a transport-info action with 
	    // an unsupported-info error if the info isn't recognized.
	    onTransportInfo: function (changes, cb) {
	        cb({
	            type: 'modify',
	            condition: 'feature-not-implemented',
	            jingleCondition: 'unsupported-info'
	        });
	    },

	    // It is mandatory to reply to a content-add action with either
	    // a content-accept or content-reject.
	    onContentAdd: function (changes, cb) {
	        // Allow ack for the content-add to be sent.
	        cb();

	        this.send('content-reject', {
	            reason: {
	                condition: 'failed-application',
	                text: 'content-add is not supported'
	            }
	        });
	    },

	    // It is mandatory to reply to a transport-add action with either
	    // a transport-accept or transport-reject.
	    onTransportReplace: function (changes, cb) {
	        // Allow ack for the transport-replace be sent.
	        cb();

	        this.send('transport-reject', {
	            reason: {
	                condition: 'failed-application',
	                text: 'transport-replace is not supported'
	            }
	        });
	    }
	});


	module.exports = JingleSession;


/***/ },
/* 456 */
/***/ function(module, exports) {

	var arr = [];
	var each = arr.forEach;
	var slice = arr.slice;


	module.exports = function(obj) {
	    each.call(slice.call(arguments, 1), function(source) {
	        if (source) {
	            for (var prop in source) {
	                obj[prop] = source[prop];
	            }
	        }
	    });
	    return obj;
	};


/***/ },
/* 457 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(197);
	var extend = __webpack_require__(456);
	var BaseSession = __webpack_require__(455);
	var RTCPeerConnection = __webpack_require__(459);


	function filterContentSources(content, stream) {
	    if (content.application.applicationType !== 'rtp') {
	        return;
	    }
	    delete content.transport;
	    delete content.application.payloads;
	    delete content.application.headerExtensions;
	    content.application.mux = false;

	    if (content.application.sources) {
	        content.application.sources = content.application.sources.filter(function (source) {
	            return stream.id === source.parameters[1].value.split(' ')[0];
	        });
	    }
	    // remove source groups not related to this stream
	    if (content.application.sourceGroups) {
	        content.application.sourceGroups = content.application.sourceGroups.filter(function (group) {
	            var found = false;
	            for (var i = 0; i < content.application.sources.length; i++) {
	                if (content.application.sources[i].ssrc === group.sources[0]) {
	                    found = true;
	                    break;
	                }
	            }
	            return found;
	        });
	    }
	}

	function filterUnusedLabels(content) {
	    // Remove mslabel and label ssrc-specific attributes
	    var sources = content.application.sources || [];
	    sources.forEach(function (source) {
	        source.parameters = source.parameters.filter(function (parameter) {
	            return !(parameter.key === 'mslabel' || parameter.key === 'label');
	        });
	    });
	}


	function MediaSession(opts) {
	    BaseSession.call(this, opts);

	    this.pc = new RTCPeerConnection({
	        iceServers: opts.iceServers || [],
	        useJingle: true
	    }, opts.constraints || {});

	    this.pc.on('ice', this.onIceCandidate.bind(this));
	    this.pc.on('endOfCandidates', this.onIceEndOfCandidates.bind(this));
	    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
	    this.pc.on('addStream', this.onAddStream.bind(this));
	    this.pc.on('removeStream', this.onRemoveStream.bind(this));
	    this.pc.on('addChannel', this.onAddChannel.bind(this));

	    if (opts.stream) {
	        this.addStream(opts.stream);
	    }

	    this._ringing = false;
	}


	util.inherits(MediaSession, BaseSession);


	Object.defineProperties(MediaSession.prototype, {
	    ringing: {
	        get: function () {
	            return this._ringing;
	        },
	        set: function (value) {
	            if (value !== this._ringing) {
	                this._ringing = value;
	                this.emit('change:ringing', value);
	            }
	        }
	    },
	    streams: {
	        get: function () {
	            if (this.pc.signalingState !== 'closed') {
	                return this.pc.getRemoteStreams();
	            }
	            return [];
	        }
	    }
	});


	MediaSession.prototype = extend(MediaSession.prototype, {

	    // ----------------------------------------------------------------
	    // Session control methods
	    // ----------------------------------------------------------------

	    start: function (offerOptions, next) {
	        var self = this;
	        this.state = 'pending';

	        next = next || function () {};

	        this.pc.isInitiator = true;
	        this.pc.offer(offerOptions, function (err, offer) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC offer', err);
	                return self.end('failed-application', true);
	            }

	            // a workaround for missing a=sendonly
	            // https://code.google.com/p/webrtc/issues/detail?id=1553
	            if (offerOptions && offerOptions.mandatory) {
	                offer.jingle.contents.forEach(function (content) {
	                    var mediaType = content.application.media;

	                    if (!content.description || content.application.applicationType !== 'rtp') {
	                        return;
	                    }

	                    if (!offerOptions.mandatory.OfferToReceiveAudio && mediaType === 'audio') {
	                        content.senders = 'initiator';
	                    }

	                    if (!offerOptions.mandatory.OfferToReceiveVideo && mediaType === 'video') {
	                        content.senders = 'initiator';
	                    }
	                });
	            }

	            offer.jingle.contents.forEach(filterUnusedLabels);

	            self.send('session-initiate', offer.jingle);

	            next();
	        });
	    },

	    accept: function (opts, next) {
	        var self = this;

	        // support calling with accept(next) or accept(opts, next)
	        if (arguments.length === 1 && typeof opts === 'function') {
	            next = opts;
	            opts = {};
	        }
	        next = next || function () {};
	        opts = opts || {};

	        var constraints = opts.constraints || {
	            mandatory: {
	                OfferToReceiveAudio: true,
	                OfferToReceiveVideo: true
	            }
	        };

	        this._log('info', 'Accepted incoming session');

	        this.state = 'active';

	        this.pc.answer(constraints, function (err, answer) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC answer', err);
	                return self.end('failed-application');
	            }

	            answer.jingle.contents.forEach(filterUnusedLabels);

	            self.send('session-accept', answer.jingle);

	            next();
	        });
	    },

	    end: function (reason, silent) {
	        var self = this;
	        this.streams.forEach(function (stream) {
	            self.onRemoveStream({stream: stream});
	        });
	        this.pc.close();
	        BaseSession.prototype.end.call(this, reason, silent);
	    },

	    ring: function () {
	        this._log('info', 'Ringing on incoming session');
	        this.ringing = true;
	        this.send('session-info', {ringing: true});
	    },

	    mute: function (creator, name) {
	        this._log('info', 'Muting', name);

	        this.send('session-info', {
	            mute: {
	                creator: creator,
	                name: name
	            }
	        });
	    },

	    unmute: function (creator, name) {
	        this._log('info', 'Unmuting', name);
	        this.send('session-info', {
	            unmute: {
	                creator: creator,
	                name: name
	            }
	        });
	    },

	    hold: function () {
	        this._log('info', 'Placing on hold');
	        this.send('session-info', {hold: true});
	    },

	    resume: function () {
	        this._log('info', 'Resuming from hold');
	        this.send('session-info', {active: true});
	    },

	    // ----------------------------------------------------------------
	    // Stream control methods
	    // ----------------------------------------------------------------

	    addStream: function (stream, renegotiate, cb) {
	        var self = this;

	        cb = cb || function () {};

	        this.pc.addStream(stream);

	        if (!renegotiate) {
	            return;
	        }

	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: this.pc.remoteDescription
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not create offer for adding new stream');
	                return cb(err);
	            }
	            self.pc.answer(function (err, answer) {
	                if (err) {
	                    self._log('error', 'Could not create answer for adding new stream');
	                    return cb(err);
	                }
	                answer.jingle.contents.forEach(function (content) {
	                    filterContentSources(content, stream);
	                });
	                answer.jingle.contents = answer.jingle.contents.filter(function (content) {
	                    return content.application.applicationType === 'rtp' && content.application.sources && content.application.sources.length;
	                });
	                delete answer.jingle.groups;

	                self.send('source-add', answer.jingle);
	                cb();
	            });
	        });
	    },

	    addStream2: function (stream, cb) {
	        this.addStream(stream, true, cb);
	    },

	    removeStream: function (stream, renegotiate, cb) {
	        var self = this;

	        cb = cb || function () {};

	        if (!renegotiate) {
	            this.pc.removeStream(stream);
	            return;
	        }

	        var desc = this.pc.localDescription;
	        desc.contents.forEach(function (content) {
	            filterContentSources(content, stream);
	        });
	        desc.contents = desc.contents.filter(function (content) {
	            return content.application.applicationType === 'rtp' && content.application.sources && content.application.sources.length;
	        });
	        delete desc.groups;

	        this.send('source-remove', desc);
	        this.pc.removeStream(stream);

	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: this.pc.remoteDescription
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not process offer for removing stream');
	                return cb(err);
	            }
	            self.pc.answer(function (err) {
	                if (err) {
	                    self._log('error', 'Could not process answer for removing stream');
	                    return cb(err);
	                }
	                cb();
	            });
	        });
	    },

	    removeStream2: function (stream, cb) {
	        this.removeStream(stream, true, cb);
	    },

	    switchStream: function (oldStream, newStream, cb) {
	        var self = this;

	        cb = cb || function () {};

	        var desc = this.pc.localDescription;
	        desc.contents.forEach(function (content) {
	            delete content.transport;
	            delete content.application.payloads;
	        });

	        this.pc.removeStream(oldStream);
	        this.send('source-remove', desc);

	        this.pc.addStream(newStream);
	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: this.pc.remoteDescription
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not process offer for switching streams');
	                return cb(err);
	            }
	            self.pc.answer(function (err, answer) {
	                if (err) {
	                    self._log('error', 'Could not process answer for switching streams');
	                    return cb(err);
	                }
	                answer.jingle.contents.forEach(function (content) {
	                    delete content.transport;
	                    delete content.application.payloads;
	                });
	                self.send('source-add', answer.jingle);
	                cb();
	            });
	        });
	    },

	    // ----------------------------------------------------------------
	    // ICE action handers
	    // ----------------------------------------------------------------

	    onIceCandidate: function (candidate) {
	        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
	        this.send('transport-info', candidate.jingle);
	    },

	    onIceEndOfCandidates: function () {
	        this._log('info', 'ICE end of candidates');
	    },

	    onIceStateChange: function () {
	        switch (this.pc.iceConnectionState) {
	            case 'checking':
	                this.connectionState = 'connecting';
	                break;
	            case 'completed':
	            case 'connected':
	                this.connectionState = 'connected';
	                break;
	            case 'disconnected':
	                if (this.pc.signalingState === 'stable') {
	                    this.connectionState = 'interrupted';
	                } else {
	                    this.connectionState = 'disconnected';
	                }
	                break;
	            case 'failed':
	                this.connectionState = 'failed';
	                this.end('failed-transport');
	                break;
	            case 'closed':
	                this.connectionState = 'disconnected';
	                break;
	        }
	    },

	    // ----------------------------------------------------------------
	    // Stream event handlers
	    // ----------------------------------------------------------------

	    onAddStream: function (event) {
	        this._log('info', 'Stream added');
	        this.emit('peerStreamAdded', this, event.stream);
	    },

	    onRemoveStream: function (event) {
	        this._log('info', 'Stream removed');
	        this.emit('peerStreamRemoved', this, event.stream);
	    },

	    // ----------------------------------------------------------------
	    // Jingle action handers
	    // ----------------------------------------------------------------

	    onSessionInitiate: function (changes, cb) {
	        var self = this;

	        this._log('info', 'Initiating incoming session');

	        this.state = 'pending';

	        this.pc.isInitiator = false;
	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: changes
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC answer');
	                return cb({condition: 'general-error'});
	            }
	            cb();
	        });
	    },

	    onSessionAccept: function (changes, cb) {
	        var self = this;

	        this.state = 'active';
	        this.pc.handleAnswer({
	            type: 'answer',
	            jingle: changes
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not process WebRTC answer');
	                return cb({condition: 'general-error'});
	            }
	            self.emit('accepted', self);
	            cb();
	        });
	    },

	    onSessionTerminate: function (changes, cb) {
	        var self = this;

	        this._log('info', 'Terminating session');
	        this.streams.forEach(function (stream) {
	            self.onRemoveStream({stream: stream});
	        });
	        this.pc.close();
	        BaseSession.prototype.end.call(this, changes.reason, true);

	        cb();
	    },

	    onSessionInfo: function (info, cb) {
	        if (info.ringing) {
	            this._log('info', 'Outgoing session is ringing');
	            this.ringing = true;
	            this.emit('ringing', this);
	            return cb();
	        }

	        if (info.hold) {
	            this._log('info', 'On hold');
	            this.emit('hold', this);
	            return cb();
	        }

	        if (info.active) {
	            this._log('info', 'Resuming from hold');
	            this.emit('resumed', this);
	            return cb();
	        }

	        if (info.mute) {
	            this._log('info', 'Muting', info.mute);
	            this.emit('mute', this, info.mute);
	            return cb();
	        }

	        if (info.unmute) {
	            this._log('info', 'Unmuting', info.unmute);
	            this.emit('unmute', this, info.unmute);
	            return cb();
	        }

	        cb();
	    },

	    onTransportInfo: function (changes, cb) {
	        this.pc.processIce(changes, function () {
	            cb();
	        });
	    },

	    onSourceAdd: function (changes, cb) {
	        var self = this;
	        this._log('info', 'Adding new stream source');

	        var newDesc = this.pc.remoteDescription;
	        this.pc.remoteDescription.contents.forEach(function (content, idx) {
	            var desc = content.application;
	            var ssrcs = desc.sources || [];
	            var groups = desc.sourceGroups || [];

	            changes.contents.forEach(function (newContent) {
	                if (content.name !== newContent.name) {
	                    return;
	                }

	                var newContentDesc = newContent.application;
	                var newSSRCs = newContentDesc.sources || [];

	                ssrcs = ssrcs.concat(newSSRCs);
	                newDesc.contents[idx].application.sources = JSON.parse(JSON.stringify(ssrcs));

	                var newGroups = newContentDesc.sourceGroups || [];
	                groups = groups.concat(newGroups);
	                newDesc.contents[idx].application.sourceGroups = JSON.parse(JSON.stringify(groups));
	            });
	        });

	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: newDesc
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Error adding new stream source');
	                return cb({
	                    condition: 'general-error'
	                });
	            }

	            self.pc.answer(function (err) {
	                if (err) {
	                    self._log('error', 'Error adding new stream source');
	                    return cb({
	                        condition: 'general-error'
	                    });
	                }
	                cb();
	            });
	        });
	    },

	    onSourceRemove: function (changes, cb) {
	        var self = this;
	        this._log('info', 'Removing stream source');

	        var newDesc = this.pc.remoteDescription;
	        this.pc.remoteDescription.contents.forEach(function (content, idx) {
	            var desc = content.application;
	            var ssrcs = desc.sources || [];
	            var groups = desc.sourceGroups || [];

	            changes.contents.forEach(function (newContent) {
	                if (content.name !== newContent.name) {
	                    return;
	                }

	                var newContentDesc = newContent.application;
	                var newSSRCs = newContentDesc.sources || [];
	                var newGroups = newContentDesc.sourceGroups || [];

	                var found, i, j, k;


	                for (i = 0; i < newSSRCs.length; i++) {
	                    found = -1;
	                    for (j = 0; j < ssrcs.length; j++) {
	                        if (newSSRCs[i].ssrc === ssrcs[j].ssrc) {
	                            found = j;
	                            break;
	                        }
	                    }
	                    if (found > -1) {
	                        ssrcs.splice(found, 1);
	                        newDesc.contents[idx].application.sources = JSON.parse(JSON.stringify(ssrcs));
	                    }
	                }

	                // Remove ssrc-groups that are no longer needed
	                for (i = 0; i < newGroups.length; i++) {
	                    found = -1;
	                    for (j = 0; j < groups.length; j++) {
	                        if (newGroups[i].semantics === groups[j].semantics &&
	                            newGroups[i].sources.length === groups[j].sources.length) {
	                            var same = true;
	                            for (k = 0; k < newGroups[i].sources.length; k++) {
	                                if (newGroups[i].sources[k] !== groups[j].sources[k]) {
	                                    same = false;
	                                    break;
	                                }
	                            }
	                            if (same) {
	                                found = j;
	                                break;
	                            }
	                        }
	                    }
	                    if (found > -1) {
	                        groups.splice(found, 1);
	                        newDesc.contents[idx].application.sourceGroups = JSON.parse(JSON.stringify(groups));
	                    }
	                }
	            });
	        });

	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: newDesc
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Error removing stream source');
	                return cb({
	                    condition: 'general-error'
	                });
	            }
	            self.pc.answer(function (err) {
	                if (err) {
	                    self._log('error', 'Error removing stream source');
	                    return cb({
	                        condition: 'general-error'
	                    });
	                }
	                cb();
	            });
	        });
	    },

	    // ----------------------------------------------------------------
	    // DataChannels
	    // ----------------------------------------------------------------
	    onAddChannel: function (channel) {
	        this.emit('addChannel', channel);
	    }
	});


	module.exports = MediaSession;


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var util = __webpack_require__(197);
	var each = __webpack_require__(226);
	var pluck = __webpack_require__(460);
	var SJJ = __webpack_require__(465);
	var WildEmitter = __webpack_require__(470);
	var Peerconn = __webpack_require__(471);
	var adapter = __webpack_require__(472);

	function PeerConnection(config, constraints) {
	    var self = this;
	    var item;
	    WildEmitter.call(this);

	    config = config || {};
	    config.iceServers = config.iceServers || [];

	    // make sure this only gets enabled in Google Chrome
	    // EXPERIMENTAL FLAG, might get removed without notice
	    this.enableChromeNativeSimulcast = false;
	    if (constraints && constraints.optional &&
	            adapter.webrtcDetectedBrowser === 'chrome' &&
	            navigator.appVersion.match(/Chromium\//) === null) {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.enableChromeNativeSimulcast) {
	                self.enableChromeNativeSimulcast = true;
	            }
	        });
	    }

	    // EXPERIMENTAL FLAG, might get removed without notice
	    this.enableMultiStreamHacks = false;
	    if (constraints && constraints.optional &&
	            adapter.webrtcDetectedBrowser === 'chrome') {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.enableMultiStreamHacks) {
	                self.enableMultiStreamHacks = true;
	            }
	        });
	    }
	    // EXPERIMENTAL FLAG, might get removed without notice
	    this.restrictBandwidth = 0;
	    if (constraints && constraints.optional) {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.andyetRestrictBandwidth) {
	                self.restrictBandwidth = constraint.andyetRestrictBandwidth;
	            }
	        });
	    }

	    // EXPERIMENTAL FLAG, might get removed without notice
	    // bundle up ice candidates, only works for jingle mode
	    // number > 0 is the delay to wait for additional candidates
	    // ~20ms seems good
	    this.batchIceCandidates = 0;
	    if (constraints && constraints.optional) {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.andyetBatchIce) {
	                self.batchIceCandidates = constraint.andyetBatchIce;
	            }
	        });
	    }
	    this.batchedIceCandidates = [];

	    // EXPERIMENTAL FLAG, might get removed without notice
	    // this attemps to strip out candidates with an already known foundation
	    // and type -- i.e. those which are gathered via the same TURN server
	    // but different transports (TURN udp, tcp and tls respectively)
	    if (constraints && constraints.optional && adapter.webrtcDetectedBrowser === 'chrome') {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.andyetFasterICE) {
	                self.eliminateDuplicateCandidates = constraint.andyetFasterICE;
	            }
	        });
	    }
	    // EXPERIMENTAL FLAG, might get removed without notice
	    // when using a server such as the jitsi videobridge we don't need to signal
	    // our candidates
	    if (constraints && constraints.optional) {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.andyetDontSignalCandidates) {
	                self.dontSignalCandidates = constraint.andyetDontSignalCandidates;
	            }
	        });
	    }


	    // EXPERIMENTAL FLAG, might get removed without notice
	    this.assumeSetLocalSuccess = false;
	    if (constraints && constraints.optional) {
	        constraints.optional.forEach(function (constraint) {
	            if (constraint.andyetAssumeSetLocalSuccess) {
	                self.assumeSetLocalSuccess = constraint.andyetAssumeSetLocalSuccess;
	            }
	        });
	    }

	    // EXPERIMENTAL FLAG, might get removed without notice
	    // working around https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
	    // pass in a timeout for this
	    if (adapter.webrtcDetectedBrowser === 'firefox') {
	        if (constraints && constraints.optional) {
	            this.wtFirefox = 0;
	            constraints.optional.forEach(function (constraint) {
	                if (constraint.andyetFirefoxMakesMeSad) {
	                    self.wtFirefox = constraint.andyetFirefoxMakesMeSad;
	                    if (self.wtFirefox > 0) {
	                        self.firefoxcandidatebuffer = [];
	                    }
	                }
	            });
	        }
	    }


	    this.pc = new Peerconn(config, constraints);

	    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);
	    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);
	    this.addStream = this.pc.addStream.bind(this.pc);
	    this.removeStream = this.pc.removeStream.bind(this.pc);

	    // proxy events
	    this.pc.on('*', function () {
	        self.emit.apply(self, arguments);
	    });

	    // proxy some events directly
	    this.pc.onremovestream = this.emit.bind(this, 'removeStream');
	    this.pc.onaddstream = this.emit.bind(this, 'addStream');
	    this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
	    this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
	    this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');

	    // handle ice candidate and data channel events
	    this.pc.onicecandidate = this._onIce.bind(this);
	    this.pc.ondatachannel = this._onDataChannel.bind(this);

	    this.localDescription = {
	        contents: []
	    };
	    this.remoteDescription = {
	        contents: []
	    };

	    this.config = {
	        debug: false,
	        ice: {},
	        sid: '',
	        isInitiator: true,
	        sdpSessionID: Date.now(),
	        useJingle: false
	    };

	    // apply our config
	    for (item in config) {
	        this.config[item] = config[item];
	    }

	    if (this.config.debug) {
	        this.on('*', function () {
	            var logger = config.logger || console;
	            logger.log('PeerConnection event:', arguments);
	        });
	    }
	    this.hadLocalStunCandidate = false;
	    this.hadRemoteStunCandidate = false;
	    this.hadLocalRelayCandidate = false;
	    this.hadRemoteRelayCandidate = false;

	    this.hadLocalIPv6Candidate = false;
	    this.hadRemoteIPv6Candidate = false;

	    // keeping references for all our data channels
	    // so they dont get garbage collected
	    // can be removed once the following bugs have been fixed
	    // https://crbug.com/405545
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=964092
	    // to be filed for opera
	    this._remoteDataChannels = [];
	    this._localDataChannels = [];

	    this._candidateBuffer = [];
	}

	util.inherits(PeerConnection, WildEmitter);

	Object.defineProperty(PeerConnection.prototype, 'signalingState', {
	    get: function () {
	        return this.pc.signalingState;
	    }
	});
	Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
	    get: function () {
	        return this.pc.iceConnectionState;
	    }
	});

	PeerConnection.prototype._role = function () {
	    return this.isInitiator ? 'initiator' : 'responder';
	};

	// Add a stream to the peer connection object
	PeerConnection.prototype.addStream = function (stream) {
	    this.localStream = stream;
	    this.pc.addStream(stream);
	};

	// helper function to check if a remote candidate is a stun/relay
	// candidate or an ipv6 candidate
	PeerConnection.prototype._checkLocalCandidate = function (candidate) {
	    var cand = SJJ.toCandidateJSON(candidate);
	    if (cand.type == 'srflx') {
	        this.hadLocalStunCandidate = true;
	    } else if (cand.type == 'relay') {
	        this.hadLocalRelayCandidate = true;
	    }
	    if (cand.ip.indexOf(':') != -1) {
	        this.hadLocalIPv6Candidate = true;
	    }
	};

	// helper function to check if a remote candidate is a stun/relay
	// candidate or an ipv6 candidate
	PeerConnection.prototype._checkRemoteCandidate = function (candidate) {
	    var cand = SJJ.toCandidateJSON(candidate);
	    if (cand.type == 'srflx') {
	        this.hadRemoteStunCandidate = true;
	    } else if (cand.type == 'relay') {
	        this.hadRemoteRelayCandidate = true;
	    }
	    if (cand.ip.indexOf(':') != -1) {
	        this.hadRemoteIPv6Candidate = true;
	    }
	};


	// Init and add ice candidate object with correct constructor
	PeerConnection.prototype.processIce = function (update, cb) {
	    cb = cb || function () {};
	    var self = this;

	    // ignore any added ice candidates to avoid errors. why does the
	    // spec not do this?
	    if (this.pc.signalingState === 'closed') return cb();

	    if (update.contents || (update.jingle && update.jingle.contents)) {
	        var contentNames = pluck(this.remoteDescription.contents, 'name');
	        var contents = update.contents || update.jingle.contents;

	        contents.forEach(function (content) {
	            var transport = content.transport || {};
	            var candidates = transport.candidates || [];
	            var mline = contentNames.indexOf(content.name);
	            var mid = content.name;

	            candidates.forEach(
	                function (candidate) {
	                var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
	                self.pc.addIceCandidate(
	                    new RTCIceCandidate({
	                        candidate: iceCandidate,
	                        sdpMLineIndex: mline,
	                        sdpMid: mid
	                    }), function () {
	                        // well, this success callback is pretty meaningless
	                    },
	                    function (err) {
	                        self.emit('error', err);
	                    }
	                );
	                self._checkRemoteCandidate(iceCandidate);
	            });
	        });
	    } else {
	        // working around https://code.google.com/p/webrtc/issues/detail?id=3669
	        if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {
	            update.candidate.candidate = 'a=' + update.candidate.candidate;
	        }

	        if (this.wtFirefox && this.firefoxcandidatebuffer !== null) {
	            // we cant add this yet due to https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
	            if (this.pc.localDescription && this.pc.localDescription.type === 'offer') {
	                this.firefoxcandidatebuffer.push(update.candidate);
	                return cb();
	            }
	        }

	        self.pc.addIceCandidate(
	            new RTCIceCandidate(update.candidate),
	            function () { },
	            function (err) {
	                self.emit('error', err);
	            }
	        );
	        self._checkRemoteCandidate(update.candidate.candidate);
	    }
	    cb();
	};

	// Generate and emit an offer with the given constraints
	PeerConnection.prototype.offer = function (constraints, cb) {
	    var self = this;
	    var hasConstraints = arguments.length === 2;
	    var mediaConstraints = hasConstraints && constraints ? constraints : {
	            offerToReceiveAudio: 1,
	            offerToReceiveVideo: 1
	        };
	    cb = hasConstraints ? cb : constraints;
	    cb = cb || function () {};

	    if (this.pc.signalingState === 'closed') return cb('Already closed');

	    // Actually generate the offer
	    this.pc.createOffer(
	        function (offer) {
	            // does not work for jingle, but jingle.js doesn't need
	            // this hack...
	            var expandedOffer = {
	                type: 'offer',
	                sdp: offer.sdp
	            };
	            if (self.assumeSetLocalSuccess) {
	                self.emit('offer', expandedOffer);
	                cb(null, expandedOffer);
	            }
	            self._candidateBuffer = [];
	            self.pc.setLocalDescription(offer,
	                function () {
	                    var jingle;
	                    if (self.config.useJingle) {
	                        jingle = SJJ.toSessionJSON(offer.sdp, {
	                            role: self._role(),
	                            direction: 'outgoing'
	                        });
	                        jingle.sid = self.config.sid;
	                        self.localDescription = jingle;

	                        // Save ICE credentials
	                        each(jingle.contents, function (content) {
	                            var transport = content.transport || {};
	                            if (transport.ufrag) {
	                                self.config.ice[content.name] = {
	                                    ufrag: transport.ufrag,
	                                    pwd: transport.pwd
	                                };
	                            }
	                        });

	                        expandedOffer.jingle = jingle;
	                    }
	                    expandedOffer.sdp.split('\r\n').forEach(function (line) {
	                        if (line.indexOf('a=candidate:') === 0) {
	                            self._checkLocalCandidate(line);
	                        }
	                    });

	                    if (!self.assumeSetLocalSuccess) {
	                        self.emit('offer', expandedOffer);
	                        cb(null, expandedOffer);
	                    }
	                },
	                function (err) {
	                    self.emit('error', err);
	                    cb(err);
	                }
	            );
	        },
	        function (err) {
	            self.emit('error', err);
	            cb(err);
	        },
	        mediaConstraints
	    );
	};


	// Process an incoming offer so that ICE may proceed before deciding
	// to answer the request.
	PeerConnection.prototype.handleOffer = function (offer, cb) {
	    cb = cb || function () {};
	    var self = this;
	    offer.type = 'offer';
	    if (offer.jingle) {
	        if (this.enableChromeNativeSimulcast) {
	            offer.jingle.contents.forEach(function (content) {
	                if (content.name === 'video') {
	                    content.application.googConferenceFlag = true;
	                }
	            });
	        }
	        if (this.enableMultiStreamHacks) {
	            // add a mixed video stream as first stream
	            offer.jingle.contents.forEach(function (content) {
	                if (content.name === 'video') {
	                    var sources = content.application.sources || [];
	                    if (sources.length === 0 || sources[0].ssrc !== "3735928559") {
	                        sources.unshift({
	                            ssrc: "3735928559", // 0xdeadbeef
	                            parameters: [
	                                {
	                                    key: "cname",
	                                    value: "deadbeef"
	                                },
	                                {
	                                    key: "msid",
	                                    value: "mixyourfecintothis please"
	                                }
	                            ]
	                        });
	                        content.application.sources = sources;
	                    }
	                }
	            });
	        }
	        if (self.restrictBandwidth > 0) {
	            if (offer.jingle.contents.length >= 2 && offer.jingle.contents[1].name === 'video') {
	                var content = offer.jingle.contents[1];
	                var hasBw = content.application && content.application.bandwidth;
	                if (!hasBw) {
	                    offer.jingle.contents[1].application.bandwidth = { type: 'AS', bandwidth: self.restrictBandwidth.toString() };
	                    offer.sdp = SJJ.toSessionSDP(offer.jingle, {
	                        sid: self.config.sdpSessionID,
	                        role: self._role(),
	                        direction: 'outgoing'
	                    });
	                }
	            }
	        }
	        offer.sdp = SJJ.toSessionSDP(offer.jingle, {
	            sid: self.config.sdpSessionID,
	            role: self._role(),
	            direction: 'incoming'
	        });
	        self.remoteDescription = offer.jingle;
	    }
	    offer.sdp.split('\r\n').forEach(function (line) {
	        if (line.indexOf('a=candidate:') === 0) {
	            self._checkRemoteCandidate(line);
	        }
	    });
	    self.pc.setRemoteDescription(new RTCSessionDescription(offer),
	        function () {
	            cb();
	        },
	        cb
	    );
	};

	// Answer an offer with audio only
	PeerConnection.prototype.answerAudioOnly = function (cb) {
	    var mediaConstraints = {
	            mandatory: {
	                OfferToReceiveAudio: true,
	                OfferToReceiveVideo: false
	            }
	        };
	    this._answer(mediaConstraints, cb);
	};

	// Answer an offer without offering to recieve
	PeerConnection.prototype.answerBroadcastOnly = function (cb) {
	    var mediaConstraints = {
	            mandatory: {
	                OfferToReceiveAudio: false,
	                OfferToReceiveVideo: false
	            }
	        };
	    this._answer(mediaConstraints, cb);
	};

	// Answer an offer with given constraints default is audio/video
	PeerConnection.prototype.answer = function (constraints, cb) {
	    var hasConstraints = arguments.length === 2;
	    var callback = hasConstraints ? cb : constraints;
	    var mediaConstraints = hasConstraints && constraints ? constraints : {
	            mandatory: {
	                OfferToReceiveAudio: true,
	                OfferToReceiveVideo: true
	            }
	        };

	    this._answer(mediaConstraints, callback);
	};

	// Process an answer
	PeerConnection.prototype.handleAnswer = function (answer, cb) {
	    cb = cb || function () {};
	    var self = this;
	    if (answer.jingle) {
	        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
	            sid: self.config.sdpSessionID,
	            role: self._role(),
	            direction: 'incoming'
	        });
	        self.remoteDescription = answer.jingle;
	    }
	    answer.sdp.split('\r\n').forEach(function (line) {
	        if (line.indexOf('a=candidate:') === 0) {
	            self._checkRemoteCandidate(line);
	        }
	    });
	    self.pc.setRemoteDescription(
	        new RTCSessionDescription(answer),
	        function () {
	            if (self.wtFirefox) {
	                window.setTimeout(function () {
	                    self.firefoxcandidatebuffer.forEach(function (candidate) {
	                        // add candidates later
	                        self.pc.addIceCandidate(
	                            new RTCIceCandidate(candidate),
	                            function () { },
	                            function (err) {
	                                self.emit('error', err);
	                            }
	                        );
	                        self._checkRemoteCandidate(candidate.candidate);
	                    });
	                    self.firefoxcandidatebuffer = null;
	                }, self.wtFirefox);
	            }
	            cb(null);
	        },
	        cb
	    );
	};

	// Close the peer connection
	PeerConnection.prototype.close = function () {
	    this.pc.close();

	    this._localDataChannels = [];
	    this._remoteDataChannels = [];

	    this.emit('close');
	};

	// Internal code sharing for various types of answer methods
	PeerConnection.prototype._answer = function (constraints, cb) {
	    cb = cb || function () {};
	    var self = this;
	    if (!this.pc.remoteDescription) {
	        // the old API is used, call handleOffer
	        throw new Error('remoteDescription not set');
	    }

	    if (this.pc.signalingState === 'closed') return cb('Already closed');

	    self.pc.createAnswer(
	        function (answer) {
	            var sim = [];
	            if (self.enableChromeNativeSimulcast) {
	                // native simulcast part 1: add another SSRC
	                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
	                    role: self._role(),
	                    direction: 'outgoing'
	                });
	                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
	                    var groups = answer.jingle.contents[1].application.sourceGroups || [];
	                    var hasSim = false;
	                    groups.forEach(function (group) {
	                        if (group.semantics == 'SIM') hasSim = true;
	                    });
	                    if (!hasSim &&
	                        answer.jingle.contents[1].application.sources.length) {
	                        var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].application.sources[0]));
	                        newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
	                        answer.jingle.contents[1].application.sources.push(newssrc);

	                        sim.push(answer.jingle.contents[1].application.sources[0].ssrc);
	                        sim.push(newssrc.ssrc);
	                        groups.push({
	                            semantics: 'SIM',
	                            sources: sim
	                        });

	                        // also create an RTX one for the SIM one
	                        var rtxssrc = JSON.parse(JSON.stringify(newssrc));
	                        rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
	                        answer.jingle.contents[1].application.sources.push(rtxssrc);
	                        groups.push({
	                            semantics: 'FID',
	                            sources: [newssrc.ssrc, rtxssrc.ssrc]
	                        });

	                        answer.jingle.contents[1].application.sourceGroups = groups;
	                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
	                            sid: self.config.sdpSessionID,
	                            role: self._role(),
	                            direction: 'outgoing'
	                        });
	                    }
	                }
	            }
	            var expandedAnswer = {
	                type: 'answer',
	                sdp: answer.sdp
	            };
	            if (self.assumeSetLocalSuccess) {
	                // not safe to do when doing simulcast mangling
	                self.emit('answer', expandedAnswer);
	                cb(null, expandedAnswer);
	            }
	            self._candidateBuffer = [];
	            self.pc.setLocalDescription(answer,
	                function () {
	                    if (self.config.useJingle) {
	                        var jingle = SJJ.toSessionJSON(answer.sdp, {
	                            role: self._role(),
	                            direction: 'outgoing'
	                        });
	                        jingle.sid = self.config.sid;
	                        self.localDescription = jingle;
	                        expandedAnswer.jingle = jingle;
	                    }
	                    if (self.enableChromeNativeSimulcast) {
	                        // native simulcast part 2:
	                        // signal multiple tracks to the receiver
	                        // for anything in the SIM group
	                        if (!expandedAnswer.jingle) {
	                            expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {
	                                role: self._role(),
	                                direction: 'outgoing'
	                            });
	                        }
	                        expandedAnswer.jingle.contents[1].application.sources.forEach(function (source, idx) {
	                            // the floor idx/2 is a hack that relies on a particular order
	                            // of groups, alternating between sim and rtx
	                            source.parameters = source.parameters.map(function (parameter) {
	                                if (parameter.key === 'msid') {
	                                    parameter.value += '-' + Math.floor(idx / 2);
	                                }
	                                return parameter;
	                            });
	                        });
	                        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {
	                            sid: self.sdpSessionID,
	                            role: self._role(),
	                            direction: 'outgoing'
	                        });
	                    }
	                    expandedAnswer.sdp.split('\r\n').forEach(function (line) {
	                        if (line.indexOf('a=candidate:') === 0) {
	                            self._checkLocalCandidate(line);
	                        }
	                    });
	                    if (!self.assumeSetLocalSuccess) {
	                        self.emit('answer', expandedAnswer);
	                        cb(null, expandedAnswer);
	                    }
	                },
	                function (err) {
	                    self.emit('error', err);
	                    cb(err);
	                }
	            );
	        },
	        function (err) {
	            self.emit('error', err);
	            cb(err);
	        },
	        constraints
	    );
	};

	// Internal method for emitting ice candidates on our peer object
	PeerConnection.prototype._onIce = function (event) {
	    var self = this;
	    if (event.candidate) {
	        if (this.dontSignalCandidates) return;
	        var ice = event.candidate;

	        var expandedCandidate = {
	            candidate: {
	                candidate: ice.candidate,
	                sdpMid: ice.sdpMid,
	                sdpMLineIndex: ice.sdpMLineIndex
	            }
	        };
	        this._checkLocalCandidate(ice.candidate);

	        var cand = SJJ.toCandidateJSON(ice.candidate);

	        var already;
	        var idx;
	        if (this.eliminateDuplicateCandidates && cand.type === 'relay') {
	            // drop candidates with same foundation, component
	            // take local type pref into account so we don't ignore udp
	            // ones when we know about a TCP one. unlikely but...
	            already = this._candidateBuffer.filter(
	                function (c) {
	                    return c.type === 'relay';
	                }).map(function (c) {
	                    return c.foundation + ':' + c.component;
	                }
	            );
	            idx = already.indexOf(cand.foundation + ':' + cand.component);
	            // remember: local type pref of udp is 0, tcp 1, tls 2
	            if (idx > -1 && ((cand.priority >> 24) >= (already[idx].priority >> 24))) {
	                // drop it, same foundation with higher (worse) type pref
	                return;
	            }
	        }
	        if (this.config.bundlePolicy === 'max-bundle') {
	            // drop candidates which are duplicate for audio/video/data
	            // duplicate means same host/port but different sdpMid
	            already = this._candidateBuffer.filter(
	                function (c) {
	                    return cand.type === c.type;
	                }).map(function (cand) {
	                    return cand.address + ':' + cand.port;
	                }
	            );
	            idx = already.indexOf(cand.address + ':' + cand.port);
	            if (idx > -1) return;
	        }
	        // also drop rtcp candidates since we know the peer supports RTCP-MUX
	        // this is a workaround until browsers implement this natively
	        if (this.config.rtcpMuxPolicy === 'require' && cand.component === '2') {
	            return;
	        }
	        this._candidateBuffer.push(cand);

	        if (self.config.useJingle) {
	            if (!ice.sdpMid) { // firefox doesn't set this
	                if (self.pc.remoteDescription && self.pc.remoteDescription.type === 'offer') {
	                    // preserve name from remote
	                    ice.sdpMid = self.remoteDescription.contents[ice.sdpMLineIndex].name;
	                } else {
	                    ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;
	                }
	            }
	            if (!self.config.ice[ice.sdpMid]) {
	                var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {
	                    role: self._role(),
	                    direction: 'outgoing'
	                });
	                each(jingle.contents, function (content) {
	                    var transport = content.transport || {};
	                    if (transport.ufrag) {
	                        self.config.ice[content.name] = {
	                            ufrag: transport.ufrag,
	                            pwd: transport.pwd
	                        };
	                    }
	                });
	            }
	            expandedCandidate.jingle = {
	                contents: [{
	                    name: ice.sdpMid,
	                    creator: self._role(),
	                    transport: {
	                        transportType: 'iceUdp',
	                        ufrag: self.config.ice[ice.sdpMid].ufrag,
	                        pwd: self.config.ice[ice.sdpMid].pwd,
	                        candidates: [
	                            cand
	                        ]
	                    }
	                }]
	            };
	            if (self.batchIceCandidates > 0) {
	                if (self.batchedIceCandidates.length === 0) {
	                    window.setTimeout(function () {
	                        var contents = {};
	                        self.batchedIceCandidates.forEach(function (content) {
	                            content = content.contents[0];
	                            if (!contents[content.name]) contents[content.name] = content;
	                            contents[content.name].transport.candidates.push(content.transport.candidates[0]);
	                        });
	                        var newCand = {
	                            jingle: {
	                                contents: []
	                            }
	                        };
	                        Object.keys(contents).forEach(function (name) {
	                            newCand.jingle.contents.push(contents[name]);
	                        });
	                        self.batchedIceCandidates = [];
	                        self.emit('ice', newCand);
	                    }, self.batchIceCandidates);
	                }
	                self.batchedIceCandidates.push(expandedCandidate.jingle);
	                return;
	            }

	        }
	        this.emit('ice', expandedCandidate);
	    } else {
	        this.emit('endOfCandidates');
	    }
	};

	// Internal method for processing a new data channel being added by the
	// other peer.
	PeerConnection.prototype._onDataChannel = function (event) {
	    // make sure we keep a reference so this doesn't get garbage collected
	    var channel = event.channel;
	    this._remoteDataChannels.push(channel);

	    this.emit('addChannel', channel);
	};

	// Create a data channel spec reference:
	// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
	PeerConnection.prototype.createDataChannel = function (name, opts) {
	    var channel = this.pc.createDataChannel(name, opts);

	    // make sure we keep a reference so this doesn't get garbage collected
	    this._localDataChannels.push(channel);

	    return channel;
	};

	PeerConnection.prototype.getStats = function (cb) {
	    this.pc.getStats(null,
	        function (res) {
	            cb(null, res);
	        },
	        function (err) {
	            cb(err);
	        }
	    );
	};

	module.exports = PeerConnection;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseGet = __webpack_require__(461),
	    toPath = __webpack_require__(462),
	    isArray = __webpack_require__(232),
	    map = __webpack_require__(463);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  var pathKey = (path + '');
	  path = toPath(path);
	  return function(object) {
	    return baseGet(object, path, pathKey);
	  };
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	    return true;
	  }
	  if (isArray(value)) {
	    return false;
	  }
	  var result = !reIsDeepProp.test(value);
	  return result || (object != null && value in toObject(object));
	}

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Gets the property value of `path` from all elements in `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Array|string} path The path of the property to pluck.
	 * @returns {Array} Returns the property values.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 40 }
	 * ];
	 *
	 * _.pluck(users, 'user');
	 * // => ['barney', 'fred']
	 *
	 * var userIndex = _.indexBy(users, 'user');
	 * _.pluck(userIndex, 'age');
	 * // => [36, 40] (iteration order is not guaranteed)
	 */
	function pluck(collection, path) {
	  return map(collection, property(path));
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates a function which returns the property value at `path` on a
	 * given object.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': { 'c': 2 } } },
	 *   { 'a': { 'b': { 'c': 1 } } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b.c'));
	 * // => [2, 1]
	 *
	 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}

	module.exports = pluck;


/***/ },
/* 461 */
/***/ function(module, exports) {

	/**
	 * lodash 3.7.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = baseGet;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.8.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var isArray = __webpack_require__(232);

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}

	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}

	module.exports = toPath;


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var arrayMap = __webpack_require__(464),
	    baseCallback = __webpack_require__(416),
	    baseEach = __webpack_require__(228),
	    isArray = __webpack_require__(232);

	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.map` without support for callback shorthands
	 * and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Creates an array of values by running each element in `collection` through
	 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `iteratee` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `iteratee` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	 * `sum`, `uniq`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @alias collect
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `iteratee`.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function timesThree(n) {
	 *   return n * 3;
	 * }
	 *
	 * _.map([1, 2], timesThree);
	 * // => [3, 6]
	 *
	 * _.map({ 'a': 1, 'b': 2 }, timesThree);
	 * // => [3, 6] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // using the `_.property` callback shorthand
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee, thisArg) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  iteratee = baseCallback(iteratee, thisArg, 3);
	  return func(collection, iteratee);
	}

	module.exports = map;


/***/ },
/* 464 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * A specialized version of `_.map` for arrays without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	var toSDP = __webpack_require__(466);
	var toJSON = __webpack_require__(468);


	// Converstion from JSON to SDP

	exports.toIncomingSDPOffer = function (session) {
	    return toSDP.toSessionSDP(session, {
	        role: 'responder',
	        direction: 'incoming'
	    });
	};
	exports.toOutgoingSDPOffer = function (session) {
	    return toSDP.toSessionSDP(session, {
	        role: 'initiator',
	        direction: 'outgoing'
	    });
	};
	exports.toIncomingSDPAnswer = function (session) {
	    return toSDP.toSessionSDP(session, {
	        role: 'initiator',
	        direction: 'incoming'
	    });
	};
	exports.toOutgoingSDPAnswer = function (session) {
	    return toSDP.toSessionSDP(session, {
	        role: 'responder',
	        direction: 'outgoing'
	    });
	};
	exports.toIncomingMediaSDPOffer = function (media) {
	    return toSDP.toMediaSDP(media, {
	        role: 'responder',
	        direction: 'incoming'
	    });
	};
	exports.toOutgoingMediaSDPOffer = function (media) {
	    return toSDP.toMediaSDP(media, {
	        role: 'initiator',
	        direction: 'outgoing'
	    });
	};
	exports.toIncomingMediaSDPAnswer = function (media) {
	    return toSDP.toMediaSDP(media, {
	        role: 'initiator',
	        direction: 'incoming'
	    });
	};
	exports.toOutgoingMediaSDPAnswer = function (media) {
	    return toSDP.toMediaSDP(media, {
	        role: 'responder',
	        direction: 'outgoing'
	    });
	};
	exports.toCandidateSDP = toSDP.toCandidateSDP;
	exports.toMediaSDP = toSDP.toMediaSDP;
	exports.toSessionSDP = toSDP.toSessionSDP;


	// Conversion from SDP to JSON

	exports.toIncomingJSONOffer = function (sdp, creators) {
	    return toJSON.toSessionJSON(sdp, {
	        role: 'responder',
	        direction: 'incoming',
	        creators: creators
	    });
	};
	exports.toOutgoingJSONOffer = function (sdp, creators) {
	    return toJSON.toSessionJSON(sdp, {
	        role: 'initiator',
	        direction: 'outgoing',
	        creators: creators
	    });
	};
	exports.toIncomingJSONAnswer = function (sdp, creators) {
	    return toJSON.toSessionJSON(sdp, {
	        role: 'initiator',
	        direction: 'incoming',
	        creators: creators
	    });
	};
	exports.toOutgoingJSONAnswer = function (sdp, creators) {
	    return toJSON.toSessionJSON(sdp, {
	        role: 'responder',
	        direction: 'outgoing',
	        creators: creators
	    });
	};
	exports.toIncomingMediaJSONOffer = function (sdp, creator) {
	    return toJSON.toMediaJSON(sdp, {
	        role: 'responder',
	        direction: 'incoming',
	        creator: creator
	    });
	};
	exports.toOutgoingMediaJSONOffer = function (sdp, creator) {
	    return toJSON.toMediaJSON(sdp, {
	        role: 'initiator',
	        direction: 'outgoing',
	        creator: creator
	    });
	};
	exports.toIncomingMediaJSONAnswer = function (sdp, creator) {
	    return toJSON.toMediaJSON(sdp, {
	        role: 'initiator',
	        direction: 'incoming',
	        creator: creator
	    });
	};
	exports.toOutgoingMediaJSONAnswer = function (sdp, creator) {
	    return toJSON.toMediaJSON(sdp, {
	        role: 'responder',
	        direction: 'outgoing',
	        creator: creator
	    });
	};
	exports.toCandidateJSON = toJSON.toCandidateJSON;
	exports.toMediaJSON = toJSON.toMediaJSON;
	exports.toSessionJSON = toJSON.toSessionJSON;


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	var SENDERS = __webpack_require__(467);


	exports.toSessionSDP = function (session, opts) {
	    var role = opts.role || 'initiator';
	    var direction = opts.direction || 'outgoing';
	    var sid = opts.sid || session.sid || Date.now();
	    var time = opts.time || Date.now();

	    var sdp = [
	        'v=0',
	        'o=- ' + sid + ' ' + time + ' IN IP4 0.0.0.0',
	        's=-',
	        't=0 0'
	    ];

	    var contents = session.contents || [];
	    var hasSources = false;
	    contents.forEach(function (content) {
	        if (content.application.sources &&
	            content.application.sources.length) {
	            hasSources = true;
	        }
	    });

	    if (hasSources) {
	        sdp.push('a=msid-semantic: WMS *');
	    }

	    var groups = session.groups || [];
	    groups.forEach(function (group) {
	        sdp.push('a=group:' + group.semantics + ' ' + group.contents.join(' '));
	    });


	    contents.forEach(function (content) {
	        sdp.push(exports.toMediaSDP(content, opts));
	    });

	    return sdp.join('\r\n') + '\r\n';
	};

	exports.toMediaSDP = function (content, opts) {
	    var sdp = [];

	    var role = opts.role || 'initiator';
	    var direction = opts.direction || 'outgoing';

	    var desc = content.application;
	    var transport = content.transport;
	    var payloads = desc.payloads || [];
	    var fingerprints = (transport && transport.fingerprints) || [];

	    var mline = [];
	    if (desc.applicationType == 'datachannel') {
	        mline.push('application');
	        mline.push('1');
	        mline.push('DTLS/SCTP');
	        if (transport.sctp) {
	            transport.sctp.forEach(function (map) {
	                mline.push(map.number);
	            });
	        }
	    } else {
	        mline.push(desc.media);
	        mline.push('1');
	        if (fingerprints.length > 0) {
	            mline.push('UDP/TLS/RTP/SAVPF');
	        } else if (desc.encryption && desc.encryption.length > 0) {
	            mline.push('RTP/SAVPF');
	        } else {
	            mline.push('RTP/AVPF');
	        }
	        payloads.forEach(function (payload) {
	            mline.push(payload.id);
	        });
	    }


	    sdp.push('m=' + mline.join(' '));

	    sdp.push('c=IN IP4 0.0.0.0');
	    if (desc.bandwidth && desc.bandwidth.type && desc.bandwidth.bandwidth) {
	        sdp.push('b=' + desc.bandwidth.type + ':' + desc.bandwidth.bandwidth);
	    }
	    if (desc.applicationType == 'rtp') {
	        sdp.push('a=rtcp:1 IN IP4 0.0.0.0');
	    }

	    if (transport) {
	        if (transport.ufrag) {
	            sdp.push('a=ice-ufrag:' + transport.ufrag);
	        }
	        if (transport.pwd) {
	            sdp.push('a=ice-pwd:' + transport.pwd);
	        }

	        var pushedSetup = false;
	        fingerprints.forEach(function (fingerprint) {
	            sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);
	            if (fingerprint.setup && !pushedSetup) {
	                sdp.push('a=setup:' + fingerprint.setup);
	            }
	        });

	        if (transport.sctp) {
	            transport.sctp.forEach(function (map) {
	                sdp.push('a=sctpmap:' + map.number + ' ' + map.protocol + ' ' + map.streams);
	            });
	        }
	    }

	    if (desc.applicationType == 'rtp') {
	        sdp.push('a=' + (SENDERS[role][direction][content.senders] || 'sendrecv'));
	    }
	    sdp.push('a=mid:' + content.name);

	    if (desc.sources && desc.sources.length) {
	        (desc.sources[0].parameters || []).forEach(function (param) {
	            if (param.key === 'msid') {
	                sdp.push('a=msid:' + param.value);
	            }
	        });
	    }

	    if (desc.mux) {
	        sdp.push('a=rtcp-mux');
	    }

	    var encryption = desc.encryption || [];
	    encryption.forEach(function (crypto) {
	        sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));
	    });
	    if (desc.googConferenceFlag) {
	        sdp.push('a=x-google-flag:conference');
	    }

	    payloads.forEach(function (payload) {
	        var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;
	        if (payload.channels && payload.channels != '1') {
	            rtpmap += '/' + payload.channels;
	        }
	        sdp.push(rtpmap);

	        if (payload.parameters && payload.parameters.length) {
	            var fmtp = ['a=fmtp:' + payload.id];
	            var parameters = [];
	            payload.parameters.forEach(function (param) {
	                parameters.push((param.key ? param.key + '=' : '') + param.value);
	            });
	            fmtp.push(parameters.join(';'));
	            sdp.push(fmtp.join(' '));
	        }

	        if (payload.feedback) {
	            payload.feedback.forEach(function (fb) {
	                if (fb.type === 'trr-int') {
	                    sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + (fb.value ? fb.value : '0'));
	                } else {
	                    sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
	                }
	            });
	        }
	    });

	    if (desc.feedback) {
	        desc.feedback.forEach(function (fb) {
	            if (fb.type === 'trr-int') {
	                sdp.push('a=rtcp-fb:* trr-int ' + (fb.value ? fb.value : '0'));
	            } else {
	                sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
	            }
	        });
	    }

	    var hdrExts = desc.headerExtensions || [];
	    hdrExts.forEach(function (hdr) {
	        sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + SENDERS[role][direction][hdr.senders] : '') + ' ' + hdr.uri);
	    });

	    var ssrcGroups = desc.sourceGroups || [];
	    ssrcGroups.forEach(function (ssrcGroup) {
	        sdp.push('a=ssrc-group:' + ssrcGroup.semantics + ' ' + ssrcGroup.sources.join(' '));
	    });

	    var ssrcs = desc.sources || [];
	    ssrcs.forEach(function (ssrc) {
	        for (var i = 0; i < ssrc.parameters.length; i++) {
	            var param = ssrc.parameters[i];
	            sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + param.key + (param.value ? (':' + param.value) : ''));
	        }
	    });

	    var candidates = transport.candidates || [];
	    candidates.forEach(function (candidate) {
	        sdp.push(exports.toCandidateSDP(candidate));
	    });

	    return sdp.join('\r\n');
	};

	exports.toCandidateSDP = function (candidate) {
	    var sdp = [];

	    sdp.push(candidate.foundation);
	    sdp.push(candidate.component);
	    sdp.push(candidate.protocol.toUpperCase());
	    sdp.push(candidate.priority);
	    sdp.push(candidate.ip);
	    sdp.push(candidate.port);

	    var type = candidate.type;
	    sdp.push('typ');
	    sdp.push(type);
	    if (type === 'srflx' || type === 'prflx' || type === 'relay') {
	        if (candidate.relAddr && candidate.relPort) {
	            sdp.push('raddr');
	            sdp.push(candidate.relAddr);
	            sdp.push('rport');
	            sdp.push(candidate.relPort);
	        }
	    }
	    if (candidate.tcpType && candidate.protocol.toUpperCase() == 'TCP') {
	        sdp.push('tcptype');
	        sdp.push(candidate.tcpType);
	    }

	    sdp.push('generation');
	    sdp.push(candidate.generation || '0');

	    // FIXME: apparently this is wrong per spec
	    // but then, we need this when actually putting this into
	    // SDP so it's going to stay.
	    // decision needs to be revisited when browsers dont
	    // accept this any longer
	    return 'a=candidate:' + sdp.join(' ');
	};


/***/ },
/* 467 */
/***/ function(module, exports) {

	module.exports = {
	    initiator: {
	        incoming: {
	            initiator: 'recvonly',
	            responder: 'sendonly',
	            both: 'sendrecv',
	            none: 'inactive',
	            recvonly: 'initiator',
	            sendonly: 'responder',
	            sendrecv: 'both',
	            inactive: 'none'
	        },
	        outgoing: {
	            initiator: 'sendonly',
	            responder: 'recvonly',
	            both: 'sendrecv',
	            none: 'inactive',
	            recvonly: 'responder',
	            sendonly: 'initiator',
	            sendrecv: 'both',
	            inactive: 'none'
	        }
	    },
	    responder: {
	        incoming: {
	            initiator: 'sendonly',
	            responder: 'recvonly',
	            both: 'sendrecv',
	            none: 'inactive',
	            recvonly: 'responder',
	            sendonly: 'initiator',
	            sendrecv: 'both',
	            inactive: 'none'
	        },
	        outgoing: {
	            initiator: 'recvonly',
	            responder: 'sendonly',
	            both: 'sendrecv',
	            none: 'inactive',
	            recvonly: 'initiator',
	            sendonly: 'responder',
	            sendrecv: 'both',
	            inactive: 'none'
	        }
	    }
	};


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	var SENDERS = __webpack_require__(467);
	var parsers = __webpack_require__(469);
	var idCounter = Math.random();


	exports._setIdCounter = function (counter) {
	    idCounter = counter;
	};

	exports.toSessionJSON = function (sdp, opts) {
	    var i;
	    var creators = opts.creators || [];
	    var role = opts.role || 'initiator';
	    var direction = opts.direction || 'outgoing';


	    // Divide the SDP into session and media sections.
	    var media = sdp.split('\r\nm=');
	    for (i = 1; i < media.length; i++) {
	        media[i] = 'm=' + media[i];
	        if (i !== media.length - 1) {
	            media[i] += '\r\n';
	        }
	    }
	    var session = media.shift() + '\r\n';
	    var sessionLines = parsers.lines(session);
	    var parsed = {};

	    var contents = [];
	    for (i = 0; i < media.length; i++) {
	        contents.push(exports.toMediaJSON(media[i], session, {
	            role: role,
	            direction: direction,
	            creator: creators[i] || 'initiator'
	        }));
	    }
	    parsed.contents = contents;

	    var groupLines = parsers.findLines('a=group:', sessionLines);
	    if (groupLines.length) {
	        parsed.groups = parsers.groups(groupLines);
	    }

	    return parsed;
	};

	exports.toMediaJSON = function (media, session, opts) {
	    var creator = opts.creator || 'initiator';
	    var role = opts.role || 'initiator';
	    var direction = opts.direction || 'outgoing';

	    var lines = parsers.lines(media);
	    var sessionLines = parsers.lines(session);
	    var mline = parsers.mline(lines[0]);

	    var content = {
	        creator: creator,
	        name: mline.media,
	        application: {
	            applicationType: 'rtp',
	            media: mline.media,
	            payloads: [],
	            encryption: [],
	            feedback: [],
	            headerExtensions: []
	        },
	        transport: {
	            transportType: 'iceUdp',
	            candidates: [],
	            fingerprints: []
	        }
	    };
	    if (mline.media == 'application') {
	        // FIXME: the description is most likely to be independent
	        // of the SDP and should be processed by other parts of the library
	        content.application = {
	            applicationType: 'datachannel'
	        };
	        content.transport.sctp = [];
	    }
	    var desc = content.application;
	    var trans = content.transport;

	    // If we have a mid, use that for the content name instead.
	    var mid = parsers.findLine('a=mid:', lines);
	    if (mid) {
	        content.name = mid.substr(6);
	    }

	    if (parsers.findLine('a=sendrecv', lines, sessionLines)) {
	        content.senders = 'both';
	    } else if (parsers.findLine('a=sendonly', lines, sessionLines)) {
	        content.senders = SENDERS[role][direction].sendonly;
	    } else if (parsers.findLine('a=recvonly', lines, sessionLines)) {
	        content.senders = SENDERS[role][direction].recvonly;
	    } else if (parsers.findLine('a=inactive', lines, sessionLines)) {
	        content.senders = 'none';
	    }

	    if (desc.applicationType == 'rtp') {
	        var bandwidth = parsers.findLine('b=', lines);
	        if (bandwidth) {
	            desc.bandwidth = parsers.bandwidth(bandwidth);
	        }

	        var ssrc = parsers.findLine('a=ssrc:', lines);
	        if (ssrc) {
	            desc.ssrc = ssrc.substr(7).split(' ')[0];
	        }

	        var rtpmapLines = parsers.findLines('a=rtpmap:', lines);
	        rtpmapLines.forEach(function (line) {
	            var payload = parsers.rtpmap(line);
	            payload.parameters = [];
	            payload.feedback = [];

	            var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines);
	            // There should only be one fmtp line per payload
	            fmtpLines.forEach(function (line) {
	                payload.parameters = parsers.fmtp(line);
	            });

	            var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);
	            fbLines.forEach(function (line) {
	                payload.feedback.push(parsers.rtcpfb(line));
	            });

	            desc.payloads.push(payload);
	        });

	        var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);
	        cryptoLines.forEach(function (line) {
	            desc.encryption.push(parsers.crypto(line));
	        });

	        if (parsers.findLine('a=rtcp-mux', lines)) {
	            desc.mux = true;
	        }

	        var fbLines = parsers.findLines('a=rtcp-fb:*', lines);
	        fbLines.forEach(function (line) {
	            desc.feedback.push(parsers.rtcpfb(line));
	        });

	        var extLines = parsers.findLines('a=extmap:', lines);
	        extLines.forEach(function (line) {
	            var ext = parsers.extmap(line);

	            ext.senders = SENDERS[role][direction][ext.senders];

	            desc.headerExtensions.push(ext);
	        });

	        var ssrcGroupLines = parsers.findLines('a=ssrc-group:', lines);
	        desc.sourceGroups = parsers.sourceGroups(ssrcGroupLines || []);

	        var ssrcLines = parsers.findLines('a=ssrc:', lines);
	        var sources = desc.sources = parsers.sources(ssrcLines || []);

	        var msidLine = parsers.findLine('a=msid:', lines);
	        if (msidLine) {
	            var msid = parsers.msid(msidLine);
	            ['msid', 'mslabel', 'label'].forEach(function (key) {
	                for (var i = 0; i < sources.length; i++) {
	                    var found = false;
	                    for (var j = 0; j < sources[i].parameters.length; j++) {
	                        if (sources[i].parameters[j].key === key) {
	                            found = true;
	                        }
	                    }
	                    if (!found) {
	                        sources[i].parameters.push({ key: key, value: msid[key] });
	                    }
	                }
	            });
	        }

	        if (parsers.findLine('a=x-google-flag:conference', lines, sessionLines)) {
	            desc.googConferenceFlag = true;
	        }
	    }

	    // transport specific attributes
	    var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);
	    var setup = parsers.findLine('a=setup:', lines, sessionLines);
	    fingerprintLines.forEach(function (line) {
	        var fp = parsers.fingerprint(line);
	        if (setup) {
	            fp.setup = setup.substr(8);
	        }
	        trans.fingerprints.push(fp);
	    });

	    var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);
	    var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);
	    if (ufragLine && pwdLine) {
	        trans.ufrag = ufragLine.substr(12);
	        trans.pwd = pwdLine.substr(10);
	        trans.candidates = [];

	        var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);
	        candidateLines.forEach(function (line) {
	            trans.candidates.push(exports.toCandidateJSON(line));
	        });
	    }

	    if (desc.applicationType == 'datachannel') {
	        var sctpmapLines = parsers.findLines('a=sctpmap:', lines);
	        sctpmapLines.forEach(function (line) {
	            var sctp = parsers.sctpmap(line);
	            trans.sctp.push(sctp);
	        });
	    }

	    return content;
	};

	exports.toCandidateJSON = function (line) {
	    var candidate = parsers.candidate(line.split('\r\n')[0]);
	    candidate.id = (idCounter++).toString(36).substr(0, 12);
	    return candidate;
	};


/***/ },
/* 469 */
/***/ function(module, exports) {

	exports.lines = function (sdp) {
	    return sdp.split('\r\n').filter(function (line) {
	        return line.length > 0;
	    });
	};

	exports.findLine = function (prefix, mediaLines, sessionLines) {
	    var prefixLength = prefix.length;
	    for (var i = 0; i < mediaLines.length; i++) {
	        if (mediaLines[i].substr(0, prefixLength) === prefix) {
	            return mediaLines[i];
	        }
	    }
	    // Continue searching in parent session section
	    if (!sessionLines) {
	        return false;
	    }

	    for (var j = 0; j < sessionLines.length; j++) {
	        if (sessionLines[j].substr(0, prefixLength) === prefix) {
	            return sessionLines[j];
	        }
	    }

	    return false;
	};

	exports.findLines = function (prefix, mediaLines, sessionLines) {
	    var results = [];
	    var prefixLength = prefix.length;
	    for (var i = 0; i < mediaLines.length; i++) {
	        if (mediaLines[i].substr(0, prefixLength) === prefix) {
	            results.push(mediaLines[i]);
	        }
	    }
	    if (results.length || !sessionLines) {
	        return results;
	    }
	    for (var j = 0; j < sessionLines.length; j++) {
	        if (sessionLines[j].substr(0, prefixLength) === prefix) {
	            results.push(sessionLines[j]);
	        }
	    }
	    return results;
	};

	exports.mline = function (line) {
	    var parts = line.substr(2).split(' ');
	    var parsed = {
	        media: parts[0],
	        port: parts[1],
	        proto: parts[2],
	        formats: []
	    };
	    for (var i = 3; i < parts.length; i++) {
	        if (parts[i]) {
	            parsed.formats.push(parts[i]);
	        }
	    }
	    return parsed;
	};

	exports.rtpmap = function (line) {
	    var parts = line.substr(9).split(' ');
	    var parsed = {
	        id: parts.shift()
	    };

	    parts = parts[0].split('/');

	    parsed.name = parts[0];
	    parsed.clockrate = parts[1];
	    parsed.channels = parts.length == 3 ? parts[2] : '1';
	    return parsed;
	};

	exports.sctpmap = function (line) {
	    // based on -05 draft
	    var parts = line.substr(10).split(' ');
	    var parsed = {
	        number: parts.shift(),
	        protocol: parts.shift(),
	        streams: parts.shift()
	    };
	    return parsed;
	};


	exports.fmtp = function (line) {
	    var kv, key, value;
	    var parts = line.substr(line.indexOf(' ') + 1).split(';');
	    var parsed = [];
	    for (var i = 0; i < parts.length; i++) {
	        kv = parts[i].split('=');
	        key = kv[0].trim();
	        value = kv[1];
	        if (key && value) {
	            parsed.push({key: key, value: value});
	        } else if (key) {
	            parsed.push({key: '', value: key});
	        }
	    }
	    return parsed;
	};

	exports.crypto = function (line) {
	    var parts = line.substr(9).split(' ');
	    var parsed = {
	        tag: parts[0],
	        cipherSuite: parts[1],
	        keyParams: parts[2],
	        sessionParams: parts.slice(3).join(' ')
	    };
	    return parsed;
	};

	exports.fingerprint = function (line) {
	    var parts = line.substr(14).split(' ');
	    return {
	        hash: parts[0],
	        value: parts[1]
	    };
	};

	exports.extmap = function (line) {
	    var parts = line.substr(9).split(' ');
	    var parsed = {};

	    var idpart = parts.shift();
	    var sp = idpart.indexOf('/');
	    if (sp >= 0) {
	        parsed.id = idpart.substr(0, sp);
	        parsed.senders = idpart.substr(sp + 1);
	    } else {
	        parsed.id = idpart;
	        parsed.senders = 'sendrecv';
	    }

	    parsed.uri = parts.shift() || '';

	    return parsed;
	};

	exports.rtcpfb = function (line) {
	    var parts = line.substr(10).split(' ');
	    var parsed = {};
	    parsed.id = parts.shift();
	    parsed.type = parts.shift();
	    if (parsed.type === 'trr-int') {
	        parsed.value = parts.shift();
	    } else {
	        parsed.subtype = parts.shift() || '';
	    }
	    parsed.parameters = parts;
	    return parsed;
	};

	exports.candidate = function (line) {
	    var parts;
	    if (line.indexOf('a=candidate:') === 0) {
	        parts = line.substring(12).split(' ');
	    } else { // no a=candidate
	        parts = line.substring(10).split(' ');
	    }

	    var candidate = {
	        foundation: parts[0],
	        component: parts[1],
	        protocol: parts[2].toLowerCase(),
	        priority: parts[3],
	        ip: parts[4],
	        port: parts[5],
	        // skip parts[6] == 'typ'
	        type: parts[7],
	        generation: '0'
	    };

	    for (var i = 8; i < parts.length; i += 2) {
	        if (parts[i] === 'raddr') {
	            candidate.relAddr = parts[i + 1];
	        } else if (parts[i] === 'rport') {
	            candidate.relPort = parts[i + 1];
	        } else if (parts[i] === 'generation') {
	            candidate.generation = parts[i + 1];
	        } else if (parts[i] === 'tcptype') {
	            candidate.tcpType = parts[i + 1];
	        }
	    }

	    candidate.network = '1';

	    return candidate;
	};

	exports.sourceGroups = function (lines) {
	    var parsed = [];
	    for (var i = 0; i < lines.length; i++) {
	        var parts = lines[i].substr(13).split(' ');
	        parsed.push({
	            semantics: parts.shift(),
	            sources: parts
	        });
	    }
	    return parsed;
	};

	exports.sources = function (lines) {
	    // http://tools.ietf.org/html/rfc5576
	    var parsed = [];
	    var sources = {};
	    for (var i = 0; i < lines.length; i++) {
	        var parts = lines[i].substr(7).split(' ');
	        var ssrc = parts.shift();

	        if (!sources[ssrc]) {
	            var source = {
	                ssrc: ssrc,
	                parameters: []
	            };
	            parsed.push(source);

	            // Keep an index
	            sources[ssrc] = source;
	        }

	        parts = parts.join(' ').split(':');
	        var attribute = parts.shift();
	        var value = parts.join(':') || null;

	        sources[ssrc].parameters.push({
	            key: attribute,
	            value: value
	        });
	    }

	    return parsed;
	};

	exports.groups = function (lines) {
	    // http://tools.ietf.org/html/rfc5888
	    var parsed = [];
	    var parts;
	    for (var i = 0; i < lines.length; i++) {
	        parts = lines[i].substr(8).split(' ');
	        parsed.push({
	            semantics: parts.shift(),
	            contents: parts
	        });
	    }
	    return parsed;
	};

	exports.bandwidth = function (line) {
	    var parts = line.substr(2).split(':');
	    var parsed = {};
	    parsed.type = parts.shift();
	    parsed.bandwidth = parts.shift();
	    return parsed;
	};

	exports.msid = function (line) {
	    var data = line.substr(7);
	    var parts = data.split(' ');
	    return {
	        msid: data,
	        mslabel: parts[0],
	        label: parts[1]
	    };
	};


/***/ },
/* 470 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	// based on https://github.com/ESTOS/strophe.jingle/
	// adds wildemitter support
	var util = __webpack_require__(197);
	var adapter = __webpack_require__(472); // jshint ignore:line
	var WildEmitter = __webpack_require__(478);

	function dumpSDP(description) {
	    return {
	        type: description.type,
	        sdp: description.sdp
	    };
	}

	function dumpStream(stream) {
	    var info = {
	        label: stream.id,
	    };
	    if (stream.getAudioTracks().length) {
	        info.audio = stream.getAudioTracks().map(function (track) {
	            return track.id;
	        });
	    }
	    if (stream.getVideoTracks().length) {
	        info.video = stream.getVideoTracks().map(function (track) {
	            return track.id;
	        });
	    }
	    return info;
	}

	function TraceablePeerConnection(config, constraints) {
	    var self = this;
	    WildEmitter.call(this);

	    this.peerconnection = new window.RTCPeerConnection(config, constraints);

	    this.trace = function (what, info) {
	        self.emit('PeerConnectionTrace', {
	            time: new Date(),
	            type: what,
	            value: info || ""
	        });
	    };

	    this.onicecandidate = null;
	    this.peerconnection.onicecandidate = function (event) {
	        self.trace('onicecandidate', event.candidate);
	        if (self.onicecandidate !== null) {
	            self.onicecandidate(event);
	        }
	    };
	    this.onaddstream = null;
	    this.peerconnection.onaddstream = function (event) {
	        self.trace('onaddstream', dumpStream(event.stream));
	        if (self.onaddstream !== null) {
	            self.onaddstream(event);
	        }
	    };
	    this.onremovestream = null;
	    this.peerconnection.onremovestream = function (event) {
	        self.trace('onremovestream', dumpStream(event.stream));
	        if (self.onremovestream !== null) {
	            self.onremovestream(event);
	        }
	    };
	    this.onsignalingstatechange = null;
	    this.peerconnection.onsignalingstatechange = function (event) {
	        self.trace('onsignalingstatechange', self.signalingState);
	        if (self.onsignalingstatechange !== null) {
	            self.onsignalingstatechange(event);
	        }
	    };
	    this.oniceconnectionstatechange = null;
	    this.peerconnection.oniceconnectionstatechange = function (event) {
	        self.trace('oniceconnectionstatechange', self.iceConnectionState);
	        if (self.oniceconnectionstatechange !== null) {
	            self.oniceconnectionstatechange(event);
	        }
	    };
	    this.onnegotiationneeded = null;
	    this.peerconnection.onnegotiationneeded = function (event) {
	        self.trace('onnegotiationneeded');
	        if (self.onnegotiationneeded !== null) {
	            self.onnegotiationneeded(event);
	        }
	    };
	    self.ondatachannel = null;
	    this.peerconnection.ondatachannel = function (event) {
	        self.trace('ondatachannel', event);
	        if (self.ondatachannel !== null) {
	            self.ondatachannel(event);
	        }
	    };
	    this.getLocalStreams = this.peerconnection.getLocalStreams.bind(this.peerconnection);
	    this.getRemoteStreams = this.peerconnection.getRemoteStreams.bind(this.peerconnection);
	}

	util.inherits(TraceablePeerConnection, WildEmitter);

	['signalingState', 'iceConnectionState', 'localDescription', 'remoteDescription'].forEach(function (prop) {
	    Object.defineProperty(TraceablePeerConnection.prototype, prop, {
	        get: function () {
	            return this.peerconnection[prop];
	        }
	    });
	});

	TraceablePeerConnection.prototype.addStream = function (stream) {
	    this.trace('addStream', dumpStream(stream));
	    this.peerconnection.addStream(stream);
	};

	TraceablePeerConnection.prototype.removeStream = function (stream) {
	    this.trace('removeStream', dumpStream(stream));
	    this.peerconnection.removeStream(stream);
	};

	TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
	    this.trace('createDataChannel', label, opts);
	    return this.peerconnection.createDataChannel(label, opts);
	};

	TraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {
	    var self = this;
	    this.trace('setLocalDescription', dumpSDP(description));
	    this.peerconnection.setLocalDescription(description,
	        function () {
	            self.trace('setLocalDescriptionOnSuccess');
	            if (successCallback) successCallback();
	        },
	        function (err) {
	            self.trace('setLocalDescriptionOnFailure', err);
	            if (failureCallback) failureCallback(err);
	        }
	    );
	};

	TraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {
	    var self = this;
	    this.trace('setRemoteDescription', dumpSDP(description));
	    this.peerconnection.setRemoteDescription(description,
	        function () {
	            self.trace('setRemoteDescriptionOnSuccess');
	            if (successCallback) successCallback();
	        },
	        function (err) {
	            self.trace('setRemoteDescriptionOnFailure', err);
	            if (failureCallback) failureCallback(err);
	        }
	    );
	};

	TraceablePeerConnection.prototype.close = function () {
	    this.trace('stop');
	    if (this.peerconnection.signalingState != 'closed') {
	        this.peerconnection.close();
	    }
	};

	TraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {
	    var self = this;
	    this.trace('createOffer', constraints);
	    this.peerconnection.createOffer(
	        function (offer) {
	            self.trace('createOfferOnSuccess', dumpSDP(offer));
	            if (successCallback) successCallback(offer);
	        },
	        function (err) {
	            self.trace('createOfferOnFailure', err);
	            if (failureCallback) failureCallback(err);
	        },
	        constraints
	    );
	};

	TraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {
	    var self = this;
	    this.trace('createAnswer', constraints);
	    this.peerconnection.createAnswer(
	        function (answer) {
	            self.trace('createAnswerOnSuccess', dumpSDP(answer));
	            if (successCallback) successCallback(answer);
	        },
	        function (err) {
	            self.trace('createAnswerOnFailure', err);
	            if (failureCallback) failureCallback(err);
	        },
	        constraints
	    );
	};

	TraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {
	    var self = this;
	    this.trace('addIceCandidate', candidate);
	    this.peerconnection.addIceCandidate(candidate,
	        function () {
	            //self.trace('addIceCandidateOnSuccess');
	            if (successCallback) successCallback();
	        },
	        function (err) {
	            self.trace('addIceCandidateOnFailure', err);
	            if (failureCallback) failureCallback(err);
	        }
	    );
	};

	TraceablePeerConnection.prototype.getStats = function () {
	    this.peerconnection.getStats.apply(this.peerconnection, arguments);
	};

	module.exports = TraceablePeerConnection;


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';

	// Shimming starts here.
	(function() {
	  // Utils.
	  var logging = __webpack_require__(473).log;
	  var browserDetails = __webpack_require__(473).browserDetails;
	  // Export to the adapter global object visible in the browser.
	  module.exports.browserDetails = browserDetails;
	  module.exports.extractVersion = __webpack_require__(473).extractVersion;
	  module.exports.disableLog = __webpack_require__(473).disableLog;

	  // Uncomment if you do not want any logging at all including the switch
	  // statement below. Can also be turned off in the browser via
	  // adapter.disableLog(true) but then logging from the switch statement below
	  // will still appear.
	  //require('./utils').disableLog(true);

	  // Warn if version is not supported regardless of browser.
	  // Min version can be set per browser in utils.js
	  if (browserDetails.version < browserDetails.minVersion) {
	    logging('Browser: ' + browserDetails.browser + ' Version: ' +
	        browserDetails.version + ' <' + ' minimum supported version: ' +
	        browserDetails.minVersion + '\n some things might not work!');
	  }

	  // Browser shims.
	  var chromeShim = __webpack_require__(474) || null;
	  var edgeShim = __webpack_require__(475) || null;
	  var firefoxShim = __webpack_require__(477) || null;

	  // Shim browser if found.
	  switch (browserDetails.browser) {
	    case 'chrome':
	      if (!chromeShim) {
	        logging('Chrome shim is not included in this adapter release.');
	        return;
	      }
	      logging('Adapter.js shimming chrome!');
	      // Export to the adapter global object visible in the browser.
	      module.exports.browserShim = chromeShim;

	      chromeShim.shimGetUserMedia();
	      chromeShim.shimSourceObject();
	      chromeShim.shimPeerConnection();
	      chromeShim.shimOnTrack();
	      break;
	    case 'edge':
	      if (!edgeShim) {
	        logging('MS edge shim is not included in this adapter release.');
	        return;
	      }
	      logging('Adapter.js shimming edge!');
	      // Export to the adapter global object visible in the browser.
	      module.exports.browserShim = edgeShim;

	      edgeShim.shimPeerConnection();
	      break;
	    case 'firefox':
	    if (!firefoxShim) {
	        logging('Firefox shim is not included in this adapter release.');
	        return;
	      }
	      logging('Adapter.js shimming firefox!');
	      // Export to the adapter global object visible in the browser.
	      module.exports.browserShim = firefoxShim;

	      firefoxShim.shimGetUserMedia();
	      firefoxShim.shimSourceObject();
	      firefoxShim.shimPeerConnection();
	      firefoxShim.shimOnTrack();
	      break;
	    default:
	      logging('Unsupported browser!');
	  }
	})();


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';

	var logDisabled_ = false;

	// Utility methods.
	var utils = {
	  disableLog: function(bool) {
	    if (typeof bool !== 'boolean') {
	      return new Error('Argument type: ' + typeof bool +
	          '. Please use a boolean.');
	    }
	    logDisabled_ = bool;
	    return (bool) ? 'adapter.js logging disabled' :
	        'adapter.js logging enabled';
	  },

	  log: function() {
	    if (typeof window === 'object') {
	      if (logDisabled_) {
	        return;
	      }
	      console.log.apply(console, arguments);
	    }
	  },

	   /**
	   * Extract browser version out of the provided user agent string.
	   * @param {!string} uastring userAgent string.
	   * @param {!string} expr Regular expression used as match criteria.
	   * @param {!number} pos position in the version string to be returned.
	   * @return {!number} browser version.
	   */
	  extractVersion: function(uastring, expr, pos) {
	    var match = uastring.match(expr);
	    return match && match.length >= pos && parseInt(match[pos], 10);
	  },

	  /**
	   * Browser detector.
	   * @return {object} result containing browser, version and minVersion
	   *     properties.
	   */
	  detectBrowser: function() {
	    // Returned result object.
	    var result = {};
	    result.browser = null;
	    result.version = null
	    result.minVersion = null;

	    // Non supported browser.
	    if (typeof window === 'undefined' || !window.navigator) {
	      result.browser = 'Not a supported browser.';
	      return result;
	    }

	    // Firefox.
	    if (navigator.mozGetUserMedia) {
	      result.browser = 'firefox';
	      result.version = this.extractVersion(navigator.userAgent,
	          /Firefox\/([0-9]+)\./, 1);
	      result.minVersion = 31;
	      return result;
	    }

	    // Chrome/Chromium/Webview.
	    if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
	      result.browser = 'chrome';
	      result.version = this.extractVersion(navigator.userAgent,
	          /Chrom(e|ium)\/([0-9]+)\./, 2);
	      result.minVersion = 38;
	      return result;
	    }

	    // Edge.
	    if (navigator.mediaDevices &&
	        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
	      result.browser = 'edge';
	      result.version = this.extractVersion(navigator.userAgent,
	          /Edge\/(\d+).(\d+)$/, 2);
	      result.minVersion = 10547;
	      return result;
	    }
	  }
	};

	// Export.
	module.exports = {
	  log: utils.log,
	  disableLog: utils.disableLog,
	  browserDetails: utils.detectBrowser(),
	  extractVersion: utils.extractVersion
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';
	var logging = __webpack_require__(473).log;
	var browserDetails = __webpack_require__(473).browserDetails;

	var chromeShim = {
	  shimOnTrack: function() {
	    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
	        window.RTCPeerConnection.prototype)) {
	      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
	        get: function() { return this._ontrack; },
	        set: function(f) {
	          var self = this;
	          if (this._ontrack) {
	            this.removeEventListener('track', this._ontrack);
	            this.removeEventListener('addstream', this._ontrackpoly);
	          }
	          this.addEventListener('track', this._ontrack = f);
	          this.addEventListener('addstream', this._ontrackpoly = function(e) {
	            // onaddstream does not fire when a track is added to an existing stream.
	            // but stream.onaddtrack is implemented so we use that
	            e.stream.addEventListener('addtrack', function(te) {
	              var event = new Event('track');
	              event.track = te.track;
	              event.receiver = {track: te.track};
	              event.streams = [e.stream];
	              self.dispatchEvent(event);
	            });
	            e.stream.getTracks().forEach(function(track) {
	              var event = new Event('track');
	              event.track = track;
	              event.receiver = {track: track};
	              event.streams = [e.stream];
	              this.dispatchEvent(event);
	            }.bind(this));
	          }.bind(this));
	        }
	      });
	    }
	  },

	  shimSourceObject: function() {
	    if (typeof window === 'object') {
	      if (window.HTMLMediaElement &&
	        !('srcObject' in window.HTMLMediaElement.prototype)) {
	        // Shim the srcObject property, once, when HTMLMediaElement is found.
	        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
	          get: function() {
	            return this._srcObject;
	          },
	          set: function(stream) {
	            // Use _srcObject as a private property for this shim
	            this._srcObject = stream;
	            if (this.src) {
	              URL.revokeObjectURL(this.src);
	            }
	            this.src = URL.createObjectURL(stream);
	            // We need to recreate the blob url when a track is added or removed.
	            // Doing it manually since we want to avoid a recursion.
	            stream.addEventListener('addtrack', function() {
	              if (self.src) {
	                URL.revokeObjectURL(self.src);
	              }
	              self.src = URL.createObjectURL(stream);
	            });
	            stream.addEventListener('removetrack', function() {
	              if (self.src) {
	                URL.revokeObjectURL(self.src);
	              }
	              self.src = URL.createObjectURL(stream);
	            });
	          }
	        });
	      }
	    }
	  },

	  shimPeerConnection: function() {
	    // The RTCPeerConnection object.
	    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
	      // Translate iceTransportPolicy to iceTransports,
	      // see https://code.google.com/p/webrtc/issues/detail?id=4869
	      logging('PeerConnection');
	      if (pcConfig && pcConfig.iceTransportPolicy) {
	        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
	      }

	      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
	      var origGetStats = pc.getStats.bind(pc);
	      pc.getStats = function(selector, successCallback, errorCallback) { // jshint ignore: line
	        var self = this;
	        var args = arguments;

	        // If selector is a function then we are in the old style stats so just
	        // pass back the original getStats format to avoid breaking old users.
	        if (arguments.length > 0 && typeof selector === 'function') {
	          return origGetStats(selector, successCallback);
	        }

	        var fixChromeStats_ = function(response) {
	          var standardReport = {};
	          var reports = response.result();
	          reports.forEach(function(report) {
	            var standardStats = {
	              id: report.id,
	              timestamp: report.timestamp,
	              type: report.type
	            };
	            report.names().forEach(function(name) {
	              standardStats[name] = report.stat(name);
	            });
	            standardReport[standardStats.id] = standardStats;
	          });

	          return standardReport;
	        };

	        if (arguments.length >= 2) {
	          var successCallbackWrapper_ = function(response) {
	            args[1](fixChromeStats_(response));
	          };

	          return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
	        }

	        // promise-support
	        return new Promise(function(resolve, reject) {
	          if (args.length === 1 && selector === null) {
	            origGetStats.apply(self, [
	                function(response) {
	                  resolve.apply(null, [fixChromeStats_(response)]);
	                }, reject]);
	          } else {
	            origGetStats.apply(self, [resolve, reject]);
	          }
	        });
	      };

	      return pc;
	    };
	    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

	    // wrap static methods. Currently just generateCertificate.
	    if (webkitRTCPeerConnection.generateCertificate) {
	      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
	        get: function() {
	          if (arguments.length) {
	            return webkitRTCPeerConnection.generateCertificate.apply(null,
	                arguments);
	          } else {
	            return webkitRTCPeerConnection.generateCertificate;
	          }
	        }
	      });
	    }

	    // add promise support
	    ['createOffer', 'createAnswer'].forEach(function(method) {
	      var nativeMethod = webkitRTCPeerConnection.prototype[method];
	      webkitRTCPeerConnection.prototype[method] = function() {
	        var self = this;
	        if (arguments.length < 1 || (arguments.length === 1 &&
	            typeof(arguments[0]) === 'object')) {
	          var opts = arguments.length === 1 ? arguments[0] : undefined;
	          return new Promise(function(resolve, reject) {
	            nativeMethod.apply(self, [resolve, reject, opts]);
	          });
	        } else {
	          return nativeMethod.apply(this, arguments);
	        }
	      };
	    });

	    ['setLocalDescription', 'setRemoteDescription',
	        'addIceCandidate'].forEach(function(method) {
	      var nativeMethod = webkitRTCPeerConnection.prototype[method];
	      webkitRTCPeerConnection.prototype[method] = function() {
	        var args = arguments;
	        var self = this;
	        return new Promise(function(resolve, reject) {
	          nativeMethod.apply(self, [args[0],
	              function() {
	                resolve();
	                if (args.length >= 2) {
	                  args[1].apply(null, []);
	                }
	              },
	              function(err) {
	                reject(err);
	                if (args.length >= 3) {
	                  args[2].apply(null, [err]);
	                }
	              }]
	            );
	        });
	      };
	    });
	  },

	  shimGetUserMedia: function() {
	    var constraintsToChrome_ = function(c) {
	      if (typeof c !== 'object' || c.mandatory || c.optional) {
	        return c;
	      }
	      var cc = {};
	      Object.keys(c).forEach(function(key) {
	        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	          return;
	        }
	        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
	        if (r.exact !== undefined && typeof r.exact === 'number') {
	          r.min = r.max = r.exact;
	        }
	        var oldname_ = function(prefix, name) {
	          if (prefix) {
	            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
	          }
	          return (name === 'deviceId') ? 'sourceId' : name;
	        };
	        if (r.ideal !== undefined) {
	          cc.optional = cc.optional || [];
	          var oc = {};
	          if (typeof r.ideal === 'number') {
	            oc[oldname_('min', key)] = r.ideal;
	            cc.optional.push(oc);
	            oc = {};
	            oc[oldname_('max', key)] = r.ideal;
	            cc.optional.push(oc);
	          } else {
	            oc[oldname_('', key)] = r.ideal;
	            cc.optional.push(oc);
	          }
	        }
	        if (r.exact !== undefined && typeof r.exact !== 'number') {
	          cc.mandatory = cc.mandatory || {};
	          cc.mandatory[oldname_('', key)] = r.exact;
	        } else {
	          ['min', 'max'].forEach(function(mix) {
	            if (r[mix] !== undefined) {
	              cc.mandatory = cc.mandatory || {};
	              cc.mandatory[oldname_(mix, key)] = r[mix];
	            }
	          });
	        }
	      });
	      if (c.advanced) {
	        cc.optional = (cc.optional || []).concat(c.advanced);
	      }
	      return cc;
	    };

	    var getUserMedia_ = function(constraints, onSuccess, onError) {
	      if (constraints.audio) {
	        constraints.audio = constraintsToChrome_(constraints.audio);
	      }
	      if (constraints.video) {
	        constraints.video = constraintsToChrome_(constraints.video);
	      }
	      logging('chrome: ' + JSON.stringify(constraints));
	      return navigator.webkitGetUserMedia(constraints, onSuccess, onError);
	    };
	    navigator.getUserMedia = getUserMedia_;

	    // Returns the result of getUserMedia as a Promise.
	    var getUserMediaPromise_ = function(constraints) {
	      return new Promise(function(resolve, reject) {
	        navigator.getUserMedia(constraints, resolve, reject);
	      });
	    }

	    if (!navigator.mediaDevices) {
	      navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
	                               enumerateDevices: function() {
	        return new Promise(function(resolve) {
	          var kinds = {audio: 'audioinput', video: 'videoinput'};
	          return MediaStreamTrack.getSources(function(devices) {
	            resolve(devices.map(function(device) {
	              return {label: device.label,
	                      kind: kinds[device.kind],
	                      deviceId: device.id,
	                      groupId: ''};
	            }));
	          });
	        });
	      }};
	    }

	    // A shim for getUserMedia method on the mediaDevices object.
	    // TODO(KaptenJansson) remove once implemented in Chrome stable.
	    if (!navigator.mediaDevices.getUserMedia) {
	      navigator.mediaDevices.getUserMedia = function(constraints) {
	        return getUserMediaPromise_(constraints);
	      };
	    } else {
	      // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
	      // function which returns a Promise, it does not accept spec-style
	      // constraints.
	      var origGetUserMedia = navigator.mediaDevices.getUserMedia.
	          bind(navigator.mediaDevices);
	      navigator.mediaDevices.getUserMedia = function(c) {
	        if (c) {
	          logging('spec:   ' + JSON.stringify(c)); // whitespace for alignment
	          c.audio = constraintsToChrome_(c.audio);
	          c.video = constraintsToChrome_(c.video);
	          logging('chrome: ' + JSON.stringify(c));
	        }
	        return origGetUserMedia(c);
	      }.bind(this);
	    }

	    // Dummy devicechange event methods.
	    // TODO(KaptenJansson) remove once implemented in Chrome stable.
	    if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
	      navigator.mediaDevices.addEventListener = function() {
	        logging('Dummy mediaDevices.addEventListener called.');
	      };
	    }
	    if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
	      navigator.mediaDevices.removeEventListener = function() {
	        logging('Dummy mediaDevices.removeEventListener called.');
	      };
	    }
	  },

	  // Attach a media stream to an element.
	  attachMediaStream: function(element, stream) {
	    logging('DEPRECATED, attachMediaStream will soon be removed.');
	    if (browserDetails.version >= 43) {
	      element.srcObject = stream;
	    } else if (typeof element.src !== 'undefined') {
	      element.src = URL.createObjectURL(stream);
	    } else {
	      logging('Error attaching stream to element.');
	    }
	  },

	  reattachMediaStream: function(to, from) {
	    logging('DEPRECATED, reattachMediaStream will soon be removed.');
	    if (browserDetails.version >= 43) {
	      to.srcObject = from.srcObject;
	    } else {
	      to.src = from.src;
	    }
	  }
	}

	// Expose public methods.
	module.exports = {
	  shimOnTrack: chromeShim.shimOnTrack,
	  shimSourceObject: chromeShim.shimSourceObject,
	  shimPeerConnection: chromeShim.shimPeerConnection,
	  shimGetUserMedia: chromeShim.shimGetUserMedia,
	  attachMediaStream: chromeShim.attachMediaStream,
	  reattachMediaStream: chromeShim.reattachMediaStream
	};


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';

	var SDPUtils = __webpack_require__(476);
	var logging = __webpack_require__(473).log;
	var browserDetails = __webpack_require__(473).browserDetails;

	var edgeShim = {
	  shimPeerConnection: function() {
	    if (window.RTCIceGatherer) {
	      // ORTC defines an RTCIceCandidate object but no constructor.
	      // Not implemented in Edge.
	      if (!window.RTCIceCandidate) {
	        window.RTCIceCandidate = function(args) {
	          return args;
	        };
	      }
	      // ORTC does not have a session description object but
	      // other browsers (i.e. Chrome) that will support both PC and ORTC
	      // in the future might have this defined already.
	      if (!window.RTCSessionDescription) {
	        window.RTCSessionDescription = function(args) {
	          return args;
	        };
	      }
	    }

	    window.RTCPeerConnection = function(config) {
	      var self = this;

	      this.onicecandidate = null;
	      this.onaddstream = null;
	      this.onremovestream = null;
	      this.onsignalingstatechange = null;
	      this.oniceconnectionstatechange = null;
	      this.onnegotiationneeded = null;
	      this.ondatachannel = null;

	      this.localStreams = [];
	      this.remoteStreams = [];
	      this.getLocalStreams = function() { return self.localStreams; };
	      this.getRemoteStreams = function() { return self.remoteStreams; };

	      this.localDescription = new RTCSessionDescription({
	        type: '',
	        sdp: ''
	      });
	      this.remoteDescription = new RTCSessionDescription({
	        type: '',
	        sdp: ''
	      });
	      this.signalingState = 'stable';
	      this.iceConnectionState = 'new';

	      this.iceOptions = {
	        gatherPolicy: 'all',
	        iceServers: []
	      };
	      if (config && config.iceTransportPolicy) {
	        switch (config.iceTransportPolicy) {
	          case 'all':
	          case 'relay':
	            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
	            break;
	          case 'none':
	            // FIXME: remove once implementation and spec have added this.
	            throw new TypeError('iceTransportPolicy "none" not supported');
	        }
	      }
	      if (config && config.iceServers) {
	        // Edge does not like
	        // 1) stun:
	        // 2) turn: that does not have all of turn:host:port?transport=udp
	        this.iceOptions.iceServers = config.iceServers.filter(function(server) {
	          if (server && server.urls) {
	            server.urls = server.urls.filter(function(url) {
	              return url.indexOf('transport=udp') !== -1;
	            })[0];
	            return true;
	          }
	          return false;
	        });
	      }

	      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
	      // everything that is needed to describe a SDP m-line.
	      this.transceivers = [];

	      // since the iceGatherer is currently created in createOffer but we
	      // must not emit candidates until after setLocalDescription we buffer
	      // them in this array.
	      this._localIceCandidatesBuffer = [];
	    };

	    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
	      var self = this;
	      // FIXME: need to apply ice candidates in a way which is async but in-order
	      this._localIceCandidatesBuffer.forEach(function(event) {
	        if (self.onicecandidate !== null) {
	          self.onicecandidate(event);
	        }
	      });
	      this._localIceCandidatesBuffer = [];
	    };

	    window.RTCPeerConnection.prototype.addStream = function(stream) {
	      // Clone is necessary for local demos mostly, attaching directly
	      // to two different senders does not work (build 10547).
	      this.localStreams.push(stream.clone());
	      this._maybeFireNegotiationNeeded();
	    };

	    window.RTCPeerConnection.prototype.removeStream = function(stream) {
	      var idx = this.localStreams.indexOf(stream);
	      if (idx > -1) {
	        this.localStreams.splice(idx, 1);
	        this._maybeFireNegotiationNeeded();
	      }
	    };

	    // Determines the intersection of local and remote capabilities.
	    window.RTCPeerConnection.prototype._getCommonCapabilities =
	        function(localCapabilities, remoteCapabilities) {
	      var commonCapabilities = {
	        codecs: [],
	        headerExtensions: [],
	        fecMechanisms: []
	      };
	      localCapabilities.codecs.forEach(function(lCodec) {
	        for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
	          var rCodec = remoteCapabilities.codecs[i];
	          if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
	              lCodec.clockRate === rCodec.clockRate &&
	              lCodec.numChannels === rCodec.numChannels) {
	            // push rCodec so we reply with offerer payload type
	            commonCapabilities.codecs.push(rCodec);

	            // FIXME: also need to determine intersection between
	            // .rtcpFeedback and .parameters
	            break;
	          }
	        }
	      });

	      localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
	        for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
	          var rHeaderExtension = remoteCapabilities.headerExtensions[i];
	          if (lHeaderExtension.uri === rHeaderExtension.uri) {
	            commonCapabilities.headerExtensions.push(rHeaderExtension);
	            break;
	          }
	        }
	      });

	      // FIXME: fecMechanisms
	      return commonCapabilities;
	    };

	    // Create ICE gatherer, ICE transport and DTLS transport.
	    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
	        function(mid, sdpMLineIndex) {
	      var self = this;
	      var iceGatherer = new RTCIceGatherer(self.iceOptions);
	      var iceTransport = new RTCIceTransport(iceGatherer);
	      iceGatherer.onlocalcandidate = function(evt) {
	        var event = {};
	        event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

	        var cand = evt.candidate;
	        // Edge emits an empty object for RTCIceCandidateComplete
	        if (!cand || Object.keys(cand).length === 0) {
	          // polyfill since RTCIceGatherer.state is not implemented in Edge 10547 yet.
	          if (iceGatherer.state === undefined) {
	            iceGatherer.state = 'completed';
	          }

	          // Emit a candidate with type endOfCandidates to make the samples work.
	          // Edge requires addIceCandidate with this empty candidate to start checking.
	          // The real solution is to signal end-of-candidates to the other side when
	          // getting the null candidate but some apps (like the samples) don't do that.
	          event.candidate.candidate =
	              'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
	        } else {
	          // RTCIceCandidate doesn't have a component, needs to be added
	          cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
	          event.candidate.candidate = SDPUtils.writeCandidate(cand);
	        }

	        var complete = self.transceivers.every(function(transceiver) {
	          return transceiver.iceGatherer &&
	              transceiver.iceGatherer.state === 'completed';
	        });
	        // FIXME: update .localDescription with candidate and (potentially) end-of-candidates.
	        //     To make this harder, the gatherer might emit candidates before localdescription
	        //     is set. To make things worse, gather.getLocalCandidates still errors in
	        //     Edge 10547 when no candidates have been gathered yet.

	        if (self.onicecandidate !== null) {
	          // Emit candidate if localDescription is set.
	          // Also emits null candidate when all gatherers are complete.
	          if (self.localDescription && self.localDescription.type === '') {
	            self._localIceCandidatesBuffer.push(event);
	            if (complete) {
	              self._localIceCandidatesBuffer.push({});
	            }
	          } else {
	            self.onicecandidate(event);
	            if (complete) {
	              self.onicecandidate({});
	            }
	          }
	        }
	      };
	      iceTransport.onicestatechange = function() {
	        self._updateConnectionState();
	      };

	      var dtlsTransport = new RTCDtlsTransport(iceTransport);
	      dtlsTransport.ondtlsstatechange = function() {
	        self._updateConnectionState();
	      };
	      dtlsTransport.onerror = function() {
	        // onerror does not set state to failed by itself.
	        dtlsTransport.state = 'failed';
	        self._updateConnectionState();
	      };

	      return {
	        iceGatherer: iceGatherer,
	        iceTransport: iceTransport,
	        dtlsTransport: dtlsTransport
	      };
	    };

	    // Start the RTP Sender and Receiver for a transceiver.
	    window.RTCPeerConnection.prototype._transceive = function(transceiver,
	        send, recv) {
	      var params = this._getCommonCapabilities(transceiver.localCapabilities,
	          transceiver.remoteCapabilities);
	      if (send && transceiver.rtpSender) {
	        params.encodings = [{
	          ssrc: transceiver.sendSsrc
	        }];
	        params.rtcp = {
	          cname: SDPUtils.localCName,
	          ssrc: transceiver.recvSsrc
	        };
	        transceiver.rtpSender.send(params);
	      }
	      if (recv && transceiver.rtpReceiver) {
	        params.encodings = [{
	          ssrc: transceiver.recvSsrc
	        }];
	        params.rtcp = {
	          cname: transceiver.cname,
	          ssrc: transceiver.sendSsrc
	        };
	        transceiver.rtpReceiver.receive(params);
	      }
	    };

	    window.RTCPeerConnection.prototype.setLocalDescription =
	        function(description) {
	      var self = this;
	      if (description.type === 'offer') {
	        if (!this._pendingOffer) {
	        } else {
	          this.transceivers = this._pendingOffer;
	          delete this._pendingOffer;
	        }
	      } else if (description.type === 'answer') {
	        var sections = SDPUtils.splitSections(self.remoteDescription.sdp);
	        var sessionpart = sections.shift();
	        sections.forEach(function(mediaSection, sdpMLineIndex) {
	          var transceiver = self.transceivers[sdpMLineIndex];
	          var iceGatherer = transceiver.iceGatherer;
	          var iceTransport = transceiver.iceTransport;
	          var dtlsTransport = transceiver.dtlsTransport;
	          var localCapabilities = transceiver.localCapabilities;
	          var remoteCapabilities = transceiver.remoteCapabilities;
	          var rejected = mediaSection.split('\n', 1)[0]
	              .split(' ', 2)[1] === '0';

	          if (!rejected) {
	            var remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
	                sessionpart);
	            iceTransport.start(iceGatherer, remoteIceParameters, 'controlled');

	            var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
	              sessionpart);
	            dtlsTransport.start(remoteDtlsParameters);

	            // Calculate intersection of capabilities.
	            var params = self._getCommonCapabilities(localCapabilities,
	                remoteCapabilities);

	            // Start the RTCRtpSender. The RTCRtpReceiver for this transceiver
	            // has already been started in setRemoteDescription.
	            self._transceive(transceiver,
	                params.codecs.length > 0,
	                false);
	          }
	        });
	      }

	      this.localDescription = description;
	      switch (description.type) {
	        case 'offer':
	          this._updateSignalingState('have-local-offer');
	          break;
	        case 'answer':
	          this._updateSignalingState('stable');
	          break;
	        default:
	          throw new TypeError('unsupported type "' + description.type + '"');
	      }

	      // If a success callback was provided, emit ICE candidates after it has been
	      // executed. Otherwise, emit callback after the Promise is resolved.
	      var hasCallback = arguments.length > 1 &&
	        typeof arguments[1] === 'function';
	      if (hasCallback) {
	        var cb = arguments[1];
	        window.setTimeout(function() {
	          cb();
	          self._emitBufferedCandidates();
	        }, 0);
	      }
	      var p = Promise.resolve();
	      p.then(function() {
	        if (!hasCallback) {
	          window.setTimeout(self._emitBufferedCandidates.bind(self), 0);
	        }
	      });
	      return p;
	    };

	    window.RTCPeerConnection.prototype.setRemoteDescription =
	        function(description) {
	      var self = this;
	      var stream = new MediaStream();
	      var sections = SDPUtils.splitSections(description.sdp);
	      var sessionpart = sections.shift();
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var lines = SDPUtils.splitLines(mediaSection);
	        var mline = lines[0].substr(2).split(' ');
	        var kind = mline[0];
	        var rejected = mline[1] === '0';
	        var direction = SDPUtils.getDirection(mediaSection, sessionpart);

	        var transceiver;
	        var iceGatherer;
	        var iceTransport;
	        var dtlsTransport;
	        var rtpSender;
	        var rtpReceiver;
	        var sendSsrc;
	        var recvSsrc;
	        var localCapabilities;

	        // FIXME: ensure the mediaSection has rtcp-mux set.
	        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
	        var remoteIceParameters;
	        var remoteDtlsParameters;
	        if (!rejected) {
	          remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
	              sessionpart);
	          remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
	              sessionpart);
	        }
	        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0].substr(6);

	        var cname;
	        // Gets the first SSRC. Note that with RTX there might be multiple SSRCs.
	        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
	            .map(function(line) {
	              return SDPUtils.parseSsrcMedia(line);
	            })
	            .filter(function(obj) {
	              return obj.attribute === 'cname';
	            })[0];
	        if (remoteSsrc) {
	          recvSsrc = parseInt(remoteSsrc.ssrc, 10);
	          cname = remoteSsrc.value;
	        }

	        if (description.type === 'offer') {
	          var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);

	          localCapabilities = RTCRtpReceiver.getCapabilities(kind);
	          sendSsrc = (2 * sdpMLineIndex + 2) * 1001;

	          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

	          // FIXME: not correct when there are multiple streams but that is
	          // not currently supported in this shim.
	          stream.addTrack(rtpReceiver.track);

	          // FIXME: look at direction.
	          if (self.localStreams.length > 0 &&
	              self.localStreams[0].getTracks().length >= sdpMLineIndex) {
	            // FIXME: actually more complicated, needs to match types etc
	            var localtrack = self.localStreams[0].getTracks()[sdpMLineIndex];
	            rtpSender = new RTCRtpSender(localtrack, transports.dtlsTransport);
	          }

	          self.transceivers[sdpMLineIndex] = {
	            iceGatherer: transports.iceGatherer,
	            iceTransport: transports.iceTransport,
	            dtlsTransport: transports.dtlsTransport,
	            localCapabilities: localCapabilities,
	            remoteCapabilities: remoteCapabilities,
	            rtpSender: rtpSender,
	            rtpReceiver: rtpReceiver,
	            kind: kind,
	            mid: mid,
	            cname: cname,
	            sendSsrc: sendSsrc,
	            recvSsrc: recvSsrc
	          };
	          // Start the RTCRtpReceiver now. The RTPSender is started in setLocalDescription.
	          self._transceive(self.transceivers[sdpMLineIndex],
	              false,
	              direction === 'sendrecv' || direction === 'sendonly');
	        } else if (description.type === 'answer' && !rejected) {
	          transceiver = self.transceivers[sdpMLineIndex];
	          iceGatherer = transceiver.iceGatherer;
	          iceTransport = transceiver.iceTransport;
	          dtlsTransport = transceiver.dtlsTransport;
	          rtpSender = transceiver.rtpSender;
	          rtpReceiver = transceiver.rtpReceiver;
	          sendSsrc = transceiver.sendSsrc;
	          //recvSsrc = transceiver.recvSsrc;
	          localCapabilities = transceiver.localCapabilities;

	          self.transceivers[sdpMLineIndex].recvSsrc = recvSsrc;
	          self.transceivers[sdpMLineIndex].remoteCapabilities =
	              remoteCapabilities;
	          self.transceivers[sdpMLineIndex].cname = cname;

	          iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
	          dtlsTransport.start(remoteDtlsParameters);

	          self._transceive(transceiver,
	              direction === 'sendrecv' || direction === 'recvonly',
	              direction === 'sendrecv' || direction === 'sendonly');

	          if (rtpReceiver &&
	              (direction === 'sendrecv' || direction === 'sendonly')) {
	            stream.addTrack(rtpReceiver.track);
	          } else {
	            // FIXME: actually the receiver should be created later.
	            delete transceiver.rtpReceiver;
	          }
	        }
	      });

	      this.remoteDescription = description;
	      switch (description.type) {
	        case 'offer':
	          this._updateSignalingState('have-remote-offer');
	          break;
	        case 'answer':
	          this._updateSignalingState('stable');
	          break;
	        default:
	          throw new TypeError('unsupported type "' + description.type + '"');
	      }
	      window.setTimeout(function() {
	        if (self.onaddstream !== null && stream.getTracks().length) {
	          self.remoteStreams.push(stream);
	          window.setTimeout(function() {
	            self.onaddstream({stream: stream});
	          }, 0);
	        }
	      }, 0);
	      if (arguments.length > 1 && typeof arguments[1] === 'function') {
	        window.setTimeout(arguments[1], 0);
	      }
	      return Promise.resolve();
	    };

	    window.RTCPeerConnection.prototype.close = function() {
	      this.transceivers.forEach(function(transceiver) {
	        /* not yet
	        if (transceiver.iceGatherer) {
	          transceiver.iceGatherer.close();
	        }
	        */
	        if (transceiver.iceTransport) {
	          transceiver.iceTransport.stop();
	        }
	        if (transceiver.dtlsTransport) {
	          transceiver.dtlsTransport.stop();
	        }
	        if (transceiver.rtpSender) {
	          transceiver.rtpSender.stop();
	        }
	        if (transceiver.rtpReceiver) {
	          transceiver.rtpReceiver.stop();
	        }
	      });
	      // FIXME: clean up tracks, local streams, remote streams, etc
	      this._updateSignalingState('closed');
	    };

	    // Update the signaling state.
	    window.RTCPeerConnection.prototype._updateSignalingState =
	        function(newState) {
	      this.signalingState = newState;
	      if (this.onsignalingstatechange !== null) {
	        this.onsignalingstatechange();
	      }
	    };

	    // Determine whether to fire the negotiationneeded event.
	    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
	        function() {
	      // Fire away (for now).
	      if (this.onnegotiationneeded !== null) {
	        this.onnegotiationneeded();
	      }
	    };

	    // Update the connection state.
	    window.RTCPeerConnection.prototype._updateConnectionState =
	        function() {
	      var self = this;
	      var newState;
	      var states = {
	        'new': 0,
	        closed: 0,
	        connecting: 0,
	        checking: 0,
	        connected: 0,
	        completed: 0,
	        failed: 0
	      };
	      this.transceivers.forEach(function(transceiver) {
	        states[transceiver.iceTransport.state]++;
	        states[transceiver.dtlsTransport.state]++;
	      });
	      // ICETransport.completed and connected are the same for this purpose.
	      states.connected += states.completed;

	      newState = 'new';
	      if (states.failed > 0) {
	        newState = 'failed';
	      } else if (states.connecting > 0 || states.checking > 0) {
	        newState = 'connecting';
	      } else if (states.disconnected > 0) {
	        newState = 'disconnected';
	      } else if (states.new > 0) {
	        newState = 'new';
	      } else if (states.connecting > 0 || states.completed > 0) {
	        newState = 'connected';
	      }

	      if (newState !== self.iceConnectionState) {
	        self.iceConnectionState = newState;
	        if (this.oniceconnectionstatechange !== null) {
	          this.oniceconnectionstatechange();
	        }
	      }
	    };

	    window.RTCPeerConnection.prototype.createOffer = function() {
	      var self = this;
	      if (this._pendingOffer) {
	        throw new Error('createOffer called while there is a pending offer.');
	      }
	      var offerOptions;
	      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	        offerOptions = arguments[0];
	      } else if (arguments.length === 3) {
	        offerOptions = arguments[2];
	      }

	      var tracks = [];
	      var numAudioTracks = 0;
	      var numVideoTracks = 0;
	      // Default to sendrecv.
	      if (this.localStreams.length) {
	        numAudioTracks = this.localStreams[0].getAudioTracks().length;
	        numVideoTracks = this.localStreams[0].getVideoTracks().length;
	      }
	      // Determine number of audio and video tracks we need to send/recv.
	      if (offerOptions) {
	        // Reject Chrome legacy constraints.
	        if (offerOptions.mandatory || offerOptions.optional) {
	          throw new TypeError(
	              'Legacy mandatory/optional constraints not supported.');
	        }
	        if (offerOptions.offerToReceiveAudio !== undefined) {
	          numAudioTracks = offerOptions.offerToReceiveAudio;
	        }
	        if (offerOptions.offerToReceiveVideo !== undefined) {
	          numVideoTracks = offerOptions.offerToReceiveVideo;
	        }
	      }
	      if (this.localStreams.length) {
	        // Push local streams.
	        this.localStreams[0].getTracks().forEach(function(track) {
	          tracks.push({
	            kind: track.kind,
	            track: track,
	            wantReceive: track.kind === 'audio' ?
	                numAudioTracks > 0 : numVideoTracks > 0
	          });
	          if (track.kind === 'audio') {
	            numAudioTracks--;
	          } else if (track.kind === 'video') {
	            numVideoTracks--;
	          }
	        });
	      }
	      // Create M-lines for recvonly streams.
	      while (numAudioTracks > 0 || numVideoTracks > 0) {
	        if (numAudioTracks > 0) {
	          tracks.push({
	            kind: 'audio',
	            wantReceive: true
	          });
	          numAudioTracks--;
	        }
	        if (numVideoTracks > 0) {
	          tracks.push({
	            kind: 'video',
	            wantReceive: true
	          });
	          numVideoTracks--;
	        }
	      }

	      var sdp = SDPUtils.writeSessionBoilerplate();
	      var transceivers = [];
	      tracks.forEach(function(mline, sdpMLineIndex) {
	        // For each track, create an ice gatherer, ice transport, dtls transport,
	        // potentially rtpsender and rtpreceiver.
	        var track = mline.track;
	        var kind = mline.kind;
	        var mid = SDPUtils.generateIdentifier();

	        var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);

	        var localCapabilities = RTCRtpSender.getCapabilities(kind);
	        var rtpSender;
	        var rtpReceiver;

	        // generate an ssrc now, to be used later in rtpSender.send
	        var sendSsrc = (2 * sdpMLineIndex + 1) * 1001;
	        if (track) {
	          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
	        }

	        if (mline.wantReceive) {
	          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
	        }

	        transceivers[sdpMLineIndex] = {
	          iceGatherer: transports.iceGatherer,
	          iceTransport: transports.iceTransport,
	          dtlsTransport: transports.dtlsTransport,
	          localCapabilities: localCapabilities,
	          remoteCapabilities: null,
	          rtpSender: rtpSender,
	          rtpReceiver: rtpReceiver,
	          kind: kind,
	          mid: mid,
	          sendSsrc: sendSsrc,
	          recvSsrc: null
	        };
	        var transceiver = transceivers[sdpMLineIndex];
	        sdp += SDPUtils.writeMediaSection(transceiver,
	            transceiver.localCapabilities, 'offer', self.localStreams[0]);
	      });

	      this._pendingOffer = transceivers;
	      var desc = new RTCSessionDescription({
	        type: 'offer',
	        sdp: sdp
	      });
	      if (arguments.length && typeof arguments[0] === 'function') {
	        window.setTimeout(arguments[0], 0, desc);
	      }
	      return Promise.resolve(desc);
	    };

	    window.RTCPeerConnection.prototype.createAnswer = function() {
	      var self = this;
	      var answerOptions;
	      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	        answerOptions = arguments[0];
	      } else if (arguments.length === 3) {
	        answerOptions = arguments[2];
	      }

	      var sdp = SDPUtils.writeSessionBoilerplate();
	      this.transceivers.forEach(function(transceiver) {
	        // Calculate intersection of capabilities.
	        var commonCapabilities = self._getCommonCapabilities(
	            transceiver.localCapabilities,
	            transceiver.remoteCapabilities);

	        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
	            'answer', self.localStreams[0]);
	      });

	      var desc = new RTCSessionDescription({
	        type: 'answer',
	        sdp: sdp
	      });
	      if (arguments.length && typeof arguments[0] === 'function') {
	        window.setTimeout(arguments[0], 0, desc);
	      }
	      return Promise.resolve(desc);
	    };

	    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
	      var mLineIndex = candidate.sdpMLineIndex;
	      if (candidate.sdpMid) {
	        for (var i = 0; i < this.transceivers.length; i++) {
	          if (this.transceivers[i].mid === candidate.sdpMid) {
	            mLineIndex = i;
	            break;
	          }
	        }
	      }
	      var transceiver = this.transceivers[mLineIndex];
	      if (transceiver) {
	        var cand = Object.keys(candidate.candidate).length > 0 ?
	            SDPUtils.parseCandidate(candidate.candidate) : {};
	        // Ignore Chrome's invalid candidates since Edge does not like them.
	        if (cand.protocol === 'tcp' && cand.port === 0) {
	          return;
	        }
	        // Ignore RTCP candidates, we assume RTCP-MUX.
	        if (cand.component !== '1') {
	          return;
	        }
	        // A dirty hack to make samples work.
	        if (cand.type === 'endOfCandidates') {
	          cand = {};
	        }
	        transceiver.iceTransport.addRemoteCandidate(cand);
	      }
	      if (arguments.length > 1 && typeof arguments[1] === 'function') {
	        window.setTimeout(arguments[1], 0);
	      }
	      return Promise.resolve();
	    };

	    window.RTCPeerConnection.prototype.getStats = function() {
	      var promises = [];
	      this.transceivers.forEach(function(transceiver) {
	        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
	            'dtlsTransport'].forEach(function(method) {
	          if (transceiver[method]) {
	            promises.push(transceiver[method].getStats());
	          }
	        });
	      });
	      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
	          arguments[1];
	      return new Promise(function(resolve) {
	        var results = {};
	        Promise.all(promises).then(function(res) {
	          res.forEach(function(result) {
	            Object.keys(result).forEach(function(id) {
	              results[id] = result[id];
	            });
	          });
	          if (cb) {
	            window.setTimeout(cb, 0, results);
	          }
	          resolve(results);
	        });
	      });
	    };
	  },

	  // Attach a media stream to an element.
	  attachMediaStream: function(element, stream) {
	    logging('DEPRECATED, attachMediaStream will soon be removed.');
	    element.srcObject = stream;
	  },

	  reattachMediaStream: function(to, from) {
	    logging('DEPRECATED, reattachMediaStream will soon be removed.');
	    to.srcObject = from.srcObject;
	  }
	}

	// Expose public methods.
	module.exports = {
	  shimPeerConnection: edgeShim.shimPeerConnection,
	  attachMediaStream: edgeShim.attachMediaStream,
	  reattachMediaStream: edgeShim.reattachMediaStream
	}



/***/ },
/* 476 */
/***/ function(module, exports) {

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';

	// SDP helpers.
	var SDPUtils = {};

	// Generate an alphanumeric identifier for cname or mids.
	// TODO: use UUIDs instead? https://gist.github.com/jed/982883
	SDPUtils.generateIdentifier = function() {
	  return Math.random().toString(36).substr(2, 10);
	};

	// The RTCP CNAME used by all peerconnections from the same JS.
	SDPUtils.localCName = SDPUtils.generateIdentifier();


	// Splits SDP into lines, dealing with both CRLF and LF.
	SDPUtils.splitLines = function(blob) {
	  return blob.trim().split('\n').map(function(line) {
	    return line.trim();
	  });
	};
	// Splits SDP into sessionpart and mediasections. Ensures CRLF.
	SDPUtils.splitSections = function(blob) {
	  var parts = blob.split('\r\nm=');
	  return parts.map(function(part, index) {
	    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
	  });
	};

	// Returns lines that start with a certain prefix.
	SDPUtils.matchPrefix = function(blob, prefix) {
	  return SDPUtils.splitLines(blob).filter(function(line) {
	    return line.indexOf(prefix) === 0;
	  });
	};

	// Parses an ICE candidate line. Sample input:
	// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8 rport 55996"
	SDPUtils.parseCandidate = function(line) {
	  var parts;
	  // Parse both variants.
	  if (line.indexOf('a=candidate:') === 0) {
	    parts = line.substring(12).split(' ');
	  } else {
	    parts = line.substring(10).split(' ');
	  }

	  var candidate = {
	    foundation: parts[0],
	    component: parts[1],
	    protocol: parts[2].toLowerCase(),
	    priority: parseInt(parts[3], 10),
	    ip: parts[4],
	    port: parseInt(parts[5], 10),
	    // skip parts[6] == 'typ'
	    type: parts[7]
	  };

	  for (var i = 8; i < parts.length; i += 2) {
	    switch (parts[i]) {
	      case 'raddr':
	        candidate.relatedAddress = parts[i + 1];
	        break;
	      case 'rport':
	        candidate.relatedPort = parseInt(parts[i + 1], 10);
	        break;
	      case 'tcptype':
	        candidate.tcpType = parts[i + 1];
	        break;
	      default: // Unknown extensions are silently ignored.
	        break;
	    }
	  }
	  return candidate;
	};

	// Translates a candidate object into SDP candidate attribute.
	SDPUtils.writeCandidate = function(candidate) {
	  var sdp = [];
	  sdp.push(candidate.foundation);
	  sdp.push(candidate.component);
	  sdp.push(candidate.protocol.toUpperCase());
	  sdp.push(candidate.priority);
	  sdp.push(candidate.ip);
	  sdp.push(candidate.port);

	  var type = candidate.type;
	  sdp.push('typ');
	  sdp.push(type);
	  if (type !== 'host' && candidate.relatedAddress &&
	      candidate.relatedPort) {
	    sdp.push('raddr');
	    sdp.push(candidate.relatedAddress); // was: relAddr
	    sdp.push('rport');
	    sdp.push(candidate.relatedPort); // was: relPort
	  }
	  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
	    sdp.push('tcptype');
	    sdp.push(candidate.tcpType);
	  }
	  return 'candidate:' + sdp.join(' ');
	};

	// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
	// a=rtpmap:111 opus/48000/2
	SDPUtils.parseRtpMap = function(line) {
	  var parts = line.substr(9).split(' ');
	  var parsed = {
	    payloadType: parseInt(parts.shift(), 10) // was: id
	  };

	  parts = parts[0].split('/');

	  parsed.name = parts[0];
	  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
	  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // was: channels
	  return parsed;
	};

	// Generate an a=rtpmap line from RTCRtpCodecCapability or RTCRtpCodecParameters.
	SDPUtils.writeRtpMap = function(codec) {
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
	      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
	};

	// Parses an ftmp line, returns dictionary. Sample input:
	// a=fmtp:96 vbr=on;cng=on
	// Also deals with vbr=on; cng=on
	SDPUtils.parseFmtp = function(line) {
	  var parsed = {};
	  var kv;
	  var parts = line.substr(line.indexOf(' ') + 1).split(';');
	  for (var j = 0; j < parts.length; j++) {
	    kv = parts[j].trim().split('=');
	    parsed[kv[0].trim()] = kv[1];
	  }
	  return parsed;
	};

	// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
	SDPUtils.writeFtmp = function(codec) {
	  var line = '';
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  if (codec.parameters && codec.parameters.length) {
	    var params = [];
	    Object.keys(codec.parameters).forEach(function(param) {
	      params.push(param + '=' + codec.parameters[param]);
	    });
	    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
	  }
	  return line;
	};

	// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
	// a=rtcp-fb:98 nack rpsi
	SDPUtils.parseRtcpFb = function(line) {
	  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
	  return {
	    type: parts.shift(),
	    parameter: parts.join(' ')
	  };
	};
	// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
	SDPUtils.writeRtcpFb = function(codec) {
	  var lines = '';
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
	    // FIXME: special handling for trr-int?
	    codec.rtcpFeedback.forEach(function(fb) {
	      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + ' ' + fb.parameter +
	          '\r\n';
	    });
	  }
	  return lines;
	};

	// Parses an RFC 5576 ssrc media attribute. Sample input:
	// a=ssrc:3735928559 cname:something
	SDPUtils.parseSsrcMedia = function(line) {
	  var sp = line.indexOf(' ');
	  var parts = {
	    ssrc: line.substr(7, sp - 7),
	  };
	  var colon = line.indexOf(':', sp);
	  if (colon > -1) {
	    parts.attribute = line.substr(sp + 1, colon - sp - 1);
	    parts.value = line.substr(colon + 1);
	  } else {
	    parts.attribute = line.substr(sp + 1);
	  }
	  return parts;
	};

	// Extracts DTLS parameters from SDP media section or sessionpart.
	// FIXME: for consistency with other functions this should only
	//   get the fingerprint line as input. See also getIceParameters.
	SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
	  var lines = SDPUtils.splitLines(mediaSection);
	  lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
	  var fpLine = lines.filter(function(line) {
	    return line.indexOf('a=fingerprint:') === 0;
	  })[0].substr(14);
	  // Note: a=setup line is ignored since we use the 'auto' role.
	  var dtlsParameters = {
	    role: 'auto',
	    fingerprints: [{
	      algorithm: fpLine.split(' ')[0],
	      value: fpLine.split(' ')[1]
	    }]
	  };
	  return dtlsParameters;
	};

	// Serializes DTLS parameters to SDP.
	SDPUtils.writeDtlsParameters = function(params, setupType) {
	  var sdp = 'a=setup:' + setupType + '\r\n';
	  params.fingerprints.forEach(function(fp) {
	    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
	  });
	  return sdp;
	};
	// Parses ICE information from SDP media section or sessionpart.
	// FIXME: for consistency with other functions this should only
	//   get the ice-ufrag and ice-pwd lines as input.
	SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
	  var lines = SDPUtils.splitLines(mediaSection);
	  lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
	  var iceParameters = {
	    usernameFragment: lines.filter(function(line) {
	      return line.indexOf('a=ice-ufrag:') === 0;
	    })[0].substr(12),
	    password: lines.filter(function(line) {
	      return line.indexOf('a=ice-pwd:') === 0;
	    })[0].substr(10)
	  };
	  return iceParameters;
	};

	// Serializes ICE parameters to SDP.
	SDPUtils.writeIceParameters = function(params) {
	  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
	      'a=ice-pwd:' + params.password + '\r\n';
	};

	// Parses the SDP media section and returns RTCRtpParameters.
	SDPUtils.parseRtpParameters = function(mediaSection) {
	  var description = {
	    codecs: [],
	    headerExtensions: [],
	    fecMechanisms: [],
	    rtcp: []
	  };
	  var lines = SDPUtils.splitLines(mediaSection);
	  var mline = lines[0].split(' ');
	  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
	    var pt = mline[i];
	    var rtpmapline = SDPUtils.matchPrefix(
	        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
	    if (rtpmapline) {
	      var codec = SDPUtils.parseRtpMap(rtpmapline);
	      var fmtps = SDPUtils.matchPrefix(
	          mediaSection, 'a=fmtp:' + pt + ' ');
	      // Only the first a=fmtp:<pt> is considered.
	      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
	      codec.rtcpFeedback = SDPUtils.matchPrefix(
	          mediaSection, 'a=rtcp-fb:' + pt + ' ')
	        .map(SDPUtils.parseRtcpFb);
	      description.codecs.push(codec);
	    }
	  }
	  // FIXME: parse headerExtensions, fecMechanisms and rtcp.
	  return description;
	};

	// Generates parts of the SDP media section describing the capabilities / parameters.
	SDPUtils.writeRtpDescription = function(kind, caps) {
	  var sdp = '';

	  // Build the mline.
	  sdp += 'm=' + kind + ' ';
	  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
	  sdp += ' UDP/TLS/RTP/SAVPF ';
	  sdp += caps.codecs.map(function(codec) {
	    if (codec.preferredPayloadType !== undefined) {
	      return codec.preferredPayloadType;
	    }
	    return codec.payloadType;
	  }).join(' ') + '\r\n';

	  sdp += 'c=IN IP4 0.0.0.0\r\n';
	  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

	  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
	  caps.codecs.forEach(function(codec) {
	    sdp += SDPUtils.writeRtpMap(codec);
	    sdp += SDPUtils.writeFtmp(codec);
	    sdp += SDPUtils.writeRtcpFb(codec);
	  });
	  // FIXME: add headerExtensions, fecMechanism and rtcp.
	  sdp += 'a=rtcp-mux\r\n';
	  return sdp;
	};

	SDPUtils.writeSessionBoilerplate = function() {
	  // FIXME: sess-id should be an NTP timestamp.
	  return 'v=0\r\n' +
	      'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
	      's=-\r\n' +
	      't=0 0\r\n';
	};

	SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
	  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

	  // Map ICE parameters (ufrag, pwd) to SDP.
	  sdp += SDPUtils.writeIceParameters(
	      transceiver.iceGatherer.getLocalParameters());

	  // Map DTLS parameters to SDP.
	  sdp += SDPUtils.writeDtlsParameters(
	      transceiver.dtlsTransport.getLocalParameters(),
	      type === 'offer' ? 'actpass' : 'active');

	  sdp += 'a=mid:' + transceiver.mid + '\r\n';

	  if (transceiver.rtpSender && transceiver.rtpReceiver) {
	    sdp += 'a=sendrecv\r\n';
	  } else if (transceiver.rtpSender) {
	    sdp += 'a=sendonly\r\n';
	  } else if (transceiver.rtpReceiver) {
	    sdp += 'a=recvonly\r\n';
	  } else {
	    sdp += 'a=inactive\r\n';
	  }

	  // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.
	  if (transceiver.rtpSender) {
	    var msid = 'msid:' + stream.id + ' ' +
	        transceiver.rtpSender.track.id + '\r\n';
	    sdp += 'a=' + msid;
	    sdp += 'a=ssrc:' + transceiver.sendSsrc + ' ' + msid;
	  }
	  // FIXME: this should be written by writeRtpDescription.
	  sdp += 'a=ssrc:' + transceiver.sendSsrc + ' cname:' +
	      SDPUtils.localCName + '\r\n';
	  return sdp;
	};

	// Gets the direction from the mediaSection or the sessionpart.
	SDPUtils.getDirection = function(mediaSection, sessionpart) {
	  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
	  var lines = SDPUtils.splitLines(mediaSection);
	  for (var i = 0; i < lines.length; i++) {
	    switch (lines[i]) {
	      case 'a=sendrecv':
	      case 'a=sendonly':
	      case 'a=recvonly':
	      case 'a=inactive':
	        return lines[i].substr(2);
	    }
	  }
	  if (sessionpart) {
	    return SDPUtils.getDirection(sessionpart);
	  }
	  return 'sendrecv';
	};

	// Expose public methods.
	module.exports = SDPUtils;


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	'use strict';

	var logging = __webpack_require__(473).log;
	var browserDetails = __webpack_require__(473).browserDetails;

	var firefoxShim = {
	  shimOnTrack: function() {
	    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
	        window.RTCPeerConnection.prototype)) {
	      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
	        get: function() { return this._ontrack; },
	        set: function(f) {
	          var self = this;
	          if (this._ontrack) {
	            this.removeEventListener('track', this._ontrack);
	            this.removeEventListener('addstream', this._ontrackpoly);
	          }
	          this.addEventListener('track', this._ontrack = f);
	          this.addEventListener('addstream', this._ontrackpoly = function(e) {
	            e.stream.getTracks().forEach(function(track) {
	              var event = new Event('track');
	              event.track = track;
	              event.receiver = {track: track};
	              event.streams = [e.stream];
	              this.dispatchEvent(event);
	            }.bind(this));
	          }.bind(this));
	        }
	      });
	    }
	  },

	  shimSourceObject: function() {
	    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
	    if (typeof window === 'object') {
	      if (window.HTMLMediaElement &&
	        !('srcObject' in window.HTMLMediaElement.prototype)) {
	        // Shim the srcObject property, once, when HTMLMediaElement is found.
	        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
	          get: function() {
	            return this.mozSrcObject;
	          },
	          set: function(stream) {
	            this.mozSrcObject = stream;
	          }
	        });
	      }
	    }
	  },

	  shimPeerConnection: function() {
	    // The RTCPeerConnection object.
	    if (!window.RTCPeerConnection) {
	      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
	        if (browserDetails.version < 38) {
	          // .urls is not supported in FF < 38.
	          // create RTCIceServers with a single url.
	          if (pcConfig && pcConfig.iceServers) {
	            var newIceServers = [];
	            for (var i = 0; i < pcConfig.iceServers.length; i++) {
	              var server = pcConfig.iceServers[i];
	              if (server.hasOwnProperty('urls')) {
	                for (var j = 0; j < server.urls.length; j++) {
	                  var newServer = {
	                    url: server.urls[j]
	                  };
	                  if (server.urls[j].indexOf('turn') === 0) {
	                    newServer.username = server.username;
	                    newServer.credential = server.credential;
	                  }
	                  newIceServers.push(newServer);
	                }
	              } else {
	                newIceServers.push(pcConfig.iceServers[i]);
	              }
	            }
	            pcConfig.iceServers = newIceServers;
	          }
	        }
	        return new mozRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
	      };
	      window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

	      // wrap static methods. Currently just generateCertificate.
	      if (mozRTCPeerConnection.generateCertificate) {
	        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
	          get: function() {
	            if (arguments.length) {
	              return mozRTCPeerConnection.generateCertificate.apply(null,
	                  arguments);
	            } else {
	              return mozRTCPeerConnection.generateCertificate;
	            }
	          }
	        });
	      }

	      window.RTCSessionDescription = mozRTCSessionDescription;
	      window.RTCIceCandidate = mozRTCIceCandidate;
	    }
	  },

	  shimGetUserMedia: function() {
	    // getUserMedia constraints shim.
	    var getUserMedia_ = function(constraints, onSuccess, onError) {
	      var constraintsToFF37_ = function(c) {
	        if (typeof c !== 'object' || c.require) {
	          return c;
	        }
	        var require = [];
	        Object.keys(c).forEach(function(key) {
	          if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	            return;
	          }
	          var r = c[key] = (typeof c[key] === 'object') ?
	              c[key] : {ideal: c[key]};
	          if (r.min !== undefined ||
	              r.max !== undefined || r.exact !== undefined) {
	            require.push(key);
	          }
	          if (r.exact !== undefined) {
	            if (typeof r.exact === 'number') {
	              r. min = r.max = r.exact;
	            } else {
	              c[key] = r.exact;
	            }
	            delete r.exact;
	          }
	          if (r.ideal !== undefined) {
	            c.advanced = c.advanced || [];
	            var oc = {};
	            if (typeof r.ideal === 'number') {
	              oc[key] = {min: r.ideal, max: r.ideal};
	            } else {
	              oc[key] = r.ideal;
	            }
	            c.advanced.push(oc);
	            delete r.ideal;
	            if (!Object.keys(r).length) {
	              delete c[key];
	            }
	          }
	        });
	        if (require.length) {
	          c.require = require;
	        }
	        return c;
	      };
	      if (browserDetails.version < 38) {
	        logging('spec: ' + JSON.stringify(constraints));
	        if (constraints.audio) {
	          constraints.audio = constraintsToFF37_(constraints.audio);
	        }
	        if (constraints.video) {
	          constraints.video = constraintsToFF37_(constraints.video);
	        }
	        logging('ff37: ' + JSON.stringify(constraints));
	      }
	      return navigator.mozGetUserMedia(constraints, onSuccess, onError);
	    };

	    navigator.getUserMedia = getUserMedia_;

	    // Returns the result of getUserMedia as a Promise.
	    var getUserMediaPromise_ = function(constraints) {
	      return new Promise(function(resolve, reject) {
	        navigator.getUserMedia(constraints, resolve, reject);
	      });
	    }

	    // Shim for mediaDevices on older versions.
	    if (!navigator.mediaDevices) {
	      navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
	        addEventListener: function() { },
	        removeEventListener: function() { }
	      };
	    }
	    navigator.mediaDevices.enumerateDevices =
	        navigator.mediaDevices.enumerateDevices || function() {
	      return new Promise(function(resolve) {
	        var infos = [
	          {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
	          {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
	        ];
	        resolve(infos);
	      });
	    };

	    if (browserDetails.version < 41) {
	      // Work around http://bugzil.la/1169665
	      var orgEnumerateDevices =
	          navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
	      navigator.mediaDevices.enumerateDevices = function() {
	        return orgEnumerateDevices().then(undefined, function(e) {
	          if (e.name === 'NotFoundError') {
	            return [];
	          }
	          throw e;
	        });
	      };
	    }
	  },

	  // Attach a media stream to an element.
	  attachMediaStream: function(element, stream) {
	    logging('DEPRECATED, attachMediaStream will soon be removed.');
	    element.srcObject = stream;
	  },

	  reattachMediaStream: function(to, from) {
	    logging('DEPRECATED, reattachMediaStream will soon be removed.');
	    to.srcObject = from.srcObject;
	  }
	}

	// Expose public methods.
	module.exports = {
	  shimOnTrack: firefoxShim.shimOnTrack,
	  shimSourceObject: firefoxShim.shimSourceObject,
	  shimPeerConnection: firefoxShim.shimPeerConnection,
	  shimGetUserMedia: firefoxShim.shimGetUserMedia,
	  attachMediaStream: firefoxShim.attachMediaStream,
	  reattachMediaStream: firefoxShim.reattachMediaStream
	}


/***/ },
/* 478 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(197);
	var extend = __webpack_require__(456);
	var BaseSession = __webpack_require__(455);
	var RTCPeerConnection = __webpack_require__(459);
	var FileTransfer = __webpack_require__(480);


	function FileTransferSession(opts) {
	    BaseSession.call(this, opts);

	    this.pc = new RTCPeerConnection({
	        iceServers: opts.iceServers || [],
	        useJingle: true
	    }, opts.constraints || {});

	    this.pc.on('ice', this.onIceCandidate.bind(this));
	    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
	    this.pc.on('addChannel', this.onChannelAdded.bind(this));

	    this.sender = null;
	    this.receiver = null;
	}


	util.inherits(FileTransferSession, BaseSession);


	FileTransferSession.prototype = extend(FileTransferSession.prototype, {

	    // ----------------------------------------------------------------
	    // Session control methods
	    // ----------------------------------------------------------------

	    start: function (file) {
	        var self = this;
	        this.state = 'pending';

	        this.pc.isInitiator = true;

	        this.sender = new FileTransfer.Sender();
	        this.sender.on('progress', function (sent, size) {
	            self._log('info', 'Send progress ' + sent + '/' + size);
	        });
	        this.sender.on('sentFile', function (meta) {
	            self._log('info', 'Sent file', meta.name);

	            var content = self.pc.localDescription.contents[0];
	            delete content.transport;

	            content.application = {
	                applicationType: 'filetransfer',
	                offer: {
	                    hash: {
	                        algo: meta.algo,
	                        value: meta.hash
	                    }
	                }
	            };

	            self.send('description-info', {
	                contents: [content]
	            });
	            self.emit('sentFile', self, meta);
	        });

	        var sendChannel = this.pc.createDataChannel('filetransfer');
	        sendChannel.onopen = function () {
	            self.sender.send(file, sendChannel);
	        };

	        var constraints = {
	            mandatory: {
	                OfferToReceiveAudio: false,
	                OfferToReceiveVideo: false
	            }
	        };

	        this.pc.offer(constraints, function (err, offer) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC offer', err);
	                return self.end('failed-application', true);
	            }

	            offer.jingle.contents[0].application = {
	                applicationType: 'filetransfer',
	                offer: {
	                    date: file.lastModifiedDate,
	                    name: file.name,
	                    size: file.size,
	                    hash: {
	                        algo: 'sha-1',
	                        value: ''
	                    }
	                }
	            };

	            self.send('session-initiate', offer.jingle);
	        });
	    },

	    accept: function () {
	        var self = this;

	        this._log('info', 'Accepted incoming session');

	        this.state = 'active';

	        this.pc.answer(function (err, answer) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC answer', err);
	                return self.end('failed-application');
	            }
	            self.send('session-accept', answer.jingle);
	        });
	    },

	    end: function (reason, silent) {
	        this.pc.close();
	        BaseSession.prototype.end.call(this, reason, silent);
	    },

	    maybeReceivedFile: function () {
	        if (!this.receiver.metadata.hash.value) {
	            // unknown hash, file transfer not completed
	        } else if (this.receiver.metadata.hash.value === this.receiver.metadata.actualhash) {
	            this._log('info', 'File hash matches');
	            this.emit('receivedFile', this, this.receivedFile, this.receiver.metadata);
	            this.end('success');
	        } else {
	            this._log('error', 'File hash does not match');
	            this.end('media-error');
	        }
	    },

	    // ----------------------------------------------------------------
	    // ICE action handers
	    // ----------------------------------------------------------------

	    onIceCandidate: function (candidate) {
	        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
	        this.send('transport-info', candidate.jingle);
	    },

	    onIceStateChange: function () {
	        switch (this.pc.iceConnectionState) {
	            case 'checking':
	                this.connectionState = 'connecting';
	                break;
	            case 'completed':
	            case 'connected':
	                this.connectionState = 'connected';
	                break;
	            case 'disconnected':
	                if (this.pc.signalingState === 'stable') {
	                    this.connectionState = 'interrupted';
	                } else {
	                    this.connectionState = 'disconnected';
	                }
	                break;
	            case 'failed':
	                this.connectionState = 'failed';
	                this.end('failed-transport');
	                break;
	            case 'closed':
	                this.connectionState = 'disconnected';
	                break;
	        }
	    },

	    onChannelAdded: function (channel) {
	        this.receiver.receive(null, channel);
	    },

	    // ----------------------------------------------------------------
	    // Jingle action handers
	    // ----------------------------------------------------------------

	    onSessionInitiate: function (changes, cb) {
	        var self = this;

	        this._log('info', 'Initiating incoming session');

	        this.state = 'pending';

	        this.pc.isInitiator = false;

	        var desc = changes.contents[0].application;


	        this.receiver = new FileTransfer.Receiver({hash: desc.offer.hash.algo});
	        this.receiver.on('progress', function (received, size) {
	            self._log('info', 'Receive progress ' + received + '/' + size);
	        });
	        this.receiver.on('receivedFile', function (file) {
	            self.receivedFile = file;
	            self.maybeReceivedFile();
	        });
	        this.receiver.metadata = desc.offer;

	        changes.contents[0].application = {
	            applicationType: 'datachannel'
	        };

	        this.pc.handleOffer({
	            type: 'offer',
	            jingle: changes
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not create WebRTC answer');
	                return cb({condition: 'general-error'});
	            }
	            cb();
	        });
	    },

	    onSessionAccept: function (changes, cb) {
	        var self = this;

	        this.state = 'active';
	        
	        changes.contents[0].application = {
	            applicationType: 'datachannel'
	        };

	        this.pc.handleAnswer({
	            type: 'answer',
	            jingle: changes
	        }, function (err) {
	            if (err) {
	                self._log('error', 'Could not process WebRTC answer');
	                return cb({condition: 'general-error'});
	            }
	            self.emit('accepted', self);
	            cb();
	        });
	    },

	    onSessionTerminate: function (changes, cb) {
	        this._log('info', 'Terminating session');
	        this.pc.close();
	        BaseSession.prototype.end.call(this, changes.reason, true);
	        cb();
	    },

	    onDescriptionInfo: function (info, cb) {
	        var hash = info.contents[0].application.offer.hash;
	        this.receiver.metadata.hash = hash;
	        if (this.receiver.metadata.actualhash) {
	            this.maybeReceivedFile();
	        }
	        cb();
	    },

	    onTransportInfo: function (changes, cb) {
	        this.pc.processIce(changes, function () {
	            cb();
	        });
	    }
	});


	module.exports = FileTransferSession;


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	var WildEmitter = __webpack_require__(481);
	var util = __webpack_require__(197);
	var hashes = __webpack_require__(428);
	var base = __webpack_require__(482);

	// drop-in replacement for filetransfer which also calculates hashes
	function Sender(opts) {
	    WildEmitter.call(this);
	    var self = this;
	    this.base = new base.Sender(opts);

	    var options = opts || {};
	    if (!options.hash) {
	        options.hash = 'sha-1';
	    }
	    this.hash = hashes.createHash(options.hash);

	    this.base.on('progress', function (start, size, data) {
	        self.emit('progress', start, size, data);
	        if (data) {
	            self.hash.update(new Uint8Array(data));
	        }
	    });
	    this.base.on('sentFile', function () {
	        self.emit('sentFile', {hash: self.hash.digest('hex'), algo: options.hash });
	    });
	}
	util.inherits(Sender, WildEmitter);
	Sender.prototype.send = function () {
	    this.base.send.apply(this.base, arguments);
	};

	function Receiver(opts) {
	    WildEmitter.call(this);
	    var self = this;
	    this.base = new base.Receiver(opts);

	    var options = opts || {};
	    if (!options.hash) {
	        options.hash = 'sha-1';
	    }
	    this.hash = hashes.createHash(options.hash);

	    this.base.on('progress', function (start, size, data) {
	        self.emit('progress', start, size, data);
	        if (data) {
	            self.hash.update(new Uint8Array(data));
	        }
	    });
	    this.base.on('receivedFile', function (file, metadata) {
	        metadata.actualhash = self.hash.digest('hex');
	        self.emit('receivedFile', file, metadata);
	    });
	}
	util.inherits(Receiver, WildEmitter);
	Receiver.prototype.receive = function () {
	    this.base.receive.apply(this.base, arguments);
	};
	Object.defineProperty(Receiver.prototype, 'metadata', {
	    get: function () {
	        return this.base.metadata;
	    },
	    set: function (value) {
	        this.base.metadata = value;
	    }
	});

	module.exports = {};
	module.exports.support = base.support;
	module.exports.Sender = Sender;
	module.exports.Receiver = Receiver;


/***/ },
/* 481 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var WildEmitter = __webpack_require__(481);
	var util = __webpack_require__(197);

	function Sender(opts) {
	    WildEmitter.call(this);
	    var options = opts || {};
	    this.config = {
	        chunksize: 16384,
	        pacing: 0
	    };
	    // set our config from options
	    var item;
	    for (item in options) {
	        this.config[item] = options[item];
	    }

	    this.file = null;
	    this.channel = null;
	}
	util.inherits(Sender, WildEmitter);

	Sender.prototype.send = function (file, channel) {
	    var self = this;
	    this.file = file;
	    this.channel = channel;
	    var sliceFile = function(offset) {
	        var reader = new window.FileReader();
	        reader.onload = (function() {
	            return function(e) {
	                self.channel.send(e.target.result);
	                self.emit('progress', offset, file.size, e.target.result);
	                if (file.size > offset + e.target.result.byteLength) {
	                    window.setTimeout(sliceFile, self.config.pacing, offset + self.config.chunksize);
	                } else {
	                    self.emit('progress', file.size, file.size, null);
	                    self.emit('sentFile');
	                }
	            };
	        })(file);
	        var slice = file.slice(offset, offset + self.config.chunksize);
	        reader.readAsArrayBuffer(slice);
	    };
	    window.setTimeout(sliceFile, 0, 0);
	};

	function Receiver() {
	    WildEmitter.call(this);

	    this.receiveBuffer = [];
	    this.received = 0;
	    this.metadata = {};
	    this.channel = null;
	}
	util.inherits(Receiver, WildEmitter);

	Receiver.prototype.receive = function (metadata, channel) {
	    var self = this;

	    if (metadata) {
	        this.metadata = metadata;
	    }
	    this.channel = channel;
	    // chrome only supports arraybuffers and those make it easier to calc the hash
	    channel.binaryType = 'arraybuffer';
	    this.channel.onmessage = function (event) {
	        var len = event.data.byteLength;
	        self.received += len;
	        self.receiveBuffer.push(event.data);

	        self.emit('progress', self.received, self.metadata.size, event.data);
	        if (self.received === self.metadata.size) {
	            self.emit('receivedFile', new window.Blob(self.receiveBuffer), self.metadata);
	            self.receiveBuffer = []; // discard receivebuffer
	        } else if (self.received > self.metadata.size) {
	            // FIXME
	            console.error('received more than expected, discarding...');
	            self.receiveBuffer = []; // just discard...

	        }
	    };
	};

	module.exports = {};
	module.exports.support = typeof window !== 'undefined' && window && window.File && window.FileReader && window.Blob;
	module.exports.Sender = Sender;
	module.exports.Receiver = Receiver;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 483 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:json:0');
	};


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BPromise = __webpack_require__(258);


	function checkConnection(client, timeout) {
	    return new BPromise(function (resolve, reject) {
	        if (client.sm.started) {
	            client.once('stream:management:ack', resolve);
	            client.sm.request();
	        } else {
	            client.ping().then(resolve).catch(function (err) {
	                if (err.error && err.error.condition !== 'timeout') {
	                    resolve();
	                } else {
	                    reject();
	                }
	            });
	        }
	    }).timeout(timeout * 1000 || 15000);
	}


	module.exports = function (client) {
	    client.enableKeepAlive = function (opts) {
	        opts = opts || {};

	        // Ping every 5 minutes
	        opts.interval = opts.interval || 300;

	        // Disconnect if no response in 15 seconds
	        opts.timeout = opts.timeout || 15;

	        function keepalive() {
	            if (client.sessionStarted) {
	                checkConnection(client, opts.timeout).catch(function () {
	                    // Kill the apparently dead connection without closing
	                    // the stream itself so we can reconnect and potentially
	                    // resume the session.
	                    client.emit('stream:error', {
	                        condition: 'connection-timeout',
	                        text: 'Server did not respond in ' + opts.timeout + ' seconds'
	                    });
	                    client.transport.hasStream = false;
	                    client.transport.disconnect();
	                });
	            }
	        }

	        client._keepAliveInterval = setInterval(keepalive, opts.interval * 1000);
	    };

	    client.disableKeepAlive = function () {
	        if (client._keepAliveInterval) {
	            clearInterval(client._keepAliveInterval);
	            delete client._keepAliveInterval;
	        }
	    };

	    client.on('disconnected', function () {
	        client.disableKeepAlive();
	    });
	};


/***/ },
/* 485 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('', 'urn:xmpp:eventlog');

	    client.sendLog = function (jid, logData) {
	        client.sendMessage({
	            to: jid,
	            type: 'normal',
	            log: logData
	        });
	    };
	};


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BPromise = __webpack_require__(258);
	var JID = __webpack_require__(222).JID;


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:mam:0');

	    client.getHistorySearchForm = function (jid, cb) {
	        return client.sendIq({
	            to: jid,
	            type: 'get',
	            mam: true
	        }, cb);
	    };

	    client.searchHistory = function (opts, cb) {
	        var self = this;
	        var queryid = this.nextId();

	        opts = opts || {};
	        opts.queryid = queryid;

	        var to = opts.jid || opts.to || '';
	        delete opts.jid;
	        delete opts.to;

	        if (!opts.form) {
	            opts.form = {};
	        }
	        opts.form.type = 'submit';
	        var fields = opts.form.fields = opts.form.fields || [];

	        var defaultFields = ['FORM_TYPE', 'with', 'start', 'end'];
	        defaultFields.forEach(function (name) {
	            if (opts[name] || name === 'FORM_TYPE') {
	                var val = opts[name];
	                var isDate = (name === 'start' || name === 'end');
	                if (isDate && typeof val !== 'string') {
	                    val = val.toISOString();
	                }
	                if (name === 'FORM_TYPE') {
	                    val = 'urn:xmpp:mam:0';
	                }

	                var existing = false;
	                for (var i = 0, len = fields.length; i < len; i++) {
	                    if (fields[i].name === name) {
	                        continue;
	                    }
	                }

	                if (!existing) {
	                    fields.push({
	                        name: name,
	                        value: val
	                    });
	                }

	                delete opts[name];
	            }
	        });

	        var dest = new JID(to || client.jid.bare);
	        var allowed = {};
	        allowed[''] = true;
	        allowed[dest.full] = true;
	        allowed[dest.bare] = true;
	        allowed[dest.domain] = true;
	        allowed[client.jid.bare] = true;
	        allowed[client.jid.domain] = true;

	        var results = [];

	        this.on('mam:item:' + queryid, 'session', function (msg) {
	            if (!allowed[msg.from.full]) {
	                return;
	            }
	            results.push(msg.mamItem);
	        });

	        var collectResults = new BPromise(function (resolve) {
	            self.once('mam:result:' + queryid, 'session', function (msg) {
	                if (!allowed[msg.from.full]) {
	                    return;
	                }
	                msg.mamResult.items = results;
	                resolve(msg);
	            });
	        });

	        var mamQuery = this.sendIq({
	            type: 'set',
	            to: to,
	            id: queryid,
	            mam: opts
	        });

	        return BPromise.all([mamQuery, collectResults])
	            .spread(function (iqRes, mamRes) {
	                return mamRes;
	            })
	            .timeout(self.config.timeout * 1000 || 15000)
	            .catch(BPromise.TimeoutError, function () {
	                throw {
	                    id: queryid,
	                    type: 'error',
	                    error: {
	                        condition: 'timeout'
	                    }
	                };
	            })
	            .finally(function () {
	                self.off('mam:item:' + queryid);
	                self.off('mam:result:' + queryid);
	            })
	            .nodeify(cb);
	    };

	    client.getHistoryPreferences = function (cb) {
	        return this.sendIq({
	            type: 'get',
	            mamPrefs: true
	        }, cb);
	    };

	    client.setHistoryPreferences = function (opts, cb) {
	        return this.sendIq({
	            type: 'set',
	            mamPrefs: opts
	        }, cb);
	    };

	    client.on('message', function (msg) {
	        if (msg.mamItem) {
	            client.emit('mam:item:' + msg.mamItem.queryid, msg);
	        }
	        if (msg.mamResult) {
	            client.emit('mam:result:' + msg.mamResult.queryid, msg);
	        }
	    });
	};


/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var each = __webpack_require__(226);
	var JID = __webpack_require__(222).JID;


	module.exports = function (client) {

	    client.disco.addFeature('http://jabber.org/protocol/muc');
	    client.disco.addFeature('jabber:x:conference');
	    client.disco.addFeature('urn:xmpp:hats:0');

	    client.joinedRooms = {};

	    function rejoinRooms() {
	        each(client.joinedRooms, function (nick, room) {
	            client.joinedRooms[room] = false;
	            client.joinRoom(room, nick);
	        });
	    }
	    client.on('session:started', rejoinRooms);
	    client.on('stream:management:resumed', rejoinRooms);

	    client.on('message', function (msg) {
	        if (msg.muc) {
	            if (msg.muc.invite) {
	                client.emit('muc:invite', {
	                    from: msg.muc.invite.from,
	                    room: msg.from,
	                    reason: msg.muc.invite.reason,
	                    password: msg.muc.password,
	                    thread: msg.muc.invite.thread,
	                    type: 'mediated'
	                });
	            }
	            if (msg.muc.destroyed) {
	                client.emit('muc:destroyed', {
	                    room: msg.from,
	                    newRoom: msg.muc.destroyed.jid,
	                    reason: msg.muc.destroyed.reason,
	                    password: msg.muc.destroyed.password
	                });
	            }
	            if (msg.muc.decline) {
	                client.emit('muc:declined', {
	                    room: msg.from,
	                    from: msg.muc.decline.from,
	                    reason: msg.muc.decline.reason
	                });
	            }
	        } else if (msg.mucInvite) {
	            client.emit('muc:invite', {
	                from: msg.from,
	                room: msg.mucInvite.jid,
	                reason: msg.mucInvite.reason,
	                password: msg.mucInvite.password,
	                thread: msg.mucInvite.thread,
	                type: 'direct'
	            });
	        }

	        if (msg.type === 'groupchat' && msg.subject) {
	            client.emit('muc:subject', msg);
	        }
	    });

	    client.on('presence', function (pres) {
	        if (pres.joinMuc && pres.type === 'error') {
	            client.emit('muc:error', pres);
	        } else if (pres.muc) {
	            var isSelf = pres.muc.codes && pres.muc.codes.indexOf('110') >= 0;
	            if (pres.type === 'error') {
	                client.emit('muc:error', pres);
	            } else if (pres.type === 'unavailable') {
	                client.emit('muc:unavailable', pres);
	                if (isSelf) {
	                    client.emit('muc:leave', pres);
	                    delete client.joinedRooms[pres.from.bare];
	                }
	            } else {
	                client.emit('muc:available', pres);
	                if (isSelf && !client.joinedRooms[pres.from.bare]) {
	                    client.emit('muc:join', pres);
	                    client.joinedRooms[pres.from.bare] = pres.from.resource;
	                }
	            }
	        }
	    });

	    client.joinRoom = function (room, nick, opts) {
	        opts = opts || {};
	        opts.to = room + '/' + nick;
	        opts.caps = this.disco.caps;
	        opts.joinMuc = opts.joinMuc || {};

	        this.sendPresence(opts);
	    };

	    client.leaveRoom = function (room, nick, opts) {
	        opts = opts || {};
	        opts.to = room + '/' + nick;
	        opts.type = 'unavailable';
	        this.sendPresence(opts);
	    };

	    client.ban = function (room, jid, reason, cb) {
	        client.setRoomAffiliation(room, jid, 'outcast', reason, cb);
	    };

	    client.kick = function (room, nick, reason, cb) {
	        client.setRoomRole(room, nick, 'none', reason, cb);
	    };

	    client.invite = function (room, opts) {
	        client.sendMessage({
	            to: room,
	            muc: {
	                invites: opts
	            }
	        });
	    };

	    client.directInvite = function (room, opts) {
	        opts.jid = room;
	        client.sendMessage({
	            to: opts.to,
	            mucInvite: opts
	        });
	    };

	    client.declineInvite = function (room, sender, reason) {
	        client.sendMessage({
	            to: room,
	            muc: {
	                decline: {
	                    to: sender,
	                    reason: reason
	                }
	            }
	        });
	    };

	    client.changeNick = function (room, nick) {
	        client.sendPresence({
	            to: (new JID(room)).bare + '/' + nick
	        });
	    };

	    client.setSubject = function (room, subject) {
	        client.sendMessage({
	            to: room,
	            type: 'groupchat',
	            subject: subject
	        });
	    };

	    client.discoverReservedNick = function (room, cb) {
	        client.getDiscoInfo(room, 'x-roomuser-item', function (err, res) {
	            if (err) {
	                return cb(err);
	            }
	            var ident = res.discoInfo.identities[0] || {};
	            cb(null, ident.name);
	        });
	    };

	    client.requestRoomVoice = function (room) {
	        client.sendMessage({
	            to: room,
	            form: {
	                fields: [
	                    {
	                        name: 'FORM_TYPE',
	                        value: 'http://jabber.org/protocol/muc#request'
	                    },
	                    {
	                        name: 'muc#role',
	                        type: 'text-single',
	                        value: 'participant'
	                    }
	                ]
	            }
	        });
	    };

	    client.setRoomAffiliation = function (room, jid, affiliation, reason, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: room,
	            mucAdmin: {
	                jid: jid,
	                affiliation: affiliation,
	                reason: reason
	            }
	        }, cb);
	    };

	    client.setRoomRole = function (room, nick, role, reason, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: room,
	            mucAdmin: {
	                nick: nick,
	                role: role,
	                reason: reason
	            }
	        }, cb);
	    };

	    client.getRoomMembers = function (room, opts, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: room,
	            mucAdmin: opts
	        }, cb);
	    };

	    client.getRoomConfig = function (jid, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            mucOwner: true
	        }, cb);
	    };

	    client.configureRoom = function (jid, form, cb) {
	        if (!form.type) {
	            form.type = 'submit';
	        }
	        return this.sendIq({
	            to: jid,
	            type: 'set',
	            mucOwner: {
	                form: form
	            }
	        }, cb);
	    };

	    client.destroyRoom = function (jid, opts, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'set',
	            mucOwner: {
	                destroy: opts
	            }
	        }, cb);
	    };

	    client.getUniqueRoomName = function (jid, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            mucUnique: true
	        }, cb);
	    };
	};


/***/ },
/* 488 */
/***/ function(module, exports) {

	'use strict';

	var NS = 'http://jabber.org/protocol/mood';


	module.exports = function (client) {

	    client.disco.addFeature(NS);
	    client.disco.addFeature(NS + '+notify');

	    client.on('pubsub:event', function (msg) {
	        if (!msg.event.updated) {
	            return;
	        }

	        if (msg.event.updated.node !== NS) {
	            return;
	        }

	        client.emit('mood', {
	            jid: msg.from,
	            mood: msg.event.updated.published[0].mood
	        });
	    });

	    client.publishMood = function (mood, text, cb) {
	        return this.publish('', NS, {
	            mood: {
	                value: mood,
	                text: text
	            }
	        }, cb);
	    };
	};


/***/ },
/* 489 */
/***/ function(module, exports) {

	'use strict';

	var NS = 'http://jabber.org/protocol/nick';


	module.exports = function (client) {

	    client.disco.addFeature(NS);
	    client.disco.addFeature(NS + '+notify');

	    client.on('pubsub:event', function (msg) {
	        if (!msg.event.updated) {
	            return;
	        }
	        if (msg.event.updated.node !== NS) {
	            return;
	        }

	        client.emit('nick', {
	            jid: msg.from,
	            nick: msg.event.updated.published[0].nick
	        });
	    });

	    client.publishNick = function (nick, cb) {
	        return this.publish('', NS, {
	            nick: nick
	        }, cb);
	    };
	};


/***/ },
/* 490 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('jabber:x:oob');
	};


/***/ },
/* 491 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:ping');

	    client.on('iq:get:ping', function (iq) {
	        client.sendIq(iq.resultReply());
	    });

	    client.ping = function (jid, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            ping: true
	        }, cb);
	    };
	};


/***/ },
/* 492 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.getPrivateData = function (opts, cb) {
	        return this.sendIq({
	            type: 'get',
	            privateStorage: opts
	        }, cb);
	    };

	    client.setPrivateData = function (opts, cb) {
	        return this.sendIq({
	            type: 'set',
	            privateStorage: opts
	        }, cb);
	    };
	};


/***/ },
/* 493 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:psa');
	};


/***/ },
/* 494 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.on('message', function (msg) {
	        if (msg.event) {
	            client.emit('pubsub:event', msg);
	            client.emit('pubsubEvent', msg);

	            if (msg.event.updated) {
	                var published = msg.event.updated.published;
	                var retracted = msg.event.updated.retracted;


	                if (published && published.length) {
	                    client.emit('pubsub:published', msg);
	                }

	                if (retracted && retracted.length) {
	                    client.emit('pubsub:retracted', msg);
	                }
	            }

	            if (msg.event.purged) {
	                client.emit('pubsub:purged', msg);
	            }

	            if (msg.event.deleted) {
	                client.emit('pubsub:deleted', msg);
	            }

	            if (msg.event.subscriptionChanged) {
	                client.emit('pubsub:subscription', msg);
	            }

	            if (msg.event.configurationChanged) {
	                client.emit('pubsub:config', msg);
	            }
	        }

	        if (msg.pubsub && msg.pubsub.affiliations) {
	            client.emit('pubsub:affiliation', msg);
	        }
	    });

	    client.subscribeToNode = function (jid, opts, cb) {
	        if (typeof opts === 'string') {
	            opts = {
	                node: opts
	            };
	        }
	        opts.jid = opts.jid || client.jid;

	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsub: {
	                subscribe: opts
	            }
	        }, cb);
	    };

	    client.unsubscribeFromNode = function (jid, opts, cb) {
	        if (typeof opts === 'string') {
	            opts = {
	                node: opts
	            };
	        }
	        opts.jid = opts.jid || client.jid.bare;

	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsub: {
	                unsubscribe: opts
	            }
	        }, cb);
	    };

	    client.publish = function (jid, node, item, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsub: {
	                publish: {
	                    node: node,
	                    item: item
	                }
	            }
	        }, cb);
	    };

	    client.getItem = function (jid, node, id, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsub: {
	                retrieve: {
	                    node: node,
	                    item: id
	                }
	            }
	        }, cb);
	    };

	    client.getItems = function (jid, node, opts, cb) {
	        opts = opts || {};
	        opts.node = node;
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsub: {
	                retrieve: {
	                    node: node,
	                    max: opts.max
	                },
	                rsm: opts.rsm
	            }
	        }, cb);
	    };

	    client.retract = function (jid, node, id, notify, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsub: {
	                retract: {
	                    node: node,
	                    notify: notify,
	                    id: id
	                }
	            }
	        }, cb);
	    };

	    client.purgeNode = function (jid, node, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsubOwner: {
	                purge: node
	            }
	        }, cb);
	    };

	    client.deleteNode = function (jid, node, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsubOwner: {
	                del: node
	            }
	        }, cb);
	    };

	    client.createNode = function (jid, node, config, cb) {
	        var cmd = {
	            type: 'set',
	            to: jid,
	            pubsub: {
	                create: node
	            }
	        };

	        if (config) {
	            cmd.pubsub.config = {form: config};
	        }

	        return this.sendIq(cmd, cb);
	    };

	    client.getSubscriptions = function (jid, opts, cb) {
	        opts = opts || {};

	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsub: {
	                subscriptions: opts
	            }
	        }, cb);
	    };

	    client.getAffiliations = function (jid, opts, cb) {
	        opts = opts || {};

	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsub: {
	                affiliations: opts
	            }
	        }, cb);
	    };

	    client.getNodeSubscribers = function (jid, node, opts, cb) {
	        opts = opts || {};
	        opts.node = node;

	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsubOwner: {
	                subscriptions: opts
	            }
	        }, cb);
	    };

	    client.updateNodeSubscriptions = function (jid, node, delta, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsubOwner: {
	                subscriptions: {
	                    node: node,
	                    list: delta
	                }
	            }
	        }, cb);
	    };

	    client.getNodeAffiliations = function (jid, node, opts, cb) {
	        opts = opts || {};
	        opts.node = node;

	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            pubsubOwner: {
	                affiliations: opts
	            }
	        }, cb);
	    };

	    client.updateNodeAffiliations = function (jid, node, delta, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            pubsubOwner: {
	                affiliations: {
	                    node: node,
	                    list: delta
	                }
	            }
	        }, cb);
	    };
	};


/***/ },
/* 495 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:reach:0');
	    client.disco.addFeature('urn:xmpp:reach:0+notify');

	    client.on('pubsub:event', function (msg) {
	        if (!msg.event.updated) {
	            return;
	        }
	        if (msg.event.updated.node !== 'urn:xmpp:reach:0') {
	            return;
	        }

	        client.emit('reachability', {
	            jid: msg.from,
	            addresses: msg.event.updated.published[0].reach
	        });
	    });

	    client.on('presence', function (pres) {
	        if (!pres.reach || !pres.reach.length) {
	            return;
	        }

	        client.emit('reachability', {
	            jid: pres.from,
	            addresses: pres.reach
	        });
	    });

	    client.publishReachability = function (data, cb) {
	        return this.publish('', 'urn:xmpp:reach:0', {
	            reach: data
	        }, cb);
	    };
	};


/***/ },
/* 496 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:receipts');

	    client.on('message', function (msg) {
	        var ackTypes = {
	            normal: true,
	            chat: true,
	            headline: true
	        };
	        if (ackTypes[msg.type] && msg.requestReceipt && !msg.receipt) {
	            client.sendMessage({
	                to: msg.from,
	                type: msg.type,
	                receipt: msg.id,
	                id: msg.id
	            });
	        }
	        if (msg.receipt) {
	            client.emit('receipt', msg);
	            client.emit('receipt:' + msg.receipt);
	        }
	    });
	};


/***/ },
/* 497 */
/***/ function(module, exports) {

	'use strict';



	module.exports = function (client) {

	    client.getAccountInfo = function (jid, cb) {
	        return this.sendIq({
	            type: 'get',
	            to: jid,
	            register: true
	        }, cb);
	    };

	    client.updateAccount = function (jid, data, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            register: data
	        }, cb);
	    };

	    client.deleteAccount = function (jid, cb) {
	        return this.sendIq({
	            type: 'set',
	            to: jid,
	            register: {
	                remove: true
	            }
	        }, cb);
	    };
	};


/***/ },
/* 498 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.on('iq:set:roster', function (iq) {
	        var allowed = {};
	        allowed[''] = true;
	        allowed[client.jid.bare] = true;
	        allowed[client.jid.domain] = true;

	        if (!allowed[iq.from.full]) {
	            return client.sendIq(iq.errorReply({
	                error: {
	                    type: 'cancel',
	                    condition: 'service-unavailable'
	                }
	            }));
	        }

	        client.emit('roster:update', iq);
	        client.sendIq({
	            id: iq.id,
	            type: 'result'
	        });
	    });

	    client.getRoster = function (cb) {
	        var self = this;
	        cb = cb || function () {};

	        return client.sendIq({
	            type: 'get',
	            roster: {
	                ver: self.config.rosterVer
	            }
	        }).then(function (resp) {
	            if (resp.roster) {
	                var ver = resp.roster.ver;
	                if (ver) {
	                    self.config.rosterVer = ver;
	                    self.emit('roster:ver', ver);
	                }
	            }
	            return resp;
	        }).nodeify(cb);
	    };

	    client.updateRosterItem = function (item, cb) {
	        return client.sendIq({
	            type: 'set',
	            roster: {
	                items: [item]
	            }
	        }, cb);
	    };

	    client.removeRosterItem = function (jid, cb) {
	        return client.updateRosterItem({jid: jid, subscription: 'remove'}, cb);
	    };

	    client.subscribe = function (jid) {
	        client.sendPresence({type: 'subscribe', to: jid});
	    };

	    client.unsubscribe = function (jid) {
	        client.sendPresence({type: 'unsubscribe', to: jid});
	    };

	    client.acceptSubscription = function (jid) {
	        client.sendPresence({type: 'subscribed', to: jid});
	    };

	    client.denySubscription = function (jid) {
	        client.sendPresence({type: 'unsubscribed', to: jid});
	    };
	};


/***/ },
/* 499 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:rtt:0');

	    client.on('message', function (msg) {
	        if (msg.rtt) {
	            client.emit('rtt', msg);
	            client.emit('rtt:' + msg.rtt.event, msg);
	        }
	    });
	};


/***/ },
/* 500 */
/***/ function(module, exports) {

	'use strict';

	var NS = 'http://jabber.org/protocol/shim';


	module.exports = function (client) {

	    client.disco.addFeature(NS);
	    client.disco.addFeature(NS + '#SubID', NS);
	};


/***/ },
/* 501 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('urn:xmpp:time');

	    client.getTime = function (jid, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            time: true
	        }, cb);
	    };

	    client.on('iq:get:time', function (iq) {
	        var time = new Date();
	        client.sendIq(iq.resultReply({
	            time: {
	                utc: time,
	                tzo: time.getTimezoneOffset()
	            }
	        }));
	    });
	};


/***/ },
/* 502 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('vcard-temp');

	    client.getVCard = function (jid, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            vCardTemp: true
	        }, cb);
	    };

	    client.publishVCard = function (vcard, cb) {
	        return this.sendIq({
	            type: 'set',
	            vCardTemp: vcard
	        }, cb);
	    };
	};


/***/ },
/* 503 */
/***/ function(module, exports) {

	'use strict';


	module.exports = function (client) {

	    client.disco.addFeature('jabber:iq:version');

	    client.on('iq:get:version', function (iq) {
	        client.sendIq(iq.resultReply({
	            version: client.config.softwareVersion || {
	                name: 'stanza.io'
	            }
	        }));
	    });

	    client.getSoftwareVersion = function (jid, cb) {
	        return this.sendIq({
	            to: jid,
	            type: 'get',
	            version: true
	        }, cb);
	    };
	};


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*global app, $, me*/
	"use strict";

	var HumanModel = __webpack_require__(505);

	module.exports = HumanModel.define({
	    initialize: function initialize() {
	        var self = this;
	        $(window).blur(function () {
	            self.focused = false;
	        });
	        $(window).focus(function () {
	            self.focused = true;
	            if (me._activeContact) {
	                me.setActiveContact(me._activeContact);
	            }
	            self.markActive();
	        });

	        app.desktop.on('sleep', function () {
	            clearTimeout(this.idleTimer);
	            console.log('went to sleep');
	            self.markInactive();
	        });

	        self.cacheStatus = app.cache.state;
	        app.cache.on('change', function (state) {
	            self.cacheStatus = state;
	        });

	        document.addEventListener('deviceid', function (event) {
	            self.deviceID = event.deviceid;
	        });

	        this.markActive();
	    },
	    session: {
	        focused: ['bool', false, true],
	        active: ['bool', false, false],
	        connected: ['bool', false, false],
	        hasConnected: ['bool', false, false],
	        idleTimeout: ['number', false, 600000],
	        idleSince: 'date',
	        allowAlerts: ['bool', false, false],
	        badge: 'string',
	        pageTitle: 'string',
	        hasActiveCall: ['boolean', false, false],
	        cacheStatus: 'string',
	        deviceID: ['string', false, ''],
	        pageChanged: ['string', false, '']
	    },
	    derived: {
	        title: {
	            deps: ['pageTitle', 'badge'],
	            fn: function fn() {
	                var base = this.pageTitle ? 'Kaiwa - ' + this.pageTitle : 'Kaiwa';
	                if (this.badge) {
	                    return this.badge + '  ' + base;
	                }
	                return base;
	            }
	        },
	        deviceIDReady: {
	            deps: ['connected', 'deviceID'],
	            fn: function fn() {
	                return this.connected && !!this.deviceID;
	            }
	        },
	        currentPageIsSettings: {
	            deps: ['pageChanged'],
	            fn: function fn() {
	                return this.pageChanged === 'settings' ? 'active' : '';
	            }
	        }
	    },
	    markActive: function markActive() {
	        clearTimeout(this.idleTimer);

	        var wasInactive = !this.active;
	        this.active = true;
	        this.idleSince = new Date(Date.now());

	        this.idleTimer = setTimeout(this.markInactive.bind(this), this.idleTimeout);
	    },
	    markInactive: function markInactive() {
	        if (this.focused) {
	            return this.markActive();
	        }

	        this.active = false;
	        this.idleSince = new Date(Date.now());
	    }
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//   (c) 2013 Henrik Joreteg
	//   MIT Licensed
	//   For all details and documentation:
	//   https://github.com/HenrikJoreteg/human-model
	//

	(function (root, factory) {

	  'use strict';

	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(506), __webpack_require__(216)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
	      return (root.HumanModel = factory(_, Backbone));
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node.
	    module.exports = factory(require('underscore'), require('backbone'));
	  } else {
	    // Browser globals
	    root.HumanModel = factory(root._, root.Backbone);
	  }

	}(this, function (_, Backbone) {

	  'use strict';

	  // Initial setup
	  // -------------

	  var slice = Array.prototype.slice;

	  // In backbone, when you add an already instantiated model to a collection
	  // the collection checks to see if what you're adding is already a model
	  // the problem is, it does this witn an instanceof check. We're wanting to
	  // use completely different models so the instanceof will fail even if they
	  // are "real" models. So we work around this by overwriting this method from
	  // backbone 1.0.0. The only difference is it looks for an initialize method
	  // (which both Backbone and HumanModel will always have) to determine whether
	  // an instantiated model or a simple object is being passed in.
	  Backbone.Collection.prototype._prepareModel = function (attrs, options) {
	    if (_.isFunction(attrs.initialize)) {
	      if (!attrs.collection) attrs.collection = this;
	      return attrs;
	    }
	    options || (options = {});
	    options.collection = this;
	    var model = new this.model(attrs, options);
	    if (!model._validate(attrs, options)) {
	      this.trigger('invalid', this, attrs, options);
	      return false;
	    }
	    return model;
	  };

	  var arrayNext = function (array, currentItem) {
	    var len = array.length;
	    var newIndex = array.indexOf(currentItem) + 1;
	    if (newIndex > (len - 1)) newIndex = 0;
	    return array[newIndex];
	  };

	  var createDerivedProperty = function (modelProto, name, definition) {
	    var def = modelProto._derived[name] = {
	      fn: _.isFunction(definition) ? definition : definition.fn,
	      cache: (definition.cache !== false),
	      depList: definition.deps || []
	    };

	    // add to our shared dependency list
	    _.each(def.depList, function (dep) {
	      modelProto._deps[dep] = _(modelProto._deps[dep] || []).union([name]);
	    });

	    // defined a top-level getter for derived names
	    Object.defineProperty(modelProto, name, {
	      get: function () {
	        return this._getDerivedProperty(name);
	      },
	      set: function () {
	        throw new TypeError('"' + name + '" is a derived property, it can\'t be set directly.');
	      }
	    });
	  };


	  // Registry
	  // ---------------

	  // Internal storage for models, seperate namespace
	  // storage from default to prevent collision of matching
	  // model type+id and namespace name

	  var Registry = function () {
	    this._cache = {};
	    this._namespaces = {};
	  };

	  // Attach all inheritable methods to the Registry prototype.
	  _.extend(Registry.prototype, {
	    // Get the general or namespaced internal cache
	    _getCache: function (ns) {
	      if (ns) {
	        this._namespaces[ns] || (this._namespaces[ns] = {});
	        return this._namespaces[ns];
	      }
	      return this._cache;
	    },

	    // Find the cached model
	    lookup: function (type, id, ns) {
	      var cache = this._getCache(ns);
	      return cache && cache[type + id];
	    },

	    // Add a model to the cache if it has not already been set
	    store: function (model) {
	      var cache = this._getCache(model._namespace),
	        key = model.type + model.getId();
	      // Prevent overriding a previously stored model
	      cache[key] = cache[key] || model;
	      return this;
	    },

	    // Remove a stored model from the cache, return `true` if removed
	    remove: function (type, id, ns) {
	      var cache = this._getCache(ns);
	      if (this.lookup.apply(this, arguments)) {
	        delete cache[type + id];
	        return true;
	      }
	      return false;
	    },

	    // Reset internal cache
	    clear: function () {
	      this._cache = {};
	      this._namespaces = {};
	    }
	  });

	  // HumanModel
	  // ------------
	  var registry = new Registry();

	  // our dataTypes
	  var dataTypes = {
	    date: {
	      set: function (newVal) {
	        var newType;
	        if (!_.isDate(newVal)) {
	          try {
	            newVal = (new Date(parseInt(newVal, 10))).valueOf();
	            newType = 'date';
	          } catch (e) {
	            newType = typeof newVal;
	          }
	        } else {
	          newType = 'date';
	          newVal = newVal.valueOf();
	        }
	        return {
	          val: newVal,
	          type: newType
	        };
	      },
	      get: function (val) {
	        return new Date(val);
	      }
	    },
	    array: {
	      set: function (newVal) {
	        return {
	          val: newVal,
	          type: _.isArray(newVal) ? 'array' : typeof newVal
	        };
	      }
	    },
	    object: {
	      set: function (newVal) {
	        var newType = typeof newVal;
	        // we have to have a way of supporting "missing" objects.
	        // Null is an object, but setting a value to undefined
	        // should work too, IMO. We just override it, in that case.
	        if (newType !== 'object' && _.isUndefined(newVal)) {
	          newVal = null;
	          newType = 'object';
	        }
	        return {
	          val: newVal,
	          type: newType
	        };
	      }
	    }
	  };

	  var define = function (spec) {
	    var key;
	    spec || (spec = {});

	    // create our constructor
	    var HumanModel = function (attrs, options) {
	      attrs || (attrs = {});
	      options || (options = {});
	      this.cid = _.uniqueId('model');
	      // set the collection if passed in
	      this.collection = options.collection || undefined;
	      if (options.parse) attrs = this.parse(attrs, options) || {};
	      this.registry = options.registry || registry;
	      options._attrs = attrs;
	      this._namespace = options.namespace;
	      this._initted = false;
	      this._values = {};
	      this._initCollections();
	      this._cache = {};
	      this._previousAttributes = {};
	      this._events = {};

	      this.set(attrs, _.extend({silent: true, initial: true}, options));
	      this._changed = {};
	      this.initialize.apply(this, arguments);
	      if (attrs[this.idAttribute]) this.registry.store(this);
	      this._initted = true;
	      if (this.seal) {
	        Object.seal(this);
	      }
	    };

	    // define a few fixed properties
	    Object.defineProperties(HumanModel.prototype, {
	      attributes: {
	        get: function () {
	          return this._getAttributes(true);
	        }
	      },
	      json: {
	        get: function () {
	          return JSON.stringify(this.serialize());
	        }
	      },
	      derived: {
	        get: function () {
	          var res = {};
	          for (var item in this._derived) res[item] = this._derived[item].fn.apply(this);
	          return res;
	        }
	      },
	      toTemplate: {
	        get: function () {
	          return _.extend(this._getAttributes(true), this.derived);
	        }
	      }
	    });



	    // Attach all inheritable methods to the Model prototype.
	    _.extend(HumanModel.prototype, Backbone.Events, {
	      idAttribute: 'id',

	      // storage for our rules about derived properties
	      _derived: {},
	      _deps: {},
	      _definition: {},

	      // can be allow, ignore, reject
	      extraProperties: 'ignore',

	      getId: function () {
	        return this.get(this.idAttribute);
	      },

	      // stubbed out to be overwritten
	      initialize: function () {
	        return this;
	      },

	      // backbone compatibility
	      parse: function (resp, options) {
	        return resp;
	      },

	      // serialize does nothing by default
	      serialize: function () {
	        return this._getAttributes(false, true);
	      },

	      // Remove model from the registry and unbind events
	      remove: function () {
	        if (this.getId()) {
	          this.registry.remove(this.type, this.getId(), this._namespace);
	        }
	        this.trigger('remove', this);
	        this.off();
	        return this;
	      },

	      set: function (key, value, options) {
	        var self = this;
	        var extraProperties = this.extraProperties;
	        var changing, previous, changes, newType,
	          interpretedType, newVal, def, attr, attrs, silent, unset, currentVal, initial;

	        // Handle both `"key", value` and `{key: value}` -style arguments.
	        if (_.isObject(key) || key === null) {
	          attrs = key;
	          options = value;
	        } else {
	          attrs = {};
	          attrs[key] = value;
	        }

	        options = options || {};

	        if (!this._validate(attrs, options)) return false;

	        // Extract attributes and options.
	        unset = options.unset;
	        silent = options.silent;
	        initial = options.initial;

	        changes = [];
	        changing = this._changing;
	        this._changing = true;

	        // if not already changing, store previous
	        if (!changing) {
	          this._previousAttributes = this._getAttributes(true);
	          this._changed = {};
	        }
	        previous = this._previousAttributes;

	        // For each `set` attribute...
	        for (attr in attrs) {
	          newVal = attrs[attr];
	          newType = typeof newVal;
	          currentVal = this._values[attr];
	          def = this._definition[attr];

	          if (!def) {
	            if (extraProperties === 'ignore') {
	              continue;
	            } else if (extraProperties === 'reject') {
	              throw new TypeError('No "' + attr + '" property defined on ' + (this.type || 'this') + ' model and allowOtherProperties not set.');
	            } else if (extraProperties === 'allow') {
	              def = this._createPropertyDefinition(attr, 'any');
	            }
	          }

	          // check type if we have one
	          if (dataTypes[def.type]) {
	            var cast = dataTypes[def.type].set(newVal);
	            newVal = cast.val;
	            newType = cast.type;
	          }

	          // If we've defined a test, run it
	          if (def.test) {
	            var err = def.test.call(this, newVal, newType);
	            if (err) {
	              throw new TypeError('Property \'' + attr + '\' failed validation with error: ' + err);
	            }
	          }

	          // If we are required but undefined, throw error.
	          // If we are null and are not allowing null, throw error
	          // If we have a defined type and the new type doesn't match, and we are not null, throw error.

	          if (_.isUndefined(newVal) && def.required) {
	            throw new TypeError('Required property \'' + attr + '\' must be of type ' + def.type + '. Tried to set ' + newVal);
	          }
	          if (_.isNull(newVal) && def.required && !def.allowNull) {
	            throw new TypeError('Property \'' + attr + '\' must be of type ' + def.type + ' (cannot be null). Tried to set ' + newVal);
	          }
	          if ((def.type && def.type !== 'any' && def.type !== newType) && !_.isNull(newVal) && !_.isUndefined(newVal)) {
	            throw new TypeError('Property \'' + attr + '\' must be of type ' + def.type + '. Tried to set ' + newVal);
	          }
	          if (def.values && !_.contains(def.values, newVal)) {
	            throw new TypeError('Property \'' + attr + '\' must be one of values: ' + def.values.map(function (item) { return item.toString(); }).join(', '));
	          }

	          // enforce `setOnce` for properties if set
	          if (def.setOnce && currentVal !== undefined && !_.isEqual(currentVal, newVal)) {
	            throw new TypeError('Property \'' + key + '\' can only be set once.');
	          }

	          // push to changes array if different
	          if (!_.isEqual(currentVal, newVal)) {
	            changes.push({prev: currentVal, val: newVal, key: attr});
	          }

	          // keep track of changed attributes
	          if (!_.isEqual(previous[attr], newVal)) {
	            self._changed[attr] = newVal;
	          } else {
	            delete self._changed[attr];
	          }
	        }

	        // actually update our values
	        _.each(changes, function (change) {
	          self._previousAttributes[change.key] = change.prev;
	          if (unset) {
	            delete self._values[change.key];
	          } else {
	            self._values[change.key] = change.val;
	          }
	        });

	        var triggers = [];

	        function gatherTriggers(key) {
	          triggers.push(key);
	          _.each((self._deps[key] || []), function (derTrigger) {
	            gatherTriggers(derTrigger);
	          });
	        }

	        if (!silent && changes.length) self._pending = true;
	        _.each(changes, function (change) {
	          gatherTriggers(change.key);
	        });

	        _.each(_.uniq(triggers), function (key) {
	          var derived = self._derived[key];
	          if (derived && derived.cache && !initial) {
	            var oldDerived = self._cache[key];
	            var newDerived = self._getDerivedProperty(key, true);
	            if (!_.isEqual(oldDerived, newDerived)) {
	              self._previousAttributes[key] = oldDerived;
	              if (!silent) self.trigger('change:' + key, self, newDerived);
	            }
	          } else {
	            if (!silent) self.trigger('change:' + key, self, self[key]);
	          }
	        });

	        // You might be wondering why there's a `while` loop here. Changes can
	        // be recursively nested within `"change"` events.
	        if (changing) return this;
	        if (!silent) {
	          while (this._pending) {
	            this._pending = false;
	            this.trigger('change', this, options);
	          }
	        }
	        this._pending = false;
	        this._changing = false;
	        return this;
	      },

	      get: function (attr) {
	        return this[attr];
	      },

	      // Toggle boolean properties or properties that have a `values`
	      // array in its definition.
	      toggle: function (property) {
	        var def = this._definition[property];
	        if (def.type === 'boolean') {
	          // if it's a bool, just flip it
	          this[property] = !this[property];
	        } else if (def && def.values) {
	          // If it's a property with an array of values
	          // skip to the next one looping back if at end.
	          this[property] = arrayNext(def.values, this[property]);
	        } else {
	          throw new TypeError('Can only toggle properties that are type `boolean` or have `values` array.');
	        }
	        return this;
	      },

	      // Get all of the attributes of the model at the time of the previous
	      // `"change"` event.
	      previousAttributes: function () {
	        return _.clone(this._previousAttributes);
	      },

	      save: function (key, val, options) {
	        var attrs, method, xhr, attributes = this.attributes;

	        // Handle both `"key", value` and `{key: value}` -style arguments.
	        if (key == null || typeof key === 'object') {
	          attrs = key;
	          options = val;
	        } else {
	          (attrs = {})[key] = val;
	        }

	        options = _.extend({validate: true}, options);

	        // If we're not waiting and attributes exist, save acts as
	        // `set(attr).save(null, opts)` with validation. Otherwise, check if
	        // the model will be valid when the attributes, if any, are set.
	        if (attrs && !options.wait) {
	          if (!this.set(attrs, options)) return false;
	        } else {
	          if (!this._validate(attrs, options)) return false;
	        }

	        // After a successful server-side save, the client is (optionally)
	        // updated with the server-side state.
	        if (options.parse === void 0) options.parse = true;
	        var model = this;
	        var success = options.success;
	        options.success = function (resp) {
	          var serverAttrs = model.parse(resp, options);
	          if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
	          if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
	            return false;
	          }
	          if (success) success(model, resp, options);
	          model.trigger('sync', model, resp, options);
	        };
	        wrapError(this, options);

	        method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
	        if (method === 'patch') options.attrs = attrs;
	        // if we're waiting we haven't actually set our attributes yet so
	        // we need to do make sure we send right data
	        if (options.wait) options.attrs = _.extend(model.serialize(), attrs);
	        xhr = this.sync(method, this, options);

	        return xhr;
	      },

	      // Fetch the model from the server. If the server's representation of the
	      // model differs from its current attributes, they will be overridden,
	      // triggering a `"change"` event.
	      fetch: function (options) {
	        options = options ? _.clone(options) : {};
	        if (options.parse === void 0) options.parse = true;
	        var model = this;
	        var success = options.success;
	        options.success = function (resp) {
	          if (!model.set(model.parse(resp, options), options)) return false;
	          if (success) success(model, resp, options);
	          model.trigger('sync', model, resp, options);
	        };
	        wrapError(this, options);
	        return this.sync('read', this, options);
	      },

	      // Destroy this model on the server if it was already persisted.
	      // Optimistically removes the model from its collection, if it has one.
	      // If `wait: true` is passed, waits for the server to respond before removal.
	      destroy: function (options) {
	        options = options ? _.clone(options) : {};
	        var model = this;
	        var success = options.success;

	        var destroy = function () {
	          model.trigger('destroy', model, model.collection, options);
	        };

	        options.success = function (resp) {
	          if (options.wait || model.isNew()) destroy();
	          if (success) success(model, resp, options);
	          if (!model.isNew()) model.trigger('sync', model, resp, options);
	        };

	        if (this.isNew()) {
	          options.success();
	          return false;
	        }
	        wrapError(this, options);

	        var xhr = this.sync('delete', this, options);
	        if (!options.wait) destroy();
	        return xhr;
	      },

	      // Determine if the model has changed since the last `"change"` event.
	      // If you specify an attribute name, determine if that attribute has changed.
	      hasChanged: function (attr) {
	        if (attr == null) return !_.isEmpty(this._changed);
	        return _.has(this._changed, attr);
	      },

	      // Return an object containing all the attributes that have changed, or
	      // false if there are no changed attributes. Useful for determining what
	      // parts of a view need to be updated and/or what attributes need to be
	      // persisted to the server. Unset attributes will be set to undefined.
	      // You can also pass an attributes object to diff against the model,
	      // determining if there *would be* a change.
	      changedAttributes: function (diff) {
	        if (!diff) return this.hasChanged() ? _.clone(this._changed) : false;
	        var val, changed = false;
	        var old = this._changing ? this._previousAttributes : this._getAttributes(true);
	        for (var attr in diff) {
	          if (_.isEqual(old[attr], (val = diff[attr]))) continue;
	          (changed || (changed = {}))[attr] = val;
	        }
	        return changed;
	      },

	      toJSON: function () {
	        return this.serialize();
	      },

	      // Returns `true` if the attribute contains a value that is not null
	      // or undefined.
	      has: function (attr) {
	        return this.get(attr) != null;
	      },

	      // Default URL for the model's representation on the server -- if you're
	      // using Backbone's restful methods, override this to change the endpoint
	      // that will be called.
	      url: function () {
	        var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
	        if (this.isNew()) return base;
	        return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.getId());
	      },

	      // A model is new if it has never been saved to the server, and lacks an id.
	      isNew: function () {
	        return this.getId() == null;
	      },

	      // return copy of model
	      clone: function () {
	        return new this.constructor(this._getAttributes(true));
	      },

	      // Check if the model is currently in a valid state.
	      isValid: function (options) {
	        return this._validate({}, _.extend(options || {}, { validate: true }));
	      },

	      // return escaped property
	      escape: function (attr) {
	        return _.escape(this[attr]);
	      },

	      // Proxy `Backbone.sync` by default -- but override this if you need
	      // custom syncing semantics for *this* particular model.
	      sync: function () {
	        return Backbone.sync.apply(this, arguments);
	      },

	      unset: function (attr, options) {
	        var def = this._definition[attr];
	        var type = def.type;
	        var val;
	        if (def.required) {
	          if (!_.isUndefined(def.default)) {
	            val = def.default;
	          } else {
	            val = this._getDefaultForType(type);
	          }
	          return this.set(attr, val, options);
	        } else {
	          return this.set(attr, val, _.extend({}, options, {unset: true}));
	        }
	      },

	      clear: function (options) {
	        var self = this;
	        _.each(this._getAttributes(true), function (val, key) {
	          self.unset(key, options);
	        });
	        return this;
	      },

	      // Run validation against the next complete set of model attributes,
	      // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
	      _validate: function (attrs, options) {
	        if (!options.validate || !this.validate) return true;
	        attrs = _.extend({}, this.attributes, attrs);
	        var error = this.validationError = this.validate(attrs, options) || null;
	        if (!error) return true;
	        this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
	        return false;
	      },

	      // Get default values for a certain type
	      _getDefaultForType: function (type) {
	        if (type === 'string') {
	          return '';
	        } else if (type === 'object') {
	          return {};
	        } else if (type === 'array') {
	          return [];
	        }
	      },

	      // convenience methods for manipulating array properties
	      addListVal: function (prop, value, prepend) {
	        var list = _.clone(this[prop]) || [];
	        if (!_(list).contains(value)) {
	          list[prepend ? 'unshift' : 'push'](value);
	          this[prop] = list;
	        }
	        return this;
	      },

	      previous: function (attr) {
	        if (attr == null || !Object.keys(this._previousAttributes).length) return null;
	        return this._previousAttributes[attr];
	      },

	      removeListVal: function (prop, value) {
	        var list = _.clone(this[prop]) || [];
	        if (_(list).contains(value)) {
	          this[prop] = _(list).without(value);
	        }
	        return this;
	      },

	      hasListVal: function (prop, value) {
	        return _.contains(this[prop] || [], value);
	      },

	      // -----------------------------------------------------------------------

	      _initCollections: function () {
	        var coll;
	        if (!this._collections) return;
	        for (coll in this._collections) {
	          this[coll] = new this._collections[coll]();
	          this[coll].parent = this;
	        }
	      },

	      // Check that all required attributes are present
	      _verifyRequired: function () {
	        var attrs = this._getAttributes(true); // should include session
	        for (var def in this._definition) {
	          if (this._definition[def].required && typeof attrs[def] === 'undefined') {
	            return false;
	          }
	        }
	        return true;
	      },

	      _createPropertyDefinition: function (name, desc, isSession) {
	        var self = this;
	        var def = this._definition[name] = {};
	        var type;
	        if (_.isString(desc)) {
	          // grab our type if all we've got is a string
	          type = this._ensureValidType(desc);
	          if (type) def.type = type;
	        } else {
	          type = this._ensureValidType(desc[0] || desc.type);
	          if (type) def.type = type;
	          if (desc[1] || desc.required) def.required = true;
	          // set default if defined
	          def.default = !_.isUndefined(desc[2]) ? desc[2] : desc.default;
	          def.allowNull = desc.allowNull ? desc.allowNull : false;
	          if (desc.setOnce) def.setOnce = true;
	          if (def.required && _.isUndefined(def.default)) def.default = this._getDefaultForType(type);
	          def.test = desc.test;
	          def.values = _.isArray(desc) ? undefined : desc.values;
	        }
	        if (isSession) def.session = true;

	        // define a getter/setter on the prototype
	        // but they get/set on the instance
	        Object.defineProperty(self, name, {
	          set: function (val) {
	            this.set(name, val);
	          },
	          get: function () {
	            var result = this._values[name];
	            if (typeof result !== 'undefined') {
	              if (dataTypes[def.type] && dataTypes[def.type].get) {
	                result = dataTypes[def.type].get(result);
	              }
	              return result;
	            }
	            return def.default;
	          }
	        });

	        return def;
	      },

	      // just makes friendlier errors when trying to define a new model
	      // only used when setting up original property definitions
	      _ensureValidType: function (type) {
	        return _.contains(['string', 'number', 'boolean', 'array', 'object', 'date', 'any'].concat(_.keys(dataTypes)), type) ? type : undefined;
	      },

	      _getAttributes: function (includeSession, raw) {
	        var res = {};
	        var val, item, def;
	        for (item in this._definition) {
	          def = this._definition[item];
	          if (!def.session || (includeSession && def.session)) {
	            val = (raw) ? this._values[item] : this[item];
	            if (typeof val === 'undefined') val = def.default;
	            if (typeof val !== 'undefined') res[item] = val;
	          }
	        }
	        return res;
	      },

	      _getDerivedProperty: function (name, flushCache) {
	        // is this a derived property that is cached
	        if (this._derived[name].cache) {
	          // read through cache
	          if (!flushCache && this._cache.hasOwnProperty(name)) {
	            return this._cache[name];
	          } else {
	            return this._cache[name] = this._derived[name].fn.apply(this);
	          }
	        } else {
	          return this._derived[name].fn.apply(this);
	        }
	      }
	    });

	    // Underscore methods that we want to implement on the Model.
	    var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

	    // Mix in each Underscore method as a proxy to `Model#attributes`.
	    _.each(modelMethods, function (method) {
	      HumanModel.prototype[method] = function () {
	        var args = slice.call(arguments);
	        args.unshift(this.attributes);
	        return _[method].apply(_, args);
	      };
	    });

	    for (key in spec) {
	      if (key === 'props' || key === 'session') {
	        _.each(spec[key], function (def, name) {
	          HumanModel.prototype._createPropertyDefinition.call(HumanModel.prototype, name, def, key === 'session');
	        });
	        //HumanModel.prototype['_' + key] = spec[key];
	      } else if (key === 'derived') {
	        _.each(spec[key], function (def, name) {
	          createDerivedProperty(HumanModel.prototype, name, def);
	        });
	      } else if (key === 'collections') {
	        HumanModel.prototype._collections = spec[key];
	      } else {
	        HumanModel.prototype[key] = spec[key];
	      }
	    }

	    HumanModel.registry = registry;

	    return HumanModel;
	  };

	  // Wrap an optional error callback with a fallback error event.
	  var wrapError = function (model, options) {
	    var error = options.error;
	    options.error = function (resp) {
	      if (error) error(model, resp, options);
	      model.trigger('error', model, resp, options);
	    };
	  };

	  // Throw an error when a URL is needed, and none is supplied.
	  var urlError = function () {
	    throw new Error('A "url" property or function must be specified');
	  };

	  return {
	    define: define,
	    registry: registry,
	    Registry: Registry,
	    dataTypes: dataTypes
	  };

	}));



/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	//     Underscore.js 1.5.1
	//     http://underscorejs.org
	//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `global` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Establish the object that gets returned to break out of a loop iteration.
	  var breaker = {};

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    concat           = ArrayProto.concat,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeForEach      = ArrayProto.forEach,
	    nativeMap          = ArrayProto.map,
	    nativeReduce       = ArrayProto.reduce,
	    nativeReduceRight  = ArrayProto.reduceRight,
	    nativeFilter       = ArrayProto.filter,
	    nativeEvery        = ArrayProto.every,
	    nativeSome         = ArrayProto.some,
	    nativeIndexOf      = ArrayProto.indexOf,
	    nativeLastIndexOf  = ArrayProto.lastIndexOf,
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object via a string identifier,
	  // for Closure Compiler "advanced" mode.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.5.1';

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles objects with the built-in `forEach`, arrays, and raw objects.
	  // Delegates to **ECMAScript 5**'s native `forEach` if available.
	  var each = _.each = _.forEach = function(obj, iterator, context) {
	    if (obj == null) return;
	    if (nativeForEach && obj.forEach === nativeForEach) {
	      obj.forEach(iterator, context);
	    } else if (obj.length === +obj.length) {
	      for (var i = 0, l = obj.length; i < l; i++) {
	        if (iterator.call(context, obj[i], i, obj) === breaker) return;
	      }
	    } else {
	      for (var key in obj) {
	        if (_.has(obj, key)) {
	          if (iterator.call(context, obj[key], key, obj) === breaker) return;
	        }
	      }
	    }
	  };

	  // Return the results of applying the iterator to each element.
	  // Delegates to **ECMAScript 5**'s native `map` if available.
	  _.map = _.collect = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	    each(obj, function(value, index, list) {
	      results.push(iterator.call(context, value, index, list));
	    });
	    return results;
	  };

	  var reduceError = 'Reduce of empty array with no initial value';

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduce && obj.reduce === nativeReduce) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	    }
	    each(obj, function(value, index, list) {
	      if (!initial) {
	        memo = value;
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, value, index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // The right-associative version of reduce, also known as `foldr`.
	  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
	    }
	    var length = obj.length;
	    if (length !== +length) {
	      var keys = _.keys(obj);
	      length = keys.length;
	    }
	    each(obj, function(value, index, list) {
	      index = keys ? keys[--length] : --length;
	      if (!initial) {
	        memo = obj[index];
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, obj[index], index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, iterator, context) {
	    var result;
	    any(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };

	  // Return all the elements that pass a truth test.
	  // Delegates to **ECMAScript 5**'s native `filter` if available.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
	    each(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, iterator, context) {
	    return _.filter(obj, function(value, index, list) {
	      return !iterator.call(context, value, index, list);
	    }, context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Delegates to **ECMAScript 5**'s native `every` if available.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = true;
	    if (obj == null) return result;
	    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
	    each(obj, function(value, index, list) {
	      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Delegates to **ECMAScript 5**'s native `some` if available.
	  // Aliased as `any`.
	  var any = _.some = _.any = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = false;
	    if (obj == null) return result;
	    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
	    each(obj, function(value, index, list) {
	      if (result || (result = iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
	    return any(obj, function(value) {
	      return value === target;
	    });
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, function(value){ return value[key]; });
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs, first) {
	    if (_.isEmpty(attrs)) return first ? void 0 : [];
	    return _[first ? 'find' : 'filter'](obj, function(value) {
	      for (var key in attrs) {
	        if (attrs[key] !== value[key]) return false;
	      }
	      return true;
	    });
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.where(obj, attrs, true);
	  };

	  // Return the maximum element or (element-based computation).
	  // Can't optimize arrays of integers longer than 65,535 elements.
	  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
	  _.max = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.max.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return -Infinity;
	    var result = {computed : -Infinity, value: -Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed > result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.min.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return Infinity;
	    var result = {computed : Infinity, value: Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed < result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Shuffle an array.
	  _.shuffle = function(obj) {
	    var rand;
	    var index = 0;
	    var shuffled = [];
	    each(obj, function(value) {
	      rand = _.random(index++);
	      shuffled[index - 1] = shuffled[rand];
	      shuffled[rand] = value;
	    });
	    return shuffled;
	  };

	  // An internal function to generate lookup iterators.
	  var lookupIterator = function(value) {
	    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
	  };

	  // Sort the object's values by a criterion produced by an iterator.
	  _.sortBy = function(obj, value, context) {
	    var iterator = lookupIterator(value);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value : value,
	        index : index,
	        criteria : iterator.call(context, value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index < right.index ? -1 : 1;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(obj, value, context, behavior) {
	    var result = {};
	    var iterator = lookupIterator(value == null ? _.identity : value);
	    each(obj, function(value, index) {
	      var key = iterator.call(context, value, index, obj);
	      behavior(result, key, value);
	    });
	    return result;
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = function(obj, value, context) {
	    return group(obj, value, context, function(result, key, value) {
	      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
	    });
	  };

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = function(obj, value, context) {
	    return group(obj, value, context, function(result, key) {
	      if (!_.has(result, key)) result[key] = 0;
	      result[key]++;
	    });
	  };

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iterator, context) {
	    iterator = iterator == null ? _.identity : lookupIterator(iterator);
	    var value = iterator.call(context, obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
	    }
	    return low;
	  };

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n != null) && !guard) {
	      return slice.call(array, Math.max(array.length - n, 0));
	    } else {
	      return array[array.length - 1];
	    }
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, (n == null) || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, output) {
	    if (shallow && _.every(input, _.isArray)) {
	      return concat.apply(output, input);
	    }
	    each(input, function(value) {
	      if (_.isArray(value) || _.isArguments(value)) {
	        shallow ? push.apply(output, value) : flatten(value, shallow, output);
	      } else {
	        output.push(value);
	      }
	    });
	    return output;
	  };

	  // Return a completely flattened version of an array.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, []);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iterator, context) {
	    if (_.isFunction(isSorted)) {
	      context = iterator;
	      iterator = isSorted;
	      isSorted = false;
	    }
	    var initial = iterator ? _.map(array, iterator, context) : array;
	    var results = [];
	    var seen = [];
	    each(initial, function(value, index) {
	      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
	        seen.push(value);
	        results.push(array[index]);
	      }
	    });
	    return results;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(_.flatten(arguments, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var rest = slice.call(arguments, 1);
	    return _.filter(_.uniq(array), function(item) {
	      return _.every(rest, function(other) {
	        return _.indexOf(other, item) >= 0;
	      });
	    });
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
	    return _.filter(array, function(value){ return !_.contains(rest, value); });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    var length = _.max(_.pluck(arguments, "length").concat(0));
	    var results = new Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(arguments, '' + i);
	    }
	    return results;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	  // we need this function. Return the position of the first occurrence of an
	  // item in an array, or -1 if the item is not included in the array.
	  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, l = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
	    for (; i < l; i++) if (array[i] === item) return i;
	    return -1;
	  };

	  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var hasIndex = from != null;
	    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
	      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
	    }
	    var i = (hasIndex ? from : array.length);
	    while (i--) if (array[i] === item) return i;
	    return -1;
	  };

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = arguments[2] || 1;

	    var len = Math.max(Math.ceil((stop - start) / step), 0);
	    var idx = 0;
	    var range = new Array(len);

	    while(idx < len) {
	      range[idx++] = start;
	      start += step;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Reusable constructor function for prototype setting.
	  var ctor = function(){};

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    var args, bound;
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError;
	    args = slice.call(arguments, 2);
	    return bound = function() {
	      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
	      ctor.prototype = func.prototype;
	      var self = new ctor;
	      ctor.prototype = null;
	      var result = func.apply(self, args.concat(slice.call(arguments)));
	      if (Object(result) === result) return result;
	      return self;
	    };
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context.
	  _.partial = function(func) {
	    var args = slice.call(arguments, 1);
	    return function() {
	      return func.apply(this, args.concat(slice.call(arguments)));
	    };
	  };

	  // Bind all of an object's methods to that object. Useful for ensuring that
	  // all callbacks defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var funcs = slice.call(arguments, 1);
	    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
	    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memo = {};
	    hasher || (hasher = _.identity);
	    return function() {
	      var key = hasher.apply(this, arguments);
	      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
	    };
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){ return func.apply(null, args); }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    options || (options = {});
	    var later = function() {
	      previous = options.leading === false ? 0 : new Date;
	      timeout = null;
	      result = func.apply(context, args);
	    };
	    return function() {
	      var now = new Date;
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var result;
	    var timeout = null;
	    return function() {
	      var context = this, args = arguments;
	      var later = function() {
	        timeout = null;
	        if (!immediate) result = func.apply(context, args);
	      };
	      var callNow = immediate && !timeout;
	      clearTimeout(timeout);
	      timeout = setTimeout(later, wait);
	      if (callNow) result = func.apply(context, args);
	      return result;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = function(func) {
	    var ran = false, memo;
	    return function() {
	      if (ran) return memo;
	      ran = true;
	      memo = func.apply(this, arguments);
	      func = null;
	      return memo;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return function() {
	      var args = [func];
	      push.apply(args, arguments);
	      return wrapper.apply(this, args);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments;
	      for (var i = funcs.length - 1; i >= 0; i--) {
	        args = [funcs[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  };

	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Object Functions
	  // ----------------

	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = nativeKeys || function(obj) {
	    if (obj !== Object(obj)) throw new TypeError('Invalid object');
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var values = [];
	    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
	    return values;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var pairs = [];
	    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    each(keys, function(key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    for (var key in obj) {
	      if (!_.contains(keys, key)) copy[key] = obj[key];
	    }
	    return copy;
	  };

	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          if (obj[prop] === void 0) obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a == 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className != toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, dates, and booleans are compared by value.
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return a == String(b);
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
	        // other numeric values.
	        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a == +b;
	      // RegExps are compared by their source patterns and flags.
	      case '[object RegExp]':
	        return a.source == b.source &&
	               a.global == b.global &&
	               a.multiline == b.multiline &&
	               a.ignoreCase == b.ignoreCase;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] == a) return bStack[length] == b;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s
	    // from different frames are.
	    var aCtor = a.constructor, bCtor = b.constructor;
	    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
	                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
	      return false;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size = 0, result = true;
	    // Recursively compare objects and arrays.
	    if (className == '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size == b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Deep compare objects.
	      for (var key in a) {
	        if (_.has(a, key)) {
	          // Count the expected number of properties.
	          size++;
	          // Deep compare each member.
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	      // Ensure that both objects contain the same number of properties.
	      if (result) {
	        for (key in b) {
	          if (_.has(b, key) && !(size--)) break;
	        }
	        result = !size;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    return obj === Object(obj);
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) == '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return !!(obj && _.has(obj, 'callee'));
	    };
	  }

	  // Optimize `isFunction` if appropriate.
	  if (true) {
	    _.isFunction = function(obj) {
	      return typeof obj === 'function';
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj != +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iterators.
	  _.identity = function(value) {
	    return value;
	  };

	  // Run a function **n** times.
	  _.times = function(n, iterator, context) {
	    var accum = Array(Math.max(0, n));
	    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // List of HTML entities for escaping.
	  var entityMap = {
	    escape: {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#x27;',
	      '/': '&#x2F;'
	    }
	  };
	  entityMap.unescape = _.invert(entityMap.escape);

	  // Regexes containing the keys and values listed immediately above.
	  var entityRegexes = {
	    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
	    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	  };

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  _.each(['escape', 'unescape'], function(method) {
	    _[method] = function(string) {
	      if (string == null) return '';
	      return ('' + string).replace(entityRegexes[method], function(match) {
	        return entityMap[method][match];
	      });
	    };
	  });

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return void 0;
	    var value = object[property];
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    each(_.functions(obj), function(name){
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\t':     't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  _.template = function(text, data, settings) {
	    var render;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset)
	        .replace(escaper, function(match) { return '\\' + escapes[match]; });

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      }
	      if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      }
	      if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	      index = offset + match.length;
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + "return __p;\n";

	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    if (data) return render(data, _);
	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function, which will delegate to the wrapper.
	  _.chain = function(obj) {
	    return _(obj).chain();
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  _.extend(_.prototype, {

	    // Start chaining a wrapped Underscore object.
	    chain: function() {
	      this._chain = true;
	      return this;
	    },

	    // Extracts the result from a wrapped and chained object.
	    value: function() {
	      return this._wrapped;
	    }

	  });

	}).call(this);


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*global app, client, URL, me*/
	"use strict";

	var HumanModel = __webpack_require__(505);
	var getUserMedia = __webpack_require__(508);
	var Contacts = __webpack_require__(510);
	var Calls = __webpack_require__(631);
	var Contact = __webpack_require__(512);
	var MUCs = __webpack_require__(633);
	var MUC = __webpack_require__(634);
	var ContactRequests = __webpack_require__(635);
	var fetchAvatar = __webpack_require__(623);
	var crypto = __webpack_require__(513);
	var StanzaIo = __webpack_require__(221);

	module.exports = HumanModel.define({
	    initialize: function initialize(opts) {
	        this.setAvatar(opts ? opts.avatarID : null);

	        this.bind('change:jid', this.load, this);
	        this.bind('change:hasFocus', function () {
	            this.setActiveContact(this._activeContact);
	        }, this);
	        this.calls.bind('add remove reset', this.updateActiveCalls, this);
	        this.bind('change:avatarID', this.save, this);
	        this.bind('change:status', this.save, this);
	        this.bind('change:rosterVer', this.save, this);
	        this.bind('change:soundEnabled', this.save, this);
	        this.contacts.bind('change:unreadCount', this.updateUnreadCount, this);
	        app.state.bind('change:active', this.updateIdlePresence, this);
	        app.state.bind('change:deviceIDReady', this.registerDevice, this);
	    },
	    props: {
	        jid: ['object', true],
	        status: 'string',
	        avatarID: 'string',
	        rosterVer: 'string',
	        nick: 'string'
	    },
	    session: {
	        avatar: 'string',
	        connected: ['bool', false, false],
	        shouldAskForAlertsPermission: ['bool', false, false],
	        hasFocus: ['bool', false, false],
	        _activeContact: 'string',
	        stream: 'object',
	        soundEnabled: ['bool', false, true]
	    },
	    collections: {
	        contacts: Contacts,
	        contactRequests: ContactRequests,
	        mucs: MUCs,
	        calls: Calls
	    },
	    derived: {
	        displayName: {
	            deps: ['nick', 'jid'],
	            fn: function fn() {
	                return this.nick || this.jid.bare;
	            }
	        },
	        streamUrl: {
	            deps: ['stream'],
	            fn: function fn() {
	                if (!this.stream) return '';
	                return URL.createObjectURL(this.stream);
	            }
	        },
	        organization: {
	            deps: ['orga'],
	            fn: function fn() {
	                return app.serverConfig().name || 'Kaiwa';
	            }
	        },
	        soundEnabledClass: {
	            deps: ['soundEnabled'],
	            fn: function fn() {
	                return this.soundEnabled ? "primary" : "secondary";
	            }
	        },
	        isAdmin: {
	            deps: ['jid'],
	            fn: function fn() {
	                return this.jid.local === SERVER_CONFIG.admin ? 'meIsAdmin' : '';
	            }
	        }
	    },
	    setActiveContact: function setActiveContact(jid) {
	        var prev = this.getContact(this._activeContact);
	        if (prev) {
	            prev.activeContact = false;
	        }
	        var curr = this.getContact(jid);
	        if (curr) {
	            curr.activeContact = true;
	            curr.unreadCount = 0;
	            this._activeContact = curr.id;
	        }
	    },
	    getName: function getName() {
	        return this.displayName;
	    },
	    getNickname: function getNickname() {
	        return this.displayName != this.nick ? this.nick : '';
	    },
	    getAvatar: function getAvatar() {
	        return this.avatar;
	    },
	    setAvatar: function setAvatar(id, type, source) {
	        var self = this;
	        fetchAvatar('', id, type, source, function (avatar) {
	            self.avatarID = avatar.id;
	            self.avatar = avatar.uri;
	        });
	    },
	    publishAvatar: function publishAvatar(data) {
	        if (!data) data = this.avatar;
	        if (!data || data.indexOf('https://') != -1) return;

	        var resampler = new Resample(data, 80, 80, function (data) {
	            var b64Data = data.split(',')[1];
	            var id = crypto.createHash('sha1').update(atob(b64Data)).digest('hex');
	            app.storage.avatars.add({ id: id, uri: data });
	            client.publishAvatar(id, b64Data, function (err, res) {
	                if (err) return;
	                client.useAvatars([{
	                    id: id,
	                    width: 80,
	                    height: 80,
	                    type: 'image/png',
	                    bytes: b64Data.length
	                }]);
	            });
	        });
	    },
	    setSoundNotification: function setSoundNotification(enable) {
	        this.soundEnabled = enable;
	    },
	    getContact: function getContact(jid, alt) {
	        if (typeof jid === 'string') {
	            if (SERVER_CONFIG.domain && jid.indexOf('@') == -1) jid += '@' + SERVER_CONFIG.domain;
	            jid = new StanzaIo.JID(jid);
	        }
	        if (typeof alt === 'string') alt = new StanzaIo.JID(alt);

	        if (this.isMe(jid)) {
	            jid = alt || jid;
	        }

	        if (!jid) return;

	        return this.contacts.get(jid.bare) || this.mucs.get(jid.bare) || this.calls.findWhere('jid', jid);
	    },
	    setContact: function setContact(data, create) {
	        var contact = this.getContact(data.jid);
	        data.jid = data.jid.bare;

	        if (contact) {
	            contact.set(data);
	            contact.save();
	        } else if (create) {
	            contact = new Contact(data);
	            contact.inRoster = true;
	            contact.owner = this.jid.bare;
	            contact.save();
	            this.contacts.add(contact);
	        }
	    },
	    removeContact: function removeContact(jid) {
	        var self = this;
	        client.removeRosterItem(jid, function (err, res) {
	            var contact = self.getContact(jid);
	            self.contacts.remove(contact.jid);
	            app.storage.roster.remove(contact.storageId);
	        });
	    },
	    load: function load() {
	        if (!this.jid.bare) return;

	        var self = this;

	        app.storage.profiles.get(this.jid.bare, function (err, profile) {
	            if (!err) {
	                self.nick = self.jid.local;
	                self.status = profile.status;
	                self.avatarID = profile.avatarID;
	                self.soundEnabled = profile.soundEnabled;
	            }
	            self.save();
	            app.storage.roster.getAll(self.jid.bare, function (err, contacts) {
	                if (err) return;

	                contacts.forEach(function (contact) {
	                    contact = new Contact(contact);
	                    contact.owner = self.jid.bare;
	                    contact.inRoster = true;
	                    if (contact.jid.indexOf("@" + SERVER_CONFIG.domain) > -1) contact.persistent = true;
	                    contact.save();
	                    self.contacts.add(contact);
	                });
	            });
	        });

	        this.mucs.once('loaded', function () {
	            self.contacts.trigger('loaded');
	        });
	    },
	    isMe: function isMe(jid) {
	        return jid && jid.bare === this.jid.bare;
	    },
	    updateJid: function updateJid(newJid) {
	        if (this.jid.domain && this.isMe(newJid)) {
	            this.jid.full = newJid.full;
	            this.jid.resource = newJid.resource;
	            this.jid.unescapedFull = newJid.unescapedFull;
	            this.jid.prepped = newJid.prepped;
	        } else {
	            this.jid = newJid;
	            this.nick = this.jid.local;
	        }
	    },
	    updateIdlePresence: function updateIdlePresence() {
	        var update = {
	            status: this.status,
	            show: this.show,
	            caps: app.api.disco.caps
	        };

	        if (!app.state.active) {
	            update.idle = { since: app.state.idleSince };
	        }

	        app.api.sendPresence(update);
	    },
	    updateUnreadCount: function updateUnreadCount() {
	        var unreadCounts = this.contacts.pluck('unreadCount');
	        var count = unreadCounts.reduce(function (a, b) {
	            return a + b;
	        });
	        if (count === 0) {
	            count = '';
	        }
	        app.state.badge = '' + count;
	    },
	    updateActiveCalls: function updateActiveCalls() {
	        app.state.hasActiveCall = !!this.calls.length;
	    },
	    save: function save() {
	        var data = {
	            jid: this.jid.bare,
	            avatarID: this.avatarID,
	            status: this.status,
	            rosterVer: this.rosterVer,
	            soundEnabled: this.soundEnabled
	        };
	        app.storage.profiles.set(data);
	    },
	    cameraOn: function cameraOn() {
	        var self = this;
	        getUserMedia(function (err, stream) {
	            if (err) {
	                console.error(err);
	            } else {
	                self.stream = stream;
	            }
	        });
	    },
	    cameraOff: function cameraOff() {
	        if (this.stream) {
	            this.stream.stop();
	            this.stream = null;
	        }
	    },
	    registerDevice: function registerDevice() {
	        var deviceID = app.state.deviceID;
	        if (!!deviceID && deviceID !== undefined && deviceID !== 'undefined') {
	            client.otalkRegister(deviceID).then(function () {
	                client.registerPush('push@push.otalk.im/prod');
	            }).catch(function (err) {
	                console.log('Could not enable push notifications');
	            });
	        }
	    }
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	// getUserMedia helper by @HenrikJoreteg
	var adapter = __webpack_require__(509);

	module.exports = function (constraints, cb) {
	    var options, error;
	    var haveOpts = arguments.length === 2;
	    var defaultOpts = {video: true, audio: true};

	    var denied = 'PermissionDeniedError';
	    var altDenied = 'PERMISSION_DENIED';
	    var notSatisfied = 'ConstraintNotSatisfiedError';

	    // make constraints optional
	    if (!haveOpts) {
	        cb = constraints;
	        constraints = defaultOpts;
	    }

	    // treat lack of browser support like an error
	    if (!navigator.getUserMedia) {
	        // throw proper error per spec
	        error = new Error('MediaStreamError');
	        error.name = 'NotSupportedError';

	        // keep all callbacks async
	        return window.setTimeout(function () {
	            cb(error);
	        }, 0);
	    }

	    // normalize error handling when no media types are requested
	    if (!constraints.audio && !constraints.video) {
	        error = new Error('MediaStreamError');
	        error.name = 'NoMediaRequestedError';

	        // keep all callbacks async
	        return window.setTimeout(function () {
	            cb(error);
	        }, 0);
	    }

	    // testing support
	    if (localStorage && localStorage.useFirefoxFakeDevice === "true") {
	        constraints.fake = true;
	    }

	    navigator.getUserMedia(constraints, function (stream) {
	        cb(null, stream);
	    }, function (err) {
	        var error;
	        // coerce into an error object since FF gives us a string
	        // there are only two valid names according to the spec
	        // we coerce all non-denied to "constraint not satisfied".
	        if (typeof err === 'string') {
	            error = new Error('MediaStreamError');
	            if (err === denied || err === altDenied) {
	                error.name = denied;
	            } else {
	                error.name = notSatisfied;
	            }
	        } else {
	            // if we get an error object make sure '.name' property is set
	            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
	            error = err;
	            if (!error.name) {
	                // this is likely chrome which
	                // sets a property called "ERROR_DENIED" on the error object
	                // if so we make sure to set a name
	                if (error[denied]) {
	                    err.name = denied;
	                } else {
	                    err.name = notSatisfied;
	                }
	            }
	        }

	        cb(error);
	    });
	};


/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */

	/* More information about these options at jshint.com/docs/options */
	/* jshint browser: true, camelcase: true, curly: true, devel: true,
	   eqeqeq: true, forin: false, globalstrict: true, node: true,
	   quotmark: single, undef: true, unused: strict */
	/* global mozRTCIceCandidate, mozRTCPeerConnection, Promise,
	mozRTCSessionDescription, webkitRTCPeerConnection, MediaStreamTrack,
	MediaStream, RTCIceGatherer, RTCIceTransport, RTCDtlsTransport,
	RTCRtpSender, RTCRtpReceiver*/
	/* exported trace,requestUserMedia */

	'use strict';

	var getUserMedia = null;
	var attachMediaStream = null;
	var reattachMediaStream = null;
	var webrtcDetectedBrowser = null;
	var webrtcDetectedVersion = null;
	var webrtcMinimumVersion = null;
	var webrtcUtils = {
	  log: function() {
	    // suppress console.log output when being included as a module.
	    if (true) {
	      return;
	    }
	    console.log.apply(console, arguments);
	  },
	  extractVersion: function(uastring, expr, pos) {
	    var match = uastring.match(expr);
	    return match && match.length >= pos && parseInt(match[pos], 10);
	  }
	};

	function trace(text) {
	  // This function is used for logging.
	  if (text[text.length - 1] === '\n') {
	    text = text.substring(0, text.length - 1);
	  }
	  if (window.performance) {
	    var now = (window.performance.now() / 1000).toFixed(3);
	    webrtcUtils.log(now + ': ' + text);
	  } else {
	    webrtcUtils.log(text);
	  }
	}

	if (typeof window === 'object') {
	  if (window.HTMLMediaElement &&
	    !('srcObject' in window.HTMLMediaElement.prototype)) {
	    // Shim the srcObject property, once, when HTMLMediaElement is found.
	    Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
	      get: function() {
	        // If prefixed srcObject property exists, return it.
	        // Otherwise use the shimmed property, _srcObject
	        return 'mozSrcObject' in this ? this.mozSrcObject : this._srcObject;
	      },
	      set: function(stream) {
	        if ('mozSrcObject' in this) {
	          this.mozSrcObject = stream;
	        } else {
	          // Use _srcObject as a private property for this shim
	          this._srcObject = stream;
	          // TODO: revokeObjectUrl(this.src) when !stream to release resources?
	          this.src = URL.createObjectURL(stream);
	        }
	      }
	    });
	  }
	  // Proxy existing globals
	  getUserMedia = window.navigator && window.navigator.getUserMedia;
	}

	// Attach a media stream to an element.
	attachMediaStream = function(element, stream) {
	  element.srcObject = stream;
	};

	reattachMediaStream = function(to, from) {
	  to.srcObject = from.srcObject;
	};

	if (typeof window === 'undefined' || !window.navigator) {
	  webrtcUtils.log('This does not appear to be a browser');
	  webrtcDetectedBrowser = 'not a browser';
	} else if (navigator.mozGetUserMedia) {
	  webrtcUtils.log('This appears to be Firefox');

	  webrtcDetectedBrowser = 'firefox';

	  // the detected firefox version.
	  webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
	      /Firefox\/([0-9]+)\./, 1);

	  // the minimum firefox version still supported by adapter.
	  webrtcMinimumVersion = 31;

	  // Shim for RTCPeerConnection on older versions.
	  if (!window.RTCPeerConnection) {
	    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
	      if (webrtcDetectedVersion < 38) {
	        // .urls is not supported in FF < 38.
	        // create RTCIceServers with a single url.
	        if (pcConfig && pcConfig.iceServers) {
	          var newIceServers = [];
	          for (var i = 0; i < pcConfig.iceServers.length; i++) {
	            var server = pcConfig.iceServers[i];
	            if (server.hasOwnProperty('urls')) {
	              for (var j = 0; j < server.urls.length; j++) {
	                var newServer = {
	                  url: server.urls[j]
	                };
	                if (server.urls[j].indexOf('turn') === 0) {
	                  newServer.username = server.username;
	                  newServer.credential = server.credential;
	                }
	                newIceServers.push(newServer);
	              }
	            } else {
	              newIceServers.push(pcConfig.iceServers[i]);
	            }
	          }
	          pcConfig.iceServers = newIceServers;
	        }
	      }
	      return new mozRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
	    };
	    window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

	    // wrap static methods. Currently just generateCertificate.
	    if (mozRTCPeerConnection.generateCertificate) {
	      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
	        get: function() {
	          if (arguments.length) {
	            return mozRTCPeerConnection.generateCertificate.apply(null,
	                arguments);
	          } else {
	            return mozRTCPeerConnection.generateCertificate;
	          }
	        }
	      });
	    }

	    window.RTCSessionDescription = mozRTCSessionDescription;
	    window.RTCIceCandidate = mozRTCIceCandidate;
	  }

	  // getUserMedia constraints shim.
	  getUserMedia = function(constraints, onSuccess, onError) {
	    var constraintsToFF37 = function(c) {
	      if (typeof c !== 'object' || c.require) {
	        return c;
	      }
	      var require = [];
	      Object.keys(c).forEach(function(key) {
	        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	          return;
	        }
	        var r = c[key] = (typeof c[key] === 'object') ?
	            c[key] : {ideal: c[key]};
	        if (r.min !== undefined ||
	            r.max !== undefined || r.exact !== undefined) {
	          require.push(key);
	        }
	        if (r.exact !== undefined) {
	          if (typeof r.exact === 'number') {
	            r.min = r.max = r.exact;
	          } else {
	            c[key] = r.exact;
	          }
	          delete r.exact;
	        }
	        if (r.ideal !== undefined) {
	          c.advanced = c.advanced || [];
	          var oc = {};
	          if (typeof r.ideal === 'number') {
	            oc[key] = {min: r.ideal, max: r.ideal};
	          } else {
	            oc[key] = r.ideal;
	          }
	          c.advanced.push(oc);
	          delete r.ideal;
	          if (!Object.keys(r).length) {
	            delete c[key];
	          }
	        }
	      });
	      if (require.length) {
	        c.require = require;
	      }
	      return c;
	    };
	    if (webrtcDetectedVersion < 38) {
	      webrtcUtils.log('spec: ' + JSON.stringify(constraints));
	      if (constraints.audio) {
	        constraints.audio = constraintsToFF37(constraints.audio);
	      }
	      if (constraints.video) {
	        constraints.video = constraintsToFF37(constraints.video);
	      }
	      webrtcUtils.log('ff37: ' + JSON.stringify(constraints));
	    }
	    return navigator.mozGetUserMedia(constraints, onSuccess, onError);
	  };

	  navigator.getUserMedia = getUserMedia;

	  // Shim for mediaDevices on older versions.
	  if (!navigator.mediaDevices) {
	    navigator.mediaDevices = {getUserMedia: requestUserMedia,
	      addEventListener: function() { },
	      removeEventListener: function() { }
	    };
	  }
	  navigator.mediaDevices.enumerateDevices =
	      navigator.mediaDevices.enumerateDevices || function() {
	    return new Promise(function(resolve) {
	      var infos = [
	        {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
	        {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
	      ];
	      resolve(infos);
	    });
	  };

	  if (webrtcDetectedVersion < 41) {
	    // Work around http://bugzil.la/1169665
	    var orgEnumerateDevices =
	        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
	    navigator.mediaDevices.enumerateDevices = function() {
	      return orgEnumerateDevices().then(undefined, function(e) {
	        if (e.name === 'NotFoundError') {
	          return [];
	        }
	        throw e;
	      });
	    };
	  }
	} else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
	  webrtcUtils.log('This appears to be Chrome');

	  webrtcDetectedBrowser = 'chrome';

	  // the detected chrome version.
	  webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
	      /Chrom(e|ium)\/([0-9]+)\./, 2);

	  // the minimum chrome version still supported by adapter.
	  webrtcMinimumVersion = 38;

	  // The RTCPeerConnection object.
	  window.RTCPeerConnection = function(pcConfig, pcConstraints) {
	    // Translate iceTransportPolicy to iceTransports,
	    // see https://code.google.com/p/webrtc/issues/detail?id=4869
	    if (pcConfig && pcConfig.iceTransportPolicy) {
	      pcConfig.iceTransports = pcConfig.iceTransportPolicy;
	    }

	    var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
	    var origGetStats = pc.getStats.bind(pc);
	    pc.getStats = function(selector, successCallback, errorCallback) { // jshint ignore: line
	      var self = this;
	      var args = arguments;

	      // If selector is a function then we are in the old style stats so just
	      // pass back the original getStats format to avoid breaking old users.
	      if (arguments.length > 0 && typeof selector === 'function') {
	        return origGetStats(selector, successCallback);
	      }

	      var fixChromeStats = function(response) {
	        var standardReport = {};
	        var reports = response.result();
	        reports.forEach(function(report) {
	          var standardStats = {
	            id: report.id,
	            timestamp: report.timestamp,
	            type: report.type
	          };
	          report.names().forEach(function(name) {
	            standardStats[name] = report.stat(name);
	          });
	          standardReport[standardStats.id] = standardStats;
	        });

	        return standardReport;
	      };

	      if (arguments.length >= 2) {
	        var successCallbackWrapper = function(response) {
	          args[1](fixChromeStats(response));
	        };

	        return origGetStats.apply(this, [successCallbackWrapper, arguments[0]]);
	      }

	      // promise-support
	      return new Promise(function(resolve, reject) {
	        if (args.length === 1 && selector === null) {
	          origGetStats.apply(self, [
	              function(response) {
	                resolve.apply(null, [fixChromeStats(response)]);
	              }, reject]);
	        } else {
	          origGetStats.apply(self, [resolve, reject]);
	        }
	      });
	    };

	    return pc;
	  };
	  window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

	  // wrap static methods. Currently just generateCertificate.
	  if (webkitRTCPeerConnection.generateCertificate) {
	    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
	      get: function() {
	        if (arguments.length) {
	          return webkitRTCPeerConnection.generateCertificate.apply(null,
	              arguments);
	        } else {
	          return webkitRTCPeerConnection.generateCertificate;
	        }
	      }
	    });
	  }

	  // add promise support
	  ['createOffer', 'createAnswer'].forEach(function(method) {
	    var nativeMethod = webkitRTCPeerConnection.prototype[method];
	    webkitRTCPeerConnection.prototype[method] = function() {
	      var self = this;
	      if (arguments.length < 1 || (arguments.length === 1 &&
	          typeof(arguments[0]) === 'object')) {
	        var opts = arguments.length === 1 ? arguments[0] : undefined;
	        return new Promise(function(resolve, reject) {
	          nativeMethod.apply(self, [resolve, reject, opts]);
	        });
	      } else {
	        return nativeMethod.apply(this, arguments);
	      }
	    };
	  });

	  ['setLocalDescription', 'setRemoteDescription',
	      'addIceCandidate'].forEach(function(method) {
	    var nativeMethod = webkitRTCPeerConnection.prototype[method];
	    webkitRTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      var self = this;
	      return new Promise(function(resolve, reject) {
	        nativeMethod.apply(self, [args[0],
	            function() {
	              resolve();
	              if (args.length >= 2) {
	                args[1].apply(null, []);
	              }
	            },
	            function(err) {
	              reject(err);
	              if (args.length >= 3) {
	                args[2].apply(null, [err]);
	              }
	            }]
	          );
	      });
	    };
	  });

	  // getUserMedia constraints shim.
	  var constraintsToChrome = function(c) {
	    if (typeof c !== 'object' || c.mandatory || c.optional) {
	      return c;
	    }
	    var cc = {};
	    Object.keys(c).forEach(function(key) {
	      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	        return;
	      }
	      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
	      if (r.exact !== undefined && typeof r.exact === 'number') {
	        r.min = r.max = r.exact;
	      }
	      var oldname = function(prefix, name) {
	        if (prefix) {
	          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
	        }
	        return (name === 'deviceId') ? 'sourceId' : name;
	      };
	      if (r.ideal !== undefined) {
	        cc.optional = cc.optional || [];
	        var oc = {};
	        if (typeof r.ideal === 'number') {
	          oc[oldname('min', key)] = r.ideal;
	          cc.optional.push(oc);
	          oc = {};
	          oc[oldname('max', key)] = r.ideal;
	          cc.optional.push(oc);
	        } else {
	          oc[oldname('', key)] = r.ideal;
	          cc.optional.push(oc);
	        }
	      }
	      if (r.exact !== undefined && typeof r.exact !== 'number') {
	        cc.mandatory = cc.mandatory || {};
	        cc.mandatory[oldname('', key)] = r.exact;
	      } else {
	        ['min', 'max'].forEach(function(mix) {
	          if (r[mix] !== undefined) {
	            cc.mandatory = cc.mandatory || {};
	            cc.mandatory[oldname(mix, key)] = r[mix];
	          }
	        });
	      }
	    });
	    if (c.advanced) {
	      cc.optional = (cc.optional || []).concat(c.advanced);
	    }
	    return cc;
	  };

	  getUserMedia = function(constraints, onSuccess, onError) {
	    if (constraints.audio) {
	      constraints.audio = constraintsToChrome(constraints.audio);
	    }
	    if (constraints.video) {
	      constraints.video = constraintsToChrome(constraints.video);
	    }
	    webrtcUtils.log('chrome: ' + JSON.stringify(constraints));
	    return navigator.webkitGetUserMedia(constraints, onSuccess, onError);
	  };
	  navigator.getUserMedia = getUserMedia;

	  if (!navigator.mediaDevices) {
	    navigator.mediaDevices = {getUserMedia: requestUserMedia,
	                              enumerateDevices: function() {
	      return new Promise(function(resolve) {
	        var kinds = {audio: 'audioinput', video: 'videoinput'};
	        return MediaStreamTrack.getSources(function(devices) {
	          resolve(devices.map(function(device) {
	            return {label: device.label,
	                    kind: kinds[device.kind],
	                    deviceId: device.id,
	                    groupId: ''};
	          }));
	        });
	      });
	    }};
	  }

	  // A shim for getUserMedia method on the mediaDevices object.
	  // TODO(KaptenJansson) remove once implemented in Chrome stable.
	  if (!navigator.mediaDevices.getUserMedia) {
	    navigator.mediaDevices.getUserMedia = function(constraints) {
	      return requestUserMedia(constraints);
	    };
	  } else {
	    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
	    // function which returns a Promise, it does not accept spec-style
	    // constraints.
	    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
	        bind(navigator.mediaDevices);
	    navigator.mediaDevices.getUserMedia = function(c) {
	      webrtcUtils.log('spec:   ' + JSON.stringify(c)); // whitespace for alignment
	      c.audio = constraintsToChrome(c.audio);
	      c.video = constraintsToChrome(c.video);
	      webrtcUtils.log('chrome: ' + JSON.stringify(c));
	      return origGetUserMedia(c);
	    };
	  }

	  // Dummy devicechange event methods.
	  // TODO(KaptenJansson) remove once implemented in Chrome stable.
	  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
	    navigator.mediaDevices.addEventListener = function() {
	      webrtcUtils.log('Dummy mediaDevices.addEventListener called.');
	    };
	  }
	  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
	    navigator.mediaDevices.removeEventListener = function() {
	      webrtcUtils.log('Dummy mediaDevices.removeEventListener called.');
	    };
	  }

	  // Attach a media stream to an element.
	  attachMediaStream = function(element, stream) {
	    if (webrtcDetectedVersion >= 43) {
	      element.srcObject = stream;
	    } else if (typeof element.src !== 'undefined') {
	      element.src = URL.createObjectURL(stream);
	    } else {
	      webrtcUtils.log('Error attaching stream to element.');
	    }
	  };
	  reattachMediaStream = function(to, from) {
	    if (webrtcDetectedVersion >= 43) {
	      to.srcObject = from.srcObject;
	    } else {
	      to.src = from.src;
	    }
	  };

	} else if (navigator.mediaDevices && navigator.userAgent.match(
	    /Edge\/(\d+).(\d+)$/)) {
	  webrtcUtils.log('This appears to be Edge');
	  webrtcDetectedBrowser = 'edge';

	  webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
	      /Edge\/(\d+).(\d+)$/, 2);

	  // The minimum version still supported by adapter.
	  // This is the build number for Edge.
	  webrtcMinimumVersion = 10547;

	  if (window.RTCIceGatherer) {
	    // Generate an alphanumeric identifier for cname or mids.
	    // TODO: use UUIDs instead? https://gist.github.com/jed/982883
	    var generateIdentifier = function() {
	      return Math.random().toString(36).substr(2, 10);
	    };

	    // The RTCP CNAME used by all peerconnections from the same JS.
	    var localCName = generateIdentifier();

	    // SDP helpers - to be moved into separate module.
	    var SDPUtils = {};

	    // Splits SDP into lines, dealing with both CRLF and LF.
	    SDPUtils.splitLines = function(blob) {
	      return blob.trim().split('\n').map(function(line) {
	        return line.trim();
	      });
	    };

	    // Splits SDP into sessionpart and mediasections. Ensures CRLF.
	    SDPUtils.splitSections = function(blob) {
	      var parts = blob.split('\r\nm=');
	      return parts.map(function(part, index) {
	        return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
	      });
	    };

	    // Returns lines that start with a certain prefix.
	    SDPUtils.matchPrefix = function(blob, prefix) {
	      return SDPUtils.splitLines(blob).filter(function(line) {
	        return line.indexOf(prefix) === 0;
	      });
	    };

	    // Parses an ICE candidate line. Sample input:
	    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8 rport 55996"
	    SDPUtils.parseCandidate = function(line) {
	      var parts;
	      // Parse both variants.
	      if (line.indexOf('a=candidate:') === 0) {
	        parts = line.substring(12).split(' ');
	      } else {
	        parts = line.substring(10).split(' ');
	      }

	      var candidate = {
	        foundation: parts[0],
	        component: parts[1],
	        protocol: parts[2].toLowerCase(),
	        priority: parseInt(parts[3], 10),
	        ip: parts[4],
	        port: parseInt(parts[5], 10),
	        // skip parts[6] == 'typ'
	        type: parts[7]
	      };

	      for (var i = 8; i < parts.length; i += 2) {
	        switch (parts[i]) {
	          case 'raddr':
	            candidate.relatedAddress = parts[i + 1];
	            break;
	          case 'rport':
	            candidate.relatedPort = parseInt(parts[i + 1], 10);
	            break;
	          case 'tcptype':
	            candidate.tcpType = parts[i + 1];
	            break;
	          default: // Unknown extensions are silently ignored.
	            break;
	        }
	      }
	      return candidate;
	    };

	    // Translates a candidate object into SDP candidate attribute.
	    SDPUtils.writeCandidate = function(candidate) {
	      var sdp = [];
	      sdp.push(candidate.foundation);
	      sdp.push(candidate.component);
	      sdp.push(candidate.protocol.toUpperCase());
	      sdp.push(candidate.priority);
	      sdp.push(candidate.ip);
	      sdp.push(candidate.port);

	      var type = candidate.type;
	      sdp.push('typ');
	      sdp.push(type);
	      if (type !== 'host' && candidate.relatedAddress &&
	          candidate.relatedPort) {
	        sdp.push('raddr');
	        sdp.push(candidate.relatedAddress); // was: relAddr
	        sdp.push('rport');
	        sdp.push(candidate.relatedPort); // was: relPort
	      }
	      if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
	        sdp.push('tcptype');
	        sdp.push(candidate.tcpType);
	      }
	      return 'candidate:' + sdp.join(' ');
	    };

	    // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
	    // a=rtpmap:111 opus/48000/2
	    SDPUtils.parseRtpMap = function(line) {
	      var parts = line.substr(9).split(' ');
	      var parsed = {
	        payloadType: parseInt(parts.shift(), 10) // was: id
	      };

	      parts = parts[0].split('/');

	      parsed.name = parts[0];
	      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
	      parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // was: channels
	      return parsed;
	    };

	    // Generate an a=rtpmap line from RTCRtpCodecCapability or RTCRtpCodecParameters.
	    SDPUtils.writeRtpMap = function(codec) {
	      var pt = codec.payloadType;
	      if (codec.preferredPayloadType !== undefined) {
	        pt = codec.preferredPayloadType;
	      }
	      return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
	          (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
	    };

	    // Parses an ftmp line, returns dictionary. Sample input:
	    // a=fmtp:96 vbr=on;cng=on
	    // Also deals with vbr=on; cng=on
	    SDPUtils.parseFmtp = function(line) {
	      var parsed = {};
	      var kv;
	      var parts = line.substr(line.indexOf(' ') + 1).split(';');
	      for (var j = 0; j < parts.length; j++) {
	        kv = parts[j].trim().split('=');
	        parsed[kv[0].trim()] = kv[1];
	      }
	      return parsed;
	    };

	    // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
	    SDPUtils.writeFtmp = function(codec) {
	      var line = '';
	      var pt = codec.payloadType;
	      if (codec.preferredPayloadType !== undefined) {
	        pt = codec.preferredPayloadType;
	      }
	      if (codec.parameters && codec.parameters.length) {
	        var params = [];
	        Object.keys(codec.parameters).forEach(function(param) {
	          params.push(param + '=' + codec.parameters[param]);
	        });
	        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
	      }
	      return line;
	    };

	    // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
	    // a=rtcp-fb:98 nack rpsi
	    SDPUtils.parseRtcpFb = function(line) {
	      var parts = line.substr(line.indexOf(' ') + 1).split(' ');
	      return {
	        type: parts.shift(),
	        parameter: parts.join(' ')
	      };
	    };
	    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
	    SDPUtils.writeRtcpFb = function(codec) {
	      var lines = '';
	      var pt = codec.payloadType;
	      if (codec.preferredPayloadType !== undefined) {
	        pt = codec.preferredPayloadType;
	      }
	      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
	        // FIXME: special handling for trr-int?
	        codec.rtcpFeedback.forEach(function(fb) {
	          lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + ' ' + fb.parameter +
	              '\r\n';
	        });
	      }
	      return lines;
	    };

	    // Parses an RFC 5576 ssrc media attribute. Sample input:
	    // a=ssrc:3735928559 cname:something
	    SDPUtils.parseSsrcMedia = function(line) {
	      var sp = line.indexOf(' ');
	      var parts = {
	        ssrc: line.substr(7, sp - 7),
	      };
	      var colon = line.indexOf(':', sp);
	      if (colon > -1) {
	        parts.attribute = line.substr(sp + 1, colon - sp - 1);
	        parts.value = line.substr(colon + 1);
	      } else {
	        parts.attribute = line.substr(sp + 1);
	      }
	      return parts;
	    };

	    // Extracts DTLS parameters from SDP media section or sessionpart.
	    // FIXME: for consistency with other functions this should only
	    //   get the fingerprint line as input. See also getIceParameters.
	    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
	      var lines = SDPUtils.splitLines(mediaSection);
	      lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
	      var fpLine = lines.filter(function(line) {
	        return line.indexOf('a=fingerprint:') === 0;
	      })[0].substr(14);
	      // Note: a=setup line is ignored since we use the 'auto' role.
	      var dtlsParameters = {
	        role: 'auto',
	        fingerprints: [{
	          algorithm: fpLine.split(' ')[0],
	          value: fpLine.split(' ')[1]
	        }]
	      };
	      return dtlsParameters;
	    };

	    // Serializes DTLS parameters to SDP.
	    SDPUtils.writeDtlsParameters = function(params, setupType) {
	      var sdp = 'a=setup:' + setupType + '\r\n';
	      params.fingerprints.forEach(function(fp) {
	        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
	      });
	      return sdp;
	    };
	    // Parses ICE information from SDP media section or sessionpart.
	    // FIXME: for consistency with other functions this should only
	    //   get the ice-ufrag and ice-pwd lines as input.
	    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
	      var lines = SDPUtils.splitLines(mediaSection);
	      lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
	      var iceParameters = {
	        usernameFragment: lines.filter(function(line) {
	          return line.indexOf('a=ice-ufrag:') === 0;
	        })[0].substr(12),
	        password: lines.filter(function(line) {
	          return line.indexOf('a=ice-pwd:') === 0;
	        })[0].substr(10)
	      };
	      return iceParameters;
	    };

	    // Serializes ICE parameters to SDP.
	    SDPUtils.writeIceParameters = function(params) {
	      return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
	          'a=ice-pwd:' + params.password + '\r\n';
	    };

	    // Parses the SDP media section and returns RTCRtpParameters.
	    SDPUtils.parseRtpParameters = function(mediaSection) {
	      var description = {
	        codecs: [],
	        headerExtensions: [],
	        fecMechanisms: [],
	        rtcp: []
	      };
	      var lines = SDPUtils.splitLines(mediaSection);
	      var mline = lines[0].split(' ');
	      for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
	        var pt = mline[i];
	        var rtpmapline = SDPUtils.matchPrefix(
	            mediaSection, 'a=rtpmap:' + pt + ' ')[0];
	        if (rtpmapline) {
	          var codec = SDPUtils.parseRtpMap(rtpmapline);
	          var fmtps = SDPUtils.matchPrefix(
	              mediaSection, 'a=fmtp:' + pt + ' ');
	          // Only the first a=fmtp:<pt> is considered.
	          codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
	          codec.rtcpFeedback = SDPUtils.matchPrefix(
	              mediaSection, 'a=rtcp-fb:' + pt + ' ')
	            .map(SDPUtils.parseRtcpFb);
	          description.codecs.push(codec);
	        }
	      }
	      // FIXME: parse headerExtensions, fecMechanisms and rtcp.
	      return description;
	    };

	    // Generates parts of the SDP media section describing the capabilities / parameters.
	    SDPUtils.writeRtpDescription = function(kind, caps) {
	      var sdp = '';

	      // Build the mline.
	      sdp += 'm=' + kind + ' ';
	      sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
	      sdp += ' UDP/TLS/RTP/SAVPF ';
	      sdp += caps.codecs.map(function(codec) {
	        if (codec.preferredPayloadType !== undefined) {
	          return codec.preferredPayloadType;
	        }
	        return codec.payloadType;
	      }).join(' ') + '\r\n';

	      sdp += 'c=IN IP4 0.0.0.0\r\n';
	      sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

	      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
	      caps.codecs.forEach(function(codec) {
	        sdp += SDPUtils.writeRtpMap(codec);
	        sdp += SDPUtils.writeFtmp(codec);
	        sdp += SDPUtils.writeRtcpFb(codec);
	      });
	      // FIXME: add headerExtensions, fecMechanism and rtcp.
	      sdp += 'a=rtcp-mux\r\n';
	      return sdp;
	    };

	    SDPUtils.writeSessionBoilerplate = function() {
	      // FIXME: sess-id should be an NTP timestamp.
	      return 'v=0\r\n' +
	          'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
	          's=-\r\n' +
	          't=0 0\r\n';
	    };

	    SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
	      var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

	      // Map ICE parameters (ufrag, pwd) to SDP.
	      sdp += SDPUtils.writeIceParameters(
	          transceiver.iceGatherer.getLocalParameters());

	      // Map DTLS parameters to SDP.
	      sdp += SDPUtils.writeDtlsParameters(
	          transceiver.dtlsTransport.getLocalParameters(),
	          type === 'offer' ? 'actpass' : 'active');

	      sdp += 'a=mid:' + transceiver.mid + '\r\n';

	      if (transceiver.rtpSender && transceiver.rtpReceiver) {
	        sdp += 'a=sendrecv\r\n';
	      } else if (transceiver.rtpSender) {
	        sdp += 'a=sendonly\r\n';
	      } else if (transceiver.rtpReceiver) {
	        sdp += 'a=recvonly\r\n';
	      } else {
	        sdp += 'a=inactive\r\n';
	      }

	      // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.
	      if (transceiver.rtpSender) {
	        var msid = 'msid:' + stream.id + ' ' +
	            transceiver.rtpSender.track.id + '\r\n';
	        sdp += 'a=' + msid;
	        sdp += 'a=ssrc:' + transceiver.sendSsrc + ' ' + msid;
	      }
	      // FIXME: this should be written by writeRtpDescription.
	      sdp += 'a=ssrc:' + transceiver.sendSsrc + ' cname:' +
	          localCName + '\r\n';
	      return sdp;
	    };

	    // Gets the direction from the mediaSection or the sessionpart.
	    SDPUtils.getDirection = function(mediaSection, sessionpart) {
	      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
	      var lines = SDPUtils.splitLines(mediaSection);
	      for (var i = 0; i < lines.length; i++) {
	        switch (lines[i]) {
	          case 'a=sendrecv':
	          case 'a=sendonly':
	          case 'a=recvonly':
	          case 'a=inactive':
	            return lines[i].substr(2);
	        }
	      }
	      if (sessionpart) {
	        return SDPUtils.getDirection(sessionpart);
	      }
	      return 'sendrecv';
	    };

	    // ORTC defines an RTCIceCandidate object but no constructor.
	    // Not implemented in Edge.
	    if (!window.RTCIceCandidate) {
	      window.RTCIceCandidate = function(args) {
	        return args;
	      };
	    }
	    // ORTC does not have a session description object but
	    // other browsers (i.e. Chrome) that will support both PC and ORTC
	    // in the future might have this defined already.
	    if (!window.RTCSessionDescription) {
	      window.RTCSessionDescription = function(args) {
	        return args;
	      };
	    }

	    window.RTCPeerConnection = function(config) {
	      var self = this;

	      this.onicecandidate = null;
	      this.onaddstream = null;
	      this.onremovestream = null;
	      this.onsignalingstatechange = null;
	      this.oniceconnectionstatechange = null;
	      this.onnegotiationneeded = null;
	      this.ondatachannel = null;

	      this.localStreams = [];
	      this.remoteStreams = [];
	      this.getLocalStreams = function() { return self.localStreams; };
	      this.getRemoteStreams = function() { return self.remoteStreams; };

	      this.localDescription = new RTCSessionDescription({
	        type: '',
	        sdp: ''
	      });
	      this.remoteDescription = new RTCSessionDescription({
	        type: '',
	        sdp: ''
	      });
	      this.signalingState = 'stable';
	      this.iceConnectionState = 'new';

	      this.iceOptions = {
	        gatherPolicy: 'all',
	        iceServers: []
	      };
	      if (config && config.iceTransportPolicy) {
	        switch (config.iceTransportPolicy) {
	          case 'all':
	          case 'relay':
	            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
	            break;
	          case 'none':
	            // FIXME: remove once implementation and spec have added this.
	            throw new TypeError('iceTransportPolicy "none" not supported');
	        }
	      }
	      if (config && config.iceServers) {
	        // Edge does not like
	        // 1) stun:
	        // 2) turn: that does not have all of turn:host:port?transport=udp
	        // 3) an array of urls
	        config.iceServers.forEach(function(server) {
	          if (server.urls) {
	            var url;
	            if (typeof(server.urls) === 'string') {
	              url = server.urls;
	            } else {
	              url = server.urls[0];
	            }
	            if (url.indexOf('transport=udp') !== -1) {
	              self.iceServers.push({
	                username: server.username,
	                credential: server.credential,
	                urls: url
	              });
	            }
	          }
	        });
	      }

	      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
	      // everything that is needed to describe a SDP m-line.
	      this.transceivers = [];

	      // since the iceGatherer is currently created in createOffer but we
	      // must not emit candidates until after setLocalDescription we buffer
	      // them in this array.
	      this._localIceCandidatesBuffer = [];
	    };

	    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
	      var self = this;
	      // FIXME: need to apply ice candidates in a way which is async but in-order
	      this._localIceCandidatesBuffer.forEach(function(event) {
	        if (self.onicecandidate !== null) {
	          self.onicecandidate(event);
	        }
	      });
	      this._localIceCandidatesBuffer = [];
	    };

	    window.RTCPeerConnection.prototype.addStream = function(stream) {
	      // Clone is necessary for local demos mostly, attaching directly
	      // to two different senders does not work (build 10547).
	      this.localStreams.push(stream.clone());
	      this._maybeFireNegotiationNeeded();
	    };

	    window.RTCPeerConnection.prototype.removeStream = function(stream) {
	      var idx = this.localStreams.indexOf(stream);
	      if (idx > -1) {
	        this.localStreams.splice(idx, 1);
	        this._maybeFireNegotiationNeeded();
	      }
	    };

	    // Determines the intersection of local and remote capabilities.
	    window.RTCPeerConnection.prototype._getCommonCapabilities =
	        function(localCapabilities, remoteCapabilities) {
	      var commonCapabilities = {
	        codecs: [],
	        headerExtensions: [],
	        fecMechanisms: []
	      };
	      localCapabilities.codecs.forEach(function(lCodec) {
	        for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
	          var rCodec = remoteCapabilities.codecs[i];
	          if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
	              lCodec.clockRate === rCodec.clockRate &&
	              lCodec.numChannels === rCodec.numChannels) {
	            // push rCodec so we reply with offerer payload type
	            commonCapabilities.codecs.push(rCodec);

	            // FIXME: also need to determine intersection between
	            // .rtcpFeedback and .parameters
	            break;
	          }
	        }
	      });

	      localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
	        for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
	          var rHeaderExtension = remoteCapabilities.headerExtensions[i];
	          if (lHeaderExtension.uri === rHeaderExtension.uri) {
	            commonCapabilities.headerExtensions.push(rHeaderExtension);
	            break;
	          }
	        }
	      });

	      // FIXME: fecMechanisms
	      return commonCapabilities;
	    };

	    // Create ICE gatherer, ICE transport and DTLS transport.
	    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
	        function(mid, sdpMLineIndex) {
	      var self = this;
	      var iceGatherer = new RTCIceGatherer(self.iceOptions);
	      var iceTransport = new RTCIceTransport(iceGatherer);
	      iceGatherer.onlocalcandidate = function(evt) {
	        var event = {};
	        event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

	        var cand = evt.candidate;
	        // Edge emits an empty object for RTCIceCandidateComplete
	        if (!cand || Object.keys(cand).length === 0) {
	          // polyfill since RTCIceGatherer.state is not implemented in Edge 10547 yet.
	          if (iceGatherer.state === undefined) {
	            iceGatherer.state = 'completed';
	          }

	          // Emit a candidate with type endOfCandidates to make the samples work.
	          // Edge requires addIceCandidate with this empty candidate to start checking.
	          // The real solution is to signal end-of-candidates to the other side when
	          // getting the null candidate but some apps (like the samples) don't do that.
	          event.candidate.candidate =
	              'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
	        } else {
	          // RTCIceCandidate doesn't have a component, needs to be added
	          cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
	          event.candidate.candidate = SDPUtils.writeCandidate(cand);
	        }

	        var complete = self.transceivers.every(function(transceiver) {
	          return transceiver.iceGatherer &&
	              transceiver.iceGatherer.state === 'completed';
	        });
	        // FIXME: update .localDescription with candidate and (potentially) end-of-candidates.
	        //     To make this harder, the gatherer might emit candidates before localdescription
	        //     is set. To make things worse, gather.getLocalCandidates still errors in
	        //     Edge 10547 when no candidates have been gathered yet.

	        if (self.onicecandidate !== null) {
	          // Emit candidate if localDescription is set.
	          // Also emits null candidate when all gatherers are complete.
	          if (self.localDescription && self.localDescription.type === '') {
	            self._localIceCandidatesBuffer.push(event);
	            if (complete) {
	              self._localIceCandidatesBuffer.push({});
	            }
	          } else {
	            self.onicecandidate(event);
	            if (complete) {
	              self.onicecandidate({});
	            }
	          }
	        }
	      };
	      iceTransport.onicestatechange = function() {
	        self._updateConnectionState();
	      };

	      var dtlsTransport = new RTCDtlsTransport(iceTransport);
	      dtlsTransport.ondtlsstatechange = function() {
	        self._updateConnectionState();
	      };
	      dtlsTransport.onerror = function() {
	        // onerror does not set state to failed by itself.
	        dtlsTransport.state = 'failed';
	        self._updateConnectionState();
	      };

	      return {
	        iceGatherer: iceGatherer,
	        iceTransport: iceTransport,
	        dtlsTransport: dtlsTransport
	      };
	    };

	    // Start the RTP Sender and Receiver for a transceiver.
	    window.RTCPeerConnection.prototype._transceive = function(transceiver,
	        send, recv) {
	      var params = this._getCommonCapabilities(transceiver.localCapabilities,
	          transceiver.remoteCapabilities);
	      if (send && transceiver.rtpSender) {
	        params.encodings = [{
	          ssrc: transceiver.sendSsrc
	        }];
	        params.rtcp = {
	          cname: localCName,
	          ssrc: transceiver.recvSsrc
	        };
	        transceiver.rtpSender.send(params);
	      }
	      if (recv && transceiver.rtpReceiver) {
	        params.encodings = [{
	          ssrc: transceiver.recvSsrc
	        }];
	        params.rtcp = {
	          cname: transceiver.cname,
	          ssrc: transceiver.sendSsrc
	        };
	        transceiver.rtpReceiver.receive(params);
	      }
	    };

	    window.RTCPeerConnection.prototype.setLocalDescription =
	        function(description) {
	      var self = this;
	      if (description.type === 'offer') {
	        if (!this._pendingOffer) {
	        } else {
	          this.transceivers = this._pendingOffer;
	          delete this._pendingOffer;
	        }
	      } else if (description.type === 'answer') {
	        var sections = SDPUtils.splitSections(self.remoteDescription.sdp);
	        var sessionpart = sections.shift();
	        sections.forEach(function(mediaSection, sdpMLineIndex) {
	          var transceiver = self.transceivers[sdpMLineIndex];
	          var iceGatherer = transceiver.iceGatherer;
	          var iceTransport = transceiver.iceTransport;
	          var dtlsTransport = transceiver.dtlsTransport;
	          var localCapabilities = transceiver.localCapabilities;
	          var remoteCapabilities = transceiver.remoteCapabilities;
	          var rejected = mediaSection.split('\n', 1)[0]
	              .split(' ', 2)[1] === '0';

	          if (!rejected) {
	            var remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
	                sessionpart);
	            iceTransport.start(iceGatherer, remoteIceParameters, 'controlled');

	            var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
	              sessionpart);
	            dtlsTransport.start(remoteDtlsParameters);

	            // Calculate intersection of capabilities.
	            var params = self._getCommonCapabilities(localCapabilities,
	                remoteCapabilities);

	            // Start the RTCRtpSender. The RTCRtpReceiver for this transceiver
	            // has already been started in setRemoteDescription.
	            self._transceive(transceiver,
	                params.codecs.length > 0,
	                false);
	          }
	        });
	      }

	      this.localDescription = description;
	      switch (description.type) {
	        case 'offer':
	          this._updateSignalingState('have-local-offer');
	          break;
	        case 'answer':
	          this._updateSignalingState('stable');
	          break;
	        default:
	          throw new TypeError('unsupported type "' + description.type + '"');
	      }

	      // If a success callback was provided, emit ICE candidates after it has been
	      // executed. Otherwise, emit callback after the Promise is resolved.
	      var hasCallback = arguments.length > 1 &&
	        typeof arguments[1] === 'function';
	      if (hasCallback) {
	        var cb = arguments[1];
	        window.setTimeout(function() {
	          cb();
	          self._emitBufferedCandidates();
	        }, 0);
	      }
	      var p = Promise.resolve();
	      p.then(function() {
	        if (!hasCallback) {
	          window.setTimeout(self._emitBufferedCandidates.bind(self), 0);
	        }
	      });
	      return p;
	    };

	    window.RTCPeerConnection.prototype.setRemoteDescription =
	        function(description) {
	      var self = this;
	      var stream = new MediaStream();
	      var sections = SDPUtils.splitSections(description.sdp);
	      var sessionpart = sections.shift();
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var lines = SDPUtils.splitLines(mediaSection);
	        var mline = lines[0].substr(2).split(' ');
	        var kind = mline[0];
	        var rejected = mline[1] === '0';
	        var direction = SDPUtils.getDirection(mediaSection, sessionpart);

	        var transceiver;
	        var iceGatherer;
	        var iceTransport;
	        var dtlsTransport;
	        var rtpSender;
	        var rtpReceiver;
	        var sendSsrc;
	        var recvSsrc;
	        var localCapabilities;

	        // FIXME: ensure the mediaSection has rtcp-mux set.
	        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
	        var remoteIceParameters;
	        var remoteDtlsParameters;
	        if (!rejected) {
	          remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
	              sessionpart);
	          remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
	              sessionpart);
	        }
	        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0].substr(6);

	        var cname;
	        // Gets the first SSRC. Note that with RTX there might be multiple SSRCs.
	        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
	            .map(function(line) {
	              return SDPUtils.parseSsrcMedia(line);
	            })
	            .filter(function(obj) {
	              return obj.attribute === 'cname';
	            })[0];
	        if (remoteSsrc) {
	          recvSsrc = parseInt(remoteSsrc.ssrc, 10);
	          cname = remoteSsrc.value;
	        }

	        if (description.type === 'offer') {
	          var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);

	          localCapabilities = RTCRtpReceiver.getCapabilities(kind);
	          sendSsrc = (2 * sdpMLineIndex + 2) * 1001;

	          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

	          // FIXME: not correct when there are multiple streams but that is
	          // not currently supported in this shim.
	          stream.addTrack(rtpReceiver.track);

	          // FIXME: look at direction.
	          if (self.localStreams.length > 0 &&
	              self.localStreams[0].getTracks().length >= sdpMLineIndex) {
	            // FIXME: actually more complicated, needs to match types etc
	            var localtrack = self.localStreams[0].getTracks()[sdpMLineIndex];
	            rtpSender = new RTCRtpSender(localtrack, transports.dtlsTransport);
	          }

	          self.transceivers[sdpMLineIndex] = {
	            iceGatherer: transports.iceGatherer,
	            iceTransport: transports.iceTransport,
	            dtlsTransport: transports.dtlsTransport,
	            localCapabilities: localCapabilities,
	            remoteCapabilities: remoteCapabilities,
	            rtpSender: rtpSender,
	            rtpReceiver: rtpReceiver,
	            kind: kind,
	            mid: mid,
	            cname: cname,
	            sendSsrc: sendSsrc,
	            recvSsrc: recvSsrc
	          };
	          // Start the RTCRtpReceiver now. The RTPSender is started in setLocalDescription.
	          self._transceive(self.transceivers[sdpMLineIndex],
	              false,
	              direction === 'sendrecv' || direction === 'sendonly');
	        } else if (description.type === 'answer' && !rejected) {
	          transceiver = self.transceivers[sdpMLineIndex];
	          iceGatherer = transceiver.iceGatherer;
	          iceTransport = transceiver.iceTransport;
	          dtlsTransport = transceiver.dtlsTransport;
	          rtpSender = transceiver.rtpSender;
	          rtpReceiver = transceiver.rtpReceiver;
	          sendSsrc = transceiver.sendSsrc;
	          //recvSsrc = transceiver.recvSsrc;
	          localCapabilities = transceiver.localCapabilities;

	          self.transceivers[sdpMLineIndex].recvSsrc = recvSsrc;
	          self.transceivers[sdpMLineIndex].remoteCapabilities =
	              remoteCapabilities;
	          self.transceivers[sdpMLineIndex].cname = cname;

	          iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
	          dtlsTransport.start(remoteDtlsParameters);

	          self._transceive(transceiver,
	              direction === 'sendrecv' || direction === 'recvonly',
	              direction === 'sendrecv' || direction === 'sendonly');

	          if (rtpReceiver &&
	              (direction === 'sendrecv' || direction === 'sendonly')) {
	            stream.addTrack(rtpReceiver.track);
	          } else {
	            // FIXME: actually the receiver should be created later.
	            delete transceiver.rtpReceiver;
	          }
	        }
	      });

	      this.remoteDescription = description;
	      switch (description.type) {
	        case 'offer':
	          this._updateSignalingState('have-remote-offer');
	          break;
	        case 'answer':
	          this._updateSignalingState('stable');
	          break;
	        default:
	          throw new TypeError('unsupported type "' + description.type + '"');
	      }
	      window.setTimeout(function() {
	        if (self.onaddstream !== null && stream.getTracks().length) {
	          self.remoteStreams.push(stream);
	          window.setTimeout(function() {
	            self.onaddstream({stream: stream});
	          }, 0);
	        }
	      }, 0);
	      if (arguments.length > 1 && typeof arguments[1] === 'function') {
	        window.setTimeout(arguments[1], 0);
	      }
	      return Promise.resolve();
	    };

	    window.RTCPeerConnection.prototype.close = function() {
	      this.transceivers.forEach(function(transceiver) {
	        /* not yet
	        if (transceiver.iceGatherer) {
	          transceiver.iceGatherer.close();
	        }
	        */
	        if (transceiver.iceTransport) {
	          transceiver.iceTransport.stop();
	        }
	        if (transceiver.dtlsTransport) {
	          transceiver.dtlsTransport.stop();
	        }
	        if (transceiver.rtpSender) {
	          transceiver.rtpSender.stop();
	        }
	        if (transceiver.rtpReceiver) {
	          transceiver.rtpReceiver.stop();
	        }
	      });
	      // FIXME: clean up tracks, local streams, remote streams, etc
	      this._updateSignalingState('closed');
	    };

	    // Update the signaling state.
	    window.RTCPeerConnection.prototype._updateSignalingState =
	        function(newState) {
	      this.signalingState = newState;
	      if (this.onsignalingstatechange !== null) {
	        this.onsignalingstatechange();
	      }
	    };

	    // Determine whether to fire the negotiationneeded event.
	    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
	        function() {
	      // Fire away (for now).
	      if (this.onnegotiationneeded !== null) {
	        this.onnegotiationneeded();
	      }
	    };

	    // Update the connection state.
	    window.RTCPeerConnection.prototype._updateConnectionState =
	        function() {
	      var self = this;
	      var newState;
	      var states = {
	        'new': 0,
	        closed: 0,
	        connecting: 0,
	        checking: 0,
	        connected: 0,
	        completed: 0,
	        failed: 0
	      };
	      this.transceivers.forEach(function(transceiver) {
	        states[transceiver.iceTransport.state]++;
	        states[transceiver.dtlsTransport.state]++;
	      });
	      // ICETransport.completed and connected are the same for this purpose.
	      states.connected += states.completed;

	      newState = 'new';
	      if (states.failed > 0) {
	        newState = 'failed';
	      } else if (states.connecting > 0 || states.checking > 0) {
	        newState = 'connecting';
	      } else if (states.disconnected > 0) {
	        newState = 'disconnected';
	      } else if (states.new > 0) {
	        newState = 'new';
	      } else if (states.connecting > 0 || states.completed > 0) {
	        newState = 'connected';
	      }

	      if (newState !== self.iceConnectionState) {
	        self.iceConnectionState = newState;
	        if (this.oniceconnectionstatechange !== null) {
	          this.oniceconnectionstatechange();
	        }
	      }
	    };

	    window.RTCPeerConnection.prototype.createOffer = function() {
	      var self = this;
	      if (this._pendingOffer) {
	        throw new Error('createOffer called while there is a pending offer.');
	      }
	      var offerOptions;
	      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	        offerOptions = arguments[0];
	      } else if (arguments.length === 3) {
	        offerOptions = arguments[2];
	      }

	      var tracks = [];
	      var numAudioTracks = 0;
	      var numVideoTracks = 0;
	      // Default to sendrecv.
	      if (this.localStreams.length) {
	        numAudioTracks = this.localStreams[0].getAudioTracks().length;
	        numVideoTracks = this.localStreams[0].getVideoTracks().length;
	      }
	      // Determine number of audio and video tracks we need to send/recv.
	      if (offerOptions) {
	        // Reject Chrome legacy constraints.
	        if (offerOptions.mandatory || offerOptions.optional) {
	          throw new TypeError(
	              'Legacy mandatory/optional constraints not supported.');
	        }
	        if (offerOptions.offerToReceiveAudio !== undefined) {
	          numAudioTracks = offerOptions.offerToReceiveAudio;
	        }
	        if (offerOptions.offerToReceiveVideo !== undefined) {
	          numVideoTracks = offerOptions.offerToReceiveVideo;
	        }
	      }
	      if (this.localStreams.length) {
	        // Push local streams.
	        this.localStreams[0].getTracks().forEach(function(track) {
	          tracks.push({
	            kind: track.kind,
	            track: track,
	            wantReceive: track.kind === 'audio' ?
	                numAudioTracks > 0 : numVideoTracks > 0
	          });
	          if (track.kind === 'audio') {
	            numAudioTracks--;
	          } else if (track.kind === 'video') {
	            numVideoTracks--;
	          }
	        });
	      }
	      // Create M-lines for recvonly streams.
	      while (numAudioTracks > 0 || numVideoTracks > 0) {
	        if (numAudioTracks > 0) {
	          tracks.push({
	            kind: 'audio',
	            wantReceive: true
	          });
	          numAudioTracks--;
	        }
	        if (numVideoTracks > 0) {
	          tracks.push({
	            kind: 'video',
	            wantReceive: true
	          });
	          numVideoTracks--;
	        }
	      }

	      var sdp = SDPUtils.writeSessionBoilerplate();
	      var transceivers = [];
	      tracks.forEach(function(mline, sdpMLineIndex) {
	        // For each track, create an ice gatherer, ice transport, dtls transport,
	        // potentially rtpsender and rtpreceiver.
	        var track = mline.track;
	        var kind = mline.kind;
	        var mid = generateIdentifier();

	        var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);

	        var localCapabilities = RTCRtpSender.getCapabilities(kind);
	        var rtpSender;
	        var rtpReceiver;

	        // generate an ssrc now, to be used later in rtpSender.send
	        var sendSsrc = (2 * sdpMLineIndex + 1) * 1001;
	        if (track) {
	          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
	        }

	        if (mline.wantReceive) {
	          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
	        }

	        transceivers[sdpMLineIndex] = {
	          iceGatherer: transports.iceGatherer,
	          iceTransport: transports.iceTransport,
	          dtlsTransport: transports.dtlsTransport,
	          localCapabilities: localCapabilities,
	          remoteCapabilities: null,
	          rtpSender: rtpSender,
	          rtpReceiver: rtpReceiver,
	          kind: kind,
	          mid: mid,
	          sendSsrc: sendSsrc,
	          recvSsrc: null
	        };
	        var transceiver = transceivers[sdpMLineIndex];
	        sdp += SDPUtils.writeMediaSection(transceiver,
	            transceiver.localCapabilities, 'offer', self.localStreams[0]);
	      });

	      this._pendingOffer = transceivers;
	      var desc = new RTCSessionDescription({
	        type: 'offer',
	        sdp: sdp
	      });
	      if (arguments.length && typeof arguments[0] === 'function') {
	        window.setTimeout(arguments[0], 0, desc);
	      }
	      return Promise.resolve(desc);
	    };

	    window.RTCPeerConnection.prototype.createAnswer = function() {
	      var self = this;
	      var answerOptions;
	      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
	        answerOptions = arguments[0];
	      } else if (arguments.length === 3) {
	        answerOptions = arguments[2];
	      }

	      var sdp = SDPUtils.writeSessionBoilerplate();
	      this.transceivers.forEach(function(transceiver) {
	        // Calculate intersection of capabilities.
	        var commonCapabilities = self._getCommonCapabilities(
	            transceiver.localCapabilities,
	            transceiver.remoteCapabilities);

	        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
	            'answer', self.localStreams[0]);
	      });

	      var desc = new RTCSessionDescription({
	        type: 'answer',
	        sdp: sdp
	      });
	      if (arguments.length && typeof arguments[0] === 'function') {
	        window.setTimeout(arguments[0], 0, desc);
	      }
	      return Promise.resolve(desc);
	    };

	    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
	      var mLineIndex = candidate.sdpMLineIndex;
	      if (candidate.sdpMid) {
	        for (var i = 0; i < this.transceivers.length; i++) {
	          if (this.transceivers[i].mid === candidate.sdpMid) {
	            mLineIndex = i;
	            break;
	          }
	        }
	      }
	      var transceiver = this.transceivers[mLineIndex];
	      if (transceiver) {
	        var cand = Object.keys(candidate.candidate).length > 0 ?
	            SDPUtils.parseCandidate(candidate.candidate) : {};
	        // Ignore Chrome's invalid candidates since Edge does not like them.
	        if (cand.protocol === 'tcp' && cand.port === 0) {
	          return;
	        }
	        // Ignore RTCP candidates, we assume RTCP-MUX.
	        if (cand.component !== '1') {
	          return;
	        }
	        // A dirty hack to make samples work.
	        if (cand.type === 'endOfCandidates') {
	          cand = {};
	        }
	        transceiver.iceTransport.addRemoteCandidate(cand);
	      }
	      if (arguments.length > 1 && typeof arguments[1] === 'function') {
	        window.setTimeout(arguments[1], 0);
	      }
	      return Promise.resolve();
	    };

	    window.RTCPeerConnection.prototype.getStats = function() {
	      var promises = [];
	      this.transceivers.forEach(function(transceiver) {
	        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
	            'dtlsTransport'].forEach(function(method) {
	          if (transceiver[method]) {
	            promises.push(transceiver[method].getStats());
	          }
	        });
	      });
	      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
	          arguments[1];
	      return new Promise(function(resolve) {
	        var results = {};
	        Promise.all(promises).then(function(res) {
	          res.forEach(function(result) {
	            Object.keys(result).forEach(function(id) {
	              results[id] = result[id];
	            });
	          });
	          if (cb) {
	            window.setTimeout(cb, 0, results);
	          }
	          resolve(results);
	        });
	      });
	    };
	  }
	} else {
	  webrtcUtils.log('Browser does not appear to be WebRTC-capable');
	}

	// Polyfill ontrack on browsers that don't yet have it
	if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
	    window.RTCPeerConnection.prototype)) {
	  Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
	    get: function() { return this._ontrack; },
	    set: function(f) {
	      var self = this;
	      if (this._ontrack) {
	        this.removeEventListener('track', this._ontrack);
	        this.removeEventListener('addstream', this._ontrackpoly);
	      }
	      this.addEventListener('track', this._ontrack = f);
	      this.addEventListener('addstream', this._ontrackpoly = function(e) {
	        if (webrtcDetectedBrowser === 'chrome') {
	          // onaddstream does not fire when a track is added to an existing stream.
	          // but stream.onaddtrack is implemented so we use tht
	          e.stream.addEventListener('addtrack', function(te) {
	            var event = new Event('track');
	            event.track = te.track;
	            event.receiver = {track: te.track};
	            event.streams = [e.stream];
	            self.dispatchEvent(event);
	          });
	        }
	        e.stream.getTracks().forEach(function(track) {
	          var event = new Event('track');
	          event.track = track;
	          event.receiver = {track: track};
	          event.streams = [e.stream];
	          this.dispatchEvent(event);
	        }.bind(this));
	      }.bind(this));
	    }
	  });
	}

	// Returns the result of getUserMedia as a Promise.
	function requestUserMedia(constraints) {
	  return new Promise(function(resolve, reject) {
	    getUserMedia(constraints, resolve, reject);
	  });
	}

	var webrtcTesting = {};
	try {
	  Object.defineProperty(webrtcTesting, 'version', {
	    set: function(version) {
	      webrtcDetectedVersion = version;
	    }
	  });
	} catch (e) {}

	if (true) {
	  var RTCPeerConnection;
	  var RTCIceCandidate;
	  var RTCSessionDescription;
	  if (typeof window !== 'undefined') {
	    RTCPeerConnection = window.RTCPeerConnection;
	    RTCIceCandidate = window.RTCIceCandidate;
	    RTCSessionDescription = window.RTCSessionDescription;
	  }
	  module.exports = {
	    RTCPeerConnection: RTCPeerConnection,
	    RTCIceCandidate: RTCIceCandidate,
	    RTCSessionDescription: RTCSessionDescription,
	    getUserMedia: getUserMedia,
	    attachMediaStream: attachMediaStream,
	    reattachMediaStream: reattachMediaStream,
	    webrtcDetectedBrowser: webrtcDetectedBrowser,
	    webrtcDetectedVersion: webrtcDetectedVersion,
	    webrtcMinimumVersion: webrtcMinimumVersion,
	    webrtcTesting: webrtcTesting,
	    webrtcUtils: webrtcUtils
	    //requestUserMedia: not exposed on purpose.
	    //trace: not exposed on purpose.
	  };
	} else if ((typeof require === 'function') && (typeof define === 'function')) {
	  // Expose objects and functions when RequireJS is doing the loading.
	  define([], function() {
	    return {
	      RTCPeerConnection: window.RTCPeerConnection,
	      RTCIceCandidate: window.RTCIceCandidate,
	      RTCSessionDescription: window.RTCSessionDescription,
	      getUserMedia: getUserMedia,
	      attachMediaStream: attachMediaStream,
	      reattachMediaStream: reattachMediaStream,
	      webrtcDetectedBrowser: webrtcDetectedBrowser,
	      webrtcDetectedVersion: webrtcDetectedVersion,
	      webrtcMinimumVersion: webrtcMinimumVersion,
	      webrtcTesting: webrtcTesting,
	      webrtcUtils: webrtcUtils
	      //requestUserMedia: not exposed on purpose.
	      //trace: not exposed on purpose.
	    };
	  });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	/*global app*/
	"use strict";

	var async = __webpack_require__(218);
	var BaseCollection = __webpack_require__(511);
	var Contact = __webpack_require__(512);

	module.exports = BaseCollection.extend({
	    type: 'contacts',
	    model: Contact,
	    comparator: function comparator(model1, model2) {
	        var show1 = model1.show;
	        var show2 = model2.show;

	        var name1 = model1.displayName.toLowerCase();
	        var name2 = model2.displayName.toLowerCase();

	        if (show1 === show2) {

	            if (name1 === name2) {
	                return 0;
	            }
	            if (name1 < name2) {
	                return -1;
	            }
	            return 1;
	        } else {
	            if (show1 === 'offline') {
	                return 1;
	            }
	            if (show2 === 'offline') {
	                return -1;
	            }

	            if (name1 === name2) {
	                return 0;
	            }
	            if (name1 < name2) {
	                return -1;
	            }

	            return 1;
	        }
	    },
	    initialize: function initialize(model, options) {
	        this.bind('change', this.sort, this);
	    }
	});

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// our base collection

	var Backbone = __webpack_require__(216);

	module.exports = Backbone.Collection.extend({
	    // ###next
	    // returns next item when given an item in the collection
	    next: function next(item, filter, start) {
	        var i = this.indexOf(item),
	            newItem;

	        if (i === -1) {
	            i = 0;
	        } else if (i + 1 >= this.length) {
	            i = 0;
	        } else {
	            i = i + 1;
	        }
	        newItem = this.at(i);
	        if (filter && newItem !== start) {
	            if (!filter(newItem)) {
	                return this.next(newItem, filter, start || item);
	            }
	        }
	        return newItem;
	    },

	    // ###prev
	    // returns previous item when given an item in the collection
	    prev: function prev(item, filter, start) {
	        var i = this.indexOf(item),
	            newItem;
	        if (i === -1) {
	            i = 0;
	        } else if (i === 0) {
	            i = this.length - 1;
	        } else {
	            i = i - 1;
	        }
	        newItem = this.at(i);
	        if (filter && newItem !== start) {
	            if (!filter(newItem)) {
	                return this.prev(newItem, filter, start || item);
	            }
	        }
	        return this.at(i);
	    }
	});

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me, client, URL*/
	"use strict";

	var _ = __webpack_require__(217);
	var crypto = __webpack_require__(513);
	var async = __webpack_require__(218);
	var uuid = __webpack_require__(620);
	var HumanModel = __webpack_require__(505);
	var Resources = __webpack_require__(621);
	var Messages = __webpack_require__(624);
	var Message = __webpack_require__(625);
	var logger = __webpack_require__(630);
	var fetchAvatar = __webpack_require__(623);

	module.exports = HumanModel.define({
	    initialize: function initialize(attrs) {
	        if (attrs.jid) {
	            this.id = attrs.jid;
	        }
	        this.setAvatar(attrs.avatarID);

	        this.resources.bind('add remove reset', this.onResourceListChange, this);
	        this.resources.bind('change', this.onResourceChange, this);

	        this.bind('change:topResource change:lockedResource change:_forceUpdate', this.summarizeResources, this);

	        this.fetchHistory(true);

	        var self = this;
	        client.on('session:started', function () {
	            if (self.messages.length) self.fetchHistory(true, true);
	        });
	    },
	    type: 'contact',
	    props: {
	        id: ['string', true, false],
	        avatarID: ['string', false, ''],
	        groups: ['array', false, []],
	        inRoster: ['bool', true, false],
	        jid: ['string', true],
	        name: ['string', false, ''],
	        owner: ['string', true, ''],
	        storageId: ['string', true, ''],
	        subscription: ['string', false, 'none']
	    },
	    session: {
	        activeContact: ['bool', false, false],
	        avatar: 'string',
	        avatarSource: 'string',
	        lastInteraction: 'date',
	        lastHistoryFetch: 'date',
	        lastSentMessage: 'object',
	        lockedResource: 'string',
	        offlineStatus: ['string', false, ''],
	        topResource: 'string',
	        unreadCount: ['number', false, 0],
	        _forceUpdate: ['number', false, 0],
	        onCall: ['boolean', false, false],
	        persistent: ['bool', false, false],
	        stream: 'object'
	    },
	    derived: {
	        streamUrl: {
	            deps: ['stream'],
	            cache: true,
	            fn: function fn() {
	                if (!this.stream) return '';
	                return URL.createObjectURL(this.stream);
	            }
	        },
	        displayName: {
	            deps: ['name', 'jid'],
	            fn: function fn() {
	                return this.name || this.jid;
	            }
	        },
	        displayUnreadCount: {
	            deps: ['unreadCount'],
	            fn: function fn() {
	                if (this.unreadCount > 0) {
	                    return this.unreadCount.toString();
	                }
	                return '';
	            }
	        },
	        formattedTZO: {
	            deps: ['timezoneOffset'],
	            fn: function fn() {
	                if (!this.timezoneOffset) return '';

	                var localTime = new Date();
	                var localTZO = localTime.getTimezoneOffset();
	                var diff = Math.abs(localTZO % (24 * 60) - this.timezoneOffset % (24 * 60));
	                var remoteTime = new Date(Date.now() + diff * 60000);

	                var day = remoteTime.getDate();
	                var hour = remoteTime.getHours();
	                var minutes = remoteTime.getMinutes();

	                var days = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

	                var dow = days[remoteTime.getDay()];
	                var localDow = days[localTime.getDay()];

	                var m = hour >= 12 ? ' PM' : ' AM';

	                hour = hour % 12;
	                if (hour === 0) {
	                    hour = 12;
	                }

	                var strDay = day < 10 ? '0' + day : day;
	                var strHour = hour < 10 ? '0' + hour : hour;
	                var strMin = minutes < 10 ? '0' + minutes : minutes;

	                if (localDow == dow) {
	                    return strHour + ':' + strMin + m;
	                } else {
	                    return dow + ' ' + strHour + ':' + strMin + m;
	                }
	            }
	        },
	        status: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                var resource = this.resources.get(this.lockedResource) || this.resources.get(this.topResource) || {};
	                return resource.status || '';
	            }
	        },
	        show: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                if (this.resources.length === 0) {
	                    return 'offline';
	                }
	                var resource = this.resources.get(this.lockedResource) || this.resources.get(this.topResource) || {};
	                return resource.show || 'online';
	            }
	        },
	        timezoneOffset: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                var resource = this.resources.get(this.lockedResource) || this.resources.get(this.topResource) || {};
	                return resource.timezoneOffset || undefined;
	            }
	        },
	        idleSince: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                var resource = this.resources.get(this.lockedResource) || this.resources.get(this.topResource) || {};
	                return resource.idleSince || undefined;
	            }
	        },
	        idle: {
	            deps: ['idleSince'],
	            fn: function fn() {
	                return this.idleSince && !isNaN(this.idleSince.valueOf());
	            }
	        },
	        chatState: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                var states = {};
	                this.resources.models.forEach(function (resource) {
	                    states[resource.chatState] = true;
	                });

	                if (states.composing) return 'composing';
	                if (states.paused) return 'paused';
	                if (states.active) return 'active';
	                if (states.inactive) return 'inactive';
	                return 'gone';
	            }
	        },
	        chatStateText: {
	            deps: ['topResource', 'lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                var chatState = this.chatState;
	                if (chatState == 'composing') return this.displayName + ' is composing';else if (chatState == 'paused') return this.displayName + ' stopped writing';else if (chatState == 'gone') return this.displayName + ' is gone';
	                return '';
	            }
	        },
	        supportsReceipts: {
	            deps: ['lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                if (!this.lockedResource) return false;
	                var res = this.resources.get(this.lockedResource);
	                return res.supportsReceipts;
	            }
	        },
	        supportsChatStates: {
	            deps: ['lockedResource', '_forceUpdate'],
	            fn: function fn() {
	                if (!this.lockedResource) return false;
	                var res = this.resources.get(this.lockedResource);
	                return res && res.supportsChatStates;
	            }
	        },
	        hasUnread: {
	            deps: ['unreadCount'],
	            fn: function fn() {
	                return this.unreadCount > 0;
	            }
	        },
	        jingleResources: {
	            deps: ['_forceUpdate'],
	            fn: function fn() {
	                return this.resources.filter(function (res) {
	                    return res.supportsJingleMedia;
	                });
	            }
	        },
	        callable: {
	            deps: ['jingleResources'],
	            fn: function fn() {
	                return !!this.jingleResources.length;
	            }
	        },
	        callObject: {
	            fn: function fn() {
	                return app.calls.where('contact', this);
	            }
	        }
	    },
	    collections: {
	        resources: Resources,
	        messages: Messages
	    },
	    call: function call() {
	        if (this.jingleResources.length) {
	            var peer = this.jingleResources[0];
	            this.callState = 'starting';
	            app.api.call(peer.id);
	        } else {
	            logger.error('no jingle resources for this user');
	        }
	    },
	    setAvatar: function setAvatar(id, type, source) {
	        var self = this;
	        fetchAvatar(this.jid, id, type, source, function (avatar) {
	            if (source == 'vcard' && self.avatarSource == 'pubsub') return;
	            self.avatarID = avatar.id;
	            self.avatar = avatar.uri;
	            self.avatarSource = source;
	            self.save();
	        });
	    },
	    onResourceChange: function onResourceChange() {
	        this.resources.sort();
	        this.topResource = (this.resources.first() || {}).id;
	        this._forceUpdate++;
	    },
	    onResourceListChange: function onResourceListChange() {
	        // Manually propagate change events for properties that
	        // depend on the resources collection.
	        this.resources.sort();

	        var res = this.resources.first();
	        if (res) {
	            this.offlineStatus = '';
	            this.topResource = res.id;
	        } else {
	            this.topResource = undefined;
	        }

	        this.lockedResource = undefined;
	    },
	    addMessage: function addMessage(message, notify) {
	        message.owner = me.jid.bare;

	        if (notify && (!this.activeContact || this.activeContact && !app.state.focused) && message.from.bare === this.jid) {
	            this.unreadCount++;
	            app.notifications.create(this.displayName, {
	                body: message.body,
	                icon: this.avatar,
	                tag: this.jid,
	                onclick: _.bind(app.navigate, app, '/chat/' + encodeURIComponent(this.jid))
	            });
	            if (me.soundEnabled) app.soundManager.play('ding');
	        }

	        var existing = Message.idLookup(message.from[message.type == 'groupchat' ? 'full' : 'bare'], message.mid);
	        if (existing) {
	            existing.set(message);
	            existing.save();
	        } else {
	            this.messages.add(message);
	            message.save();
	        }

	        var newInteraction = new Date(message.created);
	        if (!this.lastInteraction || this.lastInteraction < newInteraction) {
	            this.lastInteraction = newInteraction;
	        }
	    },
	    fetchHistory: function fetchHistory(onlyLastMessages, allInterval) {
	        var self = this;
	        app.whenConnected(function () {
	            var filter = {
	                'with': self.jid,
	                rsm: {
	                    max: !!onlyLastMessages && !allInterval ? 50 : 40
	                }
	            };

	            if (!!onlyLastMessages) {
	                var lastMessage = self.messages.last();
	                if (lastMessage && lastMessage.archivedId) {
	                    filter.rsm.after = lastMessage.archivedId;
	                }
	                if (!allInterval) {
	                    filter.rsm.before = true;

	                    if (self.lastHistoryFetch && !isNaN(self.lastHistoryFetch.valueOf())) {
	                        if (self.lastInteraction > self.lastHistoryFetch) {
	                            filter.start = self.lastInteraction;
	                        } else {
	                            filter.start = self.lastHistoryFetch;
	                        }
	                    } else {
	                        filter.end = new Date(Date.now() + app.timeInterval);
	                    }
	                }
	            } else {
	                var firstMessage = self.messages.first();
	                if (firstMessage && firstMessage.archivedId) {
	                    filter.rsm.before = firstMessage.archivedId;
	                }
	            }

	            client.searchHistory(filter, function (err, res) {
	                if (err) return;

	                self.lastHistoryFetch = new Date(Date.now() + app.timeInterval);

	                var results = res.mamResult.items || [];
	                if (!!onlyLastMessages && !allInterval) results.reverse();
	                results.forEach(function (result) {
	                    var msg = result.forwarded.message;

	                    msg.mid = msg.id;
	                    delete msg.id;

	                    if (!msg.delay) {
	                        msg.delay = result.forwarded.delay;
	                    }

	                    if (msg.replace) {
	                        var original = Message.idLookup(msg.from[msg.type == 'groupchat' ? 'full' : 'bare'], msg.replace);
	                        // Drop the message if editing a previous, but
	                        // keep it if it didn't actually change an
	                        // existing message.
	                        if (original && original.correct(msg)) return;
	                    }

	                    var message = new Message(msg);
	                    message.archivedId = result.id;
	                    message.acked = true;

	                    self.addMessage(message, false);
	                });

	                if (allInterval) {
	                    if (results.length == 40) {
	                        self.fetchHistory(true, true);
	                    } else {
	                        self.trigger('refresh');
	                    }
	                }
	            });
	        });
	    },
	    save: function save() {
	        if (!this.inRoster) return;

	        var storageId = crypto.createHash('sha1').update(this.owner + '/' + this.id).digest('hex');
	        var data = {
	            storageId: storageId,
	            owner: this.owner,
	            jid: this.jid,
	            name: this.name,
	            groups: this.groups,
	            subscription: this.subscription,
	            avatarID: this.avatarID
	        };
	        app.storage.roster.add(data);
	    }
	});

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(308)
	exports.createHash = exports.Hash = __webpack_require__(277)
	exports.createHmac = exports.Hmac = __webpack_require__(305)

	var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(__webpack_require__(514)))
	exports.getHashes = function () {
	  return hashes
	}

	var p = __webpack_require__(515)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync

	var aes = __webpack_require__(516)
	;[
	  'Cipher',
	  'createCipher',
	  'Cipheriv',
	  'createCipheriv',
	  'Decipher',
	  'createDecipher',
	  'Decipheriv',
	  'createDecipheriv',
	  'getCiphers',
	  'listCiphers'
	].forEach(function (key) {
	  exports[key] = aes[key]
	})

	var dh = __webpack_require__(543)
	;[
	  'DiffieHellmanGroup',
	  'createDiffieHellmanGroup',
	  'getDiffieHellman',
	  'createDiffieHellman',
	  'DiffieHellman'
	].forEach(function (key) {
	  exports[key] = dh[key]
	})

	var sign = __webpack_require__(565)
	;[
	  'createSign',
	  'Sign',
	  'createVerify',
	  'Verify'
	].forEach(function (key) {
	  exports[key] = sign[key]
	})

	exports.createECDH = __webpack_require__(613)

	var publicEncrypt = __webpack_require__(614)

	;[
	  'publicEncrypt',
	  'privateEncrypt',
	  'publicDecrypt',
	  'privateDecrypt'
	].forEach(function (key) {
	  exports[key] = publicEncrypt[key]
	})

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	;[
	  'createCredentials'
	].forEach(function (name) {
	  exports[name] = function () {
	    throw new Error([
	      'sorry, ' + name + ' is not implemented yet',
	      'we accept pull requests',
	      'https://github.com/crypto-browserify/crypto-browserify'
	    ].join('\n'))
	  }
	})


/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'
	exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha224',
	  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
	}
	exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha256',
	  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
	}
	exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha384',
	  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
	}
	exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha512',
	  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
	}
	exports['RSA-SHA1'] = {
	  sign: 'rsa',
	  hash: 'sha1',
	  id: new Buffer('3021300906052b0e03021a05000414', 'hex')
	}
	exports['ecdsa-with-SHA1'] = {
	  sign: 'ecdsa',
	  hash: 'sha1',
	  id: new Buffer('', 'hex')
	}

	exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
	  sign: 'dsa',
	  hash: 'sha1',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
	  sign: 'dsa',
	  hash: 'sha224',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
	  sign: 'dsa',
	  hash: 'sha256',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
	  sign: 'dsa',
	  hash: 'sha384',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
	  sign: 'dsa',
	  hash: 'sha512',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-RIPEMD160'] = {
	  sign: 'dsa',
	  hash: 'rmd160',
	  id: new Buffer('', 'hex')
	}
	exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
	  sign: 'rsa',
	  hash: 'rmd160',
	  id: new Buffer('3021300906052b2403020105000414', 'hex')
	}
	exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'md5',
	  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHmac = __webpack_require__(305)
	var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

	exports.pbkdf2 = pbkdf2
	function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
	  if (typeof digest === 'function') {
	    callback = digest
	    digest = undefined
	  }

	  if (typeof callback !== 'function') {
	    throw new Error('No callback provided to pbkdf2')
	  }

	  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	  setTimeout(function () {
	    callback(undefined, result)
	  })
	}

	exports.pbkdf2Sync = pbkdf2Sync
	function pbkdf2Sync (password, salt, iterations, keylen, digest) {
	  if (typeof iterations !== 'number') {
	    throw new TypeError('Iterations not a number')
	  }

	  if (iterations < 0) {
	    throw new TypeError('Bad iterations')
	  }

	  if (typeof keylen !== 'number') {
	    throw new TypeError('Key length not a number')
	  }

	  if (keylen < 0 || keylen > MAX_ALLOC) {
	    throw new TypeError('Bad key length')
	  }

	  digest = digest || 'sha1'

	  if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
	  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')

	  var hLen
	  var l = 1
	  var DK = new Buffer(keylen)
	  var block1 = new Buffer(salt.length + 4)
	  salt.copy(block1, 0, 0, salt.length)

	  var r
	  var T

	  for (var i = 1; i <= l; i++) {
	    block1.writeUInt32BE(i, salt.length)
	    var U = createHmac(digest, password).update(block1).digest()

	    if (!hLen) {
	      hLen = U.length
	      T = new Buffer(hLen)
	      l = Math.ceil(keylen / hLen)
	      r = keylen - (l - 1) * hLen
	    }

	    U.copy(T, 0, 0, hLen)

	    for (var j = 1; j < iterations; j++) {
	      U = createHmac(digest, password).update(U).digest()

	      for (var k = 0; k < hLen; k++) {
	        T[k] ^= U[k]
	      }
	    }

	    var destPos = (i - 1) * hLen
	    var len = (i === l ? r : hLen)
	    T.copy(DK, destPos, 0, len)
	  }

	  return DK
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	var ebtk = __webpack_require__(517)
	var aes = __webpack_require__(518)
	var DES = __webpack_require__(534)
	var desModes = __webpack_require__(542)
	var aesModes = __webpack_require__(521)
	function createCipher (suite, password) {
	  var keyLen, ivLen
	  suite = suite.toLowerCase()
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key
	    ivLen = aesModes[suite].iv
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8
	    ivLen = desModes[suite].iv
	  } else {
	    throw new TypeError('invalid suite type')
	  }
	  var keys = ebtk(password, false, keyLen, ivLen)
	  return createCipheriv(suite, keys.key, keys.iv)
	}
	function createDecipher (suite, password) {
	  var keyLen, ivLen
	  suite = suite.toLowerCase()
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key
	    ivLen = aesModes[suite].iv
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8
	    ivLen = desModes[suite].iv
	  } else {
	    throw new TypeError('invalid suite type')
	  }
	  var keys = ebtk(password, false, keyLen, ivLen)
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	function createCipheriv (suite, key, iv) {
	  suite = suite.toLowerCase()
	  if (aesModes[suite]) {
	    return aes.createCipheriv(suite, key, iv)
	  } else if (desModes[suite]) {
	    return new DES({
	      key: key,
	      iv: iv,
	      mode: suite
	    })
	  } else {
	    throw new TypeError('invalid suite type')
	  }
	}
	function createDecipheriv (suite, key, iv) {
	  suite = suite.toLowerCase()
	  if (aesModes[suite]) {
	    return aes.createDecipheriv(suite, key, iv)
	  } else if (desModes[suite]) {
	    return new DES({
	      key: key,
	      iv: iv,
	      mode: suite,
	      decrypt: true
	    })
	  } else {
	    throw new TypeError('invalid suite type')
	  }
	}
	exports.createCipher = exports.Cipher = createCipher
	exports.createCipheriv = exports.Cipheriv = createCipheriv
	exports.createDecipher = exports.Decipher = createDecipher
	exports.createDecipheriv = exports.Decipheriv = createDecipheriv
	function getCiphers () {
	  return Object.keys(desModes).concat(aes.getCiphers())
	}
	exports.listCiphers = exports.getCiphers = getCiphers


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var md5 = __webpack_require__(278)
	module.exports = EVP_BytesToKey
	function EVP_BytesToKey (password, salt, keyLen, ivLen) {
	  if (!Buffer.isBuffer(password)) {
	    password = new Buffer(password, 'binary')
	  }
	  if (salt && !Buffer.isBuffer(salt)) {
	    salt = new Buffer(salt, 'binary')
	  }
	  keyLen = keyLen / 8
	  ivLen = ivLen || 0
	  var ki = 0
	  var ii = 0
	  var key = new Buffer(keyLen)
	  var iv = new Buffer(ivLen)
	  var addmd = 0
	  var md_buf
	  var i
	  var bufs = []
	  while (true) {
	    if (addmd++ > 0) {
	      bufs.push(md_buf)
	    }
	    bufs.push(password)
	    if (salt) {
	      bufs.push(salt)
	    }
	    md_buf = md5(Buffer.concat(bufs))
	    bufs = []
	    i = 0
	    if (keyLen > 0) {
	      while (true) {
	        if (keyLen === 0) {
	          break
	        }
	        if (i === md_buf.length) {
	          break
	        }
	        key[ki++] = md_buf[i]
	        keyLen--
	        i++
	      }
	    }
	    if (ivLen > 0 && i !== md_buf.length) {
	      while (true) {
	        if (ivLen === 0) {
	          break
	        }
	        if (i === md_buf.length) {
	          break
	        }
	        iv[ii++] = md_buf[i]
	        ivLen--
	        i++
	      }
	    }
	    if (keyLen === 0 && ivLen === 0) {
	      break
	    }
	  }
	  for (i = 0; i < md_buf.length; i++) {
	    md_buf[i] = 0
	  }
	  return {
	    key: key,
	    iv: iv
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	var ciphers = __webpack_require__(519)
	exports.createCipher = exports.Cipher = ciphers.createCipher
	exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
	var deciphers = __webpack_require__(533)
	exports.createDecipher = exports.Decipher = deciphers.createDecipher
	exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
	var modes = __webpack_require__(521)
	function getCiphers () {
	  return Object.keys(modes)
	}
	exports.listCiphers = exports.getCiphers = getCiphers


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(520)
	var Transform = __webpack_require__(289)
	var inherits = __webpack_require__(199)
	var modes = __webpack_require__(521)
	var ebtk = __webpack_require__(517)
	var StreamCipher = __webpack_require__(522)
	var AuthCipher = __webpack_require__(523)
	inherits(Cipher, Transform)
	function Cipher (mode, key, iv) {
	  if (!(this instanceof Cipher)) {
	    return new Cipher(mode, key, iv)
	  }
	  Transform.call(this)
	  this._cache = new Splitter()
	  this._cipher = new aes.AES(key)
	  this._prev = new Buffer(iv.length)
	  iv.copy(this._prev)
	  this._mode = mode
	  this._autopadding = true
	}
	Cipher.prototype._update = function (data) {
	  this._cache.add(data)
	  var chunk
	  var thing
	  var out = []
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk)
	    out.push(thing)
	  }
	  return Buffer.concat(out)
	}
	Cipher.prototype._final = function () {
	  var chunk = this._cache.flush()
	  if (this._autopadding) {
	    chunk = this._mode.encrypt(this, chunk)
	    this._cipher.scrub()
	    return chunk
	  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
	    this._cipher.scrub()
	    throw new Error('data not multiple of block length')
	  }
	}
	Cipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo
	}

	function Splitter () {
	  if (!(this instanceof Splitter)) {
	    return new Splitter()
	  }
	  this.cache = new Buffer('')
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data])
	}

	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16)
	    this.cache = this.cache.slice(16)
	    return out
	  }
	  return null
	}
	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length
	  var padBuff = new Buffer(len)

	  var i = -1
	  while (++i < len) {
	    padBuff.writeUInt8(len, i)
	  }
	  var out = Buffer.concat([this.cache, padBuff])
	  return out
	}
	var modelist = {
	  ECB: __webpack_require__(526),
	  CBC: __webpack_require__(527),
	  CFB: __webpack_require__(528),
	  CFB8: __webpack_require__(529),
	  CFB1: __webpack_require__(530),
	  OFB: __webpack_require__(531),
	  CTR: __webpack_require__(532),
	  GCM: __webpack_require__(532)
	}

	function createCipheriv (suite, password, iv) {
	  var config = modes[suite.toLowerCase()]
	  if (!config) {
	    throw new TypeError('invalid suite type')
	  }
	  if (typeof iv === 'string') {
	    iv = new Buffer(iv)
	  }
	  if (typeof password === 'string') {
	    password = new Buffer(password)
	  }
	  if (password.length !== config.key / 8) {
	    throw new TypeError('invalid key length ' + password.length)
	  }
	  if (iv.length !== config.iv) {
	    throw new TypeError('invalid iv length ' + iv.length)
	  }
	  if (config.type === 'stream') {
	    return new StreamCipher(modelist[config.mode], password, iv)
	  } else if (config.type === 'auth') {
	    return new AuthCipher(modelist[config.mode], password, iv)
	  }
	  return new Cipher(modelist[config.mode], password, iv)
	}
	function createCipher (suite, password) {
	  var config = modes[suite.toLowerCase()]
	  if (!config) {
	    throw new TypeError('invalid suite type')
	  }
	  var keys = ebtk(password, false, config.key, config.iv)
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	exports.createCipheriv = createCipheriv
	exports.createCipher = createCipher

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// based on the aes implimentation in triple sec
	// https://github.com/keybase/triplesec

	// which is in turn based on the one from crypto-js
	// https://code.google.com/p/crypto-js/

	var uint_max = Math.pow(2, 32)
	function fixup_uint32 (x) {
	  var ret, x_pos
	  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
	  return ret
	}
	function scrub_vec (v) {
	  for (var i = 0; i < v.length; v++) {
	    v[i] = 0
	  }
	  return false
	}

	function Global () {
	  this.SBOX = []
	  this.INV_SBOX = []
	  this.SUB_MIX = [[], [], [], []]
	  this.INV_SUB_MIX = [[], [], [], []]
	  this.init()
	  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
	}

	Global.prototype.init = function () {
	  var d, i, sx, t, x, x2, x4, x8, xi, _i
	  d = (function () {
	    var _i, _results
	    _results = []
	    for (i = _i = 0; _i < 256; i = ++_i) {
	      if (i < 128) {
	        _results.push(i << 1)
	      } else {
	        _results.push((i << 1) ^ 0x11b)
	      }
	    }
	    return _results
	  })()
	  x = 0
	  xi = 0
	  for (i = _i = 0; _i < 256; i = ++_i) {
	    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
	    this.SBOX[x] = sx
	    this.INV_SBOX[sx] = x
	    x2 = d[x]
	    x4 = d[x2]
	    x8 = d[x4]
	    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
	    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
	    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
	    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
	    this.SUB_MIX[3][x] = t
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
	    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
	    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
	    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
	    this.INV_SUB_MIX[3][sx] = t
	    if (x === 0) {
	      x = xi = 1
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]]
	      xi ^= d[d[xi]]
	    }
	  }
	  return true
	}

	var G = new Global()

	AES.blockSize = 4 * 4

	AES.prototype.blockSize = AES.blockSize

	AES.keySize = 256 / 8

	AES.prototype.keySize = AES.keySize

	function bufferToArray (buf) {
	  var len = buf.length / 4
	  var out = new Array(len)
	  var i = -1
	  while (++i < len) {
	    out[i] = buf.readUInt32BE(i * 4)
	  }
	  return out
	}
	function AES (key) {
	  this._key = bufferToArray(key)
	  this._doReset()
	}

	AES.prototype._doReset = function () {
	  var invKsRow, keySize, keyWords, ksRow, ksRows, t
	  keyWords = this._key
	  keySize = keyWords.length
	  this._nRounds = keySize + 6
	  ksRows = (this._nRounds + 1) * 4
	  this._keySchedule = []
	  for (ksRow = 0; ksRow < ksRows; ksRow++) {
	    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
	  }
	  this._invKeySchedule = []
	  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	    ksRow = ksRows - invKsRow
	    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
	    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
	  }
	  return true
	}

	AES.prototype.encryptBlock = function (M) {
	  M = bufferToArray(new Buffer(M))
	  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
	  var buf = new Buffer(16)
	  buf.writeUInt32BE(out[0], 0)
	  buf.writeUInt32BE(out[1], 4)
	  buf.writeUInt32BE(out[2], 8)
	  buf.writeUInt32BE(out[3], 12)
	  return buf
	}

	AES.prototype.decryptBlock = function (M) {
	  M = bufferToArray(new Buffer(M))
	  var temp = [M[3], M[1]]
	  M[1] = temp[0]
	  M[3] = temp[1]
	  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
	  var buf = new Buffer(16)
	  buf.writeUInt32BE(out[0], 0)
	  buf.writeUInt32BE(out[3], 4)
	  buf.writeUInt32BE(out[2], 8)
	  buf.writeUInt32BE(out[1], 12)
	  return buf
	}

	AES.prototype.scrub = function () {
	  scrub_vec(this._keySchedule)
	  scrub_vec(this._invKeySchedule)
	  scrub_vec(this._key)
	}

	AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
	  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

	  s0 = M[0] ^ keySchedule[0]
	  s1 = M[1] ^ keySchedule[1]
	  s2 = M[2] ^ keySchedule[2]
	  s3 = M[3] ^ keySchedule[3]
	  ksRow = 4
	  for (var round = 1; round < this._nRounds; round++) {
	    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
	    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
	    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
	    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
	    s0 = t0
	    s1 = t1
	    s2 = t2
	    s3 = t3
	  }
	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
	  return [
	    fixup_uint32(t0),
	    fixup_uint32(t1),
	    fixup_uint32(t2),
	    fixup_uint32(t3)
	  ]
	}

	exports.AES = AES

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 521 */
/***/ function(module, exports) {

	exports['aes-128-ecb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	}
	exports['aes-192-ecb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	}
	exports['aes-256-ecb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	}
	exports['aes-128-cbc'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	}
	exports['aes-192-cbc'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	}
	exports['aes-256-cbc'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	}
	exports['aes128'] = exports['aes-128-cbc']
	exports['aes192'] = exports['aes-192-cbc']
	exports['aes256'] = exports['aes-256-cbc']
	exports['aes-128-cfb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	}
	exports['aes-192-cfb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	}
	exports['aes-256-cfb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	}
	exports['aes-128-cfb8'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB8',
	  type: 'stream'
	}
	exports['aes-192-cfb8'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB8',
	  type: 'stream'
	}
	exports['aes-256-cfb8'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB8',
	  type: 'stream'
	}
	exports['aes-128-cfb1'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB1',
	  type: 'stream'
	}
	exports['aes-192-cfb1'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB1',
	  type: 'stream'
	}
	exports['aes-256-cfb1'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB1',
	  type: 'stream'
	}
	exports['aes-128-ofb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	}
	exports['aes-192-ofb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	}
	exports['aes-256-ofb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	}
	exports['aes-128-ctr'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	}
	exports['aes-192-ctr'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	}
	exports['aes-256-ctr'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	}
	exports['aes-128-gcm'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 12,
	  mode: 'GCM',
	  type: 'auth'
	}
	exports['aes-192-gcm'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 12,
	  mode: 'GCM',
	  type: 'auth'
	}
	exports['aes-256-gcm'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 12,
	  mode: 'GCM',
	  type: 'auth'
	}


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(520)
	var Transform = __webpack_require__(289)
	var inherits = __webpack_require__(199)

	inherits(StreamCipher, Transform)
	module.exports = StreamCipher
	function StreamCipher (mode, key, iv, decrypt) {
	  if (!(this instanceof StreamCipher)) {
	    return new StreamCipher(mode, key, iv)
	  }
	  Transform.call(this)
	  this._cipher = new aes.AES(key)
	  this._prev = new Buffer(iv.length)
	  this._cache = new Buffer('')
	  this._secCache = new Buffer('')
	  this._decrypt = decrypt
	  iv.copy(this._prev)
	  this._mode = mode
	}
	StreamCipher.prototype._update = function (chunk) {
	  return this._mode.encrypt(this, chunk, this._decrypt)
	}
	StreamCipher.prototype._final = function () {
	  this._cipher.scrub()
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(520)
	var Transform = __webpack_require__(289)
	var inherits = __webpack_require__(199)
	var GHASH = __webpack_require__(524)
	var xor = __webpack_require__(525)
	inherits(StreamCipher, Transform)
	module.exports = StreamCipher

	function StreamCipher (mode, key, iv, decrypt) {
	  if (!(this instanceof StreamCipher)) {
	    return new StreamCipher(mode, key, iv)
	  }
	  Transform.call(this)
	  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
	  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
	  this._cipher = new aes.AES(key)
	  this._prev = new Buffer(iv.length)
	  this._cache = new Buffer('')
	  this._secCache = new Buffer('')
	  this._decrypt = decrypt
	  this._alen = 0
	  this._len = 0
	  iv.copy(this._prev)
	  this._mode = mode
	  var h = new Buffer(4)
	  h.fill(0)
	  this._ghash = new GHASH(this._cipher.encryptBlock(h))
	  this._authTag = null
	  this._called = false
	}
	StreamCipher.prototype._update = function (chunk) {
	  if (!this._called && this._alen) {
	    var rump = 16 - (this._alen % 16)
	    if (rump < 16) {
	      rump = new Buffer(rump)
	      rump.fill(0)
	      this._ghash.update(rump)
	    }
	  }
	  this._called = true
	  var out = this._mode.encrypt(this, chunk)
	  if (this._decrypt) {
	    this._ghash.update(chunk)
	  } else {
	    this._ghash.update(out)
	  }
	  this._len += chunk.length
	  return out
	}
	StreamCipher.prototype._final = function () {
	  if (this._decrypt && !this._authTag) {
	    throw new Error('Unsupported state or unable to authenticate data')
	  }
	  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
	  if (this._decrypt) {
	    if (xorTest(tag, this._authTag)) {
	      throw new Error('Unsupported state or unable to authenticate data')
	    }
	  } else {
	    this._authTag = tag
	  }
	  this._cipher.scrub()
	}
	StreamCipher.prototype.getAuthTag = function getAuthTag () {
	  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
	    return this._authTag
	  } else {
	    throw new Error('Attempting to get auth tag in unsupported state')
	  }
	}
	StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
	  if (this._decrypt) {
	    this._authTag = tag
	  } else {
	    throw new Error('Attempting to set auth tag in unsupported state')
	  }
	}
	StreamCipher.prototype.setAAD = function setAAD (buf) {
	  if (!this._called) {
	    this._ghash.update(buf)
	    this._alen += buf.length
	  } else {
	    throw new Error('Attempting to set AAD in unsupported state')
	  }
	}
	function xorTest (a, b) {
	  var out = 0
	  if (a.length !== b.length) {
	    out++
	  }
	  var len = Math.min(a.length, b.length)
	  var i = -1
	  while (++i < len) {
	    out += (a[i] ^ b[i])
	  }
	  return out
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var zeros = new Buffer(16)
	zeros.fill(0)
	module.exports = GHASH
	function GHASH (key) {
	  this.h = key
	  this.state = new Buffer(16)
	  this.state.fill(0)
	  this.cache = new Buffer('')
	}
	// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
	// by Juho Vh-Herttua
	GHASH.prototype.ghash = function (block) {
	  var i = -1
	  while (++i < block.length) {
	    this.state[i] ^= block[i]
	  }
	  this._multiply()
	}

	GHASH.prototype._multiply = function () {
	  var Vi = toArray(this.h)
	  var Zi = [0, 0, 0, 0]
	  var j, xi, lsb_Vi
	  var i = -1
	  while (++i < 128) {
	    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
	    if (xi) {
	      // Z_i+1 = Z_i ^ V_i
	      Zi = xor(Zi, Vi)
	    }

	    // Store the value of LSB(V_i)
	    lsb_Vi = (Vi[3] & 1) !== 0

	    // V_i+1 = V_i >> 1
	    for (j = 3; j > 0; j--) {
	      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
	    }
	    Vi[0] = Vi[0] >>> 1

	    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
	    if (lsb_Vi) {
	      Vi[0] = Vi[0] ^ (0xe1 << 24)
	    }
	  }
	  this.state = fromArray(Zi)
	}
	GHASH.prototype.update = function (buf) {
	  this.cache = Buffer.concat([this.cache, buf])
	  var chunk
	  while (this.cache.length >= 16) {
	    chunk = this.cache.slice(0, 16)
	    this.cache = this.cache.slice(16)
	    this.ghash(chunk)
	  }
	}
	GHASH.prototype.final = function (abl, bl) {
	  if (this.cache.length) {
	    this.ghash(Buffer.concat([this.cache, zeros], 16))
	  }
	  this.ghash(fromArray([
	    0, abl,
	    0, bl
	  ]))
	  return this.state
	}

	function toArray (buf) {
	  return [
	    buf.readUInt32BE(0),
	    buf.readUInt32BE(4),
	    buf.readUInt32BE(8),
	    buf.readUInt32BE(12)
	  ]
	}
	function fromArray (out) {
	  out = out.map(fixup_uint32)
	  var buf = new Buffer(16)
	  buf.writeUInt32BE(out[0], 0)
	  buf.writeUInt32BE(out[1], 4)
	  buf.writeUInt32BE(out[2], 8)
	  buf.writeUInt32BE(out[3], 12)
	  return buf
	}
	var uint_max = Math.pow(2, 32)
	function fixup_uint32 (x) {
	  var ret, x_pos
	  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
	  return ret
	}
	function xor (a, b) {
	  return [
	    a[0] ^ b[0],
	    a[1] ^ b[1],
	    a[2] ^ b[2],
	    a[3] ^ b[3]
	  ]
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
	  var length = Math.min(a.length, b.length)
	  var buffer = new Buffer(length)

	  for (var i = 0; i < length; ++i) {
	    buffer[i] = a[i] ^ b[i]
	  }

	  return buffer
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 526 */
/***/ function(module, exports) {

	exports.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block)
	}
	exports.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block)
	}


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	var xor = __webpack_require__(525)

	exports.encrypt = function (self, block) {
	  var data = xor(block, self._prev)

	  self._prev = self._cipher.encryptBlock(data)
	  return self._prev
	}

	exports.decrypt = function (self, block) {
	  var pad = self._prev

	  self._prev = block
	  var out = self._cipher.decryptBlock(block)

	  return xor(out, pad)
	}


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(525)

	exports.encrypt = function (self, data, decrypt) {
	  var out = new Buffer('')
	  var len

	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev)
	      self._prev = new Buffer('')
	    }

	    if (self._cache.length <= data.length) {
	      len = self._cache.length
	      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
	      data = data.slice(len)
	    } else {
	      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
	      break
	    }
	  }

	  return out
	}
	function encryptStart (self, data, decrypt) {
	  var len = data.length
	  var out = xor(data, self._cache)
	  self._cache = self._cache.slice(len)
	  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
	  return out
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
	  var pad = self._cipher.encryptBlock(self._prev)
	  var out = pad[0] ^ byteParam
	  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
	  return out
	}
	exports.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length
	  var out = new Buffer(len)
	  var i = -1
	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt)
	  }
	  return out
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
	  var pad
	  var i = -1
	  var len = 8
	  var out = 0
	  var bit, value
	  while (++i < len) {
	    pad = self._cipher.encryptBlock(self._prev)
	    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
	    value = pad[0] ^ bit
	    out += ((value & 0x80) >> (i % 8))
	    self._prev = shiftIn(self._prev, decrypt ? bit : value)
	  }
	  return out
	}
	exports.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length
	  var out = new Buffer(len)
	  var i = -1
	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt)
	  }
	  return out
	}
	function shiftIn (buffer, value) {
	  var len = buffer.length
	  var i = -1
	  var out = new Buffer(buffer.length)
	  buffer = Buffer.concat([buffer, new Buffer([value])])
	  while (++i < len) {
	    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
	  }
	  return out
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(525)

	function getBlock (self) {
	  self._prev = self._cipher.encryptBlock(self._prev)
	  return self._prev
	}

	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)])
	  }

	  var pad = self._cache.slice(0, chunk.length)
	  self._cache = self._cache.slice(chunk.length)
	  return xor(chunk, pad)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(525)

	function incr32 (iv) {
	  var len = iv.length
	  var item
	  while (len--) {
	    item = iv.readUInt8(len)
	    if (item === 255) {
	      iv.writeUInt8(0, len)
	    } else {
	      item++
	      iv.writeUInt8(item, len)
	      break
	    }
	  }
	}

	function getBlock (self) {
	  var out = self._cipher.encryptBlock(self._prev)
	  incr32(self._prev)
	  return out
	}

	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)])
	  }
	  var pad = self._cache.slice(0, chunk.length)
	  self._cache = self._cache.slice(chunk.length)
	  return xor(chunk, pad)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(520)
	var Transform = __webpack_require__(289)
	var inherits = __webpack_require__(199)
	var modes = __webpack_require__(521)
	var StreamCipher = __webpack_require__(522)
	var AuthCipher = __webpack_require__(523)
	var ebtk = __webpack_require__(517)

	inherits(Decipher, Transform)
	function Decipher (mode, key, iv) {
	  if (!(this instanceof Decipher)) {
	    return new Decipher(mode, key, iv)
	  }
	  Transform.call(this)
	  this._cache = new Splitter()
	  this._last = void 0
	  this._cipher = new aes.AES(key)
	  this._prev = new Buffer(iv.length)
	  iv.copy(this._prev)
	  this._mode = mode
	  this._autopadding = true
	}
	Decipher.prototype._update = function (data) {
	  this._cache.add(data)
	  var chunk
	  var thing
	  var out = []
	  while ((chunk = this._cache.get(this._autopadding))) {
	    thing = this._mode.decrypt(this, chunk)
	    out.push(thing)
	  }
	  return Buffer.concat(out)
	}
	Decipher.prototype._final = function () {
	  var chunk = this._cache.flush()
	  if (this._autopadding) {
	    return unpad(this._mode.decrypt(this, chunk))
	  } else if (chunk) {
	    throw new Error('data not multiple of block length')
	  }
	}
	Decipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo
	}
	function Splitter () {
	  if (!(this instanceof Splitter)) {
	    return new Splitter()
	  }
	  this.cache = new Buffer('')
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data])
	}

	Splitter.prototype.get = function (autoPadding) {
	  var out
	  if (autoPadding) {
	    if (this.cache.length > 16) {
	      out = this.cache.slice(0, 16)
	      this.cache = this.cache.slice(16)
	      return out
	    }
	  } else {
	    if (this.cache.length >= 16) {
	      out = this.cache.slice(0, 16)
	      this.cache = this.cache.slice(16)
	      return out
	    }
	  }
	  return null
	}
	Splitter.prototype.flush = function () {
	  if (this.cache.length) {
	    return this.cache
	  }
	}
	function unpad (last) {
	  var padded = last[15]
	  var i = -1
	  while (++i < padded) {
	    if (last[(i + (16 - padded))] !== padded) {
	      throw new Error('unable to decrypt data')
	    }
	  }
	  if (padded === 16) {
	    return
	  }
	  return last.slice(0, 16 - padded)
	}

	var modelist = {
	  ECB: __webpack_require__(526),
	  CBC: __webpack_require__(527),
	  CFB: __webpack_require__(528),
	  CFB8: __webpack_require__(529),
	  CFB1: __webpack_require__(530),
	  OFB: __webpack_require__(531),
	  CTR: __webpack_require__(532),
	  GCM: __webpack_require__(532)
	}

	function createDecipheriv (suite, password, iv) {
	  var config = modes[suite.toLowerCase()]
	  if (!config) {
	    throw new TypeError('invalid suite type')
	  }
	  if (typeof iv === 'string') {
	    iv = new Buffer(iv)
	  }
	  if (typeof password === 'string') {
	    password = new Buffer(password)
	  }
	  if (password.length !== config.key / 8) {
	    throw new TypeError('invalid key length ' + password.length)
	  }
	  if (iv.length !== config.iv) {
	    throw new TypeError('invalid iv length ' + iv.length)
	  }
	  if (config.type === 'stream') {
	    return new StreamCipher(modelist[config.mode], password, iv, true)
	  } else if (config.type === 'auth') {
	    return new AuthCipher(modelist[config.mode], password, iv, true)
	  }
	  return new Decipher(modelist[config.mode], password, iv)
	}

	function createDecipher (suite, password) {
	  var config = modes[suite.toLowerCase()]
	  if (!config) {
	    throw new TypeError('invalid suite type')
	  }
	  var keys = ebtk(password, false, config.key, config.iv)
	  return createDecipheriv(suite, keys.key, keys.iv)
	}
	exports.createDecipher = createDecipher
	exports.createDecipheriv = createDecipheriv

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var CipherBase = __webpack_require__(289)
	var des = __webpack_require__(535)
	var inherits = __webpack_require__(199)

	var modes = {
	  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede3': des.EDE,
	  'des-ede-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede': des.EDE,
	  'des-cbc': des.CBC.instantiate(des.DES),
	  'des-ecb': des.DES
	}
	modes.des = modes['des-cbc']
	modes.des3 = modes['des-ede3-cbc']
	module.exports = DES
	inherits(DES, CipherBase)
	function DES (opts) {
	  CipherBase.call(this)
	  var modeName = opts.mode.toLowerCase()
	  var mode = modes[modeName]
	  var type
	  if (opts.decrypt) {
	    type = 'decrypt'
	  } else {
	    type = 'encrypt'
	  }
	  var key = opts.key
	  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
	    key = Buffer.concat([key, key.slice(0, 8)])
	  }
	  var iv = opts.iv
	  this._des = mode.create({
	    key: key,
	    iv: iv,
	    type: type
	  })
	}
	DES.prototype._update = function (data) {
	  return new Buffer(this._des.update(data))
	}
	DES.prototype._final = function () {
	  return new Buffer(this._des.final())
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.utils = __webpack_require__(536);
	exports.Cipher = __webpack_require__(537);
	exports.DES = __webpack_require__(539);
	exports.CBC = __webpack_require__(540);
	exports.EDE = __webpack_require__(541);


/***/ },
/* 536 */
/***/ function(module, exports) {

	'use strict';

	exports.readUInt32BE = function readUInt32BE(bytes, off) {
	  var res =  (bytes[0 + off] << 24) |
	             (bytes[1 + off] << 16) |
	             (bytes[2 + off] << 8) |
	             bytes[3 + off];
	  return res >>> 0;
	};

	exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
	  bytes[0 + off] = value >>> 24;
	  bytes[1 + off] = (value >>> 16) & 0xff;
	  bytes[2 + off] = (value >>> 8) & 0xff;
	  bytes[3 + off] = value & 0xff;
	};

	exports.ip = function ip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	exports.rip = function rip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 0; i < 4; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }
	  for (var i = 4; i < 8; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	exports.pc1 = function pc1(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  // 7, 15, 23, 31, 39, 47, 55, 63
	  // 6, 14, 22, 30, 39, 47, 55, 63
	  // 5, 13, 21, 29, 39, 47, 55, 63
	  // 4, 12, 20, 28
	  for (var i = 7; i >= 5; i--) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outL <<= 1;
	    outL |= (inR >> (j + i)) & 1;
	  }

	  // 1, 9, 17, 25, 33, 41, 49, 57
	  // 2, 10, 18, 26, 34, 42, 50, 58
	  // 3, 11, 19, 27, 35, 43, 51, 59
	  // 36, 44, 52, 60
	  for (var i = 1; i <= 3; i++) {
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outR <<= 1;
	    outR |= (inL >> (j + i)) & 1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	exports.r28shl = function r28shl(num, shift) {
	  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
	};

	var pc2table = [
	  // inL => outL
	  14, 11, 17, 4, 27, 23, 25, 0,
	  13, 22, 7, 18, 5, 9, 16, 24,
	  2, 20, 12, 21, 1, 8, 15, 26,

	  // inR => outR
	  15, 4, 25, 19, 9, 1, 26, 16,
	  5, 11, 23, 8, 12, 7, 17, 0,
	  22, 3, 10, 14, 6, 20, 27, 24
	];

	exports.pc2 = function pc2(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  var len = pc2table.length >>> 1;
	  for (var i = 0; i < len; i++) {
	    outL <<= 1;
	    outL |= (inL >>> pc2table[i]) & 0x1;
	  }
	  for (var i = len; i < pc2table.length; i++) {
	    outR <<= 1;
	    outR |= (inR >>> pc2table[i]) & 0x1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	exports.expand = function expand(r, out, off) {
	  var outL = 0;
	  var outR = 0;

	  outL = ((r & 1) << 5) | (r >>> 27);
	  for (var i = 23; i >= 15; i -= 4) {
	    outL <<= 6;
	    outL |= (r >>> i) & 0x3f;
	  }
	  for (var i = 11; i >= 3; i -= 4) {
	    outR |= (r >>> i) & 0x3f;
	    outR <<= 6;
	  }
	  outR |= ((r & 0x1f) << 1) | (r >>> 31);

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var sTable = [
	  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
	  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
	  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
	  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

	  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
	  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
	  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
	  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

	  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
	  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
	  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
	  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

	  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
	  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
	  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
	  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

	  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
	  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
	  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
	  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

	  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
	  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
	  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
	  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

	  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
	  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
	  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
	  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

	  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
	  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
	  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
	  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
	];

	exports.substitute = function substitute(inL, inR) {
	  var out = 0;
	  for (var i = 0; i < 4; i++) {
	    var b = (inL >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  for (var i = 0; i < 4; i++) {
	    var b = (inR >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[4 * 0x40 + i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  return out >>> 0;
	};

	var permuteTable = [
	  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
	  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
	];

	exports.permute = function permute(num) {
	  var out = 0;
	  for (var i = 0; i < permuteTable.length; i++) {
	    out <<= 1;
	    out |= (num >>> permuteTable[i]) & 0x1;
	  }
	  return out >>> 0;
	};

	exports.padSplit = function padSplit(num, size, group) {
	  var str = num.toString(2);
	  while (str.length < size)
	    str = '0' + str;

	  var out = [];
	  for (var i = 0; i < size; i += group)
	    out.push(str.slice(i, i + group));
	  return out.join(' ');
	};


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assert = __webpack_require__(538);

	function Cipher(options) {
	  this.options = options;

	  this.type = this.options.type;
	  this.blockSize = 8;
	  this._init();

	  this.buffer = new Array(this.blockSize);
	  this.bufferOff = 0;
	}
	module.exports = Cipher;

	Cipher.prototype._init = function _init() {
	  // Might be overrided
	};

	Cipher.prototype.update = function update(data) {
	  if (data.length === 0)
	    return [];

	  if (this.type === 'decrypt')
	    return this._updateDecrypt(data);
	  else
	    return this._updateEncrypt(data);
	};

	Cipher.prototype._buffer = function _buffer(data, off) {
	  // Append data to buffer
	  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
	  for (var i = 0; i < min; i++)
	    this.buffer[this.bufferOff + i] = data[off + i];
	  this.bufferOff += min;

	  // Shift next
	  return min;
	};

	Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
	  this._update(this.buffer, 0, out, off);
	  this.bufferOff = 0;
	  return this.blockSize;
	};

	Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
	  var out = new Array(count * this.blockSize);

	  if (this.bufferOff !== 0) {
	    inputOff += this._buffer(data, inputOff);

	    if (this.bufferOff === this.buffer.length)
	      outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Write blocks
	  var max = data.length - ((data.length - inputOff) % this.blockSize);
	  for (; inputOff < max; inputOff += this.blockSize) {
	    this._update(data, inputOff, out, outputOff);
	    outputOff += this.blockSize;
	  }

	  // Queue rest
	  for (; inputOff < data.length; inputOff++, this.bufferOff++)
	    this.buffer[this.bufferOff] = data[inputOff];

	  return out;
	};

	Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
	  var out = new Array(count * this.blockSize);

	  // TODO(indutny): optimize it, this is far from optimal
	  for (; count > 0; count--) {
	    inputOff += this._buffer(data, inputOff);
	    outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Buffer rest of the input
	  inputOff += this._buffer(data, inputOff);

	  return out;
	};

	Cipher.prototype.final = function final(buffer) {
	  var first;
	  if (buffer)
	    first = this.update(buffer);

	  var last;
	  if (this.type === 'encrypt')
	    last = this._finalEncrypt();
	  else
	    last = this._finalDecrypt();

	  if (first)
	    return first.concat(last);
	  else
	    return last;
	};

	Cipher.prototype._pad = function _pad(buffer, off) {
	  if (off === 0)
	    return false;

	  while (off < buffer.length)
	    buffer[off++] = 0;

	  return true;
	};

	Cipher.prototype._finalEncrypt = function _finalEncrypt() {
	  if (!this._pad(this.buffer, this.bufferOff))
	    return [];

	  var out = new Array(this.blockSize);
	  this._update(this.buffer, 0, out, 0);
	  return out;
	};

	Cipher.prototype._unpad = function _unpad(buffer) {
	  return buffer;
	};

	Cipher.prototype._finalDecrypt = function _finalDecrypt() {
	  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
	  var out = new Array(this.blockSize);
	  this._flushBuffer(out, 0);

	  return this._unpad(out);
	};


/***/ },
/* 538 */
/***/ function(module, exports) {

	module.exports = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assert = __webpack_require__(538);
	var inherits = __webpack_require__(199);

	var des = __webpack_require__(535);
	var utils = des.utils;
	var Cipher = des.Cipher;

	function DESState() {
	  this.tmp = new Array(2);
	  this.keys = null;
	}

	function DES(options) {
	  Cipher.call(this, options);

	  var state = new DESState();
	  this._desState = state;

	  this.deriveKeys(state, options.key);
	}
	inherits(DES, Cipher);
	module.exports = DES;

	DES.create = function create(options) {
	  return new DES(options);
	};

	var shiftTable = [
	  1, 1, 2, 2, 2, 2, 2, 2,
	  1, 2, 2, 2, 2, 2, 2, 1
	];

	DES.prototype.deriveKeys = function deriveKeys(state, key) {
	  state.keys = new Array(16 * 2);

	  assert.equal(key.length, this.blockSize, 'Invalid key length');

	  var kL = utils.readUInt32BE(key, 0);
	  var kR = utils.readUInt32BE(key, 4);

	  utils.pc1(kL, kR, state.tmp, 0);
	  kL = state.tmp[0];
	  kR = state.tmp[1];
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var shift = shiftTable[i >>> 1];
	    kL = utils.r28shl(kL, shift);
	    kR = utils.r28shl(kR, shift);
	    utils.pc2(kL, kR, state.keys, i);
	  }
	};

	DES.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._desState;

	  var l = utils.readUInt32BE(inp, inOff);
	  var r = utils.readUInt32BE(inp, inOff + 4);

	  // Initial Permutation
	  utils.ip(l, r, state.tmp, 0);
	  l = state.tmp[0];
	  r = state.tmp[1];

	  if (this.type === 'encrypt')
	    this._encrypt(state, l, r, state.tmp, 0);
	  else
	    this._decrypt(state, l, r, state.tmp, 0);

	  l = state.tmp[0];
	  r = state.tmp[1];

	  utils.writeUInt32BE(out, l, outOff);
	  utils.writeUInt32BE(out, r, outOff + 4);
	};

	DES.prototype._pad = function _pad(buffer, off) {
	  var value = buffer.length - off;
	  for (var i = off; i < buffer.length; i++)
	    buffer[i] = value;

	  return true;
	};

	DES.prototype._unpad = function _unpad(buffer) {
	  var pad = buffer[buffer.length - 1];
	  for (var i = buffer.length - pad; i < buffer.length; i++)
	    assert.equal(buffer[i], pad);

	  return buffer.slice(0, buffer.length - pad);
	};

	DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
	  var l = lStart;
	  var r = rStart;

	  // Apply f() x16 times
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils.expand(r, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils.substitute(keyL, keyR);
	    var f = utils.permute(s);

	    var t = r;
	    r = (l ^ f) >>> 0;
	    l = t;
	  }

	  // Reverse Initial Permutation
	  utils.rip(r, l, out, off);
	};

	DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
	  var l = rStart;
	  var r = lStart;

	  // Apply f() x16 times
	  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils.expand(l, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils.substitute(keyL, keyR);
	    var f = utils.permute(s);

	    var t = l;
	    l = (r ^ f) >>> 0;
	    r = t;
	  }

	  // Reverse Initial Permutation
	  utils.rip(l, r, out, off);
	};


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assert = __webpack_require__(538);
	var inherits = __webpack_require__(199);

	var proto = {};

	function CBCState(iv) {
	  assert.equal(iv.length, 8, 'Invalid IV length');

	  this.iv = new Array(8);
	  for (var i = 0; i < this.iv.length; i++)
	    this.iv[i] = iv[i];
	}

	function instantiate(Base) {
	  function CBC(options) {
	    Base.call(this, options);
	    this._cbcInit();
	  }
	  inherits(CBC, Base);

	  var keys = Object.keys(proto);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    CBC.prototype[key] = proto[key];
	  }

	  CBC.create = function create(options) {
	    return new CBC(options);
	  };

	  return CBC;
	}

	exports.instantiate = instantiate;

	proto._cbcInit = function _cbcInit() {
	  var state = new CBCState(this.options.iv);
	  this._cbcState = state;
	};

	proto._update = function _update(inp, inOff, out, outOff) {
	  var state = this._cbcState;
	  var superProto = this.constructor.super_.prototype;

	  var iv = state.iv;
	  if (this.type === 'encrypt') {
	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] ^= inp[inOff + i];

	    superProto._update.call(this, iv, 0, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = out[outOff + i];
	  } else {
	    superProto._update.call(this, inp, inOff, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      out[outOff + i] ^= iv[i];

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = inp[inOff + i];
	  }
	};


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assert = __webpack_require__(538);
	var inherits = __webpack_require__(199);

	var des = __webpack_require__(535);
	var Cipher = des.Cipher;
	var DES = des.DES;

	function EDEState(type, key) {
	  assert.equal(key.length, 24, 'Invalid key length');

	  var k1 = key.slice(0, 8);
	  var k2 = key.slice(8, 16);
	  var k3 = key.slice(16, 24);

	  if (type === 'encrypt') {
	    this.ciphers = [
	      DES.create({ type: 'encrypt', key: k1 }),
	      DES.create({ type: 'decrypt', key: k2 }),
	      DES.create({ type: 'encrypt', key: k3 })
	    ];
	  } else {
	    this.ciphers = [
	      DES.create({ type: 'decrypt', key: k3 }),
	      DES.create({ type: 'encrypt', key: k2 }),
	      DES.create({ type: 'decrypt', key: k1 })
	    ];
	  }
	}

	function EDE(options) {
	  Cipher.call(this, options);

	  var state = new EDEState(this.type, this.options.key);
	  this._edeState = state;
	}
	inherits(EDE, Cipher);

	module.exports = EDE;

	EDE.create = function create(options) {
	  return new EDE(options);
	};

	EDE.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._edeState;

	  state.ciphers[0]._update(inp, inOff, out, outOff);
	  state.ciphers[1]._update(out, outOff, out, outOff);
	  state.ciphers[2]._update(out, outOff, out, outOff);
	};

	EDE.prototype._pad = DES.prototype._pad;
	EDE.prototype._unpad = DES.prototype._unpad;


/***/ },
/* 542 */
/***/ function(module, exports) {

	exports['des-ecb'] = {
	  key: 8,
	  iv: 0
	}
	exports['des-cbc'] = exports.des = {
	  key: 8,
	  iv: 8
	}
	exports['des-ede3-cbc'] = exports.des3 = {
	  key: 24,
	  iv: 8
	}
	exports['des-ede3'] = {
	  key: 24,
	  iv: 0
	}
	exports['des-ede-cbc'] = {
	  key: 16,
	  iv: 8
	}
	exports['des-ede'] = {
	  key: 16,
	  iv: 0
	}


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(544);
	var primes = __webpack_require__(563);

	var DH = __webpack_require__(564);

	function getDiffieHellman(mod) {
	  var prime = new Buffer(primes[mod].prime, 'hex');
	  var gen = new Buffer(primes[mod].gen, 'hex');

	  return new DH(prime, gen);
	}

	function createDiffieHellman(prime, enc, generator, genc) {
	  if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
	    genc = generator;
	    generator = enc;
	    enc = undefined;
	  }

	  enc = enc || 'binary';
	  genc = genc || 'binary';
	  generator = generator || new Buffer([2]);

	  if (!Buffer.isBuffer(generator)) {
	    generator = new Buffer(generator, genc);
	  }

	  if (typeof prime === 'number') {
	    return new DH(generatePrime(prime, generator), generator, true);
	  }

	  if (!Buffer.isBuffer(prime)) {
	    prime = new Buffer(prime, enc);
	  }

	  return new DH(prime, generator, true);
	}

	exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
	exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	var randomBytes = __webpack_require__(308);
	module.exports = findPrime;
	findPrime.simpleSieve = simpleSieve;
	findPrime.fermatTest = fermatTest;
	var BN = __webpack_require__(545);
	var TWENTYFOUR = new BN(24);
	var MillerRabin = __webpack_require__(546);
	var millerRabin = new MillerRabin();
	var ONE = new BN(1);
	var TWO = new BN(2);
	var FIVE = new BN(5);
	var SIXTEEN = new BN(16);
	var EIGHT = new BN(8);
	var TEN = new BN(10);
	var THREE = new BN(3);
	var SEVEN = new BN(7);
	var ELEVEN = new BN(11);
	var FOUR = new BN(4);
	var TWELVE = new BN(12);
	var primes = null;

	function _getPrimes() {
	  if (primes !== null)
	    return primes;

	  var limit = 0x100000;
	  var res = [];
	  res[0] = 2;
	  for (var i = 1, k = 3; k < limit; k += 2) {
	    var sqrt = Math.ceil(Math.sqrt(k));
	    for (var j = 0; j < i && res[j] <= sqrt; j++)
	      if (k % res[j] === 0)
	        break;

	    if (i !== j && res[j] <= sqrt)
	      continue;

	    res[i++] = k;
	  }
	  primes = res;
	  return res;
	}

	function simpleSieve(p) {
	  var primes = _getPrimes();

	  for (var i = 0; i < primes.length; i++)
	    if (p.modn(primes[i]) === 0) {
	      if (p.cmpn(primes[i]) === 0) {
	        return true;
	      } else {
	        return false;
	      }
	    }

	  return true;
	}

	function fermatTest(p) {
	  var red = BN.mont(p);
	  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
	}

	function findPrime(bits, gen) {
	  if (bits < 16) {
	    // this is what openssl does
	    if (gen === 2 || gen === 5) {
	      return new BN([0x8c, 0x7b]);
	    } else {
	      return new BN([0x8c, 0x27]);
	    }
	  }
	  gen = new BN(gen);

	  var num, n2;

	  while (true) {
	    num = new BN(randomBytes(Math.ceil(bits / 8)));
	    while (num.bitLength() > bits) {
	      num.ishrn(1);
	    }
	    if (num.isEven()) {
	      num.iadd(ONE);
	    }
	    if (!num.testn(1)) {
	      num.iadd(TWO);
	    }
	    if (!gen.cmp(TWO)) {
	      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
	        num.iadd(FOUR);
	      }
	    } else if (!gen.cmp(FIVE)) {
	      while (num.mod(TEN).cmp(THREE)) {
	        num.iadd(FOUR);
	      }
	    }
	    n2 = num.shrn(1);
	    if (simpleSieve(n2) && simpleSieve(num) &&
	      fermatTest(n2) && fermatTest(num) &&
	      millerRabin.test(n2) && millerRabin.test(num)) {
	      return num;
	    }
	  }

	}


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {

	'use strict';

	// Utils

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	// Could use `inherits` module, but don't want to move from single file
	// architecture yet.
	function inherits(ctor, superCtor) {
	  ctor.super_ = superCtor;
	  var TempCtor = function () {};
	  TempCtor.prototype = superCtor.prototype;
	  ctor.prototype = new TempCtor();
	  ctor.prototype.constructor = ctor;
	}

	// BN

	function BN(number, base, endian) {
	  // May be `new BN(bn)` ?
	  if (number !== null &&
	      typeof number === 'object' &&
	      Array.isArray(number.words)) {
	    return number;
	  }

	  this.negative = 0;
	  this.words = null;
	  this.length = 0;

	  // Reduction context
	  this.red = null;

	  if (number !== null) {
	    if (base === 'le' || base === 'be') {
	      endian = base;
	      base = 10;
	    }

	    this._init(number || 0, base || 10, endian || 'be');
	  }
	}
	if (typeof module === 'object')
	  module.exports = BN;
	else
	  exports.BN = BN;

	BN.BN = BN;
	BN.wordSize = 26;

	BN.max = function max(left, right) {
	  if (left.cmp(right) > 0)
	    return left;
	  else
	    return right;
	};

	BN.min = function min(left, right) {
	  if (left.cmp(right) < 0)
	    return left;
	  else
	    return right;
	};

	BN.prototype._init = function init(number, base, endian) {
	  if (typeof number === 'number') {
	    return this._initNumber(number, base, endian);
	  } else if (typeof number === 'object') {
	    return this._initArray(number, base, endian);
	  }
	  if (base === 'hex')
	    base = 16;
	  assert(base === (base | 0) && base >= 2 && base <= 36);

	  number = number.toString().replace(/\s+/g, '');
	  var start = 0;
	  if (number[0] === '-')
	    start++;

	  if (base === 16)
	    this._parseHex(number, start);
	  else
	    this._parseBase(number, base, start);

	  if (number[0] === '-')
	    this.negative = 1;

	  this.strip();

	  if (endian !== 'le')
	    return;

	  this._initArray(this.toArray(), base, endian);
	};

	BN.prototype._initNumber = function _initNumber(number, base, endian) {
	  if (number < 0) {
	    this.negative = 1;
	    number = -number;
	  }
	  if (number < 0x4000000) {
	    this.words = [ number & 0x3ffffff ];
	    this.length = 1;
	  } else if (number < 0x10000000000000) {
	    this.words = [
	      number & 0x3ffffff,
	      (number / 0x4000000) & 0x3ffffff
	    ];
	    this.length = 2;
	  } else {
	    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	    this.words = [
	      number & 0x3ffffff,
	      (number / 0x4000000) & 0x3ffffff,
	      1
	    ];
	    this.length = 3;
	  }

	  if (endian !== 'le')
	    return;

	  // Reverse the bytes
	  this._initArray(this.toArray(), base, endian);
	};

	BN.prototype._initArray = function _initArray(number, base, endian) {
	  // Perhaps a Uint8Array
	  assert(typeof number.length === 'number');
	  if (number.length <= 0) {
	    this.words = [ 0 ];
	    this.length = 1;
	    return this;
	  }

	  this.length = Math.ceil(number.length / 3);
	  this.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    this.words[i] = 0;

	  var off = 0;
	  if (endian === 'be') {
	    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
	      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	  } else if (endian === 'le') {
	    for (var i = 0, j = 0; i < number.length; i += 3) {
	      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	  }
	  return this.strip();
	};

	function parseHex(str, start, end) {
	  var r = 0;
	  var len = Math.min(str.length, end);
	  for (var i = start; i < len; i++) {
	    var c = str.charCodeAt(i) - 48;

	    r <<= 4;

	    // 'a' - 'f'
	    if (c >= 49 && c <= 54)
	      r |= c - 49 + 0xa;

	    // 'A' - 'F'
	    else if (c >= 17 && c <= 22)
	      r |= c - 17 + 0xa;

	    // '0' - '9'
	    else
	      r |= c & 0xf;
	  }
	  return r;
	}

	BN.prototype._parseHex = function _parseHex(number, start) {
	  // Create possibly bigger array to ensure that it fits the number
	  this.length = Math.ceil((number.length - start) / 6);
	  this.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    this.words[i] = 0;

	  // Scan 24-bit chunks and add them to the number
	  var off = 0;
	  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
	    var w = parseHex(number, i, i + 6);
	    this.words[j] |= (w << off) & 0x3ffffff;
	    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    off += 24;
	    if (off >= 26) {
	      off -= 26;
	      j++;
	    }
	  }
	  if (i + 6 !== start) {
	    var w = parseHex(number, start, i + 6);
	    this.words[j] |= (w << off) & 0x3ffffff;
	    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	  }
	  this.strip();
	};

	function parseBase(str, start, end, mul) {
	  var r = 0;
	  var len = Math.min(str.length, end);
	  for (var i = start; i < len; i++) {
	    var c = str.charCodeAt(i) - 48;

	    r *= mul;

	    // 'a'
	    if (c >= 49)
	      r += c - 49 + 0xa;

	    // 'A'
	    else if (c >= 17)
	      r += c - 17 + 0xa;

	    // '0' - '9'
	    else
	      r += c;
	  }
	  return r;
	}

	BN.prototype._parseBase = function _parseBase(number, base, start) {
	  // Initialize as zero
	  this.words = [ 0 ];
	  this.length = 1;

	  // Find length of limb in base
	  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
	    limbLen++;
	  limbLen--;
	  limbPow = (limbPow / base) | 0;

	  var total = number.length - start;
	  var mod = total % limbLen;
	  var end = Math.min(total, total - mod) + start;

	  var word = 0;
	  for (var i = start; i < end; i += limbLen) {
	    word = parseBase(number, i, i + limbLen, base);

	    this.imuln(limbPow);
	    if (this.words[0] + word < 0x4000000)
	      this.words[0] += word;
	    else
	      this._iaddn(word);
	  }

	  if (mod !== 0) {
	    var pow = 1;
	    var word = parseBase(number, i, number.length, base);

	    for (var i = 0; i < mod; i++)
	      pow *= base;
	    this.imuln(pow);
	    if (this.words[0] + word < 0x4000000)
	      this.words[0] += word;
	    else
	      this._iaddn(word);
	  }
	};

	BN.prototype.copy = function copy(dest) {
	  dest.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    dest.words[i] = this.words[i];
	  dest.length = this.length;
	  dest.negative = this.negative;
	  dest.red = this.red;
	};

	BN.prototype.clone = function clone() {
	  var r = new BN(null);
	  this.copy(r);
	  return r;
	};

	// Remove leading `0` from `this`
	BN.prototype.strip = function strip() {
	  while (this.length > 1 && this.words[this.length - 1] === 0)
	    this.length--;
	  return this._normSign();
	};

	BN.prototype._normSign = function _normSign() {
	  // -0 = 0
	  if (this.length === 1 && this.words[0] === 0)
	    this.negative = 0;
	  return this;
	};

	BN.prototype.inspect = function inspect() {
	  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	};

	/*

	var zeros = [];
	var groupSizes = [];
	var groupBases = [];

	var s = '';
	var i = -1;
	while (++i < BN.wordSize) {
	  zeros[i] = s;
	  s += '0';
	}
	groupSizes[0] = 0;
	groupSizes[1] = 0;
	groupBases[0] = 0;
	groupBases[1] = 0;
	var base = 2 - 1;
	while (++base < 36 + 1) {
	  var groupSize = 0;
	  var groupBase = 1;
	  while (groupBase < (1 << BN.wordSize) / base) {
	    groupBase *= base;
	    groupSize += 1;
	  }
	  groupSizes[base] = groupSize;
	  groupBases[base] = groupBase;
	}

	*/

	var zeros = [
	  '',
	  '0',
	  '00',
	  '000',
	  '0000',
	  '00000',
	  '000000',
	  '0000000',
	  '00000000',
	  '000000000',
	  '0000000000',
	  '00000000000',
	  '000000000000',
	  '0000000000000',
	  '00000000000000',
	  '000000000000000',
	  '0000000000000000',
	  '00000000000000000',
	  '000000000000000000',
	  '0000000000000000000',
	  '00000000000000000000',
	  '000000000000000000000',
	  '0000000000000000000000',
	  '00000000000000000000000',
	  '000000000000000000000000',
	  '0000000000000000000000000'
	];

	var groupSizes = [
	  0, 0,
	  25, 16, 12, 11, 10, 9, 8,
	  8, 7, 7, 7, 7, 6, 6,
	  6, 6, 6, 6, 6, 5, 5,
	  5, 5, 5, 5, 5, 5, 5,
	  5, 5, 5, 5, 5, 5, 5
	];

	var groupBases = [
	  0, 0,
	  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	];

	BN.prototype.toString = function toString(base, padding) {
	  base = base || 10;
	  var padding = padding | 0 || 1;
	  if (base === 16 || base === 'hex') {
	    var out = '';
	    var off = 0;
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = this.words[i];
	      var word = (((w << off) | carry) & 0xffffff).toString(16);
	      carry = (w >>> (24 - off)) & 0xffffff;
	      if (carry !== 0 || i !== this.length - 1)
	        out = zeros[6 - word.length] + word + out;
	      else
	        out = word + out;
	      off += 2;
	      if (off >= 26) {
	        off -= 26;
	        i--;
	      }
	    }
	    if (carry !== 0)
	      out = carry.toString(16) + out;
	    while (out.length % padding !== 0)
	      out = '0' + out;
	    if (this.negative !== 0)
	      out = '-' + out;
	    return out;
	  } else if (base === (base | 0) && base >= 2 && base <= 36) {
	    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	    var groupSize = groupSizes[base];
	    // var groupBase = Math.pow(base, groupSize);
	    var groupBase = groupBases[base];
	    var out = '';
	    var c = this.clone();
	    c.negative = 0;
	    while (c.cmpn(0) !== 0) {
	      var r = c.modn(groupBase).toString(base);
	      c = c.idivn(groupBase);

	      if (c.cmpn(0) !== 0)
	        out = zeros[groupSize - r.length] + r + out;
	      else
	        out = r + out;
	    }
	    if (this.cmpn(0) === 0)
	      out = '0' + out;
	    while (out.length % padding !== 0)
	      out = '0' + out;
	    if (this.negative !== 0)
	      out = '-' + out;
	    return out;
	  } else {
	    assert(false, 'Base should be between 2 and 36');
	  }
	};

	BN.prototype.toNumber = function toNumber() {
	  assert(this.bitLength() <= 53, 'Number can only safely store up to 53 bits');
	  return parseInt(this.toString(), 10);
	};

	BN.prototype.toJSON = function toJSON() {
	  return this.toString(16);
	};

	BN.prototype.toArray = function toArray(endian, length) {
	  var byteLength = this.byteLength();
	  var reqLength = length || byteLength;
	  assert(byteLength <= reqLength, 'byte array longer than desired length');

	  this.strip();
	  var littleEndian = endian === 'le';
	  var res = new Array(reqLength);

	  var q = this.clone();
	  if (!littleEndian) {
	    // Assume big-endian
	    for (var i = 0; i < reqLength - byteLength; i++)
	      res[i] = 0;
	    for (i = 0; q.cmpn(0) !== 0; i++) {
	      var b = q.andln(0xff);
	      q.iushrn(8);

	      res[reqLength - i - 1] = b;
	    }
	  } else {
	    for (var i = 0; q.cmpn(0) !== 0; i++) {
	      var b = q.andln(0xff);
	      q.iushrn(8);

	      res[i] = b;
	    }
	    for (; i < reqLength; i++)
	      res[i] = 0;
	  }

	  return res;
	};

	if (Math.clz32) {
	  BN.prototype._countBits = function _countBits(w) {
	    return 32 - Math.clz32(w);
	  };
	} else {
	  BN.prototype._countBits = function _countBits(w) {
	    var t = w;
	    var r = 0;
	    if (t >= 0x1000) {
	      r += 13;
	      t >>>= 13;
	    }
	    if (t >= 0x40) {
	      r += 7;
	      t >>>= 7;
	    }
	    if (t >= 0x8) {
	      r += 4;
	      t >>>= 4;
	    }
	    if (t >= 0x02) {
	      r += 2;
	      t >>>= 2;
	    }
	    return r + t;
	  };
	}

	BN.prototype._zeroBits = function _zeroBits(w) {
	  // Short-cut
	  if (w === 0)
	    return 26;

	  var t = w;
	  var r = 0;
	  if ((t & 0x1fff) === 0) {
	    r += 13;
	    t >>>= 13;
	  }
	  if ((t & 0x7f) === 0) {
	    r += 7;
	    t >>>= 7;
	  }
	  if ((t & 0xf) === 0) {
	    r += 4;
	    t >>>= 4;
	  }
	  if ((t & 0x3) === 0) {
	    r += 2;
	    t >>>= 2;
	  }
	  if ((t & 0x1) === 0)
	    r++;
	  return r;
	};

	// Return number of used bits in a BN
	BN.prototype.bitLength = function bitLength() {
	  var hi = 0;
	  var w = this.words[this.length - 1];
	  var hi = this._countBits(w);
	  return (this.length - 1) * 26 + hi;
	};

	function toBitArray(num) {
	  var w = new Array(num.bitLength());

	  for (var bit = 0; bit < w.length; bit++) {
	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	  }

	  return w;
	}

	// Number of trailing zero bits
	BN.prototype.zeroBits = function zeroBits() {
	  if (this.cmpn(0) === 0)
	    return 0;

	  var r = 0;
	  for (var i = 0; i < this.length; i++) {
	    var b = this._zeroBits(this.words[i]);
	    r += b;
	    if (b !== 26)
	      break;
	  }
	  return r;
	};

	BN.prototype.byteLength = function byteLength() {
	  return Math.ceil(this.bitLength() / 8);
	};

	BN.prototype.isNeg = function isNeg() {
	  return this.negative !== 0;
	};

	// Return negative clone of `this`
	BN.prototype.neg = function neg() {
	  if (this.cmpn(0) === 0)
	    return this.clone();

	  var r = this.clone();
	  r.negative = this.negative ^ 1;
	  return r;
	};

	BN.prototype.ineg = function ineg() {
	  this.negative ^= 1;
	  return this;
	};

	// Or `num` with `this` in-place
	BN.prototype.iuor = function iuor(num) {
	  while (this.length < num.length)
	    this.words[this.length++] = 0;

	  for (var i = 0; i < num.length; i++)
	    this.words[i] = this.words[i] | num.words[i];

	  return this.strip();
	};

	BN.prototype.ior = function ior(num) {
	  assert((this.negative | num.negative) === 0);
	  return this.iuor(num);
	};


	// Or `num` with `this`
	BN.prototype.or = function or(num) {
	  if (this.length > num.length)
	    return this.clone().ior(num);
	  else
	    return num.clone().ior(this);
	};

	BN.prototype.uor = function uor(num) {
	  if (this.length > num.length)
	    return this.clone().iuor(num);
	  else
	    return num.clone().iuor(this);
	};


	// And `num` with `this` in-place
	BN.prototype.iuand = function iuand(num) {
	  // b = min-length(num, this)
	  var b;
	  if (this.length > num.length)
	    b = num;
	  else
	    b = this;

	  for (var i = 0; i < b.length; i++)
	    this.words[i] = this.words[i] & num.words[i];

	  this.length = b.length;

	  return this.strip();
	};

	BN.prototype.iand = function iand(num) {
	  assert((this.negative | num.negative) === 0);
	  return this.iuand(num);
	};


	// And `num` with `this`
	BN.prototype.and = function and(num) {
	  if (this.length > num.length)
	    return this.clone().iand(num);
	  else
	    return num.clone().iand(this);
	};

	BN.prototype.uand = function uand(num) {
	  if (this.length > num.length)
	    return this.clone().iuand(num);
	  else
	    return num.clone().iuand(this);
	};


	// Xor `num` with `this` in-place
	BN.prototype.iuxor = function iuxor(num) {
	  // a.length > b.length
	  var a;
	  var b;
	  if (this.length > num.length) {
	    a = this;
	    b = num;
	  } else {
	    a = num;
	    b = this;
	  }

	  for (var i = 0; i < b.length; i++)
	    this.words[i] = a.words[i] ^ b.words[i];

	  if (this !== a)
	    for (; i < a.length; i++)
	      this.words[i] = a.words[i];

	  this.length = a.length;

	  return this.strip();
	};

	BN.prototype.ixor = function ixor(num) {
	  assert((this.negative | num.negative) === 0);
	  return this.iuxor(num);
	};


	// Xor `num` with `this`
	BN.prototype.xor = function xor(num) {
	  if (this.length > num.length)
	    return this.clone().ixor(num);
	  else
	    return num.clone().ixor(this);
	};

	BN.prototype.uxor = function uxor(num) {
	  if (this.length > num.length)
	    return this.clone().iuxor(num);
	  else
	    return num.clone().iuxor(this);
	};


	// Set `bit` of `this`
	BN.prototype.setn = function setn(bit, val) {
	  assert(typeof bit === 'number' && bit >= 0);

	  var off = (bit / 26) | 0;
	  var wbit = bit % 26;

	  while (this.length <= off)
	    this.words[this.length++] = 0;

	  if (val)
	    this.words[off] = this.words[off] | (1 << wbit);
	  else
	    this.words[off] = this.words[off] & ~(1 << wbit);

	  return this.strip();
	};


	// Add `num` to `this` in-place
	BN.prototype.iadd = function iadd(num) {
	  // negative + positive
	  if (this.negative !== 0 && num.negative === 0) {
	    this.negative = 0;
	    var r = this.isub(num);
	    this.negative ^= 1;
	    return this._normSign();

	  // positive + negative
	  } else if (this.negative === 0 && num.negative !== 0) {
	    num.negative = 0;
	    var r = this.isub(num);
	    num.negative = 1;
	    return r._normSign();
	  }

	  // a.length > b.length
	  var a;
	  var b;
	  if (this.length > num.length) {
	    a = this;
	    b = num;
	  } else {
	    a = num;
	    b = this;
	  }

	  var carry = 0;
	  for (var i = 0; i < b.length; i++) {
	    var r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	    this.words[i] = r & 0x3ffffff;
	    carry = r >>> 26;
	  }
	  for (; carry !== 0 && i < a.length; i++) {
	    var r = (a.words[i] | 0) + carry;
	    this.words[i] = r & 0x3ffffff;
	    carry = r >>> 26;
	  }

	  this.length = a.length;
	  if (carry !== 0) {
	    this.words[this.length] = carry;
	    this.length++;
	  // Copy the rest of the words
	  } else if (a !== this) {
	    for (; i < a.length; i++)
	      this.words[i] = a.words[i];
	  }

	  return this;
	};

	// Add `num` to `this`
	BN.prototype.add = function add(num) {
	  if (num.negative !== 0 && this.negative === 0) {
	    num.negative = 0;
	    var res = this.sub(num);
	    num.negative ^= 1;
	    return res;
	  } else if (num.negative === 0 && this.negative !== 0) {
	    this.negative = 0;
	    var res = num.sub(this);
	    this.negative = 1;
	    return res;
	  }

	  if (this.length > num.length)
	    return this.clone().iadd(num);
	  else
	    return num.clone().iadd(this);
	};

	// Subtract `num` from `this` in-place
	BN.prototype.isub = function isub(num) {
	  // this - (-num) = this + num
	  if (num.negative !== 0) {
	    num.negative = 0;
	    var r = this.iadd(num);
	    num.negative = 1;
	    return r._normSign();

	  // -this - num = -(this + num)
	  } else if (this.negative !== 0) {
	    this.negative = 0;
	    this.iadd(num);
	    this.negative = 1;
	    return this._normSign();
	  }

	  // At this point both numbers are positive
	  var cmp = this.cmp(num);

	  // Optimization - zeroify
	  if (cmp === 0) {
	    this.negative = 0;
	    this.length = 1;
	    this.words[0] = 0;
	    return this;
	  }

	  // a > b
	  var a;
	  var b;
	  if (cmp > 0) {
	    a = this;
	    b = num;
	  } else {
	    a = num;
	    b = this;
	  }

	  var carry = 0;
	  for (var i = 0; i < b.length; i++) {
	    var r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	    carry = r >> 26;
	    this.words[i] = r & 0x3ffffff;
	  }
	  for (; carry !== 0 && i < a.length; i++) {
	    var r = (a.words[i] | 0) + carry;
	    carry = r >> 26;
	    this.words[i] = r & 0x3ffffff;
	  }

	  // Copy rest of the words
	  if (carry === 0 && i < a.length && a !== this)
	    for (; i < a.length; i++)
	      this.words[i] = a.words[i];
	  this.length = Math.max(this.length, i);

	  if (a !== this)
	    this.negative = 1;

	  return this.strip();
	};

	// Subtract `num` from `this`
	BN.prototype.sub = function sub(num) {
	  return this.clone().isub(num);
	};

	/*
	// NOTE: This could be potentionally used to generate loop-less multiplications
	function _genCombMulTo(alen, blen) {
	  var len = alen + blen - 1;
	  var src = [
	    'var a = self.words;',
	    'var b = num.words;',
	    'var o = out.words;',
	    'var c = 0;',
	    'var lo;',
	    'var mid;',
	    'var hi;'
	  ];
	  for (var i = 0; i < alen; i++) {
	    src.push('var a' + i + ' = a[' + i + '] | 0;');
	    src.push('var al' + i + ' = a' + i + ' & 0x1fff;');
	    src.push('var ah' + i + ' = a' + i + ' >>> 13;');
	  }
	  for (var i = 0; i < blen; i++) {
	    src.push('var b' + i + ' = b[' + i + '] | 0;');
	    src.push('var bl' + i + ' = b' + i + ' & 0x1fff;');
	    src.push('var bh' + i + ' = b' + i + ' >>> 13;');
	  }
	  src.push('');
	  src.push('out.length = ' + len + ';');

	  for (var k = 0; k < len; k++) {
	    var minJ = Math.max(0, k - alen + 1);
	    var maxJ = Math.min(k, blen - 1);

	    src.push('\/* k = ' + k + ' *\/');
	    src.push('var w' + k + ' = c;');
	    src.push('c = 0;');
	    for (var j = minJ; j <= maxJ; j++) {
	      var i = k - j;

	      src.push('lo = Math.imul(al' + i + ', bl' + j + ');');
	      src.push('mid = Math.imul(al' + i + ', bh' + j + ');');
	      src.push('mid = (mid + Math.imul(ah' + i + ', bl' + j + ')) | 0;');
	      src.push('hi = Math.imul(ah' + i + ', bh' + j + ');');

	      src.push('w' + k + ' = (w' + k + ' + lo) | 0;');
	      src.push('w' + k + ' = (w' + k + ' + ((mid & 0x1fff) << 13)) | 0;');
	      src.push('c = (c + hi) | 0;');
	      src.push('c = (c + (mid >>> 13)) | 0;');
	      src.push('c = (c + (w' + k + ' >>> 26)) | 0;');
	      src.push('w' + k + ' &= 0x3ffffff;');
	    }
	  }
	  // Store in separate step for better memory access
	  for (var k = 0; k < len; k++)
	    src.push('o[' + k + '] = w' + k + ';');
	  src.push('if (c !== 0) {',
	           '  o[' + k + '] = c;',
	           '  out.length++;',
	           '}',
	           'return out;');

	  return src.join('\n');
	}
	console.log(_genCombMulTo(10, 10));
	*/

	function smallMulTo(self, num, out) {
	  out.negative = num.negative ^ self.negative;
	  var len = (self.length + num.length) | 0;
	  out.length = len;
	  len = (len - 1) | 0;

	  // Peel one iteration (compiler can't do it, because of code complexity)
	  var a = self.words[0] | 0;
	  var b = num.words[0] | 0;
	  var r = a * b;

	  var lo = r & 0x3ffffff;
	  var carry = (r / 0x4000000) | 0;
	  out.words[0] = lo;

	  for (var k = 1; k < len; k++) {
	    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	    // note that ncarry could be >= 0x3ffffff
	    var ncarry = carry >>> 26;
	    var rword = carry & 0x3ffffff;
	    var maxJ = Math.min(k, num.length - 1);
	    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	      var i = (k - j) | 0;
	      var a = self.words[i] | 0;
	      var b = num.words[j] | 0;
	      var r = a * b;

	      var lo = r & 0x3ffffff;
	      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	      lo = (lo + rword) | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = (ncarry + (lo >>> 26)) | 0;
	    }
	    out.words[k] = rword | 0;
	    carry = ncarry | 0;
	  }
	  if (carry !== 0) {
	    out.words[k] = carry | 0;
	  } else {
	    out.length--;
	  }

	  return out.strip();
	}

	// TODO(indutny): it may be reasonable to omit it for users who don't need
	// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	// multiplication (like elliptic secp256k1).
	var comb10MulTo = function comb10MulTo(self, num, out) {
	  var a = self.words;
	  var b = num.words;
	  var o = out.words;
	  var c = 0;
	  var lo;
	  var mid;
	  var hi;
	  var a0 = a[0] | 0;
	  var al0 = a0 & 0x1fff;
	  var ah0 = a0 >>> 13;
	  var a1 = a[1] | 0;
	  var al1 = a1 & 0x1fff;
	  var ah1 = a1 >>> 13;
	  var a2 = a[2] | 0;
	  var al2 = a2 & 0x1fff;
	  var ah2 = a2 >>> 13;
	  var a3 = a[3] | 0;
	  var al3 = a3 & 0x1fff;
	  var ah3 = a3 >>> 13;
	  var a4 = a[4] | 0;
	  var al4 = a4 & 0x1fff;
	  var ah4 = a4 >>> 13;
	  var a5 = a[5] | 0;
	  var al5 = a5 & 0x1fff;
	  var ah5 = a5 >>> 13;
	  var a6 = a[6] | 0;
	  var al6 = a6 & 0x1fff;
	  var ah6 = a6 >>> 13;
	  var a7 = a[7] | 0;
	  var al7 = a7 & 0x1fff;
	  var ah7 = a7 >>> 13;
	  var a8 = a[8] | 0;
	  var al8 = a8 & 0x1fff;
	  var ah8 = a8 >>> 13;
	  var a9 = a[9] | 0;
	  var al9 = a9 & 0x1fff;
	  var ah9 = a9 >>> 13;
	  var b0 = b[0] | 0;
	  var bl0 = b0 & 0x1fff;
	  var bh0 = b0 >>> 13;
	  var b1 = b[1] | 0;
	  var bl1 = b1 & 0x1fff;
	  var bh1 = b1 >>> 13;
	  var b2 = b[2] | 0;
	  var bl2 = b2 & 0x1fff;
	  var bh2 = b2 >>> 13;
	  var b3 = b[3] | 0;
	  var bl3 = b3 & 0x1fff;
	  var bh3 = b3 >>> 13;
	  var b4 = b[4] | 0;
	  var bl4 = b4 & 0x1fff;
	  var bh4 = b4 >>> 13;
	  var b5 = b[5] | 0;
	  var bl5 = b5 & 0x1fff;
	  var bh5 = b5 >>> 13;
	  var b6 = b[6] | 0;
	  var bl6 = b6 & 0x1fff;
	  var bh6 = b6 >>> 13;
	  var b7 = b[7] | 0;
	  var bl7 = b7 & 0x1fff;
	  var bh7 = b7 >>> 13;
	  var b8 = b[8] | 0;
	  var bl8 = b8 & 0x1fff;
	  var bh8 = b8 >>> 13;
	  var b9 = b[9] | 0;
	  var bl9 = b9 & 0x1fff;
	  var bh9 = b9 >>> 13;

	  out.length = 19;
	  /* k = 0 */
	  var w0 = c;
	  c = 0;
	  lo = Math.imul(al0, bl0);
	  mid = Math.imul(al0, bh0);
	  mid = (mid + Math.imul(ah0, bl0)) | 0;
	  hi = Math.imul(ah0, bh0);
	  w0 = (w0 + lo) | 0;
	  w0 = (w0 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w0 >>> 26)) | 0;
	  w0 &= 0x3ffffff;
	  /* k = 1 */
	  var w1 = c;
	  c = 0;
	  lo = Math.imul(al1, bl0);
	  mid = Math.imul(al1, bh0);
	  mid = (mid + Math.imul(ah1, bl0)) | 0;
	  hi = Math.imul(ah1, bh0);
	  w1 = (w1 + lo) | 0;
	  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w1 >>> 26)) | 0;
	  w1 &= 0x3ffffff;
	  lo = Math.imul(al0, bl1);
	  mid = Math.imul(al0, bh1);
	  mid = (mid + Math.imul(ah0, bl1)) | 0;
	  hi = Math.imul(ah0, bh1);
	  w1 = (w1 + lo) | 0;
	  w1 = (w1 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w1 >>> 26)) | 0;
	  w1 &= 0x3ffffff;
	  /* k = 2 */
	  var w2 = c;
	  c = 0;
	  lo = Math.imul(al2, bl0);
	  mid = Math.imul(al2, bh0);
	  mid = (mid + Math.imul(ah2, bl0)) | 0;
	  hi = Math.imul(ah2, bh0);
	  w2 = (w2 + lo) | 0;
	  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w2 >>> 26)) | 0;
	  w2 &= 0x3ffffff;
	  lo = Math.imul(al1, bl1);
	  mid = Math.imul(al1, bh1);
	  mid = (mid + Math.imul(ah1, bl1)) | 0;
	  hi = Math.imul(ah1, bh1);
	  w2 = (w2 + lo) | 0;
	  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w2 >>> 26)) | 0;
	  w2 &= 0x3ffffff;
	  lo = Math.imul(al0, bl2);
	  mid = Math.imul(al0, bh2);
	  mid = (mid + Math.imul(ah0, bl2)) | 0;
	  hi = Math.imul(ah0, bh2);
	  w2 = (w2 + lo) | 0;
	  w2 = (w2 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w2 >>> 26)) | 0;
	  w2 &= 0x3ffffff;
	  /* k = 3 */
	  var w3 = c;
	  c = 0;
	  lo = Math.imul(al3, bl0);
	  mid = Math.imul(al3, bh0);
	  mid = (mid + Math.imul(ah3, bl0)) | 0;
	  hi = Math.imul(ah3, bh0);
	  w3 = (w3 + lo) | 0;
	  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w3 >>> 26)) | 0;
	  w3 &= 0x3ffffff;
	  lo = Math.imul(al2, bl1);
	  mid = Math.imul(al2, bh1);
	  mid = (mid + Math.imul(ah2, bl1)) | 0;
	  hi = Math.imul(ah2, bh1);
	  w3 = (w3 + lo) | 0;
	  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w3 >>> 26)) | 0;
	  w3 &= 0x3ffffff;
	  lo = Math.imul(al1, bl2);
	  mid = Math.imul(al1, bh2);
	  mid = (mid + Math.imul(ah1, bl2)) | 0;
	  hi = Math.imul(ah1, bh2);
	  w3 = (w3 + lo) | 0;
	  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w3 >>> 26)) | 0;
	  w3 &= 0x3ffffff;
	  lo = Math.imul(al0, bl3);
	  mid = Math.imul(al0, bh3);
	  mid = (mid + Math.imul(ah0, bl3)) | 0;
	  hi = Math.imul(ah0, bh3);
	  w3 = (w3 + lo) | 0;
	  w3 = (w3 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w3 >>> 26)) | 0;
	  w3 &= 0x3ffffff;
	  /* k = 4 */
	  var w4 = c;
	  c = 0;
	  lo = Math.imul(al4, bl0);
	  mid = Math.imul(al4, bh0);
	  mid = (mid + Math.imul(ah4, bl0)) | 0;
	  hi = Math.imul(ah4, bh0);
	  w4 = (w4 + lo) | 0;
	  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;
	  lo = Math.imul(al3, bl1);
	  mid = Math.imul(al3, bh1);
	  mid = (mid + Math.imul(ah3, bl1)) | 0;
	  hi = Math.imul(ah3, bh1);
	  w4 = (w4 + lo) | 0;
	  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;
	  lo = Math.imul(al2, bl2);
	  mid = Math.imul(al2, bh2);
	  mid = (mid + Math.imul(ah2, bl2)) | 0;
	  hi = Math.imul(ah2, bh2);
	  w4 = (w4 + lo) | 0;
	  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;
	  lo = Math.imul(al1, bl3);
	  mid = Math.imul(al1, bh3);
	  mid = (mid + Math.imul(ah1, bl3)) | 0;
	  hi = Math.imul(ah1, bh3);
	  w4 = (w4 + lo) | 0;
	  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;
	  lo = Math.imul(al0, bl4);
	  mid = Math.imul(al0, bh4);
	  mid = (mid + Math.imul(ah0, bl4)) | 0;
	  hi = Math.imul(ah0, bh4);
	  w4 = (w4 + lo) | 0;
	  w4 = (w4 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;
	  /* k = 5 */
	  var w5 = c;
	  c = 0;
	  lo = Math.imul(al5, bl0);
	  mid = Math.imul(al5, bh0);
	  mid = (mid + Math.imul(ah5, bl0)) | 0;
	  hi = Math.imul(ah5, bh0);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  lo = Math.imul(al4, bl1);
	  mid = Math.imul(al4, bh1);
	  mid = (mid + Math.imul(ah4, bl1)) | 0;
	  hi = Math.imul(ah4, bh1);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  lo = Math.imul(al3, bl2);
	  mid = Math.imul(al3, bh2);
	  mid = (mid + Math.imul(ah3, bl2)) | 0;
	  hi = Math.imul(ah3, bh2);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  lo = Math.imul(al2, bl3);
	  mid = Math.imul(al2, bh3);
	  mid = (mid + Math.imul(ah2, bl3)) | 0;
	  hi = Math.imul(ah2, bh3);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  lo = Math.imul(al1, bl4);
	  mid = Math.imul(al1, bh4);
	  mid = (mid + Math.imul(ah1, bl4)) | 0;
	  hi = Math.imul(ah1, bh4);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  lo = Math.imul(al0, bl5);
	  mid = Math.imul(al0, bh5);
	  mid = (mid + Math.imul(ah0, bl5)) | 0;
	  hi = Math.imul(ah0, bh5);
	  w5 = (w5 + lo) | 0;
	  w5 = (w5 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;
	  /* k = 6 */
	  var w6 = c;
	  c = 0;
	  lo = Math.imul(al6, bl0);
	  mid = Math.imul(al6, bh0);
	  mid = (mid + Math.imul(ah6, bl0)) | 0;
	  hi = Math.imul(ah6, bh0);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al5, bl1);
	  mid = Math.imul(al5, bh1);
	  mid = (mid + Math.imul(ah5, bl1)) | 0;
	  hi = Math.imul(ah5, bh1);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al4, bl2);
	  mid = Math.imul(al4, bh2);
	  mid = (mid + Math.imul(ah4, bl2)) | 0;
	  hi = Math.imul(ah4, bh2);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al3, bl3);
	  mid = Math.imul(al3, bh3);
	  mid = (mid + Math.imul(ah3, bl3)) | 0;
	  hi = Math.imul(ah3, bh3);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al2, bl4);
	  mid = Math.imul(al2, bh4);
	  mid = (mid + Math.imul(ah2, bl4)) | 0;
	  hi = Math.imul(ah2, bh4);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al1, bl5);
	  mid = Math.imul(al1, bh5);
	  mid = (mid + Math.imul(ah1, bl5)) | 0;
	  hi = Math.imul(ah1, bh5);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  lo = Math.imul(al0, bl6);
	  mid = Math.imul(al0, bh6);
	  mid = (mid + Math.imul(ah0, bl6)) | 0;
	  hi = Math.imul(ah0, bh6);
	  w6 = (w6 + lo) | 0;
	  w6 = (w6 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;
	  /* k = 7 */
	  var w7 = c;
	  c = 0;
	  lo = Math.imul(al7, bl0);
	  mid = Math.imul(al7, bh0);
	  mid = (mid + Math.imul(ah7, bl0)) | 0;
	  hi = Math.imul(ah7, bh0);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al6, bl1);
	  mid = Math.imul(al6, bh1);
	  mid = (mid + Math.imul(ah6, bl1)) | 0;
	  hi = Math.imul(ah6, bh1);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al5, bl2);
	  mid = Math.imul(al5, bh2);
	  mid = (mid + Math.imul(ah5, bl2)) | 0;
	  hi = Math.imul(ah5, bh2);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al4, bl3);
	  mid = Math.imul(al4, bh3);
	  mid = (mid + Math.imul(ah4, bl3)) | 0;
	  hi = Math.imul(ah4, bh3);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al3, bl4);
	  mid = Math.imul(al3, bh4);
	  mid = (mid + Math.imul(ah3, bl4)) | 0;
	  hi = Math.imul(ah3, bh4);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al2, bl5);
	  mid = Math.imul(al2, bh5);
	  mid = (mid + Math.imul(ah2, bl5)) | 0;
	  hi = Math.imul(ah2, bh5);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al1, bl6);
	  mid = Math.imul(al1, bh6);
	  mid = (mid + Math.imul(ah1, bl6)) | 0;
	  hi = Math.imul(ah1, bh6);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  lo = Math.imul(al0, bl7);
	  mid = Math.imul(al0, bh7);
	  mid = (mid + Math.imul(ah0, bl7)) | 0;
	  hi = Math.imul(ah0, bh7);
	  w7 = (w7 + lo) | 0;
	  w7 = (w7 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;
	  /* k = 8 */
	  var w8 = c;
	  c = 0;
	  lo = Math.imul(al8, bl0);
	  mid = Math.imul(al8, bh0);
	  mid = (mid + Math.imul(ah8, bl0)) | 0;
	  hi = Math.imul(ah8, bh0);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al7, bl1);
	  mid = Math.imul(al7, bh1);
	  mid = (mid + Math.imul(ah7, bl1)) | 0;
	  hi = Math.imul(ah7, bh1);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al6, bl2);
	  mid = Math.imul(al6, bh2);
	  mid = (mid + Math.imul(ah6, bl2)) | 0;
	  hi = Math.imul(ah6, bh2);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al5, bl3);
	  mid = Math.imul(al5, bh3);
	  mid = (mid + Math.imul(ah5, bl3)) | 0;
	  hi = Math.imul(ah5, bh3);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al4, bl4);
	  mid = Math.imul(al4, bh4);
	  mid = (mid + Math.imul(ah4, bl4)) | 0;
	  hi = Math.imul(ah4, bh4);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al3, bl5);
	  mid = Math.imul(al3, bh5);
	  mid = (mid + Math.imul(ah3, bl5)) | 0;
	  hi = Math.imul(ah3, bh5);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al2, bl6);
	  mid = Math.imul(al2, bh6);
	  mid = (mid + Math.imul(ah2, bl6)) | 0;
	  hi = Math.imul(ah2, bh6);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al1, bl7);
	  mid = Math.imul(al1, bh7);
	  mid = (mid + Math.imul(ah1, bl7)) | 0;
	  hi = Math.imul(ah1, bh7);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  lo = Math.imul(al0, bl8);
	  mid = Math.imul(al0, bh8);
	  mid = (mid + Math.imul(ah0, bl8)) | 0;
	  hi = Math.imul(ah0, bh8);
	  w8 = (w8 + lo) | 0;
	  w8 = (w8 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;
	  /* k = 9 */
	  var w9 = c;
	  c = 0;
	  lo = Math.imul(al9, bl0);
	  mid = Math.imul(al9, bh0);
	  mid = (mid + Math.imul(ah9, bl0)) | 0;
	  hi = Math.imul(ah9, bh0);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al8, bl1);
	  mid = Math.imul(al8, bh1);
	  mid = (mid + Math.imul(ah8, bl1)) | 0;
	  hi = Math.imul(ah8, bh1);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al7, bl2);
	  mid = Math.imul(al7, bh2);
	  mid = (mid + Math.imul(ah7, bl2)) | 0;
	  hi = Math.imul(ah7, bh2);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al6, bl3);
	  mid = Math.imul(al6, bh3);
	  mid = (mid + Math.imul(ah6, bl3)) | 0;
	  hi = Math.imul(ah6, bh3);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al5, bl4);
	  mid = Math.imul(al5, bh4);
	  mid = (mid + Math.imul(ah5, bl4)) | 0;
	  hi = Math.imul(ah5, bh4);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al4, bl5);
	  mid = Math.imul(al4, bh5);
	  mid = (mid + Math.imul(ah4, bl5)) | 0;
	  hi = Math.imul(ah4, bh5);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al3, bl6);
	  mid = Math.imul(al3, bh6);
	  mid = (mid + Math.imul(ah3, bl6)) | 0;
	  hi = Math.imul(ah3, bh6);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al2, bl7);
	  mid = Math.imul(al2, bh7);
	  mid = (mid + Math.imul(ah2, bl7)) | 0;
	  hi = Math.imul(ah2, bh7);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al1, bl8);
	  mid = Math.imul(al1, bh8);
	  mid = (mid + Math.imul(ah1, bl8)) | 0;
	  hi = Math.imul(ah1, bh8);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  lo = Math.imul(al0, bl9);
	  mid = Math.imul(al0, bh9);
	  mid = (mid + Math.imul(ah0, bl9)) | 0;
	  hi = Math.imul(ah0, bh9);
	  w9 = (w9 + lo) | 0;
	  w9 = (w9 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;
	  /* k = 10 */
	  var w10 = c;
	  c = 0;
	  lo = Math.imul(al9, bl1);
	  mid = Math.imul(al9, bh1);
	  mid = (mid + Math.imul(ah9, bl1)) | 0;
	  hi = Math.imul(ah9, bh1);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al8, bl2);
	  mid = Math.imul(al8, bh2);
	  mid = (mid + Math.imul(ah8, bl2)) | 0;
	  hi = Math.imul(ah8, bh2);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al7, bl3);
	  mid = Math.imul(al7, bh3);
	  mid = (mid + Math.imul(ah7, bl3)) | 0;
	  hi = Math.imul(ah7, bh3);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al6, bl4);
	  mid = Math.imul(al6, bh4);
	  mid = (mid + Math.imul(ah6, bl4)) | 0;
	  hi = Math.imul(ah6, bh4);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al5, bl5);
	  mid = Math.imul(al5, bh5);
	  mid = (mid + Math.imul(ah5, bl5)) | 0;
	  hi = Math.imul(ah5, bh5);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al4, bl6);
	  mid = Math.imul(al4, bh6);
	  mid = (mid + Math.imul(ah4, bl6)) | 0;
	  hi = Math.imul(ah4, bh6);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al3, bl7);
	  mid = Math.imul(al3, bh7);
	  mid = (mid + Math.imul(ah3, bl7)) | 0;
	  hi = Math.imul(ah3, bh7);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al2, bl8);
	  mid = Math.imul(al2, bh8);
	  mid = (mid + Math.imul(ah2, bl8)) | 0;
	  hi = Math.imul(ah2, bh8);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  lo = Math.imul(al1, bl9);
	  mid = Math.imul(al1, bh9);
	  mid = (mid + Math.imul(ah1, bl9)) | 0;
	  hi = Math.imul(ah1, bh9);
	  w10 = (w10 + lo) | 0;
	  w10 = (w10 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;
	  /* k = 11 */
	  var w11 = c;
	  c = 0;
	  lo = Math.imul(al9, bl2);
	  mid = Math.imul(al9, bh2);
	  mid = (mid + Math.imul(ah9, bl2)) | 0;
	  hi = Math.imul(ah9, bh2);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al8, bl3);
	  mid = Math.imul(al8, bh3);
	  mid = (mid + Math.imul(ah8, bl3)) | 0;
	  hi = Math.imul(ah8, bh3);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al7, bl4);
	  mid = Math.imul(al7, bh4);
	  mid = (mid + Math.imul(ah7, bl4)) | 0;
	  hi = Math.imul(ah7, bh4);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al6, bl5);
	  mid = Math.imul(al6, bh5);
	  mid = (mid + Math.imul(ah6, bl5)) | 0;
	  hi = Math.imul(ah6, bh5);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al5, bl6);
	  mid = Math.imul(al5, bh6);
	  mid = (mid + Math.imul(ah5, bl6)) | 0;
	  hi = Math.imul(ah5, bh6);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al4, bl7);
	  mid = Math.imul(al4, bh7);
	  mid = (mid + Math.imul(ah4, bl7)) | 0;
	  hi = Math.imul(ah4, bh7);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al3, bl8);
	  mid = Math.imul(al3, bh8);
	  mid = (mid + Math.imul(ah3, bl8)) | 0;
	  hi = Math.imul(ah3, bh8);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  lo = Math.imul(al2, bl9);
	  mid = Math.imul(al2, bh9);
	  mid = (mid + Math.imul(ah2, bl9)) | 0;
	  hi = Math.imul(ah2, bh9);
	  w11 = (w11 + lo) | 0;
	  w11 = (w11 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;
	  /* k = 12 */
	  var w12 = c;
	  c = 0;
	  lo = Math.imul(al9, bl3);
	  mid = Math.imul(al9, bh3);
	  mid = (mid + Math.imul(ah9, bl3)) | 0;
	  hi = Math.imul(ah9, bh3);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al8, bl4);
	  mid = Math.imul(al8, bh4);
	  mid = (mid + Math.imul(ah8, bl4)) | 0;
	  hi = Math.imul(ah8, bh4);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al7, bl5);
	  mid = Math.imul(al7, bh5);
	  mid = (mid + Math.imul(ah7, bl5)) | 0;
	  hi = Math.imul(ah7, bh5);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al6, bl6);
	  mid = Math.imul(al6, bh6);
	  mid = (mid + Math.imul(ah6, bl6)) | 0;
	  hi = Math.imul(ah6, bh6);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al5, bl7);
	  mid = Math.imul(al5, bh7);
	  mid = (mid + Math.imul(ah5, bl7)) | 0;
	  hi = Math.imul(ah5, bh7);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al4, bl8);
	  mid = Math.imul(al4, bh8);
	  mid = (mid + Math.imul(ah4, bl8)) | 0;
	  hi = Math.imul(ah4, bh8);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  lo = Math.imul(al3, bl9);
	  mid = Math.imul(al3, bh9);
	  mid = (mid + Math.imul(ah3, bl9)) | 0;
	  hi = Math.imul(ah3, bh9);
	  w12 = (w12 + lo) | 0;
	  w12 = (w12 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;
	  /* k = 13 */
	  var w13 = c;
	  c = 0;
	  lo = Math.imul(al9, bl4);
	  mid = Math.imul(al9, bh4);
	  mid = (mid + Math.imul(ah9, bl4)) | 0;
	  hi = Math.imul(ah9, bh4);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  lo = Math.imul(al8, bl5);
	  mid = Math.imul(al8, bh5);
	  mid = (mid + Math.imul(ah8, bl5)) | 0;
	  hi = Math.imul(ah8, bh5);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  lo = Math.imul(al7, bl6);
	  mid = Math.imul(al7, bh6);
	  mid = (mid + Math.imul(ah7, bl6)) | 0;
	  hi = Math.imul(ah7, bh6);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  lo = Math.imul(al6, bl7);
	  mid = Math.imul(al6, bh7);
	  mid = (mid + Math.imul(ah6, bl7)) | 0;
	  hi = Math.imul(ah6, bh7);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  lo = Math.imul(al5, bl8);
	  mid = Math.imul(al5, bh8);
	  mid = (mid + Math.imul(ah5, bl8)) | 0;
	  hi = Math.imul(ah5, bh8);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  lo = Math.imul(al4, bl9);
	  mid = Math.imul(al4, bh9);
	  mid = (mid + Math.imul(ah4, bl9)) | 0;
	  hi = Math.imul(ah4, bh9);
	  w13 = (w13 + lo) | 0;
	  w13 = (w13 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;
	  /* k = 14 */
	  var w14 = c;
	  c = 0;
	  lo = Math.imul(al9, bl5);
	  mid = Math.imul(al9, bh5);
	  mid = (mid + Math.imul(ah9, bl5)) | 0;
	  hi = Math.imul(ah9, bh5);
	  w14 = (w14 + lo) | 0;
	  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;
	  lo = Math.imul(al8, bl6);
	  mid = Math.imul(al8, bh6);
	  mid = (mid + Math.imul(ah8, bl6)) | 0;
	  hi = Math.imul(ah8, bh6);
	  w14 = (w14 + lo) | 0;
	  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;
	  lo = Math.imul(al7, bl7);
	  mid = Math.imul(al7, bh7);
	  mid = (mid + Math.imul(ah7, bl7)) | 0;
	  hi = Math.imul(ah7, bh7);
	  w14 = (w14 + lo) | 0;
	  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;
	  lo = Math.imul(al6, bl8);
	  mid = Math.imul(al6, bh8);
	  mid = (mid + Math.imul(ah6, bl8)) | 0;
	  hi = Math.imul(ah6, bh8);
	  w14 = (w14 + lo) | 0;
	  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;
	  lo = Math.imul(al5, bl9);
	  mid = Math.imul(al5, bh9);
	  mid = (mid + Math.imul(ah5, bl9)) | 0;
	  hi = Math.imul(ah5, bh9);
	  w14 = (w14 + lo) | 0;
	  w14 = (w14 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;
	  /* k = 15 */
	  var w15 = c;
	  c = 0;
	  lo = Math.imul(al9, bl6);
	  mid = Math.imul(al9, bh6);
	  mid = (mid + Math.imul(ah9, bl6)) | 0;
	  hi = Math.imul(ah9, bh6);
	  w15 = (w15 + lo) | 0;
	  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w15 >>> 26)) | 0;
	  w15 &= 0x3ffffff;
	  lo = Math.imul(al8, bl7);
	  mid = Math.imul(al8, bh7);
	  mid = (mid + Math.imul(ah8, bl7)) | 0;
	  hi = Math.imul(ah8, bh7);
	  w15 = (w15 + lo) | 0;
	  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w15 >>> 26)) | 0;
	  w15 &= 0x3ffffff;
	  lo = Math.imul(al7, bl8);
	  mid = Math.imul(al7, bh8);
	  mid = (mid + Math.imul(ah7, bl8)) | 0;
	  hi = Math.imul(ah7, bh8);
	  w15 = (w15 + lo) | 0;
	  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w15 >>> 26)) | 0;
	  w15 &= 0x3ffffff;
	  lo = Math.imul(al6, bl9);
	  mid = Math.imul(al6, bh9);
	  mid = (mid + Math.imul(ah6, bl9)) | 0;
	  hi = Math.imul(ah6, bh9);
	  w15 = (w15 + lo) | 0;
	  w15 = (w15 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w15 >>> 26)) | 0;
	  w15 &= 0x3ffffff;
	  /* k = 16 */
	  var w16 = c;
	  c = 0;
	  lo = Math.imul(al9, bl7);
	  mid = Math.imul(al9, bh7);
	  mid = (mid + Math.imul(ah9, bl7)) | 0;
	  hi = Math.imul(ah9, bh7);
	  w16 = (w16 + lo) | 0;
	  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w16 >>> 26)) | 0;
	  w16 &= 0x3ffffff;
	  lo = Math.imul(al8, bl8);
	  mid = Math.imul(al8, bh8);
	  mid = (mid + Math.imul(ah8, bl8)) | 0;
	  hi = Math.imul(ah8, bh8);
	  w16 = (w16 + lo) | 0;
	  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w16 >>> 26)) | 0;
	  w16 &= 0x3ffffff;
	  lo = Math.imul(al7, bl9);
	  mid = Math.imul(al7, bh9);
	  mid = (mid + Math.imul(ah7, bl9)) | 0;
	  hi = Math.imul(ah7, bh9);
	  w16 = (w16 + lo) | 0;
	  w16 = (w16 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w16 >>> 26)) | 0;
	  w16 &= 0x3ffffff;
	  /* k = 17 */
	  var w17 = c;
	  c = 0;
	  lo = Math.imul(al9, bl8);
	  mid = Math.imul(al9, bh8);
	  mid = (mid + Math.imul(ah9, bl8)) | 0;
	  hi = Math.imul(ah9, bh8);
	  w17 = (w17 + lo) | 0;
	  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w17 >>> 26)) | 0;
	  w17 &= 0x3ffffff;
	  lo = Math.imul(al8, bl9);
	  mid = Math.imul(al8, bh9);
	  mid = (mid + Math.imul(ah8, bl9)) | 0;
	  hi = Math.imul(ah8, bh9);
	  w17 = (w17 + lo) | 0;
	  w17 = (w17 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w17 >>> 26)) | 0;
	  w17 &= 0x3ffffff;
	  /* k = 18 */
	  var w18 = c;
	  c = 0;
	  lo = Math.imul(al9, bl9);
	  mid = Math.imul(al9, bh9);
	  mid = (mid + Math.imul(ah9, bl9)) | 0;
	  hi = Math.imul(ah9, bh9);
	  w18 = (w18 + lo) | 0;
	  w18 = (w18 + ((mid & 0x1fff) << 13)) | 0;
	  c = (c + hi) | 0;
	  c = (c + (mid >>> 13)) | 0;
	  c = (c + (w18 >>> 26)) | 0;
	  w18 &= 0x3ffffff;
	  o[0] = w0;
	  o[1] = w1;
	  o[2] = w2;
	  o[3] = w3;
	  o[4] = w4;
	  o[5] = w5;
	  o[6] = w6;
	  o[7] = w7;
	  o[8] = w8;
	  o[9] = w9;
	  o[10] = w10;
	  o[11] = w11;
	  o[12] = w12;
	  o[13] = w13;
	  o[14] = w14;
	  o[15] = w15;
	  o[16] = w16;
	  o[17] = w17;
	  o[18] = w18;
	  if (c !== 0) {
	    o[19] = c;
	    out.length++;
	  }
	  return out;
	};

	// Polyfill comb
	if (!Math.imul)
	  comb10MulTo = smallMulTo;

	function bigMulTo(self, num, out) {
	  out.negative = num.negative ^ self.negative;
	  out.length = self.length + num.length;

	  var carry = 0;
	  var hncarry = 0;
	  for (var k = 0; k < out.length - 1; k++) {
	    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	    // note that ncarry could be >= 0x3ffffff
	    var ncarry = hncarry;
	    hncarry = 0;
	    var rword = carry & 0x3ffffff;
	    var maxJ = Math.min(k, num.length - 1);
	    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	      var i = k - j;
	      var a = self.words[i] | 0;
	      var b = num.words[j] | 0;
	      var r = a * b;

	      var lo = r & 0x3ffffff;
	      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	      lo = (lo + rword) | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = (ncarry + (lo >>> 26)) | 0;

	      hncarry += ncarry >>> 26;
	      ncarry &= 0x3ffffff;
	    }
	    out.words[k] = rword;
	    carry = ncarry;
	    ncarry = hncarry;
	  }
	  if (carry !== 0) {
	    out.words[k] = carry;
	  } else {
	    out.length--;
	  }

	  return out.strip();
	}

	function jumboMulTo(self, num, out) {
	  var fftm = new FFTM();
	  return fftm.mulp(self, num, out);
	}

	BN.prototype.mulTo = function mulTo(num, out) {
	  var res;
	  var len = this.length + num.length;
	  if (this.length === 10 && num.length === 10)
	    res = comb10MulTo(this, num, out);
	  else if (len < 63)
	    res = smallMulTo(this, num, out);
	  else if (len < 1024)
	    res = bigMulTo(this, num, out);
	  else
	    res = jumboMulTo(this, num, out);
	  return res;
	};

	// Cooley-Tukey algorithm for FFT
	// slightly revisited to rely on looping instead of recursion

	function FFTM(x, y) {
	  this.x = x;
	  this.y = y;
	}

	FFTM.prototype.makeRBT = function makeRBT(N) {
	  var t = new Array(N);
	  var l = BN.prototype._countBits(N) - 1;
	  for (var i = 0; i < N; i++) {
	    t[i] = this.revBin(i, l, N);
	  }

	  return t;
	};

	// Returns binary-reversed representation of `x`
	FFTM.prototype.revBin = function revBin(x, l, N) {
	  if (x === 0 || x === N - 1)
	    return x;

	  var rb = 0;
	  for (var i = 0; i < l; i++) {
	    rb |= (x & 1) << (l - i - 1);
	    x >>= 1;
	  }

	  return rb;
	};

	// Performs "tweedling" phase, therefore 'emulating'
	// behaviour of the recursive algorithm
	FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
	  for (var i = 0; i < N; i++) {
	    rtws[i] = rws[rbt[i]];
	    itws[i] = iws[rbt[i]];
	  }
	};

	FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
	  this.permute(rbt, rws, iws, rtws, itws, N);

	  for (var s = 1; s < N; s <<= 1) {
	    var l = s << 1;

	    var rtwdf = Math.cos(2 * Math.PI / l);
	    var itwdf = Math.sin(2 * Math.PI / l);

	    for (var p = 0; p < N; p += l) {
	      var rtwdf_ = rtwdf;
	      var itwdf_ = itwdf;

	      for (var j = 0; j < s; j++) {
	        var re = rtws[p + j];
	        var ie = itws[p + j];

	        var ro = rtws[p + j + s];
	        var io = itws[p + j + s];

	        var rx = rtwdf_ * ro - itwdf_ * io;

	        io = rtwdf_ * io + itwdf_ * ro;
	        ro = rx;

	        rtws[p + j] = re + ro;
	        itws[p + j] = ie + io;

	        rtws[p + j + s] = re - ro;
	        itws[p + j + s] = ie - io;

	        /* jshint maxdepth : false */
	        if (j !== l) {
	          rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	          rtwdf_ = rx;
	        }
	      }
	    }
	  }
	};

	FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
	  var N = Math.max(m, n) | 1;
	  var odd = N & 1;
	  var i = 0;
	  for (N = N / 2 | 0; N; N = N >>> 1) {
	    i++;
	  }

	  return 1 << i + 1 + odd;
	};

	FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
	  if (N <= 1)
	    return;

	  for (var i = 0; i < N / 2; i++) {
	    var t = rws[i];

	    rws[i] = rws[N - i - 1];
	    rws[N - i - 1] = t;

	    t = iws[i];

	    iws[i] = -iws[N - i - 1];
	    iws[N - i - 1] = -t;
	  }
	};

	FFTM.prototype.normalize13b = function normalize13b(ws, N) {
	  var carry = 0;
	  for (var i = 0; i < N / 2; i++) {
	    var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	            Math.round(ws[2 * i] / N) +
	            carry;

	    ws[i] = w & 0x3ffffff;

	    if (w < 0x4000000) {
	      carry = 0;
	    } else {
	      carry = w / 0x4000000 | 0;
	    }
	  }

	  return ws;
	};

	FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
	  var carry = 0;
	  for (var i = 0; i < len; i++) {
	    var carry = carry + (ws[i] | 0);

	    rws[2 * i]     = carry & 0x1fff; carry = carry >>> 13;
	    rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	  }

	  // Pad with zeroes
	  for (var i = 2 * len; i < N; ++i)
	    rws[i] = 0;

	  assert(carry === 0);
	  assert((carry & ~0x1fff) === 0);
	};

	FFTM.prototype.stub = function stub(N) {
	  var ph = new Array(N);
	  for (var i = 0; i < N; i++)
	    ph[i] = 0;

	  return ph;
	};

	FFTM.prototype.mulp = function mulp(x, y, out) {
	  var N = 2 * this.guessLen13b(x.length, y.length);

	  var rbt = this.makeRBT(N);

	  var _ = this.stub(N);

	  var rws   = new Array(N);
	  var rwst  = new Array(N);
	  var iwst  = new Array(N);

	  var nrws  = new Array(N);
	  var nrwst = new Array(N);
	  var niwst = new Array(N);

	  var rmws = out.words;
	  rmws.length = N;

	  this.convert13b(x.words, x.length, rws, N);
	  this.convert13b(y.words, y.length, nrws, N);

	  this.transform(rws, _, rwst, iwst, N, rbt);
	  this.transform(nrws, _, nrwst, niwst, N, rbt);

	  for (var i = 0; i < N; i++) {
	    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	    rwst[i] = rx;
	  }

	  this.conjugate(rwst, iwst, N);

	  this.transform(rwst, iwst, rmws, _, N, rbt);

	  this.conjugate(rmws, _, N);

	  this.normalize13b(rmws, N);

	  out.negative = x.negative ^ y.negative;
	  out.length = x.length + y.length;
	  return out.strip();
	};

	// Multiply `this` by `num`
	BN.prototype.mul = function mul(num) {
	  var out = new BN(null);
	  out.words = new Array(this.length + num.length);
	  return this.mulTo(num, out);
	};

	// Multiply employing FFT
	BN.prototype.mulf = function mulf(num) {
	  var out = new BN(null);
	  out.words = new Array(this.length + num.length);
	  return jumboMulTo(this, num, out);
	};

	// In-place Multiplication
	BN.prototype.imul = function imul(num) {
	  return this.clone().mulTo(num, this);
	};

	BN.prototype.imuln = function imuln(num) {
	  assert(typeof num === 'number');

	  // Carry
	  var carry = 0;
	  for (var i = 0; i < this.length; i++) {
	    var w = (this.words[i] | 0) * num;
	    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	    carry >>= 26;
	    carry += (w / 0x4000000) | 0;
	    // NOTE: lo is 27bit maximum
	    carry += lo >>> 26;
	    this.words[i] = lo & 0x3ffffff;
	  }

	  if (carry !== 0) {
	    this.words[i] = carry;
	    this.length++;
	  }

	  return this;
	};

	BN.prototype.muln = function muln(num) {
	  return this.clone().imuln(num);
	};

	// `this` * `this`
	BN.prototype.sqr = function sqr() {
	  return this.mul(this);
	};

	// `this` * `this` in-place
	BN.prototype.isqr = function isqr() {
	  return this.imul(this.clone());
	};

	// Math.pow(`this`, `num`)
	BN.prototype.pow = function pow(num) {
	  var w = toBitArray(num);
	  if (w.length === 0)
	    return new BN(1);

	  // Skip leading zeroes
	  var res = this;
	  for (var i = 0; i < w.length; i++, res = res.sqr())
	    if (w[i] !== 0)
	      break;

	  if (++i < w.length) {
	    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	      if (w[i] === 0)
	        continue;
	      res = res.mul(q);
	    }
	  }

	  return res;
	};

	// Shift-left in-place
	BN.prototype.iushln = function iushln(bits) {
	  assert(typeof bits === 'number' && bits >= 0);
	  var r = bits % 26;
	  var s = (bits - r) / 26;
	  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

	  if (r !== 0) {
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var newCarry = this.words[i] & carryMask;
	      var c = ((this.words[i] | 0) - newCarry) << r;
	      this.words[i] = c | carry;
	      carry = newCarry >>> (26 - r);
	    }
	    if (carry) {
	      this.words[i] = carry;
	      this.length++;
	    }
	  }

	  if (s !== 0) {
	    for (var i = this.length - 1; i >= 0; i--)
	      this.words[i + s] = this.words[i];
	    for (var i = 0; i < s; i++)
	      this.words[i] = 0;
	    this.length += s;
	  }

	  return this.strip();
	};

	BN.prototype.ishln = function ishln(bits) {
	  // TODO(indutny): implement me
	  assert(this.negative === 0);
	  return this.iushln(bits);
	};

	// Shift-right in-place
	// NOTE: `hint` is a lowest bit before trailing zeroes
	// NOTE: if `extended` is present - it will be filled with destroyed bits
	BN.prototype.iushrn = function iushrn(bits, hint, extended) {
	  assert(typeof bits === 'number' && bits >= 0);
	  var h;
	  if (hint)
	    h = (hint - (hint % 26)) / 26;
	  else
	    h = 0;

	  var r = bits % 26;
	  var s = Math.min((bits - r) / 26, this.length);
	  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	  var maskedWords = extended;

	  h -= s;
	  h = Math.max(0, h);

	  // Extended mode, copy masked part
	  if (maskedWords) {
	    for (var i = 0; i < s; i++)
	      maskedWords.words[i] = this.words[i];
	    maskedWords.length = s;
	  }

	  if (s === 0) {
	    // No-op, we should not move anything at all
	  } else if (this.length > s) {
	    this.length -= s;
	    for (var i = 0; i < this.length; i++)
	      this.words[i] = this.words[i + s];
	  } else {
	    this.words[0] = 0;
	    this.length = 1;
	  }

	  var carry = 0;
	  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	    var word = this.words[i] | 0;
	    this.words[i] = (carry << (26 - r)) | (word >>> r);
	    carry = word & mask;
	  }

	  // Push carried bits as a mask
	  if (maskedWords && carry !== 0)
	    maskedWords.words[maskedWords.length++] = carry;

	  if (this.length === 0) {
	    this.words[0] = 0;
	    this.length = 1;
	  }

	  return this.strip();
	};

	BN.prototype.ishrn = function ishrn(bits, hint, extended) {
	  // TODO(indutny): implement me
	  assert(this.negative === 0);
	  return this.iushrn(bits, hint, extended);
	};

	// Shift-left
	BN.prototype.shln = function shln(bits) {
	  return this.clone().ishln(bits);
	};

	BN.prototype.ushln = function ushln(bits) {
	  return this.clone().iushln(bits);
	};

	// Shift-right
	BN.prototype.shrn = function shrn(bits) {
	  return this.clone().ishrn(bits);
	};

	BN.prototype.ushrn = function ushrn(bits) {
	  return this.clone().iushrn(bits);
	};

	// Test if n bit is set
	BN.prototype.testn = function testn(bit) {
	  assert(typeof bit === 'number' && bit >= 0);
	  var r = bit % 26;
	  var s = (bit - r) / 26;
	  var q = 1 << r;

	  // Fast case: bit is much higher than all existing words
	  if (this.length <= s) {
	    return false;
	  }

	  // Check bit and return
	  var w = this.words[s];

	  return !!(w & q);
	};

	// Return only lowers bits of number (in-place)
	BN.prototype.imaskn = function imaskn(bits) {
	  assert(typeof bits === 'number' && bits >= 0);
	  var r = bits % 26;
	  var s = (bits - r) / 26;

	  assert(this.negative === 0, 'imaskn works only with positive numbers');

	  if (r !== 0)
	    s++;
	  this.length = Math.min(s, this.length);

	  if (r !== 0) {
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    this.words[this.length - 1] &= mask;
	  }

	  return this.strip();
	};

	// Return only lowers bits of number
	BN.prototype.maskn = function maskn(bits) {
	  return this.clone().imaskn(bits);
	};

	// Add plain number `num` to `this`
	BN.prototype.iaddn = function iaddn(num) {
	  assert(typeof num === 'number');
	  if (num < 0)
	    return this.isubn(-num);

	  // Possible sign change
	  if (this.negative !== 0) {
	    if (this.length === 1 && (this.words[0] | 0) < num) {
	      this.words[0] = num - (this.words[0] | 0);
	      this.negative = 0;
	      return this;
	    }

	    this.negative = 0;
	    this.isubn(num);
	    this.negative = 1;
	    return this;
	  }

	  // Add without checks
	  return this._iaddn(num);
	};

	BN.prototype._iaddn = function _iaddn(num) {
	  this.words[0] += num;

	  // Carry
	  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	    this.words[i] -= 0x4000000;
	    if (i === this.length - 1)
	      this.words[i + 1] = 1;
	    else
	      this.words[i + 1]++;
	  }
	  this.length = Math.max(this.length, i + 1);

	  return this;
	};

	// Subtract plain number `num` from `this`
	BN.prototype.isubn = function isubn(num) {
	  assert(typeof num === 'number');
	  if (num < 0)
	    return this.iaddn(-num);

	  if (this.negative !== 0) {
	    this.negative = 0;
	    this.iaddn(num);
	    this.negative = 1;
	    return this;
	  }

	  this.words[0] -= num;

	  if (this.length === 1 && this.words[0] < 0) {
	    this.words[0] = -this.words[0];
	    this.negative = 1;
	  } else {
	    // Carry
	    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	      this.words[i] += 0x4000000;
	      this.words[i + 1] -= 1;
	    }
	  }

	  return this.strip();
	};

	BN.prototype.addn = function addn(num) {
	  return this.clone().iaddn(num);
	};

	BN.prototype.subn = function subn(num) {
	  return this.clone().isubn(num);
	};

	BN.prototype.iabs = function iabs() {
	  this.negative = 0;

	  return this;
	};

	BN.prototype.abs = function abs() {
	  return this.clone().iabs();
	};

	BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
	  // Bigger storage is needed
	  var len = num.length + shift;
	  var i;
	  if (this.words.length < len) {
	    var t = new Array(len);
	    for (var i = 0; i < this.length; i++)
	      t[i] = this.words[i];
	    this.words = t;
	  } else {
	    i = this.length;
	  }

	  // Zeroify rest
	  this.length = Math.max(this.length, len);
	  for (; i < this.length; i++)
	    this.words[i] = 0;

	  var carry = 0;
	  for (var i = 0; i < num.length; i++) {
	    var w = (this.words[i + shift] | 0) + carry;
	    var right = (num.words[i] | 0) * mul;
	    w -= right & 0x3ffffff;
	    carry = (w >> 26) - ((right / 0x4000000) | 0);
	    this.words[i + shift] = w & 0x3ffffff;
	  }
	  for (; i < this.length - shift; i++) {
	    var w = (this.words[i + shift] | 0) + carry;
	    carry = w >> 26;
	    this.words[i + shift] = w & 0x3ffffff;
	  }

	  if (carry === 0)
	    return this.strip();

	  // Subtraction overflow
	  assert(carry === -1);
	  carry = 0;
	  for (var i = 0; i < this.length; i++) {
	    var w = -(this.words[i] | 0) + carry;
	    carry = w >> 26;
	    this.words[i] = w & 0x3ffffff;
	  }
	  this.negative = 1;

	  return this.strip();
	};

	BN.prototype._wordDiv = function _wordDiv(num, mode) {
	  var shift = this.length - num.length;

	  var a = this.clone();
	  var b = num;

	  // Normalize
	  var bhi = b.words[b.length - 1] | 0;
	  var bhiBits = this._countBits(bhi);
	  shift = 26 - bhiBits;
	  if (shift !== 0) {
	    b = b.ushln(shift);
	    a.iushln(shift);
	    bhi = b.words[b.length - 1] | 0;
	  }

	  // Initialize quotient
	  var m = a.length - b.length;
	  var q;

	  if (mode !== 'mod') {
	    q = new BN(null);
	    q.length = m + 1;
	    q.words = new Array(q.length);
	    for (var i = 0; i < q.length; i++)
	      q.words[i] = 0;
	  }

	  var diff = a.clone()._ishlnsubmul(b, 1, m);
	  if (diff.negative === 0) {
	    a = diff;
	    if (q)
	      q.words[m] = 1;
	  }

	  for (var j = m - 1; j >= 0; j--) {
	    var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	             (a.words[b.length + j - 1] | 0);

	    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	    // (0x7ffffff)
	    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	    a._ishlnsubmul(b, qj, j);
	    while (a.negative !== 0) {
	      qj--;
	      a.negative = 0;
	      a._ishlnsubmul(b, 1, j);
	      if (a.cmpn(0) !== 0)
	        a.negative ^= 1;
	    }
	    if (q)
	      q.words[j] = qj;
	  }
	  if (q)
	    q.strip();
	  a.strip();

	  // Denormalize
	  if (mode !== 'div' && shift !== 0)
	    a.iushrn(shift);
	  return { div: q ? q : null, mod: a };
	};

	BN.prototype.divmod = function divmod(num, mode, positive) {
	  assert(num.cmpn(0) !== 0);

	  if (this.negative !== 0 && num.negative === 0) {
	    var res = this.neg().divmod(num, mode);
	    var div;
	    var mod;
	    if (mode !== 'mod')
	      div = res.div.neg();
	    if (mode !== 'div') {
	      mod = res.mod.neg();
	      if (positive && mod.neg)
	        mod = mod.add(num);
	    }
	    return {
	      div: div,
	      mod: mod
	    };
	  } else if (this.negative === 0 && num.negative !== 0) {
	    var res = this.divmod(num.neg(), mode);
	    var div;
	    if (mode !== 'mod')
	      div = res.div.neg();
	    return { div: div, mod: res.mod };
	  } else if ((this.negative & num.negative) !== 0) {
	    var res = this.neg().divmod(num.neg(), mode);
	    var mod;
	    if (mode !== 'div') {
	      mod = res.mod.neg();
	      if (positive && mod.neg)
	        mod = mod.isub(num);
	    }
	    return {
	      div: res.div,
	      mod: mod
	    };
	  }

	  // Both numbers are positive at this point

	  // Strip both numbers to approximate shift value
	  if (num.length > this.length || this.cmp(num) < 0)
	    return { div: new BN(0), mod: this };

	  // Very short reduction
	  if (num.length === 1) {
	    if (mode === 'div')
	      return { div: this.divn(num.words[0]), mod: null };
	    else if (mode === 'mod')
	      return { div: null, mod: new BN(this.modn(num.words[0])) };
	    return {
	      div: this.divn(num.words[0]),
	      mod: new BN(this.modn(num.words[0]))
	    };
	  }

	  return this._wordDiv(num, mode);
	};

	// Find `this` / `num`
	BN.prototype.div = function div(num) {
	  return this.divmod(num, 'div', false).div;
	};

	// Find `this` % `num`
	BN.prototype.mod = function mod(num) {
	  return this.divmod(num, 'mod', false).mod;
	};

	BN.prototype.umod = function umod(num) {
	  return this.divmod(num, 'mod', true).mod;
	};

	// Find Round(`this` / `num`)
	BN.prototype.divRound = function divRound(num) {
	  var dm = this.divmod(num);

	  // Fast case - exact division
	  if (dm.mod.cmpn(0) === 0)
	    return dm.div;

	  var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	  var half = num.ushrn(1);
	  var r2 = num.andln(1);
	  var cmp = mod.cmp(half);

	  // Round down
	  if (cmp < 0 || r2 === 1 && cmp === 0)
	    return dm.div;

	  // Round up
	  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	};

	BN.prototype.modn = function modn(num) {
	  assert(num <= 0x3ffffff);
	  var p = (1 << 26) % num;

	  var acc = 0;
	  for (var i = this.length - 1; i >= 0; i--)
	    acc = (p * acc + (this.words[i] | 0)) % num;

	  return acc;
	};

	// In-place division by number
	BN.prototype.idivn = function idivn(num) {
	  assert(num <= 0x3ffffff);

	  var carry = 0;
	  for (var i = this.length - 1; i >= 0; i--) {
	    var w = (this.words[i] | 0) + carry * 0x4000000;
	    this.words[i] = (w / num) | 0;
	    carry = w % num;
	  }

	  return this.strip();
	};

	BN.prototype.divn = function divn(num) {
	  return this.clone().idivn(num);
	};

	BN.prototype.egcd = function egcd(p) {
	  assert(p.negative === 0);
	  assert(p.cmpn(0) !== 0);

	  var x = this;
	  var y = p.clone();

	  if (x.negative !== 0)
	    x = x.umod(p);
	  else
	    x = x.clone();

	  // A * x + B * y = x
	  var A = new BN(1);
	  var B = new BN(0);

	  // C * x + D * y = y
	  var C = new BN(0);
	  var D = new BN(1);

	  var g = 0;

	  while (x.isEven() && y.isEven()) {
	    x.iushrn(1);
	    y.iushrn(1);
	    ++g;
	  }

	  var yp = y.clone();
	  var xp = x.clone();

	  while (x.cmpn(0) !== 0) {
	    while (x.isEven()) {
	      x.iushrn(1);
	      if (A.isEven() && B.isEven()) {
	        A.iushrn(1);
	        B.iushrn(1);
	      } else {
	        A.iadd(yp).iushrn(1);
	        B.isub(xp).iushrn(1);
	      }
	    }

	    while (y.isEven()) {
	      y.iushrn(1);
	      if (C.isEven() && D.isEven()) {
	        C.iushrn(1);
	        D.iushrn(1);
	      } else {
	        C.iadd(yp).iushrn(1);
	        D.isub(xp).iushrn(1);
	      }
	    }

	    if (x.cmp(y) >= 0) {
	      x.isub(y);
	      A.isub(C);
	      B.isub(D);
	    } else {
	      y.isub(x);
	      C.isub(A);
	      D.isub(B);
	    }
	  }

	  return {
	    a: C,
	    b: D,
	    gcd: y.iushln(g)
	  };
	};

	// This is reduced incarnation of the binary EEA
	// above, designated to invert members of the
	// _prime_ fields F(p) at a maximal speed
	BN.prototype._invmp = function _invmp(p) {
	  assert(p.negative === 0);
	  assert(p.cmpn(0) !== 0);

	  var a = this;
	  var b = p.clone();

	  if (a.negative !== 0)
	    a = a.umod(p);
	  else
	    a = a.clone();

	  var x1 = new BN(1);
	  var x2 = new BN(0);

	  var delta = b.clone();

	  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	    while (a.isEven()) {
	      a.iushrn(1);
	      if (x1.isEven())
	        x1.iushrn(1);
	      else
	        x1.iadd(delta).iushrn(1);
	    }
	    while (b.isEven()) {
	      b.iushrn(1);
	      if (x2.isEven())
	        x2.iushrn(1);
	      else
	        x2.iadd(delta).iushrn(1);
	    }
	    if (a.cmp(b) >= 0) {
	      a.isub(b);
	      x1.isub(x2);
	    } else {
	      b.isub(a);
	      x2.isub(x1);
	    }
	  }

	  var res;
	  if (a.cmpn(1) === 0)
	    res = x1;
	  else
	    res = x2;

	  if (res.cmpn(0) < 0)
	    res.iadd(p);

	  return res;
	};

	BN.prototype.gcd = function gcd(num) {
	  if (this.cmpn(0) === 0)
	    return num.clone();
	  if (num.cmpn(0) === 0)
	    return this.clone();

	  var a = this.clone();
	  var b = num.clone();
	  a.negative = 0;
	  b.negative = 0;

	  // Remove common factor of two
	  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	    a.iushrn(1);
	    b.iushrn(1);
	  }

	  do {
	    while (a.isEven())
	      a.iushrn(1);
	    while (b.isEven())
	      b.iushrn(1);

	    var r = a.cmp(b);
	    if (r < 0) {
	      // Swap `a` and `b` to make `a` always bigger than `b`
	      var t = a;
	      a = b;
	      b = t;
	    } else if (r === 0 || b.cmpn(1) === 0) {
	      break;
	    }

	    a.isub(b);
	  } while (true);

	  return b.iushln(shift);
	};

	// Invert number in the field F(num)
	BN.prototype.invm = function invm(num) {
	  return this.egcd(num).a.umod(num);
	};

	BN.prototype.isEven = function isEven() {
	  return (this.words[0] & 1) === 0;
	};

	BN.prototype.isOdd = function isOdd() {
	  return (this.words[0] & 1) === 1;
	};

	// And first word and num
	BN.prototype.andln = function andln(num) {
	  return this.words[0] & num;
	};

	// Increment at the bit position in-line
	BN.prototype.bincn = function bincn(bit) {
	  assert(typeof bit === 'number');
	  var r = bit % 26;
	  var s = (bit - r) / 26;
	  var q = 1 << r;

	  // Fast case: bit is much higher than all existing words
	  if (this.length <= s) {
	    for (var i = this.length; i < s + 1; i++)
	      this.words[i] = 0;
	    this.words[s] |= q;
	    this.length = s + 1;
	    return this;
	  }

	  // Add bit and propagate, if needed
	  var carry = q;
	  for (var i = s; carry !== 0 && i < this.length; i++) {
	    var w = this.words[i] | 0;
	    w += carry;
	    carry = w >>> 26;
	    w &= 0x3ffffff;
	    this.words[i] = w;
	  }
	  if (carry !== 0) {
	    this.words[i] = carry;
	    this.length++;
	  }
	  return this;
	};

	BN.prototype.isZero = function isZero() {
	  return this.length === 1 && this.words[0] === 0;
	};

	BN.prototype.cmpn = function cmpn(num) {
	  var negative = num < 0;

	  if (this.negative !== 0 && !negative)
	    return -1;
	  else if (this.negative === 0 && negative)
	    return 1;

	  this.strip();

	  var res;
	  if (this.length > 1) {
	    res = 1;
	  } else {
	    if (negative)
	      num = -num;
	    assert(num <= 0x3ffffff, 'Number is too big');

	    var w = this.words[0] | 0;
	    res = w === num ? 0 : w < num ? -1 : 1;
	  }
	  if (this.negative !== 0)
	    res = -res;
	  return res;
	};

	// Compare two numbers and return:
	// 1 - if `this` > `num`
	// 0 - if `this` == `num`
	// -1 - if `this` < `num`
	BN.prototype.cmp = function cmp(num) {
	  if (this.negative !== 0 && num.negative === 0)
	    return -1;
	  else if (this.negative === 0 && num.negative !== 0)
	    return 1;

	  var res = this.ucmp(num);
	  if (this.negative !== 0)
	    return -res;
	  else
	    return res;
	};

	// Unsigned comparison
	BN.prototype.ucmp = function ucmp(num) {
	  // At this point both numbers have the same sign
	  if (this.length > num.length)
	    return 1;
	  else if (this.length < num.length)
	    return -1;

	  var res = 0;
	  for (var i = this.length - 1; i >= 0; i--) {
	    var a = this.words[i] | 0;
	    var b = num.words[i] | 0;

	    if (a === b)
	      continue;
	    if (a < b)
	      res = -1;
	    else if (a > b)
	      res = 1;
	    break;
	  }
	  return res;
	};

	//
	// A reduce context, could be using montgomery or something better, depending
	// on the `m` itself.
	//
	BN.red = function red(num) {
	  return new Red(num);
	};

	BN.prototype.toRed = function toRed(ctx) {
	  assert(!this.red, 'Already a number in reduction context');
	  assert(this.negative === 0, 'red works only with positives');
	  return ctx.convertTo(this)._forceRed(ctx);
	};

	BN.prototype.fromRed = function fromRed() {
	  assert(this.red, 'fromRed works only with numbers in reduction context');
	  return this.red.convertFrom(this);
	};

	BN.prototype._forceRed = function _forceRed(ctx) {
	  this.red = ctx;
	  return this;
	};

	BN.prototype.forceRed = function forceRed(ctx) {
	  assert(!this.red, 'Already a number in reduction context');
	  return this._forceRed(ctx);
	};

	BN.prototype.redAdd = function redAdd(num) {
	  assert(this.red, 'redAdd works only with red numbers');
	  return this.red.add(this, num);
	};

	BN.prototype.redIAdd = function redIAdd(num) {
	  assert(this.red, 'redIAdd works only with red numbers');
	  return this.red.iadd(this, num);
	};

	BN.prototype.redSub = function redSub(num) {
	  assert(this.red, 'redSub works only with red numbers');
	  return this.red.sub(this, num);
	};

	BN.prototype.redISub = function redISub(num) {
	  assert(this.red, 'redISub works only with red numbers');
	  return this.red.isub(this, num);
	};

	BN.prototype.redShl = function redShl(num) {
	  assert(this.red, 'redShl works only with red numbers');
	  return this.red.ushl(this, num);
	};

	BN.prototype.redMul = function redMul(num) {
	  assert(this.red, 'redMul works only with red numbers');
	  this.red._verify2(this, num);
	  return this.red.mul(this, num);
	};

	BN.prototype.redIMul = function redIMul(num) {
	  assert(this.red, 'redMul works only with red numbers');
	  this.red._verify2(this, num);
	  return this.red.imul(this, num);
	};

	BN.prototype.redSqr = function redSqr() {
	  assert(this.red, 'redSqr works only with red numbers');
	  this.red._verify1(this);
	  return this.red.sqr(this);
	};

	BN.prototype.redISqr = function redISqr() {
	  assert(this.red, 'redISqr works only with red numbers');
	  this.red._verify1(this);
	  return this.red.isqr(this);
	};

	// Square root over p
	BN.prototype.redSqrt = function redSqrt() {
	  assert(this.red, 'redSqrt works only with red numbers');
	  this.red._verify1(this);
	  return this.red.sqrt(this);
	};

	BN.prototype.redInvm = function redInvm() {
	  assert(this.red, 'redInvm works only with red numbers');
	  this.red._verify1(this);
	  return this.red.invm(this);
	};

	// Return negative clone of `this` % `red modulo`
	BN.prototype.redNeg = function redNeg() {
	  assert(this.red, 'redNeg works only with red numbers');
	  this.red._verify1(this);
	  return this.red.neg(this);
	};

	BN.prototype.redPow = function redPow(num) {
	  assert(this.red && !num.red, 'redPow(normalNum)');
	  this.red._verify1(this);
	  return this.red.pow(this, num);
	};

	// Prime numbers with efficient reduction
	var primes = {
	  k256: null,
	  p224: null,
	  p192: null,
	  p25519: null
	};

	// Pseudo-Mersenne prime
	function MPrime(name, p) {
	  // P = 2 ^ N - K
	  this.name = name;
	  this.p = new BN(p, 16);
	  this.n = this.p.bitLength();
	  this.k = new BN(1).iushln(this.n).isub(this.p);

	  this.tmp = this._tmp();
	}

	MPrime.prototype._tmp = function _tmp() {
	  var tmp = new BN(null);
	  tmp.words = new Array(Math.ceil(this.n / 13));
	  return tmp;
	};

	MPrime.prototype.ireduce = function ireduce(num) {
	  // Assumes that `num` is less than `P^2`
	  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	  var r = num;
	  var rlen;

	  do {
	    this.split(r, this.tmp);
	    r = this.imulK(r);
	    r = r.iadd(this.tmp);
	    rlen = r.bitLength();
	  } while (rlen > this.n);

	  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	  if (cmp === 0) {
	    r.words[0] = 0;
	    r.length = 1;
	  } else if (cmp > 0) {
	    r.isub(this.p);
	  } else {
	    r.strip();
	  }

	  return r;
	};

	MPrime.prototype.split = function split(input, out) {
	  input.iushrn(this.n, 0, out);
	};

	MPrime.prototype.imulK = function imulK(num) {
	  return num.imul(this.k);
	};

	function K256() {
	  MPrime.call(
	    this,
	    'k256',
	    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	}
	inherits(K256, MPrime);

	K256.prototype.split = function split(input, output) {
	  // 256 = 9 * 26 + 22
	  var mask = 0x3fffff;

	  var outLen = Math.min(input.length, 9);
	  for (var i = 0; i < outLen; i++)
	    output.words[i] = input.words[i];
	  output.length = outLen;

	  if (input.length <= 9) {
	    input.words[0] = 0;
	    input.length = 1;
	    return;
	  }

	  // Shift by 9 limbs
	  var prev = input.words[9];
	  output.words[output.length++] = prev & mask;

	  for (var i = 10; i < input.length; i++) {
	    var next = input.words[i] | 0;
	    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	    prev = next;
	  }
	  input.words[i - 10] = prev >>> 22;
	  input.length -= 9;
	};

	K256.prototype.imulK = function imulK(num) {
	  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	  num.words[num.length] = 0;
	  num.words[num.length + 1] = 0;
	  num.length += 2;

	  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	  var hi;
	  var lo = 0;
	  for (var i = 0; i < num.length; i++) {
	    var w = num.words[i] | 0;
	    hi = w * 0x40;
	    lo += w * 0x3d1;
	    hi += (lo / 0x4000000) | 0;
	    lo &= 0x3ffffff;

	    num.words[i] = lo;

	    lo = hi;
	  }

	  // Fast length reduction
	  if (num.words[num.length - 1] === 0) {
	    num.length--;
	    if (num.words[num.length - 1] === 0)
	      num.length--;
	  }
	  return num;
	};

	function P224() {
	  MPrime.call(
	    this,
	    'p224',
	    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	}
	inherits(P224, MPrime);

	function P192() {
	  MPrime.call(
	    this,
	    'p192',
	    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	}
	inherits(P192, MPrime);

	function P25519() {
	  // 2 ^ 255 - 19
	  MPrime.call(
	    this,
	    '25519',
	    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	}
	inherits(P25519, MPrime);

	P25519.prototype.imulK = function imulK(num) {
	  // K = 0x13
	  var carry = 0;
	  for (var i = 0; i < num.length; i++) {
	    var hi = (num.words[i] | 0) * 0x13 + carry;
	    var lo = hi & 0x3ffffff;
	    hi >>>= 26;

	    num.words[i] = lo;
	    carry = hi;
	  }
	  if (carry !== 0)
	    num.words[num.length++] = carry;
	  return num;
	};

	// Exported mostly for testing purposes, use plain name instead
	BN._prime = function prime(name) {
	  // Cached version of prime
	  if (primes[name])
	    return primes[name];

	  var prime;
	  if (name === 'k256')
	    prime = new K256();
	  else if (name === 'p224')
	    prime = new P224();
	  else if (name === 'p192')
	    prime = new P192();
	  else if (name === 'p25519')
	    prime = new P25519();
	  else
	    throw new Error('Unknown prime ' + name);
	  primes[name] = prime;

	  return prime;
	};

	//
	// Base reduction engine
	//
	function Red(m) {
	  if (typeof m === 'string') {
	    var prime = BN._prime(m);
	    this.m = prime.p;
	    this.prime = prime;
	  } else {
	    this.m = m;
	    this.prime = null;
	  }
	}

	Red.prototype._verify1 = function _verify1(a) {
	  assert(a.negative === 0, 'red works only with positives');
	  assert(a.red, 'red works only with red numbers');
	};

	Red.prototype._verify2 = function _verify2(a, b) {
	  assert((a.negative | b.negative) === 0, 'red works only with positives');
	  assert(a.red && a.red === b.red,
	         'red works only with red numbers');
	};

	Red.prototype.imod = function imod(a) {
	  if (this.prime)
	    return this.prime.ireduce(a)._forceRed(this);
	  return a.umod(this.m)._forceRed(this);
	};

	Red.prototype.neg = function neg(a) {
	  var r = a.clone();
	  r.negative ^= 1;
	  return r.iadd(this.m)._forceRed(this);
	};

	Red.prototype.add = function add(a, b) {
	  this._verify2(a, b);

	  var res = a.add(b);
	  if (res.cmp(this.m) >= 0)
	    res.isub(this.m);
	  return res._forceRed(this);
	};

	Red.prototype.iadd = function iadd(a, b) {
	  this._verify2(a, b);

	  var res = a.iadd(b);
	  if (res.cmp(this.m) >= 0)
	    res.isub(this.m);
	  return res;
	};

	Red.prototype.sub = function sub(a, b) {
	  this._verify2(a, b);

	  var res = a.sub(b);
	  if (res.cmpn(0) < 0)
	    res.iadd(this.m);
	  return res._forceRed(this);
	};

	Red.prototype.isub = function isub(a, b) {
	  this._verify2(a, b);

	  var res = a.isub(b);
	  if (res.cmpn(0) < 0)
	    res.iadd(this.m);
	  return res;
	};

	Red.prototype.shl = function shl(a, num) {
	  this._verify1(a);
	  return this.imod(a.ushln(num));
	};

	Red.prototype.imul = function imul(a, b) {
	  this._verify2(a, b);
	  return this.imod(a.imul(b));
	};

	Red.prototype.mul = function mul(a, b) {
	  this._verify2(a, b);
	  return this.imod(a.mul(b));
	};

	Red.prototype.isqr = function isqr(a) {
	  return this.imul(a, a);
	};

	Red.prototype.sqr = function sqr(a) {
	  return this.mul(a, a);
	};

	Red.prototype.sqrt = function sqrt(a) {
	  if (a.cmpn(0) === 0)
	    return a.clone();

	  var mod3 = this.m.andln(3);
	  assert(mod3 % 2 === 1);

	  // Fast case
	  if (mod3 === 3) {
	    var pow = this.m.add(new BN(1)).iushrn(2);
	    var r = this.pow(a, pow);
	    return r;
	  }

	  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	  //
	  // Find Q and S, that Q * 2 ^ S = (P - 1)
	  var q = this.m.subn(1);
	  var s = 0;
	  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
	    s++;
	    q.iushrn(1);
	  }
	  assert(q.cmpn(0) !== 0);

	  var one = new BN(1).toRed(this);
	  var nOne = one.redNeg();

	  // Find quadratic non-residue
	  // NOTE: Max is such because of generalized Riemann hypothesis.
	  var lpow = this.m.subn(1).iushrn(1);
	  var z = this.m.bitLength();
	  z = new BN(2 * z * z).toRed(this);
	  while (this.pow(z, lpow).cmp(nOne) !== 0)
	    z.redIAdd(nOne);

	  var c = this.pow(z, q);
	  var r = this.pow(a, q.addn(1).iushrn(1));
	  var t = this.pow(a, q);
	  var m = s;
	  while (t.cmp(one) !== 0) {
	    var tmp = t;
	    for (var i = 0; tmp.cmp(one) !== 0; i++)
	      tmp = tmp.redSqr();
	    assert(i < m);
	    var b = this.pow(c, new BN(1).iushln(m - i - 1));

	    r = r.redMul(b);
	    c = b.redSqr();
	    t = t.redMul(c);
	    m = i;
	  }

	  return r;
	};

	Red.prototype.invm = function invm(a) {
	  var inv = a._invmp(this.m);
	  if (inv.negative !== 0) {
	    inv.negative = 0;
	    return this.imod(inv).redNeg();
	  } else {
	    return this.imod(inv);
	  }
	};

	Red.prototype.pow = function pow(a, num) {
	  if (num.cmpn(0) === 0)
	    return new BN(1);
	  if (num.cmpn(1) === 0)
	    return a.clone();

	  var windowSize = 4;
	  var wnd = new Array(1 << windowSize);
	  wnd[0] = new BN(1).toRed(this);
	  wnd[1] = a;
	  for (var i = 2; i < wnd.length; i++)
	    wnd[i] = this.mul(wnd[i - 1], a);

	  var res = wnd[0];
	  var current = 0;
	  var currentLen = 0;
	  var start = num.bitLength() % 26;
	  if (start === 0)
	    start = 26;
	  for (var i = num.length - 1; i >= 0; i--) {
	    var word = num.words[i];
	    for (var j = start - 1; j >= 0; j--) {
	      var bit = (word >> j) & 1;
	      if (res !== wnd[0])
	        res = this.sqr(res);
	      if (bit === 0 && current === 0) {
	        currentLen = 0;
	        continue;
	      }

	      current <<= 1;
	      current |= bit;
	      currentLen++;
	      if (currentLen !== windowSize && (i !== 0 || j !== 0))
	        continue;

	      res = this.mul(res, wnd[current]);
	      currentLen = 0;
	      current = 0;
	    }
	    start = 26;
	  }

	  return res;
	};

	Red.prototype.convertTo = function convertTo(num) {
	  var r = num.umod(this.m);
	  if (r === num)
	    return r.clone();
	  else
	    return r;
	};

	Red.prototype.convertFrom = function convertFrom(num) {
	  var res = num.clone();
	  res.red = null;
	  return res;
	};

	//
	// Montgomery method engine
	//

	BN.mont = function mont(num) {
	  return new Mont(num);
	};

	function Mont(m) {
	  Red.call(this, m);

	  this.shift = this.m.bitLength();
	  if (this.shift % 26 !== 0)
	    this.shift += 26 - (this.shift % 26);
	  this.r = new BN(1).iushln(this.shift);
	  this.r2 = this.imod(this.r.sqr());
	  this.rinv = this.r._invmp(this.m);

	  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	  this.minv = this.minv.umod(this.r);
	  this.minv = this.r.sub(this.minv);
	}
	inherits(Mont, Red);

	Mont.prototype.convertTo = function convertTo(num) {
	  return this.imod(num.ushln(this.shift));
	};

	Mont.prototype.convertFrom = function convertFrom(num) {
	  var r = this.imod(num.mul(this.rinv));
	  r.red = null;
	  return r;
	};

	Mont.prototype.imul = function imul(a, b) {
	  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
	    a.words[0] = 0;
	    a.length = 1;
	    return a;
	  }

	  var t = a.imul(b);
	  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	  var u = t.isub(c).iushrn(this.shift);
	  var res = u;
	  if (u.cmp(this.m) >= 0)
	    res = u.isub(this.m);
	  else if (u.cmpn(0) < 0)
	    res = u.iadd(this.m);

	  return res._forceRed(this);
	};

	Mont.prototype.mul = function mul(a, b) {
	  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
	    return new BN(0)._forceRed(this);

	  var t = a.mul(b);
	  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	  var u = t.isub(c).iushrn(this.shift);
	  var res = u;
	  if (u.cmp(this.m) >= 0)
	    res = u.isub(this.m);
	  else if (u.cmpn(0) < 0)
	    res = u.iadd(this.m);

	  return res._forceRed(this);
	};

	Mont.prototype.invm = function invm(a) {
	  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	  var res = this.imod(a._invmp(this.m).mul(this.r2));
	  return res._forceRed(this);
	};

	})(typeof module === 'undefined' || module, this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	var bn = __webpack_require__(545);
	var brorand = __webpack_require__(547);

	function MillerRabin(rand) {
	  this.rand = rand || new brorand.Rand();
	}
	module.exports = MillerRabin;

	MillerRabin.create = function create(rand) {
	  return new MillerRabin(rand);
	};

	MillerRabin.prototype._rand = function _rand(n) {
	  var len = n.bitLength();
	  var buf = this.rand.generate(Math.ceil(len / 8));

	  // Set low bits
	  buf[0] |= 3;

	  // Mask high bits
	  var mask = len & 0x7;
	  if (mask !== 0)
	    buf[buf.length - 1] >>= 7 - mask;

	  return new bn(buf);
	}

	MillerRabin.prototype.test = function test(n, k, cb) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  var n2 = n1.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  var prime = true;
	  for (; k > 0; k--) {
	    var a = this._rand(n2);
	    if (cb)
	      cb(a);

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return false;
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s)
	      return false;
	  }

	  return prime;
	};

	MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  var n2 = n1.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  for (; k > 0; k--) {
	    var a = this._rand(n2);

	    var g = n.gcd(a);
	    if (g.cmpn(1) !== 0)
	      return g;

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return x.fromRed().subn(1).gcd(n);
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s) {
	      x = x.redSqr();
	      return x.fromRed().subn(1).gcd(n);
	    }
	  }

	  return false;
	};


/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	var r;

	module.exports = function rand(len) {
	  if (!r)
	    r = new Rand(null);

	  return r.generate(len);
	};

	function Rand(rand) {
	  this.rand = rand;
	}
	module.exports.Rand = Rand;

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	if (typeof window === 'object') {
	  if (window.crypto && window.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.msCrypto.getRandomValues(arr);
	      return arr;
	    };
	  } else {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js or Web worker
	  try {
	    var crypto = __webpack_require__(548);

	    Rand.prototype._rand = function _rand(n) {
	      return crypto.randomBytes(n);
	    };
	  } catch (e) {
	    // Emulate crypto API using randy
	    Rand.prototype._rand = function _rand(n) {
	      var res = new Uint8Array(n);
	      for (var i = 0; i < res.length; i++)
	        res[i] = this.rand.getByte();
	      return res;
	    };
	  }
	}


/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(549)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(551)

	exports.createHmac = __webpack_require__(560)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(561)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(550)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(205).Buffer))

/***/ },
/* 550 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(552)

	var md5 = toConstructor(__webpack_require__(557))
	var rmd160 = toConstructor(__webpack_require__(559))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(205).Buffer
	var Hash   = __webpack_require__(553)(Buffer)

	exports.sha1 = __webpack_require__(554)(Buffer, Hash)
	exports.sha256 = __webpack_require__(555)(Buffer, Hash)
	exports.sha512 = __webpack_require__(556)(Buffer, Hash)


/***/ },
/* 553 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(197).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(197).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(197).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(558);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(551)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(562)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 563 */
/***/ function(module, exports) {

	module.exports = {
		"modp1": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
		},
		"modp2": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
		},
		"modp5": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
		},
		"modp14": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
		},
		"modp15": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
		},
		"modp16": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
		},
		"modp17": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
		},
		"modp18": {
			"gen": "02",
			"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
		}
	};

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(545);
	var MillerRabin = __webpack_require__(546);
	var millerRabin = new MillerRabin();
	var TWENTYFOUR = new BN(24);
	var ELEVEN = new BN(11);
	var TEN = new BN(10);
	var THREE = new BN(3);
	var SEVEN = new BN(7);
	var primes = __webpack_require__(544);
	var randomBytes = __webpack_require__(308);
	module.exports = DH;

	function setPublicKey(pub, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(pub)) {
	    pub = new Buffer(pub, enc);
	  }
	  this._pub = new BN(pub);
	  return this;
	}

	function setPrivateKey(priv, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(priv)) {
	    priv = new Buffer(priv, enc);
	  }
	  this._priv = new BN(priv);
	  return this;
	}

	var primeCache = {};
	function checkPrime(prime, generator) {
	  var gen = generator.toString('hex');
	  var hex = [gen, prime.toString(16)].join('_');
	  if (hex in primeCache) {
	    return primeCache[hex];
	  }
	  var error = 0;

	  if (prime.isEven() ||
	    !primes.simpleSieve ||
	    !primes.fermatTest(prime) ||
	    !millerRabin.test(prime)) {
	    //not a prime so +1
	    error += 1;

	    if (gen === '02' || gen === '05') {
	      // we'd be able to check the generator
	      // it would fail so +8
	      error += 8;
	    } else {
	      //we wouldn't be able to test the generator
	      // so +4
	      error += 4;
	    }
	    primeCache[hex] = error;
	    return error;
	  }
	  if (!millerRabin.test(prime.shrn(1))) {
	    //not a safe prime
	    error += 2;
	  }
	  var rem;
	  switch (gen) {
	    case '02':
	      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
	        // unsuidable generator
	        error += 8;
	      }
	      break;
	    case '05':
	      rem = prime.mod(TEN);
	      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
	        // prime mod 10 needs to equal 3 or 7
	        error += 8;
	      }
	      break;
	    default:
	      error += 4;
	  }
	  primeCache[hex] = error;
	  return error;
	}

	function DH(prime, generator, malleable) {
	  this.setGenerator(generator);
	  this.__prime = new BN(prime);
	  this._prime = BN.mont(this.__prime);
	  this._primeLen = prime.length;
	  this._pub = undefined;
	  this._priv = undefined;
	  this._primeCode = undefined;
	  if (malleable) {
	    this.setPublicKey = setPublicKey;
	    this.setPrivateKey = setPrivateKey;
	  } else {
	    this._primeCode = 8;
	  }
	}
	Object.defineProperty(DH.prototype, 'verifyError', {
	  enumerable: true,
	  get: function () {
	    if (typeof this._primeCode !== 'number') {
	      this._primeCode = checkPrime(this.__prime, this.__gen);
	    }
	    return this._primeCode;
	  }
	});
	DH.prototype.generateKeys = function () {
	  if (!this._priv) {
	    this._priv = new BN(randomBytes(this._primeLen));
	  }
	  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
	  return this.getPublicKey();
	};

	DH.prototype.computeSecret = function (other) {
	  other = new BN(other);
	  other = other.toRed(this._prime);
	  var secret = other.redPow(this._priv).fromRed();
	  var out = new Buffer(secret.toArray());
	  var prime = this.getPrime();
	  if (out.length < prime.length) {
	    var front = new Buffer(prime.length - out.length);
	    front.fill(0);
	    out = Buffer.concat([front, out]);
	  }
	  return out;
	};

	DH.prototype.getPublicKey = function getPublicKey(enc) {
	  return formatReturnValue(this._pub, enc);
	};

	DH.prototype.getPrivateKey = function getPrivateKey(enc) {
	  return formatReturnValue(this._priv, enc);
	};

	DH.prototype.getPrime = function (enc) {
	  return formatReturnValue(this.__prime, enc);
	};

	DH.prototype.getGenerator = function (enc) {
	  return formatReturnValue(this._gen, enc);
	};

	DH.prototype.setGenerator = function (gen, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer.isBuffer(gen)) {
	    gen = new Buffer(gen, enc);
	  }
	  this.__gen = gen;
	  this._gen = new BN(gen);
	  return this;
	};

	function formatReturnValue(bn, enc) {
	  var buf = new Buffer(bn.toArray());
	  if (!enc) {
	    return buf;
	  } else {
	    return buf.toString(enc);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var _algos = __webpack_require__(514)
	var createHash = __webpack_require__(277)
	var inherits = __webpack_require__(199)
	var sign = __webpack_require__(566)
	var stream = __webpack_require__(290)
	var verify = __webpack_require__(612)

	var algos = {}
	Object.keys(_algos).forEach(function (key) {
	  algos[key] = algos[key.toLowerCase()] = _algos[key]
	})

	function Sign (algorithm) {
	  stream.Writable.call(this)

	  var data = algos[algorithm]
	  if (!data) {
	    throw new Error('Unknown message digest')
	  }

	  this._hashType = data.hash
	  this._hash = createHash(data.hash)
	  this._tag = data.id
	  this._signType = data.sign
	}
	inherits(Sign, stream.Writable)

	Sign.prototype._write = function _write (data, _, done) {
	  this._hash.update(data)
	  done()
	}

	Sign.prototype.update = function update (data, enc) {
	  if (typeof data === 'string') {
	    data = new Buffer(data, enc)
	  }

	  this._hash.update(data)
	  return this
	}

	Sign.prototype.sign = function signMethod (key, enc) {
	  this.end()
	  var hash = this._hash.digest()
	  var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)

	  return enc ? sig.toString(enc) : sig
	}

	function Verify (algorithm) {
	  stream.Writable.call(this)

	  var data = algos[algorithm]
	  if (!data) {
	    throw new Error('Unknown message digest')
	  }

	  this._hash = createHash(data.hash)
	  this._tag = data.id
	  this._signType = data.sign
	}
	inherits(Verify, stream.Writable)

	Verify.prototype._write = function _write (data, _, done) {
	  this._hash.update(data)

	  done()
	}

	Verify.prototype.update = function update (data, enc) {
	  if (typeof data === 'string') {
	    data = new Buffer(data, enc)
	  }

	  this._hash.update(data)
	  return this
	}

	Verify.prototype.verify = function verifyMethod (key, sig, enc) {
	  if (typeof sig === 'string') {
	    sig = new Buffer(sig, enc)
	  }

	  this.end()
	  var hash = this._hash.digest()

	  return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)
	}

	function createSign (algorithm) {
	  return new Sign(algorithm)
	}

	function createVerify (algorithm) {
	  return new Verify(algorithm)
	}

	module.exports = {
	  Sign: createSign,
	  Verify: createVerify,
	  createSign: createSign,
	  createVerify: createVerify
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
	var createHmac = __webpack_require__(305)
	var crt = __webpack_require__(567)
	var curves = __webpack_require__(568)
	var elliptic = __webpack_require__(569)
	var parseKeys = __webpack_require__(592)

	var BN = __webpack_require__(545)
	var EC = elliptic.ec

	function sign (hash, key, hashType, signType) {
	  var priv = parseKeys(key)
	  if (priv.curve) {
	    if (signType !== 'ecdsa') throw new Error('wrong private key type')

	    return ecSign(hash, priv)
	  } else if (priv.type === 'dsa') {
	    if (signType !== 'dsa') {
	      throw new Error('wrong private key type')
	    }
	    return dsaSign(hash, priv, hashType)
	  } else {
	    if (signType !== 'rsa') throw new Error('wrong private key type')
	  }

	  var len = priv.modulus.byteLength()
	  var pad = [ 0, 1 ]
	  while (hash.length + pad.length + 1 < len) {
	    pad.push(0xff)
	  }
	  pad.push(0x00)
	  var i = -1
	  while (++i < hash.length) {
	    pad.push(hash[i])
	  }

	  var out = crt(pad, priv)
	  return out
	}

	function ecSign (hash, priv) {
	  var curveId = curves[priv.curve.join('.')]
	  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

	  var curve = new EC(curveId)
	  var key = curve.genKeyPair()

	  key._importPrivate(priv.privateKey)
	  var out = key.sign(hash)

	  return new Buffer(out.toDER())
	}

	function dsaSign (hash, priv, algo) {
	  var x = priv.params.priv_key
	  var p = priv.params.p
	  var q = priv.params.q
	  var g = priv.params.g
	  var r = new BN(0)
	  var k
	  var H = bits2int(hash, q).mod(q)
	  var s = false
	  var kv = getKey(x, q, hash, algo)
	  while (s === false) {
	    k = makeKey(q, kv, algo)
	    r = makeR(g, k, p, q)
	    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
	    if (!s.cmpn(0)) {
	      s = false
	      r = new BN(0)
	    }
	  }
	  return toDER(r, s)
	}

	function toDER (r, s) {
	  r = r.toArray()
	  s = s.toArray()

	  // Pad values
	  if (r[0] & 0x80) {
	    r = [ 0 ].concat(r)
	  }
	  // Pad values
	  if (s[0] & 0x80) {
	    s = [0].concat(s)
	  }

	  var total = r.length + s.length + 4
	  var res = [ 0x30, total, 0x02, r.length ]
	  res = res.concat(r, [ 0x02, s.length ], s)
	  return new Buffer(res)
	}

	function getKey (x, q, hash, algo) {
	  x = new Buffer(x.toArray())
	  if (x.length < q.byteLength()) {
	    var zeros = new Buffer(q.byteLength() - x.length)
	    zeros.fill(0)
	    x = Buffer.concat([zeros, x])
	  }
	  var hlen = hash.length
	  var hbits = bits2octets(hash, q)
	  var v = new Buffer(hlen)
	  v.fill(1)
	  var k = new Buffer(hlen)
	  k.fill(0)
	  k = createHmac(algo, k)
	    .update(v)
	    .update(new Buffer([0]))
	    .update(x)
	    .update(hbits)
	    .digest()
	  v = createHmac(algo, k)
	    .update(v)
	    .digest()
	  k = createHmac(algo, k)
	    .update(v)
	    .update(new Buffer([1]))
	    .update(x)
	    .update(hbits)
	    .digest()
	  v = createHmac(algo, k)
	    .update(v)
	    .digest()
	  return {
	    k: k,
	    v: v
	  }
	}

	function bits2int (obits, q) {
	  var bits = new BN(obits)
	  var shift = (obits.length << 3) - q.bitLength()
	  if (shift > 0) {
	    bits.ishrn(shift)
	  }
	  return bits
	}

	function bits2octets (bits, q) {
	  bits = bits2int(bits, q)
	  bits = bits.mod(q)
	  var out = new Buffer(bits.toArray())
	  if (out.length < q.byteLength()) {
	    var zeros = new Buffer(q.byteLength() - out.length)
	    zeros.fill(0)
	    out = Buffer.concat([zeros, out])
	  }
	  return out
	}

	function makeKey (q, kv, algo) {
	  var t, k

	  do {
	    t = new Buffer('')

	    while (t.length * 8 < q.bitLength()) {
	      kv.v = createHmac(algo, kv.k)
	        .update(kv.v)
	        .digest()
	      t = Buffer.concat([t, kv.v])
	    }

	    k = bits2int(t, q)
	    kv.k = createHmac(algo, kv.k)
	      .update(kv.v)
	      .update(new Buffer([0]))
	      .digest()
	    kv.v = createHmac(algo, kv.k)
	      .update(kv.v)
	      .digest()
	  } while (k.cmp(q) !== -1)

	  return k
	}

	function makeR (g, k, p, q) {
	  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
	}

	module.exports = sign
	module.exports.getKey = getKey
	module.exports.makeKey = makeKey

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(545);
	var randomBytes = __webpack_require__(308);
	module.exports = crt;
	function blind(priv) {
	  var r = getr(priv);
	  var blinder = r.toRed(bn.mont(priv.modulus))
	  .redPow(new bn(priv.publicExponent)).fromRed();
	  return {
	    blinder: blinder,
	    unblinder:r.invm(priv.modulus)
	  };
	}
	function crt(msg, priv) {
	  var blinds = blind(priv);
	  var len = priv.modulus.byteLength();
	  var mod = bn.mont(priv.modulus);
	  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
	  var c1 = blinded.toRed(bn.mont(priv.prime1));
	  var c2 = blinded.toRed(bn.mont(priv.prime2));
	  var qinv = priv.coefficient;
	  var p = priv.prime1;
	  var q = priv.prime2;
	  var m1 = c1.redPow(priv.exponent1);
	  var m2 = c2.redPow(priv.exponent2);
	  m1 = m1.fromRed();
	  m2 = m2.fromRed();
	  var h = m1.isub(m2).imul(qinv).umod(p);
	  h.imul(q);
	  m2.iadd(h);
	  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
	}
	crt.getr = getr;
	function getr(priv) {
	  var len = priv.modulus.byteLength();
	  var r = new bn(randomBytes(len));
	  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
	    r = new bn(randomBytes(len));
	  }
	  return r;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 568 */
/***/ function(module, exports) {

	'use strict'
	exports['1.3.132.0.10'] = 'secp256k1'

	exports['1.3.132.0.33'] = 'p224'

	exports['1.2.840.10045.3.1.1'] = 'p192'

	exports['1.2.840.10045.3.1.7'] = 'p256'

	exports['1.3.132.0.34'] = 'p384'

	exports['1.3.132.0.35'] = 'p521'


/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var elliptic = exports;

	elliptic.version = __webpack_require__(570).version;
	elliptic.utils = __webpack_require__(571);
	elliptic.rand = __webpack_require__(547);
	elliptic.hmacDRBG = __webpack_require__(572);
	elliptic.curve = __webpack_require__(579);
	elliptic.curves = __webpack_require__(584);

	// Protocols
	elliptic.ec = __webpack_require__(586);
	elliptic.eddsa = __webpack_require__(589);


/***/ },
/* 570 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"elliptic@^6.0.0",
				"E:\\Programs\\Jenkins\\jobs\\kaiwa\\workspace\\node_modules\\browserify-sign"
			]
		],
		"_from": "elliptic@>=6.0.0 <7.0.0",
		"_id": "elliptic@6.0.2",
		"_inCache": true,
		"_installable": true,
		"_location": "/elliptic",
		"_nodeVersion": "5.0.0",
		"_npmUser": {
			"email": "fedor@indutny.com",
			"name": "indutny"
		},
		"_npmVersion": "3.3.6",
		"_phantomChildren": {},
		"_requested": {
			"name": "elliptic",
			"raw": "elliptic@^6.0.0",
			"rawSpec": "^6.0.0",
			"scope": null,
			"spec": ">=6.0.0 <7.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/browserify-sign",
			"/create-ecdh"
		],
		"_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz",
		"_shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
		"_shrinkwrap": null,
		"_spec": "elliptic@^6.0.0",
		"_where": "E:\\Programs\\Jenkins\\jobs\\kaiwa\\workspace\\node_modules\\browserify-sign",
		"author": {
			"email": "fedor@indutny.com",
			"name": "Fedor Indutny"
		},
		"bugs": {
			"url": "https://github.com/indutny/elliptic/issues"
		},
		"dependencies": {
			"bn.js": "^4.0.0",
			"brorand": "^1.0.1",
			"hash.js": "^1.0.0",
			"inherits": "^2.0.1"
		},
		"description": "EC cryptography",
		"devDependencies": {
			"browserify": "^3.44.2",
			"coveralls": "^2.11.3",
			"istanbul": "^0.3.17",
			"jscs": "^1.11.3",
			"jshint": "^2.6.0",
			"mocha": "^2.1.0",
			"uglify-js": "^2.4.13"
		},
		"directories": {},
		"dist": {
			"shasum": "219b96cd92aa9885d91d31c1fd42eaa5eb4483a9",
			"tarball": "http://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz"
		},
		"files": [
			"lib"
		],
		"gitHead": "330106da186712d228d79bc71ae8e7e68565fa9d",
		"homepage": "https://github.com/indutny/elliptic",
		"keywords": [
			"Cryptography",
			"EC",
			"Elliptic",
			"curve"
		],
		"license": "MIT",
		"main": "lib/elliptic.js",
		"maintainers": [
			{
				"name": "indutny",
				"email": "fedor@indutny.com"
			}
		],
		"name": "elliptic",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/indutny/elliptic.git"
		},
		"scripts": {
			"coveralls": "cat ./coverage/lcov.info | coveralls",
			"test": "make lint && istanbul test _mocha --reporter=spec test/*-test.js"
		},
		"version": "6.0.2"
	};

/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = exports;
	var bn = __webpack_require__(545);

	utils.assert = function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	};

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg !== 'string') {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	    return res;
	  }
	  if (!enc) {
	    for (var i = 0; i < msg.length; i++) {
	      var c = msg.charCodeAt(i);
	      var hi = c >> 8;
	      var lo = c & 0xff;
	      if (hi)
	        res.push(hi, lo);
	      else
	        res.push(lo);
	    }
	  } else if (enc === 'hex') {
	    msg = msg.replace(/[^a-z0-9]+/ig, '');
	    if (msg.length % 2 !== 0)
	      msg = '0' + msg;
	    for (var i = 0; i < msg.length; i += 2)
	      res.push(parseInt(msg[i] + msg[i + 1], 16));
	  }
	  return res;
	}
	utils.toArray = toArray;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	};

	// Represent num in a w-NAF form
	function getNAF(num, w) {
	  var naf = [];
	  var ws = 1 << (w + 1);
	  var k = num.clone();
	  while (k.cmpn(1) >= 0) {
	    var z;
	    if (k.isOdd()) {
	      var mod = k.andln(ws - 1);
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }
	    naf.push(z);

	    // Optimization, shift by word if possible
	    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
	    for (var i = 1; i < shift; i++)
	      naf.push(0);
	    k.iushrn(shift);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    []
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      var m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      var m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.iushrn(1);
	    k2.iushrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;

	function cachedProperty(obj, computer) {
	  var name = computer.name;
	  var key = '_' + name;
	  obj.prototype[name] = function cachedProperty() {
	    return this[key] !== undefined ? this[key] :
	           this[key] = computer.call(this);
	  };
	}
	utils.cachedProperty = cachedProperty;

	function parseBytes(bytes) {
	  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
	                                     bytes;
	}
	utils.parseBytes = parseBytes;

	function intFromLE(bytes) {
	  return new bn(bytes, 'hex', 'le');
	}
	utils.intFromLE = intFromLE;



/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hash = __webpack_require__(573);
	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this.reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils.toArray(options.entropy, options.entropyEnc);
	  var nonce = utils.toArray(options.nonce, options.nonceEnc);
	  var pers = utils.toArray(options.pers, options.persEnc);
	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	module.exports = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this.reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils.toBuffer(entropy, entropyEnc);
	  add = utils.toBuffer(add, addEnc);

	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this.reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this.reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils.toArray(add, addEnc);
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this.reseed++;
	  return utils.encode(res, enc);
	};


/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	var hash = exports;

	hash.utils = __webpack_require__(574);
	hash.common = __webpack_require__(575);
	hash.sha = __webpack_require__(576);
	hash.ripemd = __webpack_require__(577);
	hash.hmac = __webpack_require__(578);

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;


/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	var utils = exports;
	var inherits = __webpack_require__(199);

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        var hi = c >> 8;
	        var lo = c & 0xff;
	        if (hi)
	          res.push(hi, lo);
	        else
	          res.push(lo);
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (var i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	utils.htonl = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	utils.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils.split32 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils.rotr32 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils.rotl32 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	utils.sum32 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	utils.sum32_3 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	utils.sum32_4 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	utils.sum32_5 = sum32_5;

	function assert(cond, msg) {
	  if (!cond)
	    throw new Error(msg || 'Assertion failed');
	}
	utils.assert = assert;

	utils.inherits = inherits;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	exports.sum64 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	};
	exports.sum64_hi = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	};
	exports.sum64_lo = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	};
	exports.sum64_4_hi = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	};
	exports.sum64_4_lo = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	};
	exports.sum64_5_hi = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	};
	exports.sum64_5_lo = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	};
	exports.rotr64_hi = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	};
	exports.rotr64_lo = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	};
	exports.shr64_hi = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	};
	exports.shr64_lo = shr64_lo;


/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(573);
	var utils = hash.utils;
	var assert = utils.assert;

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	exports.BlockHash = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};


/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(573);
	var utils = hash.utils;
	var assert = utils.assert;

	var rotr32 = utils.rotr32;
	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_4 = utils.sum32_4;
	var sum32_5 = utils.sum32_5;
	var rotr64_hi = utils.rotr64_hi;
	var rotr64_lo = utils.rotr64_lo;
	var shr64_hi = utils.shr64_hi;
	var shr64_lo = utils.shr64_lo;
	var sum64 = utils.sum64;
	var sum64_hi = utils.sum64_hi;
	var sum64_lo = utils.sum64_lo;
	var sum64_4_hi = utils.sum64_4_hi;
	var sum64_4_lo = utils.sum64_4_lo;
	var sum64_5_hi = utils.sum64_5_hi;
	var sum64_5_lo = utils.sum64_5_lo;
	var BlockHash = hash.common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash.call(this);
	  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils.inherits(SHA256, BlockHash);
	exports.sha256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32(T1, T2);
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	  this.h[5] = sum32(this.h[5], f);
	  this.h[6] = sum32(this.h[6], g);
	  this.h[7] = sum32(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils.inherits(SHA224, SHA256);
	exports.sha224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils.split32(this.h.slice(0, 7), 'big');
	};

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash.call(this);
	  this.h = [ 0x6a09e667, 0xf3bcc908,
	             0xbb67ae85, 0x84caa73b,
	             0x3c6ef372, 0xfe94f82b,
	             0xa54ff53a, 0x5f1d36f1,
	             0x510e527f, 0xade682d1,
	             0x9b05688c, 0x2b3e6c1f,
	             0x1f83d9ab, 0xfb41bd6b,
	             0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils.inherits(SHA512, BlockHash);
	exports.sha512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi(c0_hi, c0_lo,
	                      c1_hi, c1_lo,
	                      c2_hi, c2_lo,
	                      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
	                          c1_hi, c1_lo,
	                          c2_hi, c2_lo,
	                          c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
	                           c1_hi, c1_lo,
	                           c2_hi, c2_lo,
	                           c3_hi, c3_lo,
	                           c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
	                           c1_hi, c1_lo,
	                           c2_hi, c2_lo,
	                           c3_hi, c3_lo,
	                           c4_hi, c4_lo);

	    var c0_hi = s0_512_hi(ah, al);
	    var c0_lo = s0_512_lo(ah, al);
	    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
	    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64(this.h, 0, ah, al);
	  sum64(this.h, 2, bh, bl);
	  sum64(this.h, 4, ch, cl);
	  sum64(this.h, 6, dh, dl);
	  sum64(this.h, 8, eh, el);
	  sum64(this.h, 10, fh, fl);
	  sum64(this.h, 12, gh, gl);
	  sum64(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  SHA512.call(this);
	  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
	             0x629a292a, 0x367cd507,
	             0x9159015a, 0x3070dd17,
	             0x152fecd8, 0xf70e5939,
	             0x67332667, 0xffc00b31,
	             0x8eb44a87, 0x68581511,
	             0xdb0c2e0d, 0x64f98fa7,
	             0x47b5481d, 0xbefa4fa4 ];
	}
	utils.inherits(SHA384, SHA512);
	exports.sha384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils.split32(this.h.slice(0, 12), 'big');
	};

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash.call(this);
	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
	             0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils.inherits(SHA1, BlockHash);
	exports.sha1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (var i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}

	function s0_256(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}

	function s1_256(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}

	function g0_256(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}

	function g1_256(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}

	function ch64_hi(xh, xl, yh, yl, zh, zl) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh, zl) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 28);
	  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 28);
	  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 14);
	  var c1_hi = rotr64_hi(xh, xl, 18);
	  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 14);
	  var c1_lo = rotr64_lo(xh, xl, 18);
	  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 1);
	  var c1_hi = rotr64_hi(xh, xl, 8);
	  var c2_hi = shr64_hi(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 1);
	  var c1_lo = rotr64_lo(xh, xl, 8);
	  var c2_lo = shr64_lo(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 19);
	  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 19);
	  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}


/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(573);
	var utils = hash.utils;

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_3 = utils.sum32_3;
	var sum32_4 = utils.sum32_4;
	var BlockHash = hash.common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils.inherits(RIPEMD160, BlockHash);
	exports.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'little');
	  else
	    return utils.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];


/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	var hmac = exports;

	var hash = __webpack_require__(573);
	var utils = hash.utils;
	var assert = utils.assert;

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils.toArray(key, enc));
	}
	module.exports = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};


/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var curve = exports;

	curve.base = __webpack_require__(580);
	curve.short = __webpack_require__(581);
	curve.mont = __webpack_require__(582);
	curve.edwards = __webpack_require__(583);


/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bn = __webpack_require__(545);
	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var getNAF = utils.getNAF;
	var getJSF = utils.getJSF;
	var assert = utils.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new bn(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

	  // Useful for many curves
	  this.zero = new bn(0).toRed(this.red);
	  this.one = new bn(1).toRed(this.red);
	  this.two = new bn(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new bn(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);
	}
	module.exports = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  for (var j = 0; j < naf.length; j += doubles.step) {
	    var nafW = 0;
	    for (var k = j + doubles.step - 1; k >= j; k--)
	      nafW = (nafW << 1) + naf[k];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (var j = 0; j < repr.length; j++) {
	      var nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var k = 0; i >= 0 && naf[i] === 0; i--)
	      k++;
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	                                                       points,
	                                                       coeffs,
	                                                       len) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  for (var i = 0; i < len; i++) {
	    var p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (var i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a]);
	      naf[b] = getNAF(coeffs[b], wndWidth[b]);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b] /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (var j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (var i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (var j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (var j = 0; j < len; j++) {
	      var z = tmp[j];
	      var p;
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (var i = 0; i < len; i++)
	    wnd[i] = null;
	  return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils.toArray(bytes, enc);

	  var len = this.p.byteLength();
	  if (bytes[0] === 0x04 && bytes.length - 1 === 2 * len) {
	    return this.point(bytes.slice(1, 1 + len),
	                      bytes.slice(1 + len, 1 + 2 * len));
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};


/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var curve = __webpack_require__(579);
	var elliptic = __webpack_require__(569);
	var bn = __webpack_require__(545);
	var inherits = __webpack_require__(199);
	var Base = curve.base;

	var assert = elliptic.utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	module.exports = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new bn(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new bn(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new bn(vec.a, 16),
	        b: new bn(vec.b, 16)
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : bn.mont(num);
	  var tinv = new bn(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new bn(1);
	  var y1 = new bn(0);
	  var x2 = new bn(0);
	  var y2 = new bn(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 }
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs) {
	  var npoints = this._endoWnafT1;
	  var ncoeffs = this._endoWnafT2;
	  for (var i = 0; i < points.length; i++) {
	    var split = this._endoSplit(coeffs[i]);
	    var p = points[i];
	    var beta = p._getBeta();

	    if (split.k1.negative) {
	      split.k1.ineg();
	      p = p.neg(true);
	    }
	    if (split.k2.negative) {
	      split.k2.ineg();
	      beta = beta.neg(true);
	    }

	    npoints[i * 2] = p;
	    npoints[i * 2 + 1] = beta;
	    ncoeffs[i * 2] = split.k1;
	    ncoeffs[i * 2 + 1] = split.k2;
	  }
	  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

	  // Clean-up references to points and coefficients
	  for (var j = 0; j < i * 2; j++) {
	    npoints[j] = null;
	    ncoeffs[j] = null;
	  }
	  return res;
	};

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul)
	      }
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1)
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1)
	    }
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point))
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point))
	    }
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new bn(k, 16);

	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate)
	      }
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new bn(0);
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = new bn(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (var i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (var i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new bn(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};


/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var curve = __webpack_require__(579);
	var bn = __webpack_require__(545);
	var inherits = __webpack_require__(199);
	var Base = curve.base;

	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.i4 = new bn(4).toRed(this.red).redInvm();
	  this.two = new bn(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	module.exports = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new bn(x, 16);
	    this.z = new bn(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};


/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var curve = __webpack_require__(579);
	var elliptic = __webpack_require__(569);
	var bn = __webpack_require__(545);
	var inherits = __webpack_require__(199);
	var Base = curve.base;

	var assert = elliptic.utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new bn(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new bn(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new bn(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits(EdwardsCurve, Base);
	module.exports = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y = rhs.redMul(lhs.redInvm()).redSqrt();
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new bn(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - 1) / (d y^2 + 1)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.one);
	  var rhs = y2.redMul(this.d).redAdd(this.one);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = z ? new bn(z, 16) : this.curve.one;
	    this.t = t && new bn(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	         this.y.cmp(this.z) === 0;
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // E = a * C
	    var e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      var h = this.z.redSqr();
	      // J = F - 2 * H
	      var j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    var e = c.redAdd(d);
	    // H = (c * Z1)^2
	    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
	    // J = E - 2 * H
	    var j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	                          this.y,
	                          this.z,
	                          this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;


/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var curves = exports;

	var hash = __webpack_require__(573);
	var elliptic = __webpack_require__(569);

	var assert = elliptic.utils.assert;

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new elliptic.curve.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new elliptic.curve.edwards(options);
	  else
	    this.curve = new elliptic.curve.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve
	      });
	      return curve;
	    }
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
	  ]
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
	  ]
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
	  ]
	});

	defineCurve('p384', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 ffffffff',
	  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 fffffffc',
	  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
	     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
	  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
	     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
	  hash: hash.sha384,
	  gRed: false,
	  g: [
	    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
	    '5502f25d bf55296c 3a545e38 72760ab7',
	    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
	    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
	  ]
	});

	defineCurve('p521', {
	  type: 'short',
	  prime: null,
	  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff',
	  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff fffffffc',
	  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
	     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
	     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
	  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
	     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
	  hash: hash.sha512,
	  gRed: false,
	  g: [
	    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
	    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
	    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
	    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
	    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
	    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
	  ]
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '0',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '9'
	  ]
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658'
	  ]
	});

	var pre;
	try {
	  pre = __webpack_require__(585);
	} catch (e) {
	  pre = undefined;
	}

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3'
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15'
	    }
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    pre
	  ]
	});


/***/ },
/* 585 */
/***/ function(module, exports) {

	module.exports = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
	      ]
	    ]
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
	      ]
	    ]
	  }
	};


/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bn = __webpack_require__(545);
	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;

	var KeyPair = __webpack_require__(587);
	var Signature = __webpack_require__(588);

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

	    options = elliptic.curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof elliptic.curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	module.exports = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new KeyPair(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return KeyPair.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return KeyPair.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
	    nonce: this.n.toArray()
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new bn(2));
	  do {
	    var priv = new bn(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  } while (true);
	};

	EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new bn(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray();
	  for (var i = bkey.length; i < bytes; i++)
	    bkey.unshift(0);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray();
	  for (var i = nonce.length; i < bytes; i++)
	    nonce.unshift(0);

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new bn(1));
	  do {
	    var k = new bn(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
	  } while (true);
	};

	EC.prototype.verify = function verify(msg, signature, key, enc) {
	  msg = this._truncateToN(new bn(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);

	  var p = this.g.mulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  return p.getX().umod(this.n).cmp(r) === 0;
	};

	EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
	  assert((3 & j) === j, 'The recovery param is more than two bits');
	  signature = new Signature(signature, enc);

	  var n = this.n;
	  var e = new bn(msg);
	  var r = signature.r;
	  var s = signature.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var eNeg = n.sub(e);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  var rInv = signature.r.invm(n);
	  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
	  signature = new Signature(signature, enc);
	  if (signature.recoveryParam !== null)
	    return signature.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime = this.recoverPubKey(e, signature, i);

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};


/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bn = __webpack_require__(545);

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	module.exports = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new bn(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};


/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bn = __webpack_require__(545);

	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert(options.r && options.s, 'Signature without r or s');
	  this.r = new bn(options.r, 16);
	  this.s = new bn(options.s, 16);
	  if (options.recoveryParam !== null)
	    this.recoveryParam = options.recoveryParam;
	  else
	    this.recoveryParam = null;
	}
	module.exports = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;
	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	  }
	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0 && (r[1] & 0x80)) {
	    r = r.slice(1);
	  }
	  if (s[0] === 0 && (s[1] & 0x80)) {
	    s = s.slice(1);
	  }

	  this.r = new bn(r);
	  this.s = new bn(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils.encode(res, enc);
	};


/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hash = __webpack_require__(573);
	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = __webpack_require__(590);
	var Signature = __webpack_require__(591);

	function EDDSA(curve) {
	  assert(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  var curve = elliptic.curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	module.exports = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	               .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};


/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var cachedProperty = utils.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair)
	    return pub;
	  return new KeyPair(eddsa, { pub: pub });
	};

	KeyPair.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair)
	    return secret;
	  return new KeyPair(eddsa, { secret: secret });
	};

	KeyPair.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair, function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair, function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair, function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair, function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair, function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair, function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair.prototype.sign = function sign(message) {
	  assert(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair.prototype.getSecret = function getSecret(enc) {
	  assert(this._secret, 'KeyPair is public only');
	  return utils.encode(this.secret(), enc);
	};

	KeyPair.prototype.getPublic = function getPublic(enc) {
	  return utils.encode(this.pubBytes(), enc);
	};

	module.exports = KeyPair;


/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bn = __webpack_require__(545);
	var elliptic = __webpack_require__(569);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var cachedProperty = utils.cachedProperty;
	var parseBytes = utils.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength)
	    };
	  }

	  assert(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof bn)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature, function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature, function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature, function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature, function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature.prototype.toHex = function toHex() {
	  return utils.encode(this.toBytes(), 'hex').toUpperCase();
	};

	module.exports = Signature;


/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(593)
	var aesid = __webpack_require__(610)
	var fixProc = __webpack_require__(611)
	var ciphers = __webpack_require__(518)
	var compat = __webpack_require__(515)
	module.exports = parseKeys

	function parseKeys (buffer) {
	  var password
	  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
	    password = buffer.passphrase
	    buffer = buffer.key
	  }
	  if (typeof buffer === 'string') {
	    buffer = new Buffer(buffer)
	  }

	  var stripped = fixProc(buffer, password)

	  var type = stripped.tag
	  var data = stripped.data
	  var subtype, ndata
	  switch (type) {
	    case 'PUBLIC KEY':
	      ndata = asn1.PublicKey.decode(data, 'der')
	      subtype = ndata.algorithm.algorithm.join('.')
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
	        case '1.2.840.10045.2.1':
	          ndata.subjectPrivateKey = ndata.subjectPublicKey
	          return {
	            type: 'ec',
	            data: ndata
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
	          return {
	            type: 'dsa',
	            data: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'ENCRYPTED PRIVATE KEY':
	      data = asn1.EncryptedPrivateKey.decode(data, 'der')
	      data = decrypt(data, password)
	      // falls through
	    case 'PRIVATE KEY':
	      ndata = asn1.PrivateKey.decode(data, 'der')
	      subtype = ndata.algorithm.algorithm.join('.')
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
	        case '1.2.840.10045.2.1':
	          return {
	            curve: ndata.algorithm.curve,
	            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
	          return {
	            type: 'dsa',
	            params: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'RSA PUBLIC KEY':
	      return asn1.RSAPublicKey.decode(data, 'der')
	    case 'RSA PRIVATE KEY':
	      return asn1.RSAPrivateKey.decode(data, 'der')
	    case 'DSA PRIVATE KEY':
	      return {
	        type: 'dsa',
	        params: asn1.DSAPrivateKey.decode(data, 'der')
	      }
	    case 'EC PRIVATE KEY':
	      data = asn1.ECPrivateKey.decode(data, 'der')
	      return {
	        curve: data.parameters.value,
	        privateKey: data.privateKey
	      }
	    default: throw new Error('unknown key type ' + type)
	  }
	}
	parseKeys.signature = asn1.signature
	function decrypt (data, password) {
	  var salt = data.algorithm.decrypt.kde.kdeparams.salt
	  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
	  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
	  var iv = data.algorithm.decrypt.cipher.iv
	  var cipherText = data.subjectPrivateKey
	  var keylen = parseInt(algo.split('-')[1], 10) / 8
	  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
	  var cipher = ciphers.createDecipheriv(algo, key, iv)
	  var out = []
	  out.push(cipher.update(cipherText))
	  out.push(cipher.final())
	  return Buffer.concat(out)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
	// Fedor, you are amazing.

	var asn1 = __webpack_require__(594)

	var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('modulus').int(),
	    this.key('publicExponent').int(),
	    this.key('privateExponent').int(),
	    this.key('prime1').int(),
	    this.key('prime2').int(),
	    this.key('exponent1').int(),
	    this.key('exponent2').int(),
	    this.key('coefficient').int()
	  )
	})
	exports.RSAPrivateKey = RSAPrivateKey

	var RSAPublicKey = asn1.define('RSAPublicKey', function () {
	  this.seq().obj(
	    this.key('modulus').int(),
	    this.key('publicExponent').int()
	  )
	})
	exports.RSAPublicKey = RSAPublicKey

	var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPublicKey').bitstr()
	  )
	})
	exports.PublicKey = PublicKey

	var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('none').null_().optional(),
	    this.key('curve').objid().optional(),
	    this.key('params').seq().obj(
	      this.key('p').int(),
	      this.key('q').int(),
	      this.key('g').int()
	    ).optional()
	  )
	})

	var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPrivateKey').octstr()
	  )
	})
	exports.PrivateKey = PrivateKeyInfo
	var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').seq().obj(
	      this.key('id').objid(),
	      this.key('decrypt').seq().obj(
	        this.key('kde').seq().obj(
	          this.key('id').objid(),
	          this.key('kdeparams').seq().obj(
	            this.key('salt').octstr(),
	            this.key('iters').int()
	          )
	        ),
	        this.key('cipher').seq().obj(
	          this.key('algo').objid(),
	          this.key('iv').octstr()
	        )
	      )
	    ),
	    this.key('subjectPrivateKey').octstr()
	  )
	})

	exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

	var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('p').int(),
	    this.key('q').int(),
	    this.key('g').int(),
	    this.key('pub_key').int(),
	    this.key('priv_key').int()
	  )
	})
	exports.DSAPrivateKey = DSAPrivateKey

	exports.DSAparam = asn1.define('DSAparam', function () {
	  this.int()
	})
	var ECPrivateKey = asn1.define('ECPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('privateKey').octstr(),
	    this.key('parameters').optional().explicit(0).use(ECParameters),
	    this.key('publicKey').optional().explicit(1).bitstr()
	  )
	})
	exports.ECPrivateKey = ECPrivateKey
	var ECParameters = asn1.define('ECParameters', function () {
	  this.choice({
	    namedCurve: this.objid()
	  })
	})

	exports.signature = asn1.define('signature', function () {
	  this.seq().obj(
	    this.key('r').int(),
	    this.key('s').int()
	  )
	})


/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	var asn1 = exports;

	asn1.bignum = __webpack_require__(545);

	asn1.define = __webpack_require__(595).define;
	asn1.base = __webpack_require__(598);
	asn1.constants = __webpack_require__(602);
	asn1.decoders = __webpack_require__(604);
	asn1.encoders = __webpack_require__(607);


/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__) {

	var asn1 = __webpack_require__(594);
	var inherits = __webpack_require__(199);

	var api = exports;

	api.define = function define(name, body) {
	  return new Entity(name, body);
	};

	function Entity(name, body) {
	  this.name = name;
	  this.body = body;

	  this.decoders = {};
	  this.encoders = {};
	};

	Entity.prototype._createNamed = function createNamed(base) {
	  var named;
	  try {
	    named = __webpack_require__(596).runInThisContext(
	      '(function ' + this.name + '(entity) {\n' +
	      '  this._initNamed(entity);\n' +
	      '})'
	    );
	  } catch (e) {
	    named = function (entity) {
	      this._initNamed(entity);
	    };
	  }
	  inherits(named, base);
	  named.prototype._initNamed = function initnamed(entity) {
	    base.call(this, entity);
	  };

	  return new named(this);
	};

	Entity.prototype._getDecoder = function _getDecoder(enc) {
	  // Lazily create decoder
	  if (!this.decoders.hasOwnProperty(enc))
	    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
	  return this.decoders[enc];
	};

	Entity.prototype.decode = function decode(data, enc, options) {
	  return this._getDecoder(enc).decode(data, options);
	};

	Entity.prototype._getEncoder = function _getEncoder(enc) {
	  // Lazily create encoder
	  if (!this.encoders.hasOwnProperty(enc))
	    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
	  return this.encoders[enc];
	};

	Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
	  return this._getEncoder(enc).encode(data, reporter);
	};


/***/ },
/* 596 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(597);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 597 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 598 */
/***/ function(module, exports, __webpack_require__) {

	var base = exports;

	base.Reporter = __webpack_require__(599).Reporter;
	base.DecoderBuffer = __webpack_require__(600).DecoderBuffer;
	base.EncoderBuffer = __webpack_require__(600).EncoderBuffer;
	base.Node = __webpack_require__(601);


/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);

	function Reporter(options) {
	  this._reporterState = {
	    obj: null,
	    path: [],
	    options: options || {},
	    errors: []
	  };
	}
	exports.Reporter = Reporter;

	Reporter.prototype.isError = function isError(obj) {
	  return obj instanceof ReporterError;
	};

	Reporter.prototype.save = function save() {
	  var state = this._reporterState;

	  return { obj: state.obj, pathLen: state.path.length };
	};

	Reporter.prototype.restore = function restore(data) {
	  var state = this._reporterState;

	  state.obj = data.obj;
	  state.path = state.path.slice(0, data.pathLen);
	};

	Reporter.prototype.enterKey = function enterKey(key) {
	  return this._reporterState.path.push(key);
	};

	Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
	  var state = this._reporterState;

	  state.path = state.path.slice(0, index - 1);
	  if (state.obj !== null)
	    state.obj[key] = value;
	};

	Reporter.prototype.enterObject = function enterObject() {
	  var state = this._reporterState;

	  var prev = state.obj;
	  state.obj = {};
	  return prev;
	};

	Reporter.prototype.leaveObject = function leaveObject(prev) {
	  var state = this._reporterState;

	  var now = state.obj;
	  state.obj = prev;
	  return now;
	};

	Reporter.prototype.error = function error(msg) {
	  var err;
	  var state = this._reporterState;

	  var inherited = msg instanceof ReporterError;
	  if (inherited) {
	    err = msg;
	  } else {
	    err = new ReporterError(state.path.map(function(elem) {
	      return '[' + JSON.stringify(elem) + ']';
	    }).join(''), msg.message || msg, msg.stack);
	  }

	  if (!state.options.partial)
	    throw err;

	  if (!inherited)
	    state.errors.push(err);

	  return err;
	};

	Reporter.prototype.wrapResult = function wrapResult(result) {
	  var state = this._reporterState;
	  if (!state.options.partial)
	    return result;

	  return {
	    result: this.isError(result) ? null : result,
	    errors: state.errors
	  };
	};

	function ReporterError(path, msg) {
	  this.path = path;
	  this.rethrow(msg);
	};
	inherits(ReporterError, Error);

	ReporterError.prototype.rethrow = function rethrow(msg) {
	  this.message = msg + ' at: ' + (this.path || '(shallow)');
	  Error.captureStackTrace(this, ReporterError);

	  return this;
	};


/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);
	var Reporter = __webpack_require__(598).Reporter;
	var Buffer = __webpack_require__(205).Buffer;

	function DecoderBuffer(base, options) {
	  Reporter.call(this, options);
	  if (!Buffer.isBuffer(base)) {
	    this.error('Input not Buffer');
	    return;
	  }

	  this.base = base;
	  this.offset = 0;
	  this.length = base.length;
	}
	inherits(DecoderBuffer, Reporter);
	exports.DecoderBuffer = DecoderBuffer;

	DecoderBuffer.prototype.save = function save() {
	  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
	};

	DecoderBuffer.prototype.restore = function restore(save) {
	  // Return skipped data
	  var res = new DecoderBuffer(this.base);
	  res.offset = save.offset;
	  res.length = this.offset;

	  this.offset = save.offset;
	  Reporter.prototype.restore.call(this, save.reporter);

	  return res;
	};

	DecoderBuffer.prototype.isEmpty = function isEmpty() {
	  return this.offset === this.length;
	};

	DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
	  if (this.offset + 1 <= this.length)
	    return this.base.readUInt8(this.offset++, true);
	  else
	    return this.error(fail || 'DecoderBuffer overrun');
	}

	DecoderBuffer.prototype.skip = function skip(bytes, fail) {
	  if (!(this.offset + bytes <= this.length))
	    return this.error(fail || 'DecoderBuffer overrun');

	  var res = new DecoderBuffer(this.base);

	  // Share reporter state
	  res._reporterState = this._reporterState;

	  res.offset = this.offset;
	  res.length = this.offset + bytes;
	  this.offset += bytes;
	  return res;
	}

	DecoderBuffer.prototype.raw = function raw(save) {
	  return this.base.slice(save ? save.offset : this.offset, this.length);
	}

	function EncoderBuffer(value, reporter) {
	  if (Array.isArray(value)) {
	    this.length = 0;
	    this.value = value.map(function(item) {
	      if (!(item instanceof EncoderBuffer))
	        item = new EncoderBuffer(item, reporter);
	      this.length += item.length;
	      return item;
	    }, this);
	  } else if (typeof value === 'number') {
	    if (!(0 <= value && value <= 0xff))
	      return reporter.error('non-byte EncoderBuffer value');
	    this.value = value;
	    this.length = 1;
	  } else if (typeof value === 'string') {
	    this.value = value;
	    this.length = Buffer.byteLength(value);
	  } else if (Buffer.isBuffer(value)) {
	    this.value = value;
	    this.length = value.length;
	  } else {
	    return reporter.error('Unsupported type: ' + typeof value);
	  }
	}
	exports.EncoderBuffer = EncoderBuffer;

	EncoderBuffer.prototype.join = function join(out, offset) {
	  if (!out)
	    out = new Buffer(this.length);
	  if (!offset)
	    offset = 0;

	  if (this.length === 0)
	    return out;

	  if (Array.isArray(this.value)) {
	    this.value.forEach(function(item) {
	      item.join(out, offset);
	      offset += item.length;
	    });
	  } else {
	    if (typeof this.value === 'number')
	      out[offset] = this.value;
	    else if (typeof this.value === 'string')
	      out.write(this.value, offset);
	    else if (Buffer.isBuffer(this.value))
	      this.value.copy(out, offset);
	    offset += this.length;
	  }

	  return out;
	};


/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

	var Reporter = __webpack_require__(598).Reporter;
	var EncoderBuffer = __webpack_require__(598).EncoderBuffer;
	var assert = __webpack_require__(538);

	// Supported tags
	var tags = [
	  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
	  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str', 'bmpstr',
	  'numstr', 'printstr'
	];

	// Public methods list
	var methods = [
	  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
	  'any'
	].concat(tags);

	// Overrided methods list
	var overrided = [
	  '_peekTag', '_decodeTag', '_use',
	  '_decodeStr', '_decodeObjid', '_decodeTime',
	  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

	  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
	  '_encodeNull', '_encodeInt', '_encodeBool'
	];

	function Node(enc, parent) {
	  var state = {};
	  this._baseState = state;

	  state.enc = enc;

	  state.parent = parent || null;
	  state.children = null;

	  // State
	  state.tag = null;
	  state.args = null;
	  state.reverseArgs = null;
	  state.choice = null;
	  state.optional = false;
	  state.any = false;
	  state.obj = false;
	  state.use = null;
	  state.useDecoder = null;
	  state.key = null;
	  state['default'] = null;
	  state.explicit = null;
	  state.implicit = null;

	  // Should create new instance on each method
	  if (!state.parent) {
	    state.children = [];
	    this._wrap();
	  }
	}
	module.exports = Node;

	var stateProps = [
	  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
	  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
	  'implicit'
	];

	Node.prototype.clone = function clone() {
	  var state = this._baseState;
	  var cstate = {};
	  stateProps.forEach(function(prop) {
	    cstate[prop] = state[prop];
	  });
	  var res = new this.constructor(cstate.parent);
	  res._baseState = cstate;
	  return res;
	};

	Node.prototype._wrap = function wrap() {
	  var state = this._baseState;
	  methods.forEach(function(method) {
	    this[method] = function _wrappedMethod() {
	      var clone = new this.constructor(this);
	      state.children.push(clone);
	      return clone[method].apply(clone, arguments);
	    };
	  }, this);
	};

	Node.prototype._init = function init(body) {
	  var state = this._baseState;

	  assert(state.parent === null);
	  body.call(this);

	  // Filter children
	  state.children = state.children.filter(function(child) {
	    return child._baseState.parent === this;
	  }, this);
	  assert.equal(state.children.length, 1, 'Root node can have only one child');
	};

	Node.prototype._useArgs = function useArgs(args) {
	  var state = this._baseState;

	  // Filter children and args
	  var children = args.filter(function(arg) {
	    return arg instanceof this.constructor;
	  }, this);
	  args = args.filter(function(arg) {
	    return !(arg instanceof this.constructor);
	  }, this);

	  if (children.length !== 0) {
	    assert(state.children === null);
	    state.children = children;

	    // Replace parent to maintain backward link
	    children.forEach(function(child) {
	      child._baseState.parent = this;
	    }, this);
	  }
	  if (args.length !== 0) {
	    assert(state.args === null);
	    state.args = args;
	    state.reverseArgs = args.map(function(arg) {
	      if (typeof arg !== 'object' || arg.constructor !== Object)
	        return arg;

	      var res = {};
	      Object.keys(arg).forEach(function(key) {
	        if (key == (key | 0))
	          key |= 0;
	        var value = arg[key];
	        res[value] = key;
	      });
	      return res;
	    });
	  }
	};

	//
	// Overrided methods
	//

	overrided.forEach(function(method) {
	  Node.prototype[method] = function _overrided() {
	    var state = this._baseState;
	    throw new Error(method + ' not implemented for encoding: ' + state.enc);
	  };
	});

	//
	// Public methods
	//

	tags.forEach(function(tag) {
	  Node.prototype[tag] = function _tagMethod() {
	    var state = this._baseState;
	    var args = Array.prototype.slice.call(arguments);

	    assert(state.tag === null);
	    state.tag = tag;

	    this._useArgs(args);

	    return this;
	  };
	});

	Node.prototype.use = function use(item) {
	  var state = this._baseState;

	  assert(state.use === null);
	  state.use = item;

	  return this;
	};

	Node.prototype.optional = function optional() {
	  var state = this._baseState;

	  state.optional = true;

	  return this;
	};

	Node.prototype.def = function def(val) {
	  var state = this._baseState;

	  assert(state['default'] === null);
	  state['default'] = val;
	  state.optional = true;

	  return this;
	};

	Node.prototype.explicit = function explicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.explicit = num;

	  return this;
	};

	Node.prototype.implicit = function implicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.implicit = num;

	  return this;
	};

	Node.prototype.obj = function obj() {
	  var state = this._baseState;
	  var args = Array.prototype.slice.call(arguments);

	  state.obj = true;

	  if (args.length !== 0)
	    this._useArgs(args);

	  return this;
	};

	Node.prototype.key = function key(newKey) {
	  var state = this._baseState;

	  assert(state.key === null);
	  state.key = newKey;

	  return this;
	};

	Node.prototype.any = function any() {
	  var state = this._baseState;

	  state.any = true;

	  return this;
	};

	Node.prototype.choice = function choice(obj) {
	  var state = this._baseState;

	  assert(state.choice === null);
	  state.choice = obj;
	  this._useArgs(Object.keys(obj).map(function(key) {
	    return obj[key];
	  }));

	  return this;
	};

	//
	// Decoding
	//

	Node.prototype._decode = function decode(input) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return input.wrapResult(state.children[0]._decode(input));

	  var result = state['default'];
	  var present = true;

	  var prevKey;
	  if (state.key !== null)
	    prevKey = input.enterKey(state.key);

	  // Check if tag is there
	  if (state.optional) {
	    var tag = null;
	    if (state.explicit !== null)
	      tag = state.explicit;
	    else if (state.implicit !== null)
	      tag = state.implicit;
	    else if (state.tag !== null)
	      tag = state.tag;

	    if (tag === null && !state.any) {
	      // Trial and Error
	      var save = input.save();
	      try {
	        if (state.choice === null)
	          this._decodeGeneric(state.tag, input);
	        else
	          this._decodeChoice(input);
	        present = true;
	      } catch (e) {
	        present = false;
	      }
	      input.restore(save);
	    } else {
	      present = this._peekTag(input, tag, state.any);

	      if (input.isError(present))
	        return present;
	    }
	  }

	  // Push object on stack
	  var prevObj;
	  if (state.obj && present)
	    prevObj = input.enterObject();

	  if (present) {
	    // Unwrap explicit values
	    if (state.explicit !== null) {
	      var explicit = this._decodeTag(input, state.explicit);
	      if (input.isError(explicit))
	        return explicit;
	      input = explicit;
	    }

	    // Unwrap implicit and normal values
	    if (state.use === null && state.choice === null) {
	      if (state.any)
	        var save = input.save();
	      var body = this._decodeTag(
	        input,
	        state.implicit !== null ? state.implicit : state.tag,
	        state.any
	      );
	      if (input.isError(body))
	        return body;

	      if (state.any)
	        result = input.raw(save);
	      else
	        input = body;
	    }

	    // Select proper method for tag
	    if (state.any)
	      result = result;
	    else if (state.choice === null)
	      result = this._decodeGeneric(state.tag, input);
	    else
	      result = this._decodeChoice(input);

	    if (input.isError(result))
	      return result;

	    // Decode children
	    if (!state.any && state.choice === null && state.children !== null) {
	      var fail = state.children.some(function decodeChildren(child) {
	        // NOTE: We are ignoring errors here, to let parser continue with other
	        // parts of encoded data
	        child._decode(input);
	      });
	      if (fail)
	        return err;
	    }
	  }

	  // Pop object
	  if (state.obj && present)
	    result = input.leaveObject(prevObj);

	  // Set key
	  if (state.key !== null && (result !== null || present === true))
	    input.leaveKey(prevKey, state.key, result);

	  return result;
	};

	Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
	  var state = this._baseState;

	  if (tag === 'seq' || tag === 'set')
	    return null;
	  if (tag === 'seqof' || tag === 'setof')
	    return this._decodeList(input, tag, state.args[0]);
	  else if (tag === 'octstr' || tag === 'bitstr')
	    return this._decodeStr(input, tag);
	  else if (tag === 'ia5str' || tag === 'utf8str' || tag === 'bmpstr')
	    return this._decodeStr(input, tag);
	  else if (tag === 'numstr' || tag === 'printstr')
	    return this._decodeStr(input, tag);
	  else if (tag === 'objid' && state.args)
	    return this._decodeObjid(input, state.args[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._decodeObjid(input, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._decodeTime(input, tag);
	  else if (tag === 'null_')
	    return this._decodeNull(input);
	  else if (tag === 'bool')
	    return this._decodeBool(input);
	  else if (tag === 'int' || tag === 'enum')
	    return this._decodeInt(input, state.args && state.args[0]);
	  else if (state.use !== null)
	    return this._getUse(state.use, input._reporterState.obj)._decode(input);
	  else
	    return input.error('unknown tag: ' + tag);

	  return null;
	};

	Node.prototype._getUse = function _getUse(entity, obj) {

	  var state = this._baseState;
	  // Create altered use decoder if implicit is set
	  state.useDecoder = this._use(entity, obj);
	  assert(state.useDecoder._baseState.parent === null);
	  state.useDecoder = state.useDecoder._baseState.children[0];
	  if (state.implicit !== state.useDecoder._baseState.implicit) {
	    state.useDecoder = state.useDecoder.clone();
	    state.useDecoder._baseState.implicit = state.implicit;
	  }
	  return state.useDecoder;
	};

	Node.prototype._decodeChoice = function decodeChoice(input) {
	  var state = this._baseState;
	  var result = null;
	  var match = false;

	  Object.keys(state.choice).some(function(key) {
	    var save = input.save();
	    var node = state.choice[key];
	    try {
	      var value = node._decode(input);
	      if (input.isError(value))
	        return false;

	      result = { type: key, value: value };
	      match = true;
	    } catch (e) {
	      input.restore(save);
	      return false;
	    }
	    return true;
	  }, this);

	  if (!match)
	    return input.error('Choice not matched');

	  return result;
	};

	//
	// Encoding
	//

	Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
	  return new EncoderBuffer(data, this.reporter);
	};

	Node.prototype._encode = function encode(data, reporter, parent) {
	  var state = this._baseState;
	  if (state['default'] !== null && state['default'] === data)
	    return;

	  var result = this._encodeValue(data, reporter, parent);
	  if (result === undefined)
	    return;

	  if (this._skipDefault(result, reporter, parent))
	    return;

	  return result;
	};

	Node.prototype._encodeValue = function encode(data, reporter, parent) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return state.children[0]._encode(data, reporter || new Reporter());

	  var result = null;
	  var present = true;

	  // Set reporter to share it with a child class
	  this.reporter = reporter;

	  // Check if data is there
	  if (state.optional && data === undefined) {
	    if (state['default'] !== null)
	      data = state['default']
	    else
	      return;
	  }

	  // For error reporting
	  var prevKey;

	  // Encode children first
	  var content = null;
	  var primitive = false;
	  if (state.any) {
	    // Anything that was given is translated to buffer
	    result = this._createEncoderBuffer(data);
	  } else if (state.choice) {
	    result = this._encodeChoice(data, reporter);
	  } else if (state.children) {
	    content = state.children.map(function(child) {
	      if (child._baseState.tag === 'null_')
	        return child._encode(null, reporter, data);

	      if (child._baseState.key === null)
	        return reporter.error('Child should have a key');
	      var prevKey = reporter.enterKey(child._baseState.key);

	      if (typeof data !== 'object')
	        return reporter.error('Child expected, but input is not object');

	      var res = child._encode(data[child._baseState.key], reporter, data);
	      reporter.leaveKey(prevKey);

	      return res;
	    }, this).filter(function(child) {
	      return child;
	    });

	    content = this._createEncoderBuffer(content);
	  } else {
	    if (state.tag === 'seqof' || state.tag === 'setof') {
	      // TODO(indutny): this should be thrown on DSL level
	      if (!(state.args && state.args.length === 1))
	        return reporter.error('Too many args for : ' + state.tag);

	      if (!Array.isArray(data))
	        return reporter.error('seqof/setof, but data is not Array');

	      var child = this.clone();
	      child._baseState.implicit = null;
	      content = this._createEncoderBuffer(data.map(function(item) {
	        var state = this._baseState;

	        return this._getUse(state.args[0], data)._encode(item, reporter);
	      }, child));
	    } else if (state.use !== null) {
	      result = this._getUse(state.use, parent)._encode(data, reporter);
	    } else {
	      content = this._encodePrimitive(state.tag, data);
	      primitive = true;
	    }
	  }

	  // Encode data itself
	  var result;
	  if (!state.any && state.choice === null) {
	    var tag = state.implicit !== null ? state.implicit : state.tag;
	    var cls = state.implicit === null ? 'universal' : 'context';

	    if (tag === null) {
	      if (state.use === null)
	        reporter.error('Tag could be ommited only for .use()');
	    } else {
	      if (state.use === null)
	        result = this._encodeComposite(tag, primitive, cls, content);
	    }
	  }

	  // Wrap in explicit
	  if (state.explicit !== null)
	    result = this._encodeComposite(state.explicit, false, 'context', result);

	  return result;
	};

	Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
	  var state = this._baseState;

	  var node = state.choice[data.type];
	  if (!node) {
	    assert(
	        false,
	        data.type + ' not found in ' +
	            JSON.stringify(Object.keys(state.choice)));
	  }
	  return node._encode(data.value, reporter);
	};

	Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
	  var state = this._baseState;

	  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
	    return this._encodeStr(data, tag);
	  else if (tag === 'utf8str' || tag === 'bmpstr')
	    return this._encodeStr(data, tag);
	  else if (tag === 'numstr' || tag === 'printstr')
	    return this._encodeStr(data, tag);
	  else if (tag === 'objid' && state.args)
	    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._encodeObjid(data, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._encodeTime(data, tag);
	  else if (tag === 'null_')
	    return this._encodeNull();
	  else if (tag === 'int' || tag === 'enum')
	    return this._encodeInt(data, state.args && state.reverseArgs[0]);
	  else if (tag === 'bool')
	    return this._encodeBool(data);
	  else
	    throw new Error('Unsupported tag: ' + tag);
	};

	Node.prototype._isNumstr = function isNumstr(str) {
	  return /^[0-9 ]*$/.test(str);
	};

	Node.prototype._isPrintstr = function isPrintstr(str) {
	  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
	};

/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

	var constants = exports;

	// Helper
	constants._reverse = function reverse(map) {
	  var res = {};

	  Object.keys(map).forEach(function(key) {
	    // Convert key to integer if it is stringified
	    if ((key | 0) == key)
	      key = key | 0;

	    var value = map[key];
	    res[value] = key;
	  });

	  return res;
	};

	constants.der = __webpack_require__(603);


/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(602);

	exports.tagClass = {
	  0: 'universal',
	  1: 'application',
	  2: 'context',
	  3: 'private'
	};
	exports.tagClassByName = constants._reverse(exports.tagClass);

	exports.tag = {
	  0x00: 'end',
	  0x01: 'bool',
	  0x02: 'int',
	  0x03: 'bitstr',
	  0x04: 'octstr',
	  0x05: 'null_',
	  0x06: 'objid',
	  0x07: 'objDesc',
	  0x08: 'external',
	  0x09: 'real',
	  0x0a: 'enum',
	  0x0b: 'embed',
	  0x0c: 'utf8str',
	  0x0d: 'relativeOid',
	  0x10: 'seq',
	  0x11: 'set',
	  0x12: 'numstr',
	  0x13: 'printstr',
	  0x14: 't61str',
	  0x15: 'videostr',
	  0x16: 'ia5str',
	  0x17: 'utctime',
	  0x18: 'gentime',
	  0x19: 'graphstr',
	  0x1a: 'iso646str',
	  0x1b: 'genstr',
	  0x1c: 'unistr',
	  0x1d: 'charstr',
	  0x1e: 'bmpstr'
	};
	exports.tagByName = constants._reverse(exports.tag);


/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	var decoders = exports;

	decoders.der = __webpack_require__(605);
	decoders.pem = __webpack_require__(606);


/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);

	var asn1 = __webpack_require__(594);
	var base = asn1.base;
	var bignum = asn1.bignum;

	// Import DER constants
	var der = asn1.constants.der;

	function DERDecoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	};
	module.exports = DERDecoder;

	DERDecoder.prototype.decode = function decode(data, options) {
	  if (!(data instanceof base.DecoderBuffer))
	    data = new base.DecoderBuffer(data, options);

	  return this.tree._decode(data, options);
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
	  if (buffer.isEmpty())
	    return false;

	  var state = buffer.save();
	  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  buffer.restore(state);

	  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
	};

	DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
	  var decodedTag = derDecodeTag(buffer,
	                                'Failed to decode tag of "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  var len = derDecodeLen(buffer,
	                         decodedTag.primitive,
	                         'Failed to get length of "' + tag + '"');

	  // Failure
	  if (buffer.isError(len))
	    return len;

	  if (!any &&
	      decodedTag.tag !== tag &&
	      decodedTag.tagStr !== tag &&
	      decodedTag.tagStr + 'of' !== tag) {
	    return buffer.error('Failed to match tag: "' + tag + '"');
	  }

	  if (decodedTag.primitive || len !== null)
	    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

	  // Indefinite length... find END tag
	  var state = buffer.save();
	  var res = this._skipUntilEnd(
	      buffer,
	      'Failed to skip indefinite length body: "' + this.tag + '"');
	  if (buffer.isError(res))
	    return res;

	  len = buffer.offset - state.offset;
	  buffer.restore(state);
	  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
	};

	DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
	  while (true) {
	    var tag = derDecodeTag(buffer, fail);
	    if (buffer.isError(tag))
	      return tag;
	    var len = derDecodeLen(buffer, tag.primitive, fail);
	    if (buffer.isError(len))
	      return len;

	    var res;
	    if (tag.primitive || len !== null)
	      res = buffer.skip(len)
	    else
	      res = this._skipUntilEnd(buffer, fail);

	    // Failure
	    if (buffer.isError(res))
	      return res;

	    if (tag.tagStr === 'end')
	      break;
	  }
	};

	DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
	  var result = [];
	  while (!buffer.isEmpty()) {
	    var possibleEnd = this._peekTag(buffer, 'end');
	    if (buffer.isError(possibleEnd))
	      return possibleEnd;

	    var res = decoder.decode(buffer, 'der');
	    if (buffer.isError(res) && possibleEnd)
	      break;
	    result.push(res);
	  }
	  return result;
	};

	DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
	  if (tag === 'octstr') {
	    return buffer.raw();
	  } else if (tag === 'bitstr') {
	    var unused = buffer.readUInt8();
	    if (buffer.isError(unused))
	      return unused;

	    return { unused: unused, data: buffer.raw() };
	  } else if (tag === 'ia5str' || tag === 'utf8str') {
	    return buffer.raw().toString();
	  } else if(tag === 'numstr') {
	    var numstr = buffer.raw().toString('ascii');
	    if (!this._isNumstr(numstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'numstr unsupported characters');
	    }

	    return numstr;
	  } else if (tag === 'printstr') {
	    var printstr = buffer.raw().toString('ascii');
	    if (!this._isPrintstr(printstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'printstr unsupported characters');
	    }

	    return printstr;
	  } else if(tag === 'bmpstr') {
	    var raw = buffer.raw();
	    if (raw.length % 2 === 1)
	      return buffer.error('Decoding of string type: bmpstr length mismatch');

	    var str = '';
	    for (var i = 0; i < raw.length / 2; i++) {
	      str += String.fromCharCode(raw.readUInt16BE(i * 2));
	    }
	    return str;
	  } else {
	    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
	  }
	};

	DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
	  var identifiers = [];
	  var ident = 0;
	  while (!buffer.isEmpty()) {
	    var subident = buffer.readUInt8();
	    ident <<= 7;
	    ident |= subident & 0x7f;
	    if ((subident & 0x80) === 0) {
	      identifiers.push(ident);
	      ident = 0;
	    }
	  }
	  if (subident & 0x80)
	    identifiers.push(ident);

	  var first = (identifiers[0] / 40) | 0;
	  var second = identifiers[0] % 40;

	  if (relative)
	    result = identifiers;
	  else
	    result = [first, second].concat(identifiers.slice(1));

	  if (values)
	    result = values[result.join(' ')];

	  return result;
	};

	DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
	  var str = buffer.raw().toString();
	  if (tag === 'gentime') {
	    var year = str.slice(0, 4) | 0;
	    var mon = str.slice(4, 6) | 0;
	    var day = str.slice(6, 8) | 0;
	    var hour = str.slice(8, 10) | 0;
	    var min = str.slice(10, 12) | 0;
	    var sec = str.slice(12, 14) | 0;
	  } else if (tag === 'utctime') {
	    var year = str.slice(0, 2) | 0;
	    var mon = str.slice(2, 4) | 0;
	    var day = str.slice(4, 6) | 0;
	    var hour = str.slice(6, 8) | 0;
	    var min = str.slice(8, 10) | 0;
	    var sec = str.slice(10, 12) | 0;
	    if (year < 70)
	      year = 2000 + year;
	    else
	      year = 1900 + year;
	  } else {
	    return buffer.error('Decoding ' + tag + ' time is not supported yet');
	  }

	  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
	};

	DERNode.prototype._decodeNull = function decodeNull(buffer) {
	  return null;
	};

	DERNode.prototype._decodeBool = function decodeBool(buffer) {
	  var res = buffer.readUInt8();
	  if (buffer.isError(res))
	    return res;
	  else
	    return res !== 0;
	};

	DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
	  // Bigint, return as it is (assume big endian)
	  var raw = buffer.raw();
	  var res = new bignum(raw);

	  if (values)
	    res = values[res.toString(10)] || res;

	  return res;
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getDecoder('der').tree;
	};

	// Utility methods

	function derDecodeTag(buf, fail) {
	  var tag = buf.readUInt8(fail);
	  if (buf.isError(tag))
	    return tag;

	  var cls = der.tagClass[tag >> 6];
	  var primitive = (tag & 0x20) === 0;

	  // Multi-octet tag - load
	  if ((tag & 0x1f) === 0x1f) {
	    var oct = tag;
	    tag = 0;
	    while ((oct & 0x80) === 0x80) {
	      oct = buf.readUInt8(fail);
	      if (buf.isError(oct))
	        return oct;

	      tag <<= 7;
	      tag |= oct & 0x7f;
	    }
	  } else {
	    tag &= 0x1f;
	  }
	  var tagStr = der.tag[tag];

	  return {
	    cls: cls,
	    primitive: primitive,
	    tag: tag,
	    tagStr: tagStr
	  };
	}

	function derDecodeLen(buf, primitive, fail) {
	  var len = buf.readUInt8(fail);
	  if (buf.isError(len))
	    return len;

	  // Indefinite form
	  if (!primitive && len === 0x80)
	    return null;

	  // Definite form
	  if ((len & 0x80) === 0) {
	    // Short form
	    return len;
	  }

	  // Long form
	  var num = len & 0x7f;
	  if (num >= 4)
	    return buf.error('length octect is too long');

	  len = 0;
	  for (var i = 0; i < num; i++) {
	    len <<= 8;
	    var j = buf.readUInt8(fail);
	    if (buf.isError(j))
	      return j;
	    len |= j;
	  }

	  return len;
	}


/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);
	var Buffer = __webpack_require__(205).Buffer;

	var asn1 = __webpack_require__(594);
	var DERDecoder = __webpack_require__(605);

	function PEMDecoder(entity) {
	  DERDecoder.call(this, entity);
	  this.enc = 'pem';
	};
	inherits(PEMDecoder, DERDecoder);
	module.exports = PEMDecoder;

	PEMDecoder.prototype.decode = function decode(data, options) {
	  var lines = data.toString().split(/[\r\n]+/g);

	  var label = options.label.toUpperCase();

	  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
	  var start = -1;
	  var end = -1;
	  for (var i = 0; i < lines.length; i++) {
	    var match = lines[i].match(re);
	    if (match === null)
	      continue;

	    if (match[2] !== label)
	      continue;

	    if (start === -1) {
	      if (match[1] !== 'BEGIN')
	        break;
	      start = i;
	    } else {
	      if (match[1] !== 'END')
	        break;
	      end = i;
	      break;
	    }
	  }
	  if (start === -1 || end === -1)
	    throw new Error('PEM section not found for: ' + label);

	  var base64 = lines.slice(start + 1, end).join('');
	  // Remove excessive symbols
	  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

	  var input = new Buffer(base64, 'base64');
	  return DERDecoder.prototype.decode.call(this, input, options);
	};


/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	var encoders = exports;

	encoders.der = __webpack_require__(608);
	encoders.pem = __webpack_require__(609);


/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);
	var Buffer = __webpack_require__(205).Buffer;

	var asn1 = __webpack_require__(594);
	var base = asn1.base;
	var bignum = asn1.bignum;

	// Import DER constants
	var der = asn1.constants.der;

	function DEREncoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	};
	module.exports = DEREncoder;

	DEREncoder.prototype.encode = function encode(data, reporter) {
	  return this.tree._encode(data, reporter).join();
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._encodeComposite = function encodeComposite(tag,
	                                                              primitive,
	                                                              cls,
	                                                              content) {
	  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

	  // Short form
	  if (content.length < 0x80) {
	    var header = new Buffer(2);
	    header[0] = encodedTag;
	    header[1] = content.length;
	    return this._createEncoderBuffer([ header, content ]);
	  }

	  // Long form
	  // Count octets required to store length
	  var lenOctets = 1;
	  for (var i = content.length; i >= 0x100; i >>= 8)
	    lenOctets++;

	  var header = new Buffer(1 + 1 + lenOctets);
	  header[0] = encodedTag;
	  header[1] = 0x80 | lenOctets;

	  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
	    header[i] = j & 0xff;

	  return this._createEncoderBuffer([ header, content ]);
	};

	DERNode.prototype._encodeStr = function encodeStr(str, tag) {
	  if (tag === 'octstr') {
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'bitstr') {
	    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
	  } else if (tag === 'ia5str' || tag === 'utf8str') {
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'bmpstr') {
	    var buf = new Buffer(str.length * 2);
	    for (var i = 0; i < str.length; i++) {
	      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
	    }
	    return this._createEncoderBuffer(buf);
	  } else if (tag === 'numstr') {
	    if (!this._isNumstr(str)) {
	      return this.reporter.error('Encoding of string type: numstr supports ' +
	                                 'only digits and space');
	    }

	    return this._createEncoderBuffer(str);
	  } else if (tag === 'printstr') {
	    if (!this._isPrintstr(str)) {
	      return this.reporter.error('Encoding of string type: printstr supports ' +
	                                 'only latin upper and lower case letters, ' +
	                                 'digits, space, apostrophe, left and rigth ' +
	                                 'parenthesis, plus sign, comma, hyphen, ' +
	                                 'dot, slash, colon, equal sign, ' +
	                                 'question mark');
	    }

	    return this._createEncoderBuffer(str);
	  } else {
	    return this.reporter.error('Encoding of string type: ' + tag +
	                               ' unsupported');
	  }
	};

	DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
	  if (typeof id === 'string') {
	    if (!values)
	      return this.reporter.error('string objid given, but no values map found');
	    if (!values.hasOwnProperty(id))
	      return this.reporter.error('objid not found in values map');
	    id = values[id].split(/[\s\.]+/g);
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  } else if (Array.isArray(id)) {
	    id = id.slice();
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  }

	  if (!Array.isArray(id)) {
	    return this.reporter.error('objid() should be either array or string, ' +
	                               'got: ' + JSON.stringify(id));
	  }

	  if (!relative) {
	    if (id[1] >= 40)
	      return this.reporter.error('Second objid identifier OOB');
	    id.splice(0, 2, id[0] * 40 + id[1]);
	  }

	  // Count number of octets
	  var size = 0;
	  for (var i = 0; i < id.length; i++) {
	    var ident = id[i];
	    for (size++; ident >= 0x80; ident >>= 7)
	      size++;
	  }

	  var objid = new Buffer(size);
	  var offset = objid.length - 1;
	  for (var i = id.length - 1; i >= 0; i--) {
	    var ident = id[i];
	    objid[offset--] = ident & 0x7f;
	    while ((ident >>= 7) > 0)
	      objid[offset--] = 0x80 | (ident & 0x7f);
	  }

	  return this._createEncoderBuffer(objid);
	};

	function two(num) {
	  if (num < 10)
	    return '0' + num;
	  else
	    return num;
	}

	DERNode.prototype._encodeTime = function encodeTime(time, tag) {
	  var str;
	  var date = new Date(time);

	  if (tag === 'gentime') {
	    str = [
	      two(date.getFullYear()),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else if (tag === 'utctime') {
	    str = [
	      two(date.getFullYear() % 100),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else {
	    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
	  }

	  return this._encodeStr(str, 'octstr');
	};

	DERNode.prototype._encodeNull = function encodeNull() {
	  return this._createEncoderBuffer('');
	};

	DERNode.prototype._encodeInt = function encodeInt(num, values) {
	  if (typeof num === 'string') {
	    if (!values)
	      return this.reporter.error('String int or enum given, but no values map');
	    if (!values.hasOwnProperty(num)) {
	      return this.reporter.error('Values map doesn\'t contain: ' +
	                                 JSON.stringify(num));
	    }
	    num = values[num];
	  }

	  // Bignum, assume big endian
	  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
	    var numArray = num.toArray();
	    if (!num.sign && numArray[0] & 0x80) {
	      numArray.unshift(0);
	    }
	    num = new Buffer(numArray);
	  }

	  if (Buffer.isBuffer(num)) {
	    var size = num.length;
	    if (num.length === 0)
	      size++;

	    var out = new Buffer(size);
	    num.copy(out);
	    if (num.length === 0)
	      out[0] = 0
	    return this._createEncoderBuffer(out);
	  }

	  if (num < 0x80)
	    return this._createEncoderBuffer(num);

	  if (num < 0x100)
	    return this._createEncoderBuffer([0, num]);

	  var size = 1;
	  for (var i = num; i >= 0x100; i >>= 8)
	    size++;

	  var out = new Array(size);
	  for (var i = out.length - 1; i >= 0; i--) {
	    out[i] = num & 0xff;
	    num >>= 8;
	  }
	  if(out[0] & 0x80) {
	    out.unshift(0);
	  }

	  return this._createEncoderBuffer(new Buffer(out));
	};

	DERNode.prototype._encodeBool = function encodeBool(value) {
	  return this._createEncoderBuffer(value ? 0xff : 0);
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getEncoder('der').tree;
	};

	DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
	  var state = this._baseState;
	  var i;
	  if (state['default'] === null)
	    return false;

	  var data = dataBuffer.join();
	  if (state.defaultBuffer === undefined)
	    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

	  if (data.length !== state.defaultBuffer.length)
	    return false;

	  for (i=0; i < data.length; i++)
	    if (data[i] !== state.defaultBuffer[i])
	      return false;

	  return true;
	};

	// Utility methods

	function encodeTag(tag, primitive, cls, reporter) {
	  var res;

	  if (tag === 'seqof')
	    tag = 'seq';
	  else if (tag === 'setof')
	    tag = 'set';

	  if (der.tagByName.hasOwnProperty(tag))
	    res = der.tagByName[tag];
	  else if (typeof tag === 'number' && (tag | 0) === tag)
	    res = tag;
	  else
	    return reporter.error('Unknown tag: ' + tag);

	  if (res >= 0x1f)
	    return reporter.error('Multi-octet tag encoding unsupported');

	  if (!primitive)
	    res |= 0x20;

	  res |= (der.tagClassByName[cls || 'universal'] << 6);

	  return res;
	}


/***/ },
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(199);
	var Buffer = __webpack_require__(205).Buffer;

	var asn1 = __webpack_require__(594);
	var DEREncoder = __webpack_require__(608);

	function PEMEncoder(entity) {
	  DEREncoder.call(this, entity);
	  this.enc = 'pem';
	};
	inherits(PEMEncoder, DEREncoder);
	module.exports = PEMEncoder;

	PEMEncoder.prototype.encode = function encode(data, options) {
	  var buf = DEREncoder.prototype.encode.call(this, data);

	  var p = buf.toString('base64');
	  var out = [ '-----BEGIN ' + options.label + '-----' ];
	  for (var i = 0; i < p.length; i += 64)
	    out.push(p.slice(i, i + 64));
	  out.push('-----END ' + options.label + '-----');
	  return out.join('\n');
	};


/***/ },
/* 610 */
/***/ function(module, exports) {

	module.exports = {
		"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
		"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
		"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
		"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
		"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
		"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
		"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
		"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
		"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
		"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
		"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
		"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
	};

/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip
	var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
	var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
	var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
	var evp = __webpack_require__(517)
	var ciphers = __webpack_require__(518)
	module.exports = function (okey, password) {
	  var key = okey.toString()
	  var match = key.match(findProc)
	  var decrypted
	  if (!match) {
	    var match2 = key.match(fullRegex)
	    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
	  } else {
	    var suite = 'aes' + match[1]
	    var iv = new Buffer(match[2], 'hex')
	    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
	    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
	    var out = []
	    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
	    out.push(cipher.update(cipherText))
	    out.push(cipher.final())
	    decrypted = Buffer.concat(out)
	  }
	  var tag = key.match(startRegex)[1] + ' KEY'
	  return {
	    tag: tag,
	    data: decrypted
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
	var curves = __webpack_require__(568)
	var elliptic = __webpack_require__(569)
	var parseKeys = __webpack_require__(592)

	var BN = __webpack_require__(545)
	var EC = elliptic.ec

	function verify (sig, hash, key, signType) {
	  var pub = parseKeys(key)
	  if (pub.type === 'ec') {
	    if (signType !== 'ecdsa') {
	      throw new Error('wrong public key type')
	    }
	    return ecVerify(sig, hash, pub)
	  } else if (pub.type === 'dsa') {
	    if (signType !== 'dsa') {
	      throw new Error('wrong public key type')
	    }
	    return dsaVerify(sig, hash, pub)
	  } else {
	    if (signType !== 'rsa') {
	      throw new Error('wrong public key type')
	    }
	  }
	  var len = pub.modulus.byteLength()
	  var pad = [ 1 ]
	  var padNum = 0
	  while (hash.length + pad.length + 2 < len) {
	    pad.push(0xff)
	    padNum++
	  }
	  pad.push(0x00)
	  var i = -1
	  while (++i < hash.length) {
	    pad.push(hash[i])
	  }
	  pad = new Buffer(pad)
	  var red = BN.mont(pub.modulus)
	  sig = new BN(sig).toRed(red)

	  sig = sig.redPow(new BN(pub.publicExponent))

	  sig = new Buffer(sig.fromRed().toArray())
	  var out = 0
	  if (padNum < 8) {
	    out = 1
	  }
	  len = Math.min(sig.length, pad.length)
	  if (sig.length !== pad.length) {
	    out = 1
	  }

	  i = -1
	  while (++i < len) {
	    out |= (sig[i] ^ pad[i])
	  }
	  return out === 0
	}

	function ecVerify (sig, hash, pub) {
	  var curveId = curves[pub.data.algorithm.curve.join('.')]
	  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

	  var curve = new EC(curveId)
	  var pubkey = pub.data.subjectPrivateKey.data

	  return curve.verify(hash, sig, pubkey)
	}

	function dsaVerify (sig, hash, pub) {
	  var p = pub.data.p
	  var q = pub.data.q
	  var g = pub.data.g
	  var y = pub.data.pub_key
	  var unpacked = parseKeys.signature.decode(sig, 'der')
	  var s = unpacked.s
	  var r = unpacked.r
	  checkValue(s, q)
	  checkValue(r, q)
	  var montp = BN.mont(p)
	  var w = s.invm(q)
	  var v = g.toRed(montp)
	    .redPow(new BN(hash).mul(w).mod(q))
	    .fromRed()
	    .mul(
	      y.toRed(montp)
	        .redPow(r.mul(w).mod(q))
	        .fromRed()
	  ).mod(p).mod(q)
	  return !v.cmp(r)
	}

	function checkValue (b, q) {
	  if (b.cmpn(0) <= 0) {
	    throw new Error('invalid sig')
	  }
	  if (b.cmp(q) >= q) {
	    throw new Error('invalid sig')
	  }
	}

	module.exports = verify

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(569);
	var BN = __webpack_require__(545);

	module.exports = function createECDH(curve) {
		return new ECDH(curve);
	};

	var aliases = {
		secp256k1: {
			name: 'secp256k1',
			byteLength: 32
		},
		secp224r1: {
			name: 'p224',
			byteLength: 28
		},
		prime256v1: {
			name: 'p256',
			byteLength: 32
		},
		prime192v1: {
			name: 'p192',
			byteLength: 24
		},
		ed25519: {
			name: 'ed25519',
			byteLength: 32
		},
		secp384r1: {
			name: 'p384',
			byteLength: 48
		},
		secp521r1: {
			name: 'p521',
			byteLength: 66
		}
	};

	aliases.p224 = aliases.secp224r1;
	aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
	aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
	aliases.p384 = aliases.secp384r1;
	aliases.p521 = aliases.secp521r1;

	function ECDH(curve) {
		this.curveType = aliases[curve];
		if (!this.curveType ) {
			this.curveType = {
				name: curve
			};
		}
		this.curve = new elliptic.ec(this.curveType.name);
		this.keys = void 0;
	}

	ECDH.prototype.generateKeys = function (enc, format) {
		this.keys = this.curve.genKeyPair();
		return this.getPublicKey(enc, format);
	};

	ECDH.prototype.computeSecret = function (other, inenc, enc) {
		inenc = inenc || 'utf8';
		if (!Buffer.isBuffer(other)) {
			other = new Buffer(other, inenc);
		}
		var otherPub = this.curve.keyFromPublic(other).getPublic();
		var out = otherPub.mul(this.keys.getPrivate()).getX();
		return formatReturnValue(out, enc, this.curveType.byteLength);
	};

	ECDH.prototype.getPublicKey = function (enc, format) {
		var key = this.keys.getPublic(format === 'compressed', true);
		if (format === 'hybrid') {
			if (key[key.length - 1] % 2) {
				key[0] = 7;
			} else {
				key [0] = 6;
			}
		}
		return formatReturnValue(key, enc);
	};

	ECDH.prototype.getPrivateKey = function (enc) {
		return formatReturnValue(this.keys.getPrivate(), enc);
	};

	ECDH.prototype.setPublicKey = function (pub, enc) {
		enc = enc || 'utf8';
		if (!Buffer.isBuffer(pub)) {
			pub = new Buffer(pub, enc);
		}
		this.keys._importPublic(pub);
		return this;
	};

	ECDH.prototype.setPrivateKey = function (priv, enc) {
		enc = enc || 'utf8';
		if (!Buffer.isBuffer(priv)) {
			priv = new Buffer(priv, enc);
		}
		var _priv = new BN(priv);
		_priv = _priv.toString(16);
		this.keys._importPrivate(_priv);
		return this;
	};

	function formatReturnValue(bn, enc, len) {
		if (!Array.isArray(bn)) {
			bn = bn.toArray();
		}
		var buf = new Buffer(bn);
		if (len && buf.length < len) {
			var zeros = new Buffer(len - buf.length);
			zeros.fill(0);
			buf = Buffer.concat([zeros, buf]);
		}
		if (!enc) {
			return buf;
		} else {
			return buf.toString(enc);
		}
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	exports.publicEncrypt = __webpack_require__(615);
	exports.privateDecrypt = __webpack_require__(619);

	exports.privateEncrypt = function privateEncrypt(key, buf) {
	  return exports.publicEncrypt(key, buf, true);
	};

	exports.publicDecrypt = function publicDecrypt(key, buf) {
	  return exports.privateDecrypt(key, buf, true);
	};

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(592);
	var randomBytes = __webpack_require__(308);
	var createHash = __webpack_require__(277);
	var mgf = __webpack_require__(616);
	var xor = __webpack_require__(617);
	var bn = __webpack_require__(545);
	var withPublic = __webpack_require__(618);
	var crt = __webpack_require__(567);

	var constants = {
	  RSA_PKCS1_OAEP_PADDING: 4,
	  RSA_PKCS1_PADDIN: 1,
	  RSA_NO_PADDING: 3
	};

	module.exports = function publicEncrypt(public_key, msg, reverse) {
	  var padding;
	  if (public_key.padding) {
	    padding = public_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  var key = parseKeys(public_key);
	  var paddedMsg;
	  if (padding === 4) {
	    paddedMsg = oaep(key, msg);
	  } else if (padding === 1) {
	    paddedMsg = pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    paddedMsg = new bn(msg);
	    if (paddedMsg.cmp(key.modulus) >= 0) {
	      throw new Error('data too long for modulus');
	    }
	  } else {
	    throw new Error('unknown padding');
	  }
	  if (reverse) {
	    return crt(paddedMsg, key);
	  } else {
	    return withPublic(paddedMsg, key);
	  }
	};

	function oaep(key, msg){
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (mLen > k - hLen2 - 2) {
	    throw new Error('message too long');
	  }
	  var ps = new Buffer(k - mLen - hLen2 - 2);
	  ps.fill(0);
	  var dblen = k - hLen - 1;
	  var seed = randomBytes(hLen);
	  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
	  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
	  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
	}
	function pkcs1(key, msg, reverse){
	  var mLen = msg.length;
	  var k = key.modulus.byteLength();
	  if (mLen > k - 11) {
	    throw new Error('message too long');
	  }
	  var ps;
	  if (reverse) {
	    ps = new Buffer(k - mLen - 3);
	    ps.fill(0xff);
	  } else {
	    ps = nonZero(k - mLen - 3);
	  }
	  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
	}
	function nonZero(len, crypto) {
	  var out = new Buffer(len);
	  var i = 0;
	  var cache = randomBytes(len*2);
	  var cur = 0;
	  var num;
	  while (i < len) {
	    if (cur === cache.length) {
	      cache = randomBytes(len*2);
	      cur = 0;
	    }
	    num = cache[cur++];
	    if (num) {
	      out[i++] = num;
	    }
	  }
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(277);
	module.exports = function (seed, len) {
	  var t = new Buffer('');
	  var  i = 0, c;
	  while (t.length < len) {
	    c = i2ops(i++);
	    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
	  }
	  return t.slice(0, len);
	};

	function i2ops(c) {
	  var out = new Buffer(4);
	  out.writeUInt32BE(c,0);
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 617 */
/***/ function(module, exports) {

	module.exports = function xor(a, b) {
	  var len = a.length;
	  var i = -1;
	  while (++i < len) {
	    a[i] ^= b[i];
	  }
	  return a
	};

/***/ },
/* 618 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(545);
	function withPublic(paddedMsg, key) {
	  return new Buffer(paddedMsg
	    .toRed(bn.mont(key.modulus))
	    .redPow(new bn(key.publicExponent))
	    .fromRed()
	    .toArray());
	}

	module.exports = withPublic;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(592);
	var mgf = __webpack_require__(616);
	var xor = __webpack_require__(617);
	var bn = __webpack_require__(545);
	var crt = __webpack_require__(567);
	var createHash = __webpack_require__(277);
	var withPublic = __webpack_require__(618);
	module.exports = function privateDecrypt(private_key, enc, reverse) {
	  var padding;
	  if (private_key.padding) {
	    padding = private_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  
	  var key = parseKeys(private_key);
	  var k = key.modulus.byteLength();
	  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
	    throw new Error('decryption error');
	  }
	  var msg;
	  if (reverse) {
	    msg = withPublic(new bn(enc), key);
	  } else {
	    msg = crt(enc, key);
	  }
	  var zBuffer = new Buffer(k - msg.length);
	  zBuffer.fill(0);
	  msg = Buffer.concat([zBuffer, msg], k);
	  if (padding === 4) {
	    return oaep(key, msg);
	  } else if (padding === 1) {
	    return pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    return msg;
	  } else {
	    throw new Error('unknown padding');
	  }
	};

	function oaep(key, msg){
	  var n = key.modulus;
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (msg[0] !== 0) {
	    throw new Error('decryption error');
	  }
	  var maskedSeed = msg.slice(1, hLen + 1);
	  var maskedDb =  msg.slice(hLen + 1);
	  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
	  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
	  if (compare(iHash, db.slice(0, hLen))) {
	    throw new Error('decryption error');
	  }
	  var i = hLen;
	  while (db[i] === 0) {
	    i++;
	  }
	  if (db[i++] !== 1) {
	    throw new Error('decryption error');
	  }
	  return db.slice(i);
	}

	function pkcs1(key, msg, reverse){
	  var p1 = msg.slice(0, 2);
	  var i = 2;
	  var status = 0;
	  while (msg[i++] !== 0) {
	    if (i >= msg.length) {
	      status++;
	      break;
	    }
	  }
	  var ps = msg.slice(2, i - 1);
	  var p2 = msg.slice(i - 1, i);

	  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
	    status++;
	  }
	  if (ps.length < 8) {
	    status++;
	  }
	  if (status) {
	    throw new Error('decryption error');
	  }
	  return  msg.slice(i);
	}
	function compare(a, b){
	  a = new Buffer(a);
	  b = new Buffer(b);
	  var dif = 0;
	  var len = a.length;
	  if (a.length !== b.length) {
	    dif++;
	    len = Math.min(a.length, b.length);
	  }
	  var i = -1;
	  while (++i < len) {
	    dif += (a[i] ^ b[i]);
	  }
	  return dif;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(205).Buffer))

/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(console, Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(548).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196), __webpack_require__(205).Buffer))

/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var BaseCollection = __webpack_require__(511);
	var Resource = __webpack_require__(622);

	module.exports = BaseCollection.extend({
	    type: 'resources',
	    model: Resource,
	    comparator: function comparator(res1, res2) {
	        var name1 = res1.mucDisplayName.toLowerCase(),
	            name2 = res2.mucDisplayName.toLowerCase();
	        return name1 > name2 ? 1 : name1 < name2 ? -1 : 0;
	    },
	    search: function search(letters, removeMe, addAll) {
	        if (letters == "" && !removeMe) return this;

	        var collection = new module.exports(this.models);
	        if (addAll) collection.add({ id: this.parent.jid.bare + '/all' });

	        var pattern = new RegExp('^' + letters + '.*$', "i");
	        var filtered = collection.filter(function (data) {
	            var nick = data.get("mucDisplayName");
	            if (nick === me.nick) return false;
	            return pattern.test(nick);
	        });
	        return new module.exports(filtered);
	    }
	});

/***/ },
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, client*/
	"use strict";

	var HumanModel = __webpack_require__(505);
	var fetchAvatar = __webpack_require__(623);

	module.exports = HumanModel.define({
	    initialize: function initialize() {},
	    type: 'resource',
	    props: {
	        avatarID: ['string', false, '']
	    },
	    session: {
	        id: ['string', true],
	        status: 'string',
	        show: 'string',
	        priority: ['number', false, 0],
	        chatState: ['string', false, 'gone'],
	        idleSince: 'date',
	        discoInfo: 'object',
	        timezoneOffset: 'number',
	        avatar: 'string',
	        avatarSource: 'string'
	    },
	    derived: {
	        mucDisplayName: {
	            deps: ['id'],
	            fn: function fn() {
	                return this.id.split('/')[1] || '';
	            }
	        },
	        idle: {
	            deps: ['idleSince'],
	            fn: function fn() {
	                return this.idleSince && !isNaN(this.idleSince.valueOf());
	            }
	        },
	        supportsReceipts: {
	            deps: ['discoInfo'],
	            fn: function fn() {
	                if (!this.discoInfo) return false;
	                var features = this.discoInfo.features || [];
	                return features.indexOf('urn:xmpp:receipts') >= 0;
	            }
	        },
	        supportsChatStates: {
	            deps: ['discoInfo'],
	            fn: function fn() {
	                if (!this.discoInfo) return false;
	                var features = this.discoInfo.features || [];
	                return features.indexOf('http://jabber.org/protocol/chatstate') >= 0;
	            }
	        },
	        supportsJingleMedia: {
	            deps: ['discoInfo'],
	            fn: function fn() {
	                if (!this.discoInfo) return false;
	                var features = this.discoInfo.features || [];
	                if (features.indexOf('urn:xmpp:jingle:1') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:apps:rtp:1') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:apps:rtp:audio') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:apps:rtp:video') === -1) {
	                    return false;
	                }

	                return true;
	            }
	        },
	        supportsJingleFiletransfer: {
	            deps: ['discoInfo'],
	            fn: function fn() {
	                if (!this.discoInfo) return false;
	                var features = this.discoInfo.features || [];
	                if (features.indexOf('urn:xmpp:jingle:1') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:apps:file-transfer:3') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:transports:ice-udp:1') === -1) {
	                    return false;
	                }

	                if (features.indexOf('urn:xmpp:jingle:transports:dtls-sctp:1') === -1) {
	                    return false;
	                }

	                return true;
	            }
	        }
	    },
	    fetchTimezone: function fetchTimezone() {
	        var self = this;

	        if (self.timezoneOffset) return;

	        app.whenConnected(function () {
	            client.getTime(self.id, function (err, res) {
	                if (err) return;
	                self.timezoneOffset = res.time.tzo;
	            });
	        });
	    },
	    fetchDisco: function fetchDisco() {
	        var self = this;

	        if (self.discoInfo) return;

	        app.whenConnected(function () {
	            client.getDiscoInfo(self.id, '', function (err, res) {
	                if (err) return;
	                self.discoInfo = res.discoInfo;
	            });
	        });
	    },
	    setAvatar: function setAvatar(id, type, source) {
	        var self = this;
	        fetchAvatar(this.id, id, type, source, function (avatar) {
	            if (source == 'vcard' && self.avatarSource == 'pubsub') return;
	            self.avatarID = avatar.id;
	            self.avatar = avatar.uri;
	            self.avatarSource = source;
	        });
	    }

	});

/***/ },
/* 623 */
/***/ function(module, exports, __webpack_require__) {

	/*global app*/
	"use strict";

	var crypto = __webpack_require__(513);

	function fallback(jid) {
	    var gID = crypto.createHash('md5').update(jid).digest('hex');
	    return {
	        uri: 'https://gravatar.com/avatar/' + gID + '?s=80&d=mm'
	    };
	};

	module.exports = function (jid, id, type, source, cb) {
	    if (!id) {
	        return cb(fallback(jid));
	    }

	    app.storage.avatars.get(id, function (err, avatar) {
	        if (!err) {
	            return cb(avatar);
	        }

	        if (!type) {
	            return cb(fallback(jid));
	        }

	        app.whenConnected(function () {
	            if (source == 'vcard') {
	                app.api.getVCard(jid, function (err, resp) {
	                    if (err) {
	                        return cb(fallback(jid));
	                    }

	                    if (!resp.vCardTemp.photo) return cb(fallback(jid));

	                    type = resp.vCardTemp.photo.type || type;

	                    var data = resp.vCardTemp.photo.data;
	                    
	                    	                   
	                    var uri = data;	                    
	                    if (data.indexOf("data:") == -1) uri =  'data:' + type + ';base64,' + data;	                    

	                    avatar = {
	                        id: id,
	                        type: type,
	                        uri: uri
	                    };

	                    app.storage.avatars.add(avatar);
	                    return cb(avatar);
	                });
	            } else {
	                app.api.getAvatar(jid, id, function (err, resp) {
	                    if (err) {
	                        return;
	                    }

			    var data = "/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCACAAIADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD603Ubqi3UFqoCQt700v71GW96jd/egCVnqNpfeoXkxVaSbHekgLbTe9Rmf3rMub+GL78gz/dHJ/Kqo1WAnkyJ7vGyj9aYG75/vThN71gtqUC9JN5P9z5v5U6LVYCeTJH7uhUfrSRJ0Cy+9SrJ71lQzhgCGBB9KsRy0wNAP704P71VSSpFegosbqN1QhqXdQBFuoLVFupGb3oFccz+9QySe9I7+9VpZPegLhLLjvWbe3bb1t4FMk8nyqo/nS39ysMLSMeg6etb/hXTltLBbiYA3Mw3O/f2H5YoESaLodnYwKZI1muDy7v8xz7Z6Voy29tKhSSCJ19GQGn5ozUlFa102wttxhtIVz/sCpZra1mQpLBE6nsyA1JmjNAHE6hBNot1IvkyGxZspJ1CZ7GrcEwYDBHPeunu4Ibq3kt51DRyLtYeorh4hJZX0unTH5ojlD/eT1/pTEzdikHrU6OPWs2GTI61ajf0NMZdDil3VXVven7vegVyLdTWao91NZqBhI3vVSZ/enyNVSd+tBI3S4E1HX0t5RmK3USsPU9v5V24wBgDpXIeCIzLqV9fAZjKrEp91J/xrraTGh+aM0yikMfmjNMooAfmuc8cW6izj1FBiS3cAn1UnGP1roKp61ai90ue3JHzLkfUcihAzm4JAQDmrkTj1rF0qUvbgP8AeQlG+o4rUibiqJLyNTw3vVZGqQNQUQ7qaze9M3UxmoJEkJqncHKnntViRveqsxoA3PA0itoKRd4XMbfUYrdzXI+B5gl7fWxbBJDhfXPf9K6zNSxodmjNNzRmgY7NGabmjNADs1X1KQR6fcSE42xMf0qbNc/46uTFpAgRtrzuEHr1yf0oQmc/pGfskbd3+b8+a1Ijx1rPtgFVVXoOBVyM1QIuIxqQGq6t704NQIi3U1mqEuaaXoHce7e9V5TSu9QSPQIrzPNBOl1bNtmjOR/tD0rtfD+pLqmmx3YQpngg+orh5Wp/hrU/7N1dbea5eO0l6KeRu9PajcZ6N+NH41GGBGR0NLmpC4/8aPxpmaM0BcV3CIXJ4HNcHq2qf21exSpG0dvbk7N3Vm5GatePNSc3EOmW11tLAmdEPO3tn9ax7baihVAAFMDRiPvVqM9OaoRPViN+KYi4rU/dVVXpwc0AVjJTDJ71A0lRtJ70ATvIemagkkqJ5cDJIqt58k0nlWsMlxJ/dQUASXMwjjZ2PCjNdN4N0WCK0j1G5TzbqYbst/CO2KybHwvf3pVtQdbeE8mNeWI9DXbQosUSRKMKihRSAmz2FGaZmjNIofmjNMzRmgDH8Q+H7bVP3yHyLsDiVe/sfauNQywXM1nOMTQNtfHQ8Zr0rNcZ4q0e+XUZNStIhPG4+dF+8PemhFKOSp0k96yobpSdpJVhwVYYIq0knvTEaCye9PElUVk96kEnvQBVaT3qvbyXF9IYtPga5ccEr91fqe1NihbUNRg01GI807nI7IOv8xXodnbQWkCw28axoowAKNgOb03wo8hEmrXBfv5MfAH1PeumsrW2s4RDawpDGP4VGBUuaM1O49h2aM03NGaAuOzRmm5ozQFx2aM03NGaAuOzRmm5ozQFyjqmkafqQzdW6tJ2kHDD8a5u+8MahbEvp9wLiPtHLwR/wLvXZZozTDQ83kne2mEF7E9tKegkGN309asK9dvfWdrewNDcxLIrDuORXATwvYalcWDtu8ogofVTyKe4jR8CxCbV7y6I/wBSqov/AAIc/wAq7TNcp8OlBsLu4/56Tkf98kiuo/Gkx9B+aM0z8aPxpDH5ozTPxo/GgB+aM0z8aPxoAfmjNM/Gj8aAH5ozTPxo/GgB+aM0z8aPxoAfmuK8cx+VrdpcrwskbI3ueMV2X41zHxEj/wCJfa3AH+ruFz9MGmhdD//Z";

			    if (resp.pubsub && resp.pubsub.retrieve && resp.pubsub.retrieve.item)
			    {
				data = resp.pubsub.retrieve.item.avatarData;
			    }
                    

	                    var uri = data;	                    
	                    if (data.indexOf("data:") == -1) uri =  'data:' + type + ';base64,' + data;

	                    avatar = {
	                        id: id,
	                        type: type,
	                        uri: uri
	                    };

	                    app.storage.avatars.add(avatar);
	                    return cb(avatar);
	                });
	            }
	        });
	    });
	};

/***/ },
/* 624 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var BaseCollection = __webpack_require__(511);
	var Message = __webpack_require__(625);

	module.exports = BaseCollection.extend({
	    type: 'messages',
	    model: Message,
	    comparator: 'created'
	});

/***/ },
/* 625 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me*/
	"use strict";

	var _ = __webpack_require__(217);
	var uuid = __webpack_require__(620);
	var HumanModel = __webpack_require__(505);
	var templates = __webpack_require__(626);
	var htmlify = __webpack_require__(629);

	var ID_CACHE = {};

	var Message = module.exports = HumanModel.define({
	    initialize: function initialize(attrs) {
	        this._created = new Date(Date.now() + app.timeInterval);
	    },
	    type: 'message',
	    props: {
	        mid: 'string',
	        owner: 'string',
	        to: 'object',
	        from: 'object',
	        body: 'string',
	        type: ['string', false, 'normal'],
	        acked: ['bool', false, false],
	        requestReceipt: ['bool', false, false],
	        receipt: ['bool', false, false],
	        archivedId: 'string',
	        oobURIs: 'array'
	    },
	    derived: {
	        mine: {
	            deps: ['from', '_mucMine'],
	            fn: function fn() {
	                return this._mucMine || me.isMe(this.from);
	            }
	        },
	        sender: {
	            deps: ['from', 'mine'],
	            fn: function fn() {
	                if (this.mine) {
	                    return me;
	                } else {
	                    return me.getContact(this.from);
	                }
	            }
	        },
	        delayed: {
	            deps: ['delay'],
	            fn: function fn() {
	                return !!this.delay;
	            }
	        },
	        created: {
	            deps: ['delay', '_created', '_edited'],
	            fn: function fn() {
	                if (this.delay && this.delay.stamp) {
	                    return this.delay.stamp;
	                }
	                return this._created;
	            }
	        },
	        timestamp: {
	            deps: ['created', '_edited'],
	            fn: function fn() {
	                if (this._edited && !isNaN(this._edited.valueOf())) {
	                    return this._edited;
	                }
	                return this.created;
	            }
	        },
	        formattedTime: {
	            deps: ['created'],
	            fn: function fn() {
	                if (this.created) {
	                    var month = this.created.getMonth() + 1;
	                    var day = this.created.getDate();
	                    var hour = this.created.getHours();
	                    var minutes = this.created.getMinutes();

	                    var m = hour >= 12 ? 'p' : 'a';
	                    var strDay = day < 10 ? '0' + day : day;
	                    var strHour = hour < 10 ? '0' + hour : hour;
	                    var strMin = minutes < 10 ? '0' + minutes : minutes;

	                    return '' + month + '/' + strDay + ' ' + strHour + ':' + strMin + m;
	                }
	                return undefined;
	            }
	        },
	        pending: {
	            deps: ['acked'],
	            fn: function fn() {
	                return !this.acked;
	            }
	        },
	        nick: {
	            deps: ['mine', 'type'],
	            fn: function fn() {
	                if (this.type === 'groupchat') {
	                    return this.from.resource;
	                }
	                if (this.mine) {
	                    return 'me';
	                }
	                return me.getContact(this.from.bare).displayName;
	            }
	        },
	        processedBody: {
	            deps: ['body', 'meAction', 'mentions'],
	            fn: function fn() {
	                var body = this.body;
	                if (this.meAction) {
	                    body = body.substr(4);
	                }
	                body = htmlify.toHTML(body);
	                for (var i = 0; i < this.mentions.length; i++) {
	                    var existing = htmlify.toHTML(this.mentions[i]);
	                    var parts = body.split(existing);
	                    body = parts.join('<span class="mention">' + existing + '</span>');
	                }
	                return body;
	            }
	        },
	        partialTemplateHtml: {
	            deps: ['edited', 'pending', 'body', 'urls'],
	            cache: false,
	            fn: function fn() {
	                return this.bareMessageTemplate(false);
	            }
	        },
	        templateHtml: {
	            deps: ['edited', 'pending', 'body', 'urls'],
	            cache: false,
	            fn: function fn() {
	                if (this.type === 'groupchat') {
	                    return templates.includes.mucWrappedMessage({ message: this, messageDate: Date.create(this.timestamp), firstEl: true });
	                } else {
	                    return templates.includes.wrappedMessage({ message: this, messageDate: Date.create(this.timestamp), firstEl: true });
	                }
	            }
	        },
	        classList: {
	            cache: false,
	            fn: function fn() {
	                var res = [];

	                if (this.mine) res.push('mine');
	                if (this.pending) res.push('pending');
	                if (this.delayed) res.push('delayed');
	                if (this.edited) res.push('edited');
	                if (this.requestReceipt) res.push('pendingReceipt');
	                if (this.receiptReceived) res.push('delivered');
	                if (this.meAction) res.push('meAction');

	                return res.join(' ');
	            }
	        },
	        meAction: {
	            deps: ['body'],
	            fn: function fn() {
	                return this.body.indexOf('/me') === 0;
	            }
	        },
	        urls: {
	            deps: ['body', 'oobURIs'],
	            fn: function fn() {
	                var self = this;
	                var result = [];
	                var urls = htmlify.collectLinks(this.body);
	                var oobURIs = _.pluck(this.oobURIs || [], 'url');
	                var uniqueURIs = _.unique(result.concat(urls).concat(oobURIs));

	                _.each(uniqueURIs, function (url) {
	                    var oidx = oobURIs.indexOf(url);
	                    if (oidx >= 0) {
	                        result.push({
	                            href: url,
	                            desc: self.oobURIs[oidx].desc,
	                            source: 'oob'
	                        });
	                    } else {
	                        result.push({
	                            href: url,
	                            desc: url,
	                            source: 'body'
	                        });
	                    }
	                });

	                return result;
	            }
	        }
	    },
	    session: {
	        _created: 'date',
	        _edited: 'date',
	        _mucMine: 'bool',
	        receiptReceived: ['bool', true, false],
	        edited: ['bool', true, false],
	        delay: 'object',
	        mentions: ['array', false, []]
	    },
	    correct: function correct(msg) {
	        if (this.from.full !== msg.from.full) return false;

	        delete msg.id;

	        this.set(msg);
	        this._edited = new Date(Date.now() + app.timeInterval);
	        this.edited = true;

	        this.save();

	        return true;
	    },
	    bareMessageTemplate: function bareMessageTemplate(firstEl) {
	        if (this.type === 'groupchat') {
	            return templates.includes.mucBareMessage({ message: this, messageDate: Date.create(this.timestamp), firstEl: firstEl });
	        } else {
	            return templates.includes.bareMessage({ message: this, messageDate: Date.create(this.timestamp), firstEl: firstEl });
	        }
	    },
	    save: function save() {
	        if (this.mid) {
	            var from = this.type == 'groupchat' ? this.from.full : this.from.bare;
	            Message.idStore(from, this.mid, this);
	        }

	        var data = {
	            archivedId: this.archivedId || uuid.v4(),
	            owner: this.owner,
	            to: this.to,
	            from: this.from,
	            created: this.created,
	            body: this.body,
	            type: this.type,
	            delay: this.delay,
	            edited: this.edited
	        };
	        app.storage.archive.add(data);
	    },
	    shouldGroupWith: function shouldGroupWith(previous) {
	        if (this.type === 'groupchat') {
	            return previous && previous.from.full === this.from.full && Math.round((this.created - previous.created) / 1000) <= 300 && previous.created.toLocaleDateString() === this.created.toLocaleDateString();
	        } else {
	            return previous && previous.from.bare === this.from.bare && Math.round((this.created - previous.created) / 1000) <= 300 && previous.created.toLocaleDateString() === this.created.toLocaleDateString();
	        }
	    }
	});

	Message.idLookup = function (jid, mid) {
	    var cache = ID_CACHE[jid] || (ID_CACHE[jid] = {});
	    return cache[mid];
	};

	Message.idStore = function (jid, mid, msg) {
	    var cache = ID_CACHE[jid] || (ID_CACHE[jid] = {});
	    cache[mid] = msg;
	};

/***/ },
/* 626 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var jade = __webpack_require__(627);

	var templatizer = {};

	templatizer["includes"] = {};
	templatizer["pages"] = {};
	templatizer["misc"] = {};

	// body.jade compiled template
	templatizer["body"] = function tmpl_body() {
	    return '<body><div id="updateBar"><p>Update available!</p><button class="primary upgrade">Upgrade</button></div><div id="wrapper"><aside id="menu"><section id="organization"><span id="orga_name"></span><a href="/" class="button secondary settings"><svg id="settingssvg" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 25 25" height="25" width="25"><g transform="scale(0.4)"><path d="M37.418,34.3c-2.1-2.721-2.622-6.352-1.292-9.604c0.452-1.107,1.104-2.1,1.902-2.951 c-0.753-0.877-1.573-1.697-2.507-2.387l-2.609,1.408c-1.05-0.629-2.194-1.112-3.414-1.421l-0.845-2.833 c-0.75-0.112-1.512-0.188-2.287-0.188c-0.783,0-1.54,0.075-2.288,0.188l-0.851,2.833c-1.215,0.309-2.355,0.792-3.41,1.421 l-2.614-1.408c-1.229,0.912-2.318,2-3.228,3.231l1.404,2.612c-0.628,1.053-1.11,2.193-1.419,3.411l-2.832,0.849 c-0.114,0.75-0.187,1.508-0.187,2.287c0,0.778,0.073,1.537,0.187,2.286l2.832,0.848c0.309,1.22,0.791,2.36,1.419,3.413l-1.404,2.61 c0.909,1.231,1.999,2.321,3.228,3.231l2.614-1.406c1.055,0.628,2.195,1.11,3.41,1.42l0.851,2.832 c0.748,0.114,1.505,0.188,2.288,0.188c0.775,0,1.537-0.074,2.287-0.188l0.845-2.832c1.224-0.31,2.364-0.792,3.414-1.42l0.062,0.033 l2.045-3.02L37.418,34.3z M26.367,36.776c-2.777,0-5.027-2.253-5.027-5.027c0-2.775,2.25-5.028,5.027-5.028 c2.774,0,5.024,2.253,5.024,5.028C31.391,34.523,29.141,36.776,26.367,36.776z"></path><path d="M51.762,24.505l-1.125-0.459l-1.451,3.55c-0.814,1.993-2.832,3.054-4.505,2.37l-0.355-0.144 c-1.673-0.686-2.37-2.856-1.558-4.849l1.451-3.551l-1.125-0.46c-2.225,0.608-4.153,2.2-5.092,4.501 c-1.225,2.997-0.422,6.312,1.771,8.436l-2.958,6.812l-2.204,3.249l-0.007,2.281l5.275,2.154l1.593-1.633l0.7-3.861l2.901-6.836 c3.049,0.018,5.947-1.785,7.174-4.779C53.186,28.983,52.924,26.499,51.762,24.505z"></path></g></svg></a></section><div class="viewport"><section id="bookmarks"><h1>Rooms</h1><nav></nav><input type="text" placeholder="add a room" id="joinmuc" class="inline"/></section><section id="roster"><h1>Contacts</h1><ul id="contactrequests"></ul><nav></nav><input type="text" placeholder="add a contact" id="addcontact" class="inline"/></section></div><section id="kaiwaNotice">Powered by<a href="http://getkaiwa.com" target="_blank"><img src="images/logo.png" alt="Kaiwa"/></a></section></aside><header id="topbar"><div id="connectionStatus"><p>You\'re currently&nbsp;<strong>disconnected</strong></p><button class="primary reconnect">Reconnect</button></div><div id="me"><img class="avatar"/><div><span class="name"></span><span contenteditable="true" spellcheck="false" class="status"></span></div></div></header><main id="pages"></main></div></body>';
	};

	// head.jade compiled template
	templatizer["head"] = function tmpl_head() {
	    return '<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0"/><meta name="apple-mobile-web-app-capable" content="yes"/><link rel="stylesheet" type="text/css" href="fonts.css"/><link rel="stylesheet" type="text/css" href="font-awesome-4.7.0/css/font-awesome.min.css"/>';
	};

	// includes\contactListItem.jade compiled template
	templatizer["includes"]["contactListItem"] = function tmpl_includes_contactListItem(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (contact) {
	        buf.push('<li class="contact joined"><div class="wrap"><i title="remove from contacts" class="remove fa fa-times-circle"></i><i class="presence fa fa-circle"></i><div class="user"><img class="avatar"/><span class="name">' + jade.escape(null == (jade_interp = contact.displayName) ? "" : jade_interp) + '</span><span class="idleTime">' + jade.escape(null == (jade_interp = contact.idleSince) ? "" : jade_interp) + '</span></div><div class="unread">' + jade.escape(null == (jade_interp = contact.unreadCount) ? "" : jade_interp) + "</div></div></li>");
	    }).call(this, "contact" in locals_for_with ? locals_for_with.contact : typeof contact !== "undefined" ? contact : undefined);
	    return buf.join("");
	};

	// includes\bareMessage.jade compiled template
	templatizer["includes"]["bareMessage"] = function tmpl_includes_bareMessage(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (firstEl, message, messageDate, undefined) {
	        var messageClasses = message.classList;
	        if (firstEl) {
	            messageClasses += " first";
	        }
	        buf.push("<div" + jade.attr("id", "chat" + message.cid, true, false) + jade.cls(["message", messageClasses], [null, true]) + "><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + '</div><p class="body">' + ((jade_interp = message.processedBody) == null ? "" : jade_interp) + "</p>");
	        var urls = message.urls;
	        buf.push('<section class="embeds">');
	        (function () {
	            var $$obj = urls;
	            if ("number" == typeof $$obj.length) {
	                for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            } else {
	                var $$l = 0;
	                for (var $index in $$obj) {
	                    $$l++;
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            }
	        }).call(this);
	        buf.push("</section></div>");
	    }).call(this, "firstEl" in locals_for_with ? locals_for_with.firstEl : typeof firstEl !== "undefined" ? firstEl : undefined, "message" in locals_for_with ? locals_for_with.message : typeof message !== "undefined" ? message : undefined, "messageDate" in locals_for_with ? locals_for_with.messageDate : typeof messageDate !== "undefined" ? messageDate : undefined, "undefined" in locals_for_with ? locals_for_with.undefined :  false ? undefined : undefined);
	    return buf.join("");
	};

	// includes\call.jade compiled template
	templatizer["includes"]["call"] = function tmpl_includes_call() {
	    return '<div class="call"><img class="callerAvatar"/><h1 class="caller"><span class="callerName"></span><span class="callerNumber"></span></h1><h2 class="callTime"></h2><div class="callActions"><button class="answer">Answer</button><button class="ignore">Ignore</button><button class="cancel">Cancel</button><button class="end">End</button><button class="mute">Mute</button><button class="unmute">Unmute</button></div></div>';
	};

	// includes\contactListItemResource.jade compiled template
	templatizer["includes"]["contactListItemResource"] = function tmpl_includes_contactListItemResource(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (resource) {
	        buf.push('<li><p class="jid">' + jade.escape(null == (jade_interp = resource.jid) ? "" : jade_interp) + '</p><p class="status">' + jade.escape(null == (jade_interp = resource.status) ? "" : jade_interp) + "</p></li>");
	    }).call(this, "resource" in locals_for_with ? locals_for_with.resource : typeof resource !== "undefined" ? resource : undefined);
	    return buf.join("");
	};

	// includes\contactRequest.jade compiled template
	templatizer["includes"]["contactRequest"] = function tmpl_includes_contactRequest() {
	    return '<li><div class="jid"></div><div class="response"><button class="primary small approve">Approve</button><button class="secondary small deny">Deny</button></div></li>';
	};

	// includes\dayDivider.jade compiled template
	templatizer["includes"]["dayDivider"] = function tmpl_includes_dayDivider(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (day_name) {
	        buf.push('<li class="day_divider"><hr/><div class="day_divider_name">' + jade.escape((jade_interp = day_name) == null ? "" : jade_interp) + "</div></li>");
	    }).call(this, "day_name" in locals_for_with ? locals_for_with.day_name : typeof day_name !== "undefined" ? day_name : undefined);
	    return buf.join("");
	};

	// includes\messageGroup.jade compiled template
	templatizer["includes"]["messageGroup"] = function tmpl_includes_messageGroup() {
	    return "<li></li>";
	};

	// includes\embeds.jade compiled template
	templatizer["includes"]["embeds"] = function tmpl_includes_embeds(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    if (locals.type === "photo") {
	        buf.push('<section class="embed active"><a' + jade.attr("href", locals.original, true, false) + ' target="_blank" class="photo"><img' + jade.attr("width", locals.width, true, false) + jade.attr("height", locals.height, true, false) + jade.attr("src", locals.url, true, false) + jade.attr("alt", locals.title, true, false) + ' class="embedded"/>');
	        if (locals.title || locals.description) {
	            buf.push('<div class="description">');
	            if (locals.title) {
	                buf.push("<h3>" + jade.escape(null == (jade_interp = locals.title) ? "" : jade_interp) + "</h3>");
	            }
	            if (locals.description) {
	                buf.push("<p>" + jade.escape(null == (jade_interp = locals.description) ? "" : jade_interp) + "</p>");
	            }
	            buf.push("</div>");
	        }
	        buf.push("</a></section>");
	    } else if (locals.type === "video" && locals.thumbnail_url) {
	        buf.push('<section class="embed active"><a' + jade.attr("href", locals.original, true, false) + ' target="_blank" class="preview"><img' + jade.attr("width", locals.width, true, false) + jade.attr("height", locals.height, true, false) + jade.attr("src", locals.thumbnail_url, true, false) + jade.attr("alt", locals.title, true, false) + ' class="embedded"/>');
	        if (locals.title || locals.description) {
	            buf.push('<div class="description">');
	            if (locals.title) {
	                buf.push("<h3>" + jade.escape(null == (jade_interp = locals.title) ? "" : jade_interp) + "</h3>");
	            }
	            if (locals.description) {
	                buf.push("<p>" + jade.escape(null == (jade_interp = locals.description) ? "" : jade_interp) + "</p>");
	            }
	            buf.push("</div>");
	        }
	        buf.push("</a></section>");
	    }
	    return buf.join("");
	};

	// includes\message.jade compiled template
	templatizer["includes"]["message"] = function tmpl_includes_message(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (message) {
	        buf.push('<li><div class="message"><span class="timestamp">' + jade.escape(null == (jade_interp = message.timestamp) ? "" : jade_interp) + '</span><p class="body">' + jade.escape(null == (jade_interp = message.body) ? "" : jade_interp) + "</p></div></li>");
	    }).call(this, "message" in locals_for_with ? locals_for_with.message : typeof message !== "undefined" ? message : undefined);
	    return buf.join("");
	};

	// includes\mucListItem.jade compiled template
	templatizer["includes"]["mucListItem"] = function tmpl_includes_mucListItem(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (contact) {
	        buf.push('<li class="contact"><div class="wrap"><i title="remove from bookmarks" class="remove fa fa-times-circle"></i><i class="join fa fa-sign-in"></i><div class="unread">' + jade.escape(null == (jade_interp = contact.unreadCount) ? "" : jade_interp) + '</div><span class="name">' + jade.escape(null == (jade_interp = contact.displayName) ? "" : jade_interp) + "</span></div></li>");
	    }).call(this, "contact" in locals_for_with ? locals_for_with.contact : typeof contact !== "undefined" ? contact : undefined);
	    return buf.join("");
	};

	// includes\mucBareMessage.jade compiled template
	templatizer["includes"]["mucBareMessage"] = function tmpl_includes_mucBareMessage(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (firstEl, message, messageDate, undefined) {
	        var messageClasses = message.classList;
	        if (firstEl) {
	            messageClasses += " first";
	        }
	        buf.push("<div" + jade.attr("id", "chat" + message.cid, true, false) + jade.cls(["message", messageClasses], [null, true]) + "><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + '</div><p class="body">' + ((jade_interp = message.processedBody) == null ? "" : jade_interp) + "</p>");
	        var urls = message.urls;
	        buf.push('<section class="embeds">');
	        (function () {
	            var $$obj = urls;
	            if ("number" == typeof $$obj.length) {
	                for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            } else {
	                var $$l = 0;
	                for (var $index in $$obj) {
	                    $$l++;
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            }
	        }).call(this);
	        buf.push("</section></div>");
	    }).call(this, "firstEl" in locals_for_with ? locals_for_with.firstEl : typeof firstEl !== "undefined" ? firstEl : undefined, "message" in locals_for_with ? locals_for_with.message : typeof message !== "undefined" ? message : undefined, "messageDate" in locals_for_with ? locals_for_with.messageDate : typeof messageDate !== "undefined" ? messageDate : undefined, "undefined" in locals_for_with ? locals_for_with.undefined :  false ? undefined : undefined);
	    return buf.join("");
	};

	// includes\mucWrappedMessage.jade compiled template
	templatizer["includes"]["mucWrappedMessage"] = function tmpl_includes_mucWrappedMessage(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (firstEl, message, messageDate, undefined) {
		var avatar = "";
		
		if (message.sender && typeof message.sender.getAvatar == "function" && typeof message.sender.getName == "function")
		{
	        	buf.push('<li><div class="sender"><a href="#" class="messageAvatar"><img' + jade.attr("src", message.sender.getAvatar(message.from.full), true, false) + jade.attr("alt", message.from.resource, true, false) + ' data-placement="below"/></a></div><div class="messageWrapper"><div class="message_header"><div class="name">' + jade.escape((jade_interp = (message.sender.getName(message.from.full)) == null ? "" : jade_interp)) + '</div><div class="nickname">' + jade.escape((jade_interp = message.sender.getNickname(message.from.full)) == null ? "" : jade_interp) + "</div><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + "</div></div>");
	        }
	        var messageClasses = message.classList;
	        if (firstEl) {
	            messageClasses += " first";
	        }
	        buf.push("<div" + jade.attr("id", "chat" + message.cid, true, false) + jade.cls(["message", messageClasses], [null, true]) + "><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + '</div><p class="body">' + ((jade_interp = message.processedBody) == null ? "" : jade_interp) + "</p>");
	        var urls = message.urls;
	        buf.push('<section class="embeds">');
	        (function () {
	            var $$obj = urls;
	            if ("number" == typeof $$obj.length) {
	                for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            } else {
	                var $$l = 0;
	                for (var $index in $$obj) {
	                    $$l++;
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            }
	        }).call(this);
	        buf.push("</section></div></div></li>");
	    }).call(this, "firstEl" in locals_for_with ? locals_for_with.firstEl : typeof firstEl !== "undefined" ? firstEl : undefined, "message" in locals_for_with ? locals_for_with.message : typeof message !== "undefined" ? message : undefined, "messageDate" in locals_for_with ? locals_for_with.messageDate : typeof messageDate !== "undefined" ? messageDate : undefined, "undefined" in locals_for_with ? locals_for_with.undefined :  false ? undefined : undefined);
	    return buf.join("");
	};

	// includes\mucRosterItem.jade compiled template
	templatizer["includes"]["mucRosterItem"] = function tmpl_includes_mucRosterItem() {
	    return '<li class="online"><div class="name"></div></li>';
	};

	// includes\wrappedMessage.jade compiled template
	templatizer["includes"]["wrappedMessage"] = function tmpl_includes_wrappedMessage(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (firstEl, message, messageDate, undefined) {
	        buf.push('<li><div class="sender"><a href="#" class="messageAvatar"><img' + jade.attr("src", message.sender.avatar, true, false) + jade.attr("alt", message.sender.displayName, true, false) + ' data-placement="below"/></a></div><div class="messageWrapper"><div class="message_header"><div class="name">' + jade.escape((jade_interp = message.sender.displayName) == null ? "" : jade_interp) + "</div><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + "</div></div>");
	        var messageClasses = message.classList;
	        if (firstEl) {
	            messageClasses += " first";
	        }
	        buf.push("<div" + jade.attr("id", "chat" + message.cid, true, false) + jade.cls(["message", messageClasses], [null, true]) + "><div" + jade.attr("title", messageDate.format("{Dow}, {MM}/{dd}/{yyyy} - {h}:{mm} {Tt}"), true, false) + ' class="date">' + jade.escape((jade_interp = messageDate.format("{h}:{mm} {tt}")) == null ? "" : jade_interp) + '</div><p class="body">' + ((jade_interp = message.processedBody) == null ? "" : jade_interp) + "</p>");
	        var urls = message.urls;
	        buf.push('<section class="embeds">');
	        (function () {
	            var $$obj = urls;
	            if ("number" == typeof $$obj.length) {
	                for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            } else {
	                var $$l = 0;
	                for (var $index in $$obj) {
	                    $$l++;
	                    var item = $$obj[$index];
	                    if (item.source == "body") {
	                        buf.push('<section class="embed hidden"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    } else {
	                        buf.push('<section class="embed"><a' + jade.attr("href", item.href, true, false) + ' class="source">' + jade.escape(null == (jade_interp = item.desc) ? "" : jade_interp) + "</a></section>");
	                    }
	                }
	            }
	        }).call(this);
	        buf.push("</section></div></div></li>");
	    }).call(this, "firstEl" in locals_for_with ? locals_for_with.firstEl : typeof firstEl !== "undefined" ? firstEl : undefined, "message" in locals_for_with ? locals_for_with.message : typeof message !== "undefined" ? message : undefined, "messageDate" in locals_for_with ? locals_for_with.messageDate : typeof messageDate !== "undefined" ? messageDate : undefined, "undefined" in locals_for_with ? locals_for_with.undefined :  false ? undefined : undefined);
	    return buf.join("");
	};

	// pages\groupchat.jade compiled template
	templatizer["pages"]["groupchat"] = function tmpl_pages_groupchat() {
	    return '<section class="page chat"><section class="group conversation"><header class="online"><div class="title"><span class="name"></span><i class="channel_actions fa fa-comments-o"></i><span contenteditable="true" spellcheck="false" class="status"></span></div></header><ul class="messages"></ul><a id="members_toggle"><i class="fa fa-user"></i><span id="members_toggle_count"></span></a><ul class="groupRoster"></ul><div class="chatBox"><ul class="autoComplete"></ul><form class="formwrap"><textarea name="chatInput" type="text" placeholder="Send a message..." autocomplete="off"></textarea></form></div></section></section>';
	};

	// pages\chat.jade compiled template
	templatizer["pages"]["chat"] = function tmpl_pages_chat() {
	    return '<section class="page chat"><section class="conversation"><header><div class="title"><span class="name"></span><i class="user_presence fa fa-circle"></i><span class="status"></span></div><div class="tzo"></div></header><ul class="messages scroll-container"></ul><div class="activeCall"><div class="container"><video autoplay="autoplay" class="remote"></video><video autoplay="autoplay" muted="muted" class="local"></video><aside class="button-wrap"><button class="accept primary">Accept</button><button class="end secondary">End</button><div class="button-group outlined"><button class="mute">Mute</button><button class="unmute">Unmute</button></div></aside></div></div><div class="chatBox"><div class="contactState"></div><form class="formwrap"><textarea name="chatInput" type="text" placeholder="Send a message..." autocomplete="off"></textarea></form><button class="primary small call">Call</button></div></section></section>';
	};

	// pages\settings.jade compiled template
	templatizer["pages"]["settings"] = function tmpl_pages_settings() {
	    return '<section class="page main"><h1 id="title">Settings</h1><div id="avatarChanger"><h4>Change Avatar</h4><div class="uploadRegion"><p>Drag and drop a new avatar here</p><img/><form><input id="uploader" type="file"/></form></div></div><div><h4>Desktop Integration</h4><button class="enableAlerts">Enable alerts</button><button class="primary installFirefox">Install app</button><button class="soundNotifs">sound notifications</button></div><div><button class="disconnect">Disconnect</button><button class="primary logout">Logout</button></div></section>';
	};

	// pages\signin.jade compiled template
	templatizer["pages"]["signin"] = function tmpl_pages_signin() {
	    return '<section class="page signin"><div id="loginForm"><form><label>JID:<input type="text" id="jid" placeholder="you@aweso.me"/></label><label>Password:<input type="password" id="password"/></label><label>WebSocket URL:<input type="text" id="wsURL" placeholder="wss://aweso.me:5281/xmpp-websocket"/></label><input type="submit" value="Connect" class="button primary"/></form></div></section>';
	};

	// misc\growlMessage.jade compiled template
	templatizer["misc"]["growlMessage"] = function tmpl_misc_growlMessage(locals) {
	    var buf = [];
	    var jade_mixins = {};
	    var jade_interp;
	    var locals_for_with = locals || {};
	    (function (description, icon, title) {
	        buf.push('<div class="growlMessage">');
	        if (icon) {
	            buf.push("<img" + jade.attr("src", icon, true, false) + ' height="30" width="30"/>');
	        }
	        if (title) {
	            buf.push("<h1>" + jade.escape(null == (jade_interp = title) ? "" : jade_interp) + "</h1>");
	        }
	        if (description) {
	            buf.push("<p>" + jade.escape(null == (jade_interp = description) ? "" : jade_interp) + "</p>");
	        }
	        buf.push("</div>");
	    }).call(this, "description" in locals_for_with ? locals_for_with.description : typeof description !== "undefined" ? description : undefined, "icon" in locals_for_with ? locals_for_with.icon : typeof icon !== "undefined" ? icon : undefined, "title" in locals_for_with ? locals_for_with.title : typeof title !== "undefined" ? title : undefined);
	    return buf.join("");
	};

	module.exports = templatizer;

/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';

	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */

	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];

	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }

	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }

	  return a;
	};

	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */

	function nulls(val) {
	  return val != null && val !== '';
	}

	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}

	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};


	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};

	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];

	  var keys = Object.keys(obj);

	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];

	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }

	  return buf.join('');
	};

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;

	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}

	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};

	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */

	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(628).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);

	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');

	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};

	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 628 */
/***/ function(module, exports) {

	

/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(217);

	/*
	 * JavaScript Linkify - v0.3 - 6/27/2009
	 * http://benalman.com/projects/javascript-linkify/
	 *
	 * Copyright (c) 2009 "Cowboy" Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 *
	 * Some regexps adapted from http://userscripts.org/scripts/review/7122
	 */
	var parseLinks = (function () {
	    var k = "[a-z\\d.-]+://",
	        h = "(?:(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])",
	        c = "(?:(?:[^\\s!@#$%^&*()_=+[\\]{}\\\\|;:'\",.<>/?]+)\\.)+",
	        n = "(?:ac|ad|aero|ae|af|ag|ai|al|am|an|ao|aq|arpa|ar|asia|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|biz|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|cat|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|coop|com|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|info|int|in|io|iq|ir|is|it|je|jm|jobs|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mil|mk|ml|mm|mn|mobi|mo|mp|mq|mr|ms|mt|museum|mu|mv|mw|mx|my|mz|name|na|nc|net|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pro|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm|tn|to|tp|travel|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|xn--0zwm56d|xn--11b5bs3a9aj6g|xn--80akhbyknj4f|xn--9t4b11yi5a|xn--deba0ad|xn--g6w251d|xn--hgbk6aj7f53bba|xn--hlcj6aya9esc7a|xn--jxalpdlp|xn--kgbechtv|xn--zckzah|ye|yt|yu|za|zm|zw)",
	        f = "(?:" + c + n + "|" + h + ")",
	        o = "(?:[;/][^#?<>\\s]*)?",
	        e = "(?:\\?[^#<>\\s]*)?(?:#[^<>\\s]*)?",
	        d = "\\b" + k + "[^<>\\s]+",
	        a = "\\b" + f + o + e + "(?!\\w)",
	        m = "mailto:",
	        j = "(?:" + m + ")?[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@" + f + e + "(?!\\w)",
	        l = new RegExp("(?:" + d + "|" + a + "|" + j + ")", "ig"),
	        g = new RegExp("^" + k, "i"),
	        b = { "'": "`", ">": "<", ")": "(", "]": "[", "}": "{", "B;": "B+", "b:": "b9" },
	        i = { callback: function callback(q, p) {
	            return p ? '<a href="' + p + '" title="' + p + '">' + q + "</a>" : q;
	        }, punct_regexp: /(?:[!?.,:;'"]|(?:&|&amp;)(?:lt|gt|quot|apos|raquo|laquo|rsaquo|lsaquo);)$/ };return function (u, z) {
	        z = z || {};var w,
	            v,
	            A,
	            p,
	            x = "",
	            t = [],
	            s,
	            E,
	            C,
	            y,
	            q,
	            D,
	            B,
	            r;for (v in i) {
	            if (z[v] === undefined) {
	                z[v] = i[v];
	            }
	        }while (w = l.exec(u)) {
	            A = w[0];E = l.lastIndex;C = E - A.length;if (/[\/:]/.test(u.charAt(C - 1))) {
	                continue;
	            }do {
	                y = A;r = A.substr(-1);B = b[r];if (B) {
	                    q = A.match(new RegExp("\\" + B + "(?!$)", "g"));D = A.match(new RegExp("\\" + r, "g"));if ((q ? q.length : 0) < (D ? D.length : 0)) {
	                        A = A.substr(0, A.length - 1);E--;
	                    }
	                }if (z.punct_regexp) {
	                    A = A.replace(z.punct_regexp, function (F) {
	                        E -= F.length;return "";
	                    });
	                }
	            } while (A.length && A !== y);p = A;if (!g.test(p)) {
	                p = (p.indexOf("@") !== -1 ? !p.indexOf(m) ? "" : m : !p.indexOf("irc.") ? "irc://" : !p.indexOf("ftp.") ? "ftp://" : "http://") + p;
	            }if (s != C) {
	                t.push([u.slice(s, C)]);s = E;
	            }t.push([A, p]);
	        }t.push([u.substr(s)]);for (v = 0; v < t.length; v++) {
	            x += z.callback.apply(window, t[v]);
	        }return x || u;
	    };
	})();

	module.exports = {
	    toHTML: function toHTML(msg, team) {
	        var html = this.escapeHTML(msg);
	        return this.linkify(html);
	    },
	    linkify: function linkify(text) {
	        return parseLinks(text, {
	            callback: function callback(text, href) {
	                return href ? '<a href="' + href + '" target="_blank">' + text + '</a>' : text;
	            }
	        });
	    },
	    collectLinks: function collectLinks(text) {
	        var links = [];
	        parseLinks(text, {
	            callback: function callback(text, href) {
	                if (!href) return;
	                links.push(href);
	            }
	        });
	        return links;
	    },
	    escapeHTML: function escapeHTML(s) {
	        var re = /[&\"'<>]/g,
	            // "
	        map = { "&": "&amp;", "\"": "&quot;", "'": "&apos;", "<": "&lt;", ">": "&gt;" };
	        return s.replace(re, function (c) {
	            return map[c];
	        });
	    }
	};

/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {// follow @HenrikJoreteg and @andyet if you like this ;)
	(function () {
	    var inNode = typeof window === 'undefined',
	        ls = !inNode && window.localStorage,
	        out = {};

	    if (inNode) {
	        module.exports = console;
	        return;
	    }

	    var andlogKey = ls.andlogKey || 'debug'
	    if (ls && ls[andlogKey] && window.console) {
	        out = window.console;
	    } else {
	        var methods = "assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,time,timeEnd,trace,warn".split(","),
	            l = methods.length,
	            fn = function () {};

	        while (l--) {
	            out[methods[l]] = fn;
	        }
	    }
	    if (true) {
	        module.exports = out;
	    } else {
	        window.console = out;
	    }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var BaseCollection = __webpack_require__(511);
	var Call = __webpack_require__(632);

	module.exports = BaseCollection.extend({
	    type: 'calls',
	    model: Call
	});

/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me, client*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanModel = __webpack_require__(505);
	var logger = __webpack_require__(630);

	module.exports = HumanModel.define({
	    type: 'call',
	    initialize: function initialize(attrs) {
	        this.contact.onCall = true;
	        // temporary, this won't stay here
	        app.navigate('/chat/' + encodeURIComponent(this.contact.jid));
	    },
	    session: {
	        contact: 'object',
	        jingleSession: 'object',
	        state: ['string', true, 'inactive'],
	        multiUser: ['boolean', true, false]
	    },
	    end: function end(reasonForEnding) {
	        var reason = reasonForEnding || 'success';
	        this.contact.onCall = false;
	        if (this.jingleSession) {
	            this.jingleSession.end(reasonForEnding);
	        }
	        this.collection.remove(this);
	    }
	});

/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, client*/
	"use strict";

	var async = __webpack_require__(218);
	var BaseCollection = __webpack_require__(511);
	var MUC = __webpack_require__(634);

	module.exports = BaseCollection.extend({
	    type: 'mucs',
	    model: MUC,
	    comparator: function comparator(model1, model2) {
	        var name1 = model1.displayName.toLowerCase();
	        var name2 = model2.displayName.toLowerCase();
	        if (name1 === name2) {
	            return 0;
	        }
	        if (name1 < name2) {
	            return -1;
	        }
	        return 1;
	    },
	    initialize: function initialize(model, options) {
	        this.bind('change', this.sort, this);
	    },
	    fetch: function fetch() {
	        var self = this;
	        app.whenConnected(function () {
	            client.getBookmarks(function (err, res) {
	                if (err) return;

	                var mucs = res.privateStorage.bookmarks.conferences || [];
	                mucs.forEach(function (muc) {
	                    self.add(muc);
	                    if (muc.autoJoin) {
	                        self.get(muc.jid).join();
	                    }
	                });

	                self.trigger('loaded');
	            });
	        });
	    },
	    save: function save(cb) {
	        var self = this;
	        app.whenConnected(function () {
	            var models = [];
	            self.models.forEach(function (model) {
	                models.push({
	                    name: model.name,
	                    jid: model.jid,
	                    nick: model.nick,
	                    autoJoin: model.autoJoin
	                });
	            });
	            client.setBookmarks({ conferences: models }, cb);
	        });
	    }
	});

/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me, client*/
	"use strict";

	var _ = __webpack_require__(217);
	var async = __webpack_require__(218);
	var uuid = __webpack_require__(620);
	var htmlify = __webpack_require__(629);
	var HumanModel = __webpack_require__(505);
	var Resources = __webpack_require__(621);
	var Messages = __webpack_require__(624);
	var Message = __webpack_require__(625);
	var fetchAvatar = __webpack_require__(623);

	module.exports = HumanModel.define({
	    initialize: function initialize(attrs) {
	        if (attrs.jid) {
	            this.id = attrs.jid.full;
	        }
	        var self = this;
	        this.resources.bind("add remove reset", function () {
	            self.membersCount = self.resources.length;
	        });
	    },
	    type: 'muc',
	    props: {
	        id: ['string', true],
	        name: 'string',
	        autoJoin: ['bool', false, false],
	        nick: 'string',
	        jid: 'object'
	    },
	    session: {
	        subject: 'string',
	        activeContact: ['bool', false, false],
	        lastInteraction: 'date',
	        lastSentMessage: 'object',
	        unreadCount: ['number', false, 0],
	        persistent: ['bool', false, false],
	        joined: ['bool', true, false],
	        membersCount: ['number', false, 0]
	    },
	    derived: {
	        displayName: {
	            deps: ['name', 'jid'],
	            fn: function fn() {
	                var disp = this.name;
	                if (!disp) disp = this.jid.jid;
	                return disp.split('@')[0];
	            }
	        },
	        displayUnreadCount: {
	            deps: ['unreadCount'],
	            fn: function fn() {
	                if (this.unreadCount > 0) {
	                    if (this.unreadCount < 100) return this.unreadCount.toString();else return '99+';
	                }
	                return '';
	            }
	        },
	        displaySubject: {
	            deps: ['subject'],
	            fn: function fn() {
	                return htmlify.toHTML(this.subject);
	            }
	        },
	        hasUnread: {
	            deps: ['unreadCount'],
	            fn: function fn() {
	                return this.unreadCount > 0;
	            }
	        }
	    },
	    collections: {
	        resources: Resources,
	        messages: Messages
	    },
	    getName: function getName(jid) {
	        var nickname = jid.split('/')[1];
	        var name = nickname;
	        var xmppContact = me.getContact(nickname);
	        if (xmppContact) {
	            name = xmppContact.displayName;
	        }
	        return name != '' ? name : nickname;
	    },
	    getNickname: function getNickname(jid) {
	        var nickname = jid.split('/')[1];
	        return nickname != this.getName(jid) ? nickname : '';
	    },
	    getAvatar: function getAvatar(jid) {
	        var resource = this.resources.get(jid);
	        if (resource && resource.avatar) {
	            return resource.avatar;
	        }
	        return "https://www.gravatar.com/avatar/00000000000000000000000000000000?s=80&d=mm";
	    },
	    addMessage: function addMessage(message, notify) {
	        message.owner = me.jid.bare;

	        var self = this;

	        var mentions = [];
	        var toMe = false;
	        if (message.body.toLowerCase().indexOf(self.nick) >= 0) {
	            mentions.push(self.nick);
	            toMe = true;
	        }
	        if (message.body.toLowerCase().indexOf('all: ') >= 0) {
	            mentions.push('all:');
	        }
	        message.mentions = mentions;

	        var mine = message.from.resource === this.nick;

	        if (mine) {
	            message._mucMine = true;
	        }

	        if (notify && (!this.activeContact || this.activeContact && !app.state.focused) && !mine) {
	            this.unreadCount++;
	            if (toMe) {
	                app.notifications.create(this.displayName, {
	                    body: message.body,
	                    icon: this.avatar,
	                    tag: this.id,
	                    onclick: _.bind(app.navigate, app, '/groupchat/' + encodeURIComponent(this.jid))
	                });
	                if (me.soundEnabled) app.soundManager.play('threetone-alert');
	            } else {
	                if (me.soundEnabled) app.soundManager.play('ding');
	            }
	        }

	        message.acked = true;

	        if (mine) {
	            this.lastSentMessage = message;
	        }

	        var existing = Message.idLookup(message.from['full'], message.mid);
	        if (existing) {
	            existing.set(message);
	            existing.save();
	        } else {
	            this.messages.add(message);
	            message.save();
	        }

	        var newInteraction = new Date(message.created);
	        if (!this.lastInteraction || this.lastInteraction < newInteraction) {
	            this.lastInteraction = newInteraction;
	        }
	    },
	    join: function join(manual) {
	        if (!this.nick) {
	            this.nick = me.jid.local;
	        }
	        this.messages.reset();
	        this.resources.reset();

	        client.joinRoom(this.jid, this.nick, {
	            joinMuc: {
	                history: {
	                    maxstanzas: 50
	                }
	            }
	        });

	        if (manual) {
	            var form = {
	                fields: [{
	                    type: 'hidden',
	                    name: 'FORM_TYPE',
	                    value: 'http://jabber.org/protocol/muc#roomconfig'
	                }, {
	                    type: 'boolean',
	                    name: 'muc#roomconfig_changesubject',
	                    value: true
	                }, {
	                    type: 'boolean',
	                    name: 'muc#roomconfig_persistentroom',
	                    value: true
	                }]
	            };
	            client.configureRoom(this.jid, form, function (err, resp) {
	                if (err) return;
	            });

	            if (SERVER_CONFIG.domain && SERVER_CONFIG.admin) {
	                var self = this;
	                client.setRoomAffiliation(this.jid, SERVER_CONFIG.admin + '@' + SERVER_CONFIG.domain, 'owner', 'administration', function (err, resp) {
	                    if (err) return;
	                    client.setRoomAffiliation(self.jid, me.jid, 'none', 'administration');
	                });
	            }
	        }

	        var self = this;
	        // After a reconnection
	        client.on('muc:join', function (pres) {
	            if (self.messages.length) {
	                self.fetchHistory(true);
	            }
	        });
	    },
	    fetchHistory: function fetchHistory(allInterval) {
	        var self = this;
	        app.whenConnected(function () {
	            var filter = {
	                'to': self.jid,
	                rsm: {
	                    max: 40,
	                    before: !allInterval
	                }
	            };

	            if (allInterval) {
	                var lastMessage = self.messages.last();
	                if (lastMessage && lastMessage.created) {
	                    var start = new Date(lastMessage.created);
	                    filter.start = start.toISOString();
	                }
	            } else {
	                var firstMessage = self.messages.first();
	                if (firstMessage && firstMessage.created) {
	                    var end = new Date(firstMessage.created);
	                    filter.end = end.toISOString();
	                }
	            }

	            client.searchHistory(filter, function (err, res) {
	                if (err) return;

	                var results = res.mamResult.items || [];

	                results.forEach(function (result) {
	                    var msg = result.forwarded.message;

	                    msg.mid = msg.id;
	                    delete msg.id;

	                    if (!msg.delay) {
	                        msg.delay = result.forwarded.delay;
	                    }

	                    if (msg.replace) {
	                        var original = Message.idLookup(msg.from[msg.type == 'groupchat' ? 'full' : 'bare'], msg.replace);
	                        // Drop the message if editing a previous, but
	                        // keep it if it didn't actually change an
	                        // existing message.
	                        if (original && original.correct(msg)) return;
	                    }

	                    var message = new Message(msg);
	                    message.archivedId = result.id;
	                    message.acked = true;

	                    self.addMessage(message, false);
	                });

	                if (allInterval) {
	                    self.trigger('refresh');
	                    if (results.length == 40) self.fetchHistory(true);
	                }
	            });
	        });
	    },
	    leave: function leave() {
	        this.resources.reset();
	        client.leaveRoom(this.jid, this.nick);
	    }
	});

/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var BaseCollection = __webpack_require__(511);
	var ContactRequest = __webpack_require__(636);

	module.exports = BaseCollection.extend({
	    type: 'contactRequests',
	    model: ContactRequest
	});

/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me*/
	"use strict";

	var HumanModel = __webpack_require__(505);

	module.exports = HumanModel.define({
	    type: 'contactRequest',
	    props: {
	        jid: ['string', true, '']
	    }
	});

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*global $, app, me, client*/
	"use strict";

	var HumanView = __webpack_require__(638);
	var StanzaIo = __webpack_require__(221);
	var templates = __webpack_require__(626);
	var ContactListItem = __webpack_require__(639);
	var MUCListItem = __webpack_require__(640);
	var CallView = __webpack_require__(641);

	var ContactRequestItem = __webpack_require__(642);

	module.exports = HumanView.extend({
	    template: templates.body,
	    initialize: function initialize() {
	        this.listenTo(app.state, 'change:title', this.handleTitle);
	        app.desktop.updateBadge('');
	        app.state.on('change:deviceID', function () {
	            console.log('DEVICE ID>>>', app.state.deviceID);
	        });

	        app.state.bind('change:connected', this.connectionChange, this);
	    },
	    events: {
	        'click a[href]': 'handleLinkClick',
	        'click .embed': 'handleEmbedClick',
	        'click .reconnect': 'handleReconnect',
	        'click .logout': 'handleLogout',
	        'keydown #addcontact': 'keyDownAddContact',
	        'keydown #joinmuc': 'keyDownJoinMUC',
	        'blur #me .status': 'handleStatusChange',
	        'keydown .status': 'keyDownStatus'
	    },
	    classBindings: {
	        connected: '#topbar',
	        cacheStatus: '#updateBar',
	        hasActiveCall: '#wrapper',
	        currentPageIsSettings: '.settings'
	    },
	    render: function render() {
	        $('head').append(templates.head());
	        $('body').removeClass('aux');
	        this.renderAndBind();
	        this.renderCollection(me.contacts, ContactListItem, this.$('#roster nav'));
	        this.renderCollection(me.mucs, MUCListItem, this.$('#bookmarks nav'));
	        this.renderCollection(me.contactRequests, ContactRequestItem, this.$('#contactrequests'));

	        this.$joinmuc = this.$('#joinmuc');
	        this.$addcontact = this.$('#addcontact');
	        this.$meStatus = this.$('#footer .status');

	        this.registerBindings(me, {
	            textBindings: {
	                displayName: '#me .name',
	                status: '#me .status',
	                organization: '#organization #orga_name'
	            },
	            srcBindings: {
	                avatar: '#me .avatar'
	            }
	        });
	        return this;
	    },
	    handleReconnect: function handleReconnect(e) {
	        client.connect();
	    },
	    handleLinkClick: function handleLinkClick(e) {
	        var t = $(e.target);
	        var aEl = t.is('a') ? t[0] : t.closest('a')[0];
	        var local = window.location.host === aEl.host;
	        var path = aEl.pathname.slice(1);

	        if (local) {
	            e.preventDefault();
	            app.navigate(path);
	            return false;
	        }
	    },
	    handleEmbedClick: function handleEmbedClick(e) {
	        if (e.shiftKey) {
	            e.preventDefault();
	            $(e.currentTarget).toggleClass('collapsed');
	        }
	    },
	    handleTitle: function handleTitle(e) {
	        document.title = app.state.title;
	        app.desktop.updateBadge(app.state.badge);
	    },
	    handleStatusChange: function handleStatusChange(e) {
	        var text = e.target.textContent;
	        me.status = text;
	        client.sendPresence({
	            status: text,
	            caps: client.disco.caps
	        });
	    },
	    keyDownStatus: function keyDownStatus(e) {
	        if (e.which === 13 && !e.shiftKey) {
	            e.target.blur();
	            return false;
	        }
	    },
	    handleLogout: function handleLogout(e) {
	        app.navigate('/logout');
	    },
	    handleAddContact: function handleAddContact(e) {
	        e.preventDefault();

	        var contact = this.$('#addcontact').val();
	        if (contact.indexOf('@') == -1 && SERVER_CONFIG.domain) contact += '@' + SERVER_CONFIG.domain;
	        if (contact) {
	            app.api.sendPresence({ to: contact, type: 'subscribe' });
	        }
	        this.$('#addcontact').val('');

	        return false;
	    },
	    keyDownAddContact: function keyDownAddContact(e) {
	        if (e.which === 13 && !e.shiftKey) {
	            this.handleAddContact(e);
	            return false;
	        }
	    },
	    handleJoinMUC: function handleJoinMUC(e) {
	        e.preventDefault();

	        var mucjid = this.$('#joinmuc').val();
	        this.$('#joinmuc').val('');
	        if (mucjid.indexOf('@') == -1 && SERVER_CONFIG.muc) mucjid += '@' + SERVER_CONFIG.muc;
	        me.mucs.add({
	            id: mucjid,
	            name: mucjid,
	            jid: new StanzaIo.JID(mucjid),
	            nick: me.nick,
	            autoJoin: true
	        });        
	        me.mucs.save();
	        var room = me.mucs.get(decodeURIComponent(mucjid));	        
	        if (room) room.join(true)
	    },
	    keyDownJoinMUC: function keyDownJoinMUC(e) {
	        if (e.which === 13 && !e.shiftKey) {
	            this.handleJoinMUC(e);
	            return false;
	        }
	    },
	    connectionChange: function connectionChange() {
	        if (app.state.connected) {
	            this.$joinmuc.attr("disabled", false);
	            this.$addcontact.attr("disabled", false);
	            this.$meStatus.attr("contenteditable", true);
	        } else {
	            this.$joinmuc.attr("disabled", "disabled");
	            this.$addcontact.attr("disabled", "disabled");
	            this.$meStatus.attr("contenteditable", false);
	        }
	    }
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/*global $*/
	(function () {
	  "use strict";
	  var Backbone, _;
	  var slice = Array.prototype.slice;

	  if (true) {
	    Backbone = __webpack_require__(216);
	    _ = __webpack_require__(217);
	  } else {
	    Backbone = window.Backbone;
	    _ = window._;
	  }

	  var HumanView = Backbone.View.extend({
	    // ## registerSubview
	    // Pass it a view. This can be anything with a `remove` method
	    registerSubview: function (view) {
	      // Storage for our subviews.
	      this._subviews || (this._subviews = []);
	      this._subviews.push(view);
	      // If view has an 'el' it's a single view not
	      // an array of views registered by renderCollection
	      // so we store a reference to the parent view.
	      if (view.el) view.parent = this;
	      return view;
	    },

	    // ## renderSubview
	    // Pass it a view instance and a container element
	    // to render it in. It's `remove` method will be called
	    // when theh parent view is destroyed.
	    renderSubview: function (view, container) {
	      if (typeof container === 'string') {
	        container = this.$(container)[0];
	      } else {
	        // de-jquerify
	        container = container[0] || container;
	      }
	      this.registerSubview(view);
	      view.render();
	      container.appendChild(view.el);
	      return view;
	    },

	    // ## registerBindings
	    // This makes it simple to bind model attributes to the DOM.
	    // To use it, add a declarative bindings to your view like this:
	    //
	    //   var ProfileView = HumanView.extend({
	    //     template: 'profile',
	    //     textBindings: {
	    //       'name': '.name'
	    //     },
	    //     classBindings: {
	    //       'active': ''
	    //     },
	    //     render: function () {
	    //       this.renderAndBind();
	    //       return this;
	    //     }
	    //   });
	    registerBindings: function (specificModel, bindings) {
	      var self = this;
	      var types = {
	        textBindings: 'text',
	        htmlBindings: 'html',
	        srcBindings: 'src',
	        hrefBindings: 'href',
	        attributeBindings: '',
	        inputBindings: 'val'
	      };
	      var model = specificModel || this.model;
	      var bindingObject = bindings || this;

	      if (!model) throw new Error('Cannot register bindings without a model');
	      _.each(types, function (methodName, bindingType) {
	        _.each(bindingObject[bindingType], function (selector, key) {
	          var func;
	          var attrName = function () {
	            var res;
	            if (bindingType === 'attributeBindings') {
	              res = selector[1];
	              selector = selector[0];
	              return res;
	            } else if (methodName === 'href' || methodName === 'src') {
	              return methodName;
	            }
	          }();
	          func = function () {
	            var el = self.getMatches(self.el, selector);

	            if (attrName) {
	              el.attr(attrName, model.get(key));
	            } else {
	              el[methodName](model.get(key));
	            }
	          };
	          self.listenTo(model, 'change:' + key, func);
	          func();
	        });
	      });

	      // Class bindings are a bit special. We have to
	      // remove previous, etc.
	      _.each(bindingObject.classBindings, function (selector, key) {
	        var func = function () {
	          var newVal = model.get(key);
	          var prevVal = model.previous(key);
	          var el = self.getMatches(self.el, selector);

	          if (_.isBoolean(newVal)) {
	            if (newVal) {
	              el.addClass(key);
	            } else {
	              el.removeClass(key);
	            }
	          } else {
	            if (prevVal) el.removeClass(prevVal);
	            el.addClass(newVal);
	          }
	        };
	        self.listenTo(model, 'change:' + key, func);
	        func();
	      });

	      return this;
	    },

	    // ## renderAndBind
	    // Commbo for renderWithTemplate and registering bindings
	    renderAndBind: function (context, templateArg) {
	      this.renderWithTemplate(context, templateArg);
	      if (this.model) this.registerBindings();
	      return this;
	    },

	    // ## getByRole
	    // Gets an element within a view by its role attribute.
	    // Also works for the root `el` if it has the right role.
	    getByRole: function (role) {
	      return this.$('[role="' + role + '"]')[0] ||
	        ((this.el.getAttribute('role') === role && this.el) || undefined);
	    },

	    // ## getMatches
	    // Gets matching element from the view by selector
	    getMatches: function (el, selector) {
	      var $el = $(el);

	      if (selector === '') return $el;
	      if ($el.is(selector)) return $el;
	      return $(slice.call(el.querySelectorAll(selector)));
	    },

	    // Shortcut for doing everything we need to do to
	    // render and fully replace current root element.
	    // Either define a `template` property of your view
	    // or pass in a template directly.
	    // The template can either be a string or a function.
	    // If it's a function it will be passed the `context`
	    // argument.
	    renderWithTemplate: function (context, templateArg) {
	      var template = templateArg || this.template;
	      if (!template) throw new Error('Template string or function needed.');
	      var html = _.isString(template) ? template : template(context || {});
	      var wrappedEl = $(html);
	      var newEl = wrappedEl[0];

	      // this is needed because jQuery and others
	      // do weird things if you try to replace the body.
	      // Also doing $(newEl)[0] will give you first child if
	      // it's a <body> element for some reason.
	      if (this.el === document.body) {
	        document.body.innerHTML = html;
	        this.delegateEvents();
	      } else {
	        // safeguard check to help developers debug situation where
	        // they have more than one root element in the template.
	        if (wrappedEl[1]) throw new Error('Views can only have one root element.');

	        $(this.el).replaceWith(newEl);
	        // We don't call delegate events if rendered by parent
	        // this solves a stupid bug in jQuery where you can't
	        // attach event handlers to a detached element
	        // ref: http://api.jquery.com/on/#direct-and-delegated-events
	        this.setElement(newEl, !this.renderedByParentView);
	      }
	    },

	    // ## addReferences
	    // This is a shortcut for adding reference to specific elements within your view for
	    // access later. This is avoids excessive DOM queries and gives makes it easier to update
	    // your view if your template changes. You could argue whether this is worth doing or not,
	    // but I like it.
	    // In your `render` method. Use it like so:
	    //
	    //     render: function () {
	    //       this.basicRender();
	    //       this.addReferences({
	    //         pages: '#pages',
	    //         chat: '#teamChat',
	    //         nav: 'nav#views ul',
	    //         me: '#me',
	    //         cheatSheet: '#cheatSheet',
	    //         omniBox: '#awesomeSauce'
	    //       });
	    //     }
	    //
	    // Then later you can access elements by reference like so: `this.$pages`, or `this.$chat`.
	    addReferences: function (hash) {
	      for (var item in hash) {
	        this['$' + item] = $(hash[item], this.el);
	      }
	    },

	    // ## listenToAndRun
	    // Shortcut for registering a listener for a model
	    // and also triggering it right away.
	    listenToAndRun: function (object, events, handler) {
	      var bound = _.bind(handler, this);
	      this.listenTo(object, events, bound);
	      bound();
	    },

	    // ## animateRemove
	    // Placeholder for if you want to do something special when they're removed.
	    // For example fade it out, etc.
	    // Any override here should call `.remove()` when done.
	    animateRemove: function () {
	      this.remove();
	    },

	    // ## renderCollection
	    // Method for rendering a collections with individual views.
	    // Just pass it the collection, and the view to use for the items in the
	    // collection.
	    renderCollection: function (collection, ViewClass, container, opts) {
	      var self = this;
	      var views = [];
	      var options = _.defaults(opts || {}, {
	        filter: null,
	        viewOptions: {},
	        reverse: false
	      });
	      var containerEl = $(container);

	      // store a reference on the view to it's collection views
	      // so we can clean up memory references when we're done
	      this.registerSubview(views);

	      function getViewBy(model) {
	        return _.find(views, function (view) {
	          return model === view.model;
	        });
	      }

	      function addView(model, collection, opts) {
	        var matches = options.filter ? options.filter(model) : true;
	        var view;
	        if (matches) {
	          view = getViewBy(model);
	          if (!view) {
	            view = new ViewClass(_({model: model, collection: collection}).extend(options.viewOptions));
	            views.push(view);
	            view.parent = self;
	            view.renderedByParentView = true;
	            view.render({containerEl: container});
	          }
	          // give the option for the view to choose where it's inserted if you so choose
	          if (!view.insertSelf) containerEl[options.reverse ? 'prepend' : 'append'](view.el);
	          view.delegateEvents();
	        }
	      }
	      function reRender() {
	        // Empty without using jQuery's empty (which removes jQuery handlers)
	        // Originally we did: containerEl[0].innerHTML = '';
	        // but that fails in IE10 because of a browser bug.
	        var parent = containerEl[0];
	        var childNodes = Array.prototype.slice.call(parent.childNodes);
	        _.each(childNodes, function (child) {
	          parent.removeChild(child);
	        });
	        collection.each(addView);
	      }
	      this.listenTo(collection, 'add', addView);
	      this.listenTo(collection, 'remove', function (model) {
	        var index = views.indexOf(getViewBy(model));
	        if (index !== -1) {
	          // remove it if we found it calling animateRemove
	          // to give user option of gracefully destroying.
	          views.splice(index, 1)[0].animateRemove();
	        }
	      });
	      this.listenTo(collection, 'move sort', reRender);
	      this.listenTo(collection, 'refresh reset', function () {
	        // empty array calling `remove` on each
	        // without re-defining `views`
	        while (views.length) {
	          views.pop().remove();
	        }
	        reRender();
	      });
	      reRender();
	    },

	    // ## remove
	    // Overwrites Backbone's `remove` to also unbinds handlers
	    // for models in any views rendered by `renderCollection`.
	    remove: function () {
	      _.chain(this._subviews).flatten().invoke('remove');
	      // call super
	      return Backbone.View.prototype.remove.call(this);
	    }
	  });


	  if (typeof module !== "undefined" && module && module.exports) {
	    module.exports = HumanView;
	  } else {
	    window.HumanView = HumanView;
	  }

	}());

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.contactListItem,
	    classBindings: {
	        show: '',
	        subscription: '',
	        chatState: '',
	        activeContact: '',
	        hasUnread: '',
	        idle: '',
	        persistent: ''
	    },
	    textBindings: {
	        displayName: '.name',
	        displayUnreadCount: '.unread'
	    },
	    srcBindings: {
	        avatar: '.avatar'
	    },
	    events: {
	        'click': 'handleClick',
	        'click .remove': 'handleRemoveContact'
	    },
	    render: function render() {
	        this.renderAndBind({ contact: this.model });
	        return this;
	    },
	    handleClick: function handleClick() {
	        if (me.contacts.get(this.model.jid)) {
	            app.navigate('chat/' + encodeURIComponent(this.model.jid));
	        }
	    },
	    handleRemoveContact: function handleRemoveContact() {
	        var question = "Remove " + (this.model.name ? this.model.name + " (" + this.model.jid + ")" : this.model.jid) + " from contact list?";
	        if (!confirm(question)) return;
	        me.removeContact(this.model.jid);
	        if (app.history.fragment === 'chat/' + encodeURIComponent(this.model.jid)) {
	            app.navigate('/');
	        }
	    }
	});

/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.mucListItem,
	    classBindings: {
	        activeContact: '',
	        hasUnread: '',
	        joined: '',
	        persistent: ''
	    },
	    textBindings: {
	        displayName: '.name',
	        displayUnreadCount: '.unread'
	    },
	    events: {
	        'click': 'handleClick',
	        'click .join': 'handleJoinRoom',
	        'click .remove': 'handleLeaveRoom'
	    },
	    render: function render() {
	        this.renderAndBind({ contact: this.model });
	        return this;
	    },
	    handleClick: function handleClick(e) {
	        app.navigate('groupchat/' + encodeURIComponent(this.model.jid));
	    },
	    handleJoinRoom: function handleJoinRoom(e) {
	        this.model.join();
	    },
	    handleLeaveRoom: function handleLeaveRoom(e) {
	        var muc = this.model;
	        muc.leave();
	    }
	});

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*global $, app*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.call,
	    classBindings: {
	        state: ''
	    },
	    events: {
	        'click .answer': 'handleAnswerClick',
	        'click .ignore': 'handleIgnoreClick',
	        'click .cancel': 'handleCancelClick',
	        'click .end': 'handleEndClick',
	        'click .mute': 'handleMuteClick'
	    },
	    render: function render() {
	        this.renderAndBind();
	        // register bindings for sub model
	        this.registerBindings(this.model.contact, {
	            textBindings: {
	                displayName: '.callerName'
	            },
	            srcBindings: {
	                avatar: '.callerAvatar'
	            }
	        });
	        this.$buttons = this.$('button');
	        this.listenToAndRun(this.model, 'change:state', this.handleCallStateChange);

	        return this;
	    },
	    handleAnswerClick: function handleAnswerClick(e) {
	        e.preventDefault();
	        var self = this;
	        self.model.state = 'active';
	        app.navigate('/chat/' + encodeURIComponent(self.model.contact.jid));
	        self.model.contact.onCall = true;
	        self.model.jingleSession.accept();
	        return false;
	    },
	    handleIgnoreClick: function handleIgnoreClick(e) {
	        e.preventDefault();
	        this.model.jingleSession.end({
	            condition: 'decline'
	        });
	        return false;
	    },
	    handleCancelClick: function handleCancelClick(e) {
	        e.preventDefault();
	        this.model.jingleSession.end({
	            condition: 'cancel'
	        });
	        return false;
	    },
	    handleEndClick: function handleEndClick(e) {
	        e.preventDefault();
	        this.model.jingleSession.end({
	            condition: 'success'
	        });
	        return false;
	    },
	    handleMuteClick: function handleMuteClick(e) {
	        return false;
	    },
	    // we want to make sure we show the appropriate buttons
	    // when in various stages of the call
	    handleCallStateChange: function handleCallStateChange(model, callState) {
	        var state = callState || this.model.state;
	        // hide all
	        this.$buttons.hide();

	        var map = {
	            incoming: '.ignore, .answer',
	            outgoing: '.cancel',
	            accepted: '.end, .mute',
	            terminated: '',
	            ringing: '.cancel',
	            mute: '.end, .unmute',
	            unmute: '.end, .mute'
	        };

	        //hold: '',
	        //resumed: ''
	        console.log('map[state]', map[state]);

	        this.$(map[state]).show();
	    }
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.contactRequest,
	    initialize: function initialize(opts) {
	        this.render();
	    },
	    events: {
	        'click .approve': 'handleApprove',
	        'click .deny': 'handleDeny'
	    },
	    textBindings: {
	        jid: '.jid'
	    },
	    render: function render() {
	        this.renderAndBind({ message: this.model });
	        return this;
	    },
	    handleApprove: function handleApprove(e) {
	        e.preventDefault();
	        app.api.sendPresence({
	            to: this.model.jid,
	            type: 'subscribed'
	        });
	        app.api.sendPresence({
	            to: this.model.jid,
	            type: 'subscribe'
	        });
	        app.me.contactRequests.remove(this.model);
	        return false;
	    },
	    handleDeny: function handleDeny(e) {
	        e.preventDefault();
	        app.api.sendPresence({
	            to: this.model.jid,
	            type: 'unsubscribed'
	        });
	        app.me.contactRequests.remove(this.model);
	        return false;
	    }
	});

/***/ },
/* 643 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me, client*/
	"use strict";

	var Backbone = __webpack_require__(216);
	var SettingsPage = __webpack_require__(644);
	var ChatPage = __webpack_require__(646);
	var GroupChatPage = __webpack_require__(651);

	module.exports = Backbone.Router.extend({
	    routes: {
	        '': 'settings',
	        'chat/:jid': 'chat',
	        'chat/:jid/:resource': 'chat',
	        'groupchat/:jid': 'groupchat',
	        'logout': 'logout'
	    },
	    // ------- ROUTE HANDLERS ---------
	    settings: function settings() {
	        app.renderPage(new SettingsPage({
	            model: me
	        }));
	    },
	    chat: function chat(jid) {
	        var contact = me.contacts.get(decodeURIComponent(jid));
	        if (contact) {
	            app.renderPage(new ChatPage({
	                model: contact
	            }));
	        } else {
	            app.navigate('/');
	        }
	    },
	    groupchat: function groupchat(jid) {
	        var contact = me.mucs.get(decodeURIComponent(jid));
	        if (contact) {
	            app.renderPage(new GroupChatPage({
	                model: contact
	            }));
	        } else {
	            app.navigate('/');
	        }
	    },
	    logout: function logout() {
	        if (client.sessionStarted) {
	            client.disconnect();
	        }
	        localStorage.clear();
	        window.location = 'login.html';
	    }
	});

/***/ },
/* 644 */
/***/ function(module, exports, __webpack_require__) {

	/*global app, me, client, Resample*/
	"use strict";

	var BasePage = __webpack_require__(645);
	var templates = __webpack_require__(626);

	module.exports = BasePage.extend({
	    template: templates.pages.settings,
	    classBindings: {
	        shouldAskForAlertsPermission: '.enableAlerts',
	        soundEnabledClass: '.soundNotifs'
	    },
	    srcBindings: {
	        avatar: '#avatarChanger img'
	    },
	    textBindings: {
	        status: '.status'
	    },
	    events: {
	        'click .enableAlerts': 'enableAlerts',
	        'click .installFirefox': 'installFirefox',
	        'click .soundNotifs': 'handleSoundNotifs',
	        'dragover': 'handleAvatarChangeDragOver',
	        'drop': 'handleAvatarChange',
	        'change #uploader': 'handleAvatarChange',
	        'click .disconnect': 'handleDisconnect'
	    },
	    render: function render() {
	        this.renderAndBind();
	        return this;
	    },
	    enableAlerts: function enableAlerts() {
	        if (app.notifications.permissionNeeded()) {
	            app.notifications.requestPermission(function (perm) {
	                if (perm === 'granted') {
	                    app.notifications.create('Ok, sweet!', {
	                        body: "You'll now be notified of stuff that happens."
	                    });
	                }
	            });
	        }
	    },
	    installFirefox: function installFirefox() {
	        if (!app.desktop.installed) {
	            app.desktop.install();
	        } else {
	            app.desktop.uninstall();
	        }
	    },
	    handleAvatarChangeDragOver: function handleAvatarChangeDragOver(e) {
	        e.preventDefault();
	        return false;
	    },
	    handleAvatarChange: function handleAvatarChange(e) {
	        var file;

	        e.preventDefault();

	        if (e.dataTransfer) {
	            file = e.dataTransfer.files[0];
	        } else if (e.target.files) {
	            file = e.target.files[0];
	        } else {
	            return;
	        }

	        if (file.type.match('image.*')) {
	            var fileTracker = new FileReader();
	            fileTracker.onload = function () {
	                me.publishAvatar(this.result);
	            };
	            fileTracker.readAsDataURL(file);
	        }
	    },
	    handleSoundNotifs: function handleSoundNotifs(e) {
	        this.model.setSoundNotification(!this.model.soundEnabled);
	    },
	    handleDisconnect: function handleDisconnect(e) {
	        client.disconnect();
	    }
	});

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);

	module.exports = HumanView.extend({
	        show: function show(animation) {
	                var self = this;

	                $('body').scrollTop(0);

	                if (this.detached) {
	                        this.$('#pages').append(this.el);
	                        this.detached = false;
	                } else {
	                        this.render();
	                }

	                this.$el.addClass('active');

	                app.currentPage = this;

	                app.state.pageTitle = _.result(self, 'title');

	                this.trigger('pageloaded');

	                if (this.model.jid) {
	                        me.setActiveContact(this.model.jid);
	                }

	                return this;
	        },
	        hide: function hide() {
	                var self = this;

	                this.$el.removeClass('active');

	                this.trigger('pageunloaded');

	                if (this.cache) {
	                        this.$el.detach();
	                        this.detached = true;
	                } else {
	                        this.animateRemove();
	                }

	                me.setActiveContact('');

	                return this;
	        }
	});

/***/ },
/* 646 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me, client*/
	"use strict";

	var _ = __webpack_require__(217);
	var StanzaIo = __webpack_require__(221);
	var StayDown = __webpack_require__(647);
	var BasePage = __webpack_require__(645);
	var templates = __webpack_require__(626);
	var Message = __webpack_require__(648);
	var MessageModel = __webpack_require__(625);
	var embedIt = __webpack_require__(649);
	var htmlify = __webpack_require__(629);
	var attachMediaStream = __webpack_require__(650);

	module.exports = BasePage.extend({
	    template: templates.pages.chat,
	    initialize: function initialize(spec) {
	        this.editMode = false;

	        this.listenTo(this, 'pageloaded', this.handlePageLoaded);
	        this.listenTo(this, 'pageunloaded', this.handlePageUnloaded);

	        this.listenTo(this.model.messages, 'change', this.refreshModel);
	        this.listenTo(this.model.messages, 'reset', this.renderCollection);
	        this.listenTo(this.model, 'refresh', this.renderCollection);

	        app.state.bind('change:connected', this.connectionChange, this);
	        this.model.bind('change:avatar', this.handleAvatarChanged, this);

	        this.render();
	    },
	    events: {
	        'keydown textarea': 'handleKeyDown',
	        'keyup textarea': 'handleKeyUp',
	        'click .call': 'handleCallClick',
	        'click .accept': 'handleAcceptClick',
	        'click .end': 'handleEndClick',
	        'click .mute': 'handleMuteClick'
	    },
	    srcBindings: {
	        streamUrl: 'video.remote'
	    },
	    textBindings: {
	        displayName: 'header .name',
	        formattedTZO: 'header .tzo',
	        status: 'header .status',
	        chatStateText: '.chatBox .contactState'
	    },
	    classBindings: {
	        chatState: 'header',
	        idle: '.user_presence',
	        show: '.user_presence',
	        onCall: '.conversation'
	    },
	    show: function show(animation) {
	        BasePage.prototype.show.apply(this, [animation]);
	        this.sendChatState('active');

	        this.firstChanged = true;
	        var self = this;
	        $('.messages').scroll(function () {
	            if (self.firstChanged && $(".messages li:first-child").offset().top > 0) {
	                self.firstChanged = false;
	                self.model.fetchHistory();
	            }
	        });

	        this.$chatInput.focus();
	    },
	    hide: function hide() {
	        BasePage.prototype.hide.apply(this);
	        this.sendChatState('inactive');
	    },
	    render: function render() {
	        if (this.rendered) return this;
	        var self = this;

	        this.rendered = true;

	        this.renderAndBind();

	        this.$chatInput = this.$('.chatBox textarea');
	        this.$chatInput.val(app.composing[this.model.jid] || '');
	        this.$chatBox = this.$('.chatBox');
	        this.$messageList = this.$('.messages');

	        this.staydown = new StayDown({ target: this.$messageList[0], interval: 500 });
	        this.renderCollection();

	        this.listenTo(this.model.messages, 'add', this.handleChatAdded);
	        this.listenToAndRun(this.model, 'change:jingleResources', this.handleJingleResourcesChanged);

	        $(window).on('resize', _.bind(this.resizeInput, this));

	        this.registerBindings(me, {
	            srcBindings: {
	                streamUrl: 'video.local'
	            }
	        });

	        return this;
	    },
	    handlePageLoaded: function handlePageLoaded() {
	        this.staydown.checkdown();
	        this.resizeInput();
	    },
	    handleCallClick: function handleCallClick(e) {
	        e.preventDefault();
	        this.model.call();
	        return false;
	    },
	    renderCollection: function renderCollection() {
	        var self = this;

	        this.$messageList.empty();
	        delete this.firstModel;
	        delete this.firstDate;
	        delete this.lastModel;
	        delete this.lastDate;

	        this.model.messages.each(function (model, i) {
	            self.appendModel(model);
	        });
	        this.staydown.checkdown();
	    },
	    handleKeyDown: function handleKeyDown(e) {
	        if (e.which === 13 && !e.shiftKey) {
	            app.composing[this.model.jid] = '';
	            this.sendChat();
	            this.sendChatState('active');
	            e.preventDefault();
	            return false;
	        } else if (e.which === 38 && this.$chatInput.val() === '' && this.model.lastSentMessage) {
	            this.editMode = true;
	            this.$chatInput.addClass('editing');
	            this.$chatInput.val(this.model.lastSentMessage.body);
	            e.preventDefault();
	            return false;
	        } else if (e.which === 40 && this.editMode) {
	            this.editMode = false;
	            this.$chatInput.removeClass('editing');
	            e.preventDefault();
	            return false;
	        } else if (!e.ctrlKey && !e.metaKey) {
	            if (!this.typing || this.paused) {
	                this.typing = true;
	                this.paused = false;
	                this.$chatInput.addClass('typing');
	                this.sendChatState('composing');
	            }
	        }
	    },
	    handleKeyUp: function handleKeyUp(e) {
	        this.resizeInput();
	        app.composing[this.model.jid] = this.$chatInput.val();
	        if (this.typing && this.$chatInput.val().length === 0) {
	            this.typing = false;
	            this.$chatInput.removeClass('typing');
	            this.sendChatState('active');
	        } else if (this.typing) {
	            this.pausedTyping();
	        }
	    },
	    pausedTyping: _.debounce(function () {
	        if (this.typing && !this.paused) {
	            this.paused = true;
	            this.sendChatState('paused');
	        }
	    }, 3000),
	    sendChatState: function sendChatState(state) {
	        //if (!this.model.supportsChatStates) return;
	        client.sendMessage({
	            to: this.model.lockedResource || this.model.jid,
	            chatState: state
	        });
	    },
	    sendChat: function sendChat() {
	        var message;
	        var val = this.$chatInput.val();

	        if (val) {
	            this.staydown.intend_down = true;

	            var links = _.map(htmlify.collectLinks(val), function (link) {
	                return { url: link };
	            });

	            message = {
	                id: client.nextId(),
	                to: new StanzaIo.JID(this.model.lockedResource || this.model.jid),
	                type: 'chat',
	                body: val,
	                requestReceipt: true,
	                oobURIs: links
	            };
	            if (this.model.supportsChatStates) {
	                message.chatState = 'active';
	            }
	            if (this.editMode) {
	                message.replace = this.model.lastSentMessage.id;
	            }

	            client.sendMessage(message);

	            // Prep message to create a Message model
	            message.from = me.jid;
	            message.mid = message.id;
	            delete message.id;

	            if (this.editMode) {
	                this.model.lastSentMessage.correct(message);
	            } else {
	                var msgModel = new MessageModel(message);
	                this.model.addMessage(msgModel, false);
	                this.model.lastSentMessage = msgModel;
	            }
	        }
	        this.editMode = false;
	        this.typing = false;
	        this.paused = false;
	        this.$chatInput.removeClass('typing');
	        this.$chatInput.removeClass('editing');
	        this.$chatInput.val('');
	    },
	    handleChatAdded: function handleChatAdded(model) {
	        this.appendModel(model, true);
	    },
	    refreshModel: function refreshModel(model) {
	        var existing = this.$('#chat' + model.cid);
	        existing.replaceWith(model.bareMessageTemplate(existing.prev().hasClass('message_header')));
	        existing = this.$('#chat' + model.cid);
	        embedIt(existing);
	    },
	    handleJingleResourcesChanged: function handleJingleResourcesChanged(model, val) {
	        var resources = val || this.model.jingleResources;
	        this.$('button.call').prop('disabled', !resources.length);
	    },
	    handleAvatarChanged: function handleAvatarChanged(contact, uri) {
	        if (!me.isMe(contact.jid)) {
	            $('.' + contact.jid.substr(0, contact.jid.indexOf('@')) + ' .messageAvatar img').attr('src', uri);
	        }
	    },
	    appendModel: function appendModel(model, preload) {
	        var newEl, first, last;
	        var msgDate = Date.create(model.timestamp);
	        var messageDay = msgDate.format('{month} {ord}, {yyyy}');

	        if (this.firstModel === undefined || msgDate > Date.create(this.firstModel.timestamp)) {
	            if (this.firstModel === undefined) {
	                this.firstModel = model;
	                this.firstDate = messageDay;
	            }

	            if (messageDay !== this.lastDate) {
	                var dayDivider = $(templates.includes.dayDivider({ day_name: messageDay }));
	                this.staydown.append(dayDivider[0]);
	                this.lastDate = messageDay;
	            }

	            var isGrouped = model.shouldGroupWith(this.lastModel);
	            if (isGrouped) {          
	                newEl = $(model.partialTemplateHtml);
	                last = this.$messageList.find('li').last();
	                last.find('.messageWrapper').append(newEl);
	                last.addClass('chatGroup');
	                this.staydown.checkdown();
	            } else {
	                newEl = $(model.templateHtml);
	                if (model.sender && !me.isMe(model.sender.jid)) newEl.addClass(model.sender.jid.toString().substr(0, model.sender.jid.toString().indexOf('@')));
	                this.staydown.append(newEl[0]);
	                this.lastModel = model;
	            }
	            if (!model.pending) embedIt(newEl);
	        } else {
	            var scrollDown = this.$messageList.prop('scrollHeight') - this.$messageList.scrollTop();
	            var firstEl = this.$messageList.find('li').first();

	            if (messageDay !== this.firstDate) {
	                var dayDivider = $(templates.includes.dayDivider({ day_name: messageDay }));
	                firstEl.before(dayDivider[0]);
	                var firstEl = this.$messageList.find('li').first();
	                this.firstDate = messageDay;
	            }

	            var isGrouped = model.shouldGroupWith(this.firstModel);
	            if (isGrouped) {
	                newEl = $(model.partialTemplateHtml);
	                first = this.$messageList.find('li').first().next();
	                first.find('.messageWrapper div:first').after(newEl);
	                first.addClass('chatGroup');
	            } else {
	                newEl = $(model.templateHtml);
	                if (!me.isMe(model.sender.jid)) newEl.addClass(model.sender.jid.toString().substr(0, model.sender.jid.toString().indexOf('@')));
	                firstEl.after(newEl[0]);
	                this.firstModel = model;
	            }
	            if (!model.pending) embedIt(newEl);

	            this.$messageList.scrollTop(this.$messageList.prop('scrollHeight') - scrollDown);
	            this.firstChanged = true;
	        }
	    },
	    handleAcceptClick: function handleAcceptClick(e) {
	        e.preventDefault();
	        var self = this;

	        this.$('button.accept').prop('disabled', true);
	        if (this.model.jingleCall.jingleSession.state == 'pending') {
	            if (!client.jingle.localStream) {
	                client.jingle.startLocalMedia(null, function (err) {
	                    if (err) {
	                        self.model.jingleCall.end({
	                            condition: 'decline'
	                        });
	                    } else {
	                        client.sendPresence({ to: new StanzaIo.JID(self.model.jingleCall.jingleSession.peer) });
	                        self.model.jingleCall.jingleSession.accept();
	                    }
	                });
	            } else {
	                client.sendPresence({ to: new StanzaIo.JID(this.model.jingleCall.jingleSession.peer) });
	                this.model.jingleCall.jingleSession.accept();
	            }
	        }
	        return false;
	    },
	    handleEndClick: function handleEndClick(e) {
	        e.preventDefault();
	        var condition = 'success';
	        if (this.model.jingleCall) {
	            if (this.model.jingleCall.jingleSession && this.model.jingleCall.jingleSession.state == 'pending') {
	                condition = 'decline';
	            }
	            this.model.jingleCall.end({
	                condition: condition
	            });
	        }
	        return false;
	    },
	    handleMuteClick: function handleMuteClick(e) {
	        return false;
	    },
	    resizeInput: _.throttle(function () {
	        var height;
	        var scrollHeight;
	        var heightDiff;
	        var newHeight;
	        var newMargin;
	        var marginDelta;
	        var maxHeight = parseInt(this.$chatInput.css('max-height'), 10);

	        this.$chatInput.removeAttr('style');
	        height = this.$chatInput.outerHeight(), scrollHeight = this.$chatInput.get(0).scrollHeight, newHeight = Math.max(height, scrollHeight);
	        heightDiff = height - this.$chatInput.innerHeight();

	        if (newHeight > maxHeight) newHeight = maxHeight;
	        if (newHeight > height) {
	            this.$chatInput.css('height', newHeight + heightDiff);
	            this.$chatInput.scrollTop(this.$chatInput[0].scrollHeight - this.$chatInput.height());
	            newMargin = newHeight - height + heightDiff;
	            marginDelta = newMargin - parseInt(this.$messageList.css('marginBottom'), 10);
	            if (!!marginDelta) {
	                this.$messageList.css('marginBottom', newMargin);
	            }
	        } else {
	            this.$messageList.css('marginBottom', 0);
	        }
	    }, 300),
	    connectionChange: function connectionChange() {
	        if (app.state.connected) {
	            this.$chatInput.attr("disabled", false);
	        } else {
	            this.$chatInput.attr("disabled", "disabled");
	        }
	    }
	});

/***/ },
/* 647 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {function StayDown(opts) {
	    opts = opts || {};
	    this.target = opts.target;
	    this.interval = opts.interval;
	    this.max = opts.max || 0;
	    this.callback = opts.callback;
	    this.userScroll = true;
	    this.spinner = opts.spinner;
	    this.spin_img = new Image();
	    if (this.spinner) {
	        this.spin_img.src = this.spinner;
	    }
	    var staydown = this;
	    this.intend_down = true;

	    this.emit('lock');

	    var wheelevent = "wheel";
	    if (document.onmousewheel !== undefined) {
	        wheelevent = 'mousewheel';
	    }

	    window.addEventListener('resize', function (event) {
	        staydown.emit('windowresize');
	        staydown.checkdown();
	    });

	    this.target.addEventListener('scroll', function (event) {
	        if (staydown.userScroll) {
	            if (staydown.intend_down && !staydown.isdown()) {
	                staydown.intend_down = false;
	                staydown.emit('release');
	            } else if (!staydown.intend_down && staydown.isdown()) {
	                staydown.intend_down = true;
	                staydown.emit('lock');
	            }
	        }
	        staydown.userScroll = true;
	    });

	    if (window.MutationObserver) {
	        //private function for getting images recursively from dom

	        //mutation observer for whenever the overflow element changes
	        this.mo = new MutationObserver(function (mutations) {
	            var mut, idx, nidx, imgs, img, iidx, ilen, parent, spin;
	            staydown.userScroll = false;
	            //something changed, check scroll
	            staydown.checkdown();
	            //check to see if image was added, and add onload check
	            for (idx = 0; idx < mutations.length; idx++) {
	                mut = mutations[idx];
	                for (nidx = 0; nidx < mut.addedNodes.length; nidx++) {
	                    // Check if we appended a node type that isn't
	                    // an element that we can search for images inside.
	                    if (!mut.addedNodes[nidx].getElementsByTagName) {
	                        continue;
	                    }

	                    imgs = mut.addedNodes[nidx].getElementsByTagName('img');
	                    for (iidx = 0, ilen = imgs.length; iidx < ilen; iidx++) {
	                        img = imgs[iidx];
	                        if (!img.complete) {
	                            parent = img.parentNode;
	                            if (staydown.spinner) {
	                                spin = staydown.spin_img.cloneNode();
	                                parent.replaceChild(spin, img);
	                            }
	                            var onImageLoad = function (event) {
	                                if (spin) {
	                                    //image loads later, and isn't a mutation
	                                    parent.replaceChild(img, spin);
	                                }
	                                staydown.emit('imageload');
	                                staydown.checkdown();
	                                event.target.removeEventListener('load', onImageLoad);
	                            };
	                            img.addEventListener('load', onImageLoad);
	                        }
	                    }
	                }
	            }
	        });
	        this.mo.observe(this.target, {attributes: true, childList: true, characterData: true, subtree: true});
	    } else {
	        var checkdown = function () {
	            staydown.checkdown();
	            window.setTimeout(checkdown, staydown.interval);
	        };
	        checkdown();
	    }

	}

	(function () {

	    this.isdown = function () {
	        return (this.target.scrollTop + this.target.clientHeight == this.target.scrollHeight);
	    };

	    this.append = function (newel) {
	        this.emit('append');
	        this.target.appendChild(newel);
	        if (this.intend_down) {
	            this.target.scrollTop = this.target.scrollHeight;
	            this.emit('scrolldown');
	        }
	        while (this.max !== 0 && this.target.children.length > this.max) {
	            this.target.removeChild(this.target.children[0]);
	            this.emit('removechild');
	        }
	    };

	    this.emit = function (type, msg) {
	        if (typeof this.callback === 'function') {
	            this.callback(type, msg);
	        }
	    };

	    this.checkdown = function () {
	        if (this.intend_down && 
	            this.target.scrollTop + this.target.clientHeight != this.target.scrollHeight) {
	            this.target.scrollTop = this.target.scrollHeight;
	            this.userScroll = false;
	            this.emit('scrolldown');
	        }
	    };

	}).call(StayDown.prototype);

	if (!module) {
	    window.StayDown = StayDown;
	} else {
	    module.exports = StayDown;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module)))

/***/ },
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	/*global $*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.message,
	    initialize: function initialize(opts) {
	        this.render();
	    },
	    classBindings: {
	        mine: '.message',
	        receiptReceived: '.message',
	        pending: '.message',
	        delayed: '.message',
	        edited: '.message',
	        meAction: '.message'
	    },
	    textBindings: {
	        body: '.body',
	        formattedTime: '.timestamp'
	    },
	    render: function render() {
	        this.renderAndBind({ message: this.model });
	        return this;
	    }
	});

/***/ },
/* 649 */
/***/ function(module, exports) {

	"use strict";

	/*global $, app*/

	module.exports = function ($html, cb) {
	    cb = cb || function () {};

	    $($html).find("a.source").oembed(null, {
	        fallback: false,
	        includeHandle: false,
	        maxWidth: 500,
	        maxHeight: 350,
	        afterEmbed: function afterEmbed(container, oembedData) {
	            this.parent().parent().parent().show();
	        },
	        onProviderNotFound: function onProviderNotFound() {
	            var link = $($html).find("a.source");
	            var resourceURL = link.attr("href");
	            if (resourceURL.match(/\.(jpg|png|gif)\b/)) {
	                link.parent().append("<div class='oembedall-container'><a href='" + resourceURL + "' target='_blank'><img src='" + resourceURL + "' / style='max-width:500px; max-height:350px; width: auto; height: auto;'></a></div>");
	                this.parent().parent().show();
	            }
	        }
	    });
	};

/***/ },
/* 650 */
/***/ function(module, exports, __webpack_require__) {

	var adapter = __webpack_require__(509);
	module.exports = function (stream, el, options) {
	    var item;
	    var URL = window.URL;
	    var element = el;
	    var opts = {
	        autoplay: true,
	        mirror: false,
	        muted: false,
	        audio: false,
	        disableContextMenu: false
	    };

	    if (options) {
	        for (item in options) {
	            opts[item] = options[item];
	        }
	    }

	    if (!element) {
	        element = document.createElement(opts.audio ? 'audio' : 'video');
	    } else if (element.tagName.toLowerCase() === 'audio') {
	        opts.audio = true;
	    }

	    if (opts.disableContextMenu) {
	        element.oncontextmenu = function (e) {
	            e.preventDefault();
	        };
	    }

	    if (opts.autoplay) element.autoplay = 'autoplay';
	    if (opts.muted) element.muted = true;
	    if (!opts.audio && opts.mirror) {
	        ['', 'moz', 'webkit', 'o', 'ms'].forEach(function (prefix) {
	            var styleName = prefix ? prefix + 'Transform' : 'transform';
	            element.style[styleName] = 'scaleX(-1)';
	        });
	    }

	    adapter.attachMediaStream(element, stream);
	    return element;
	};


/***/ },
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me, client*/
	"use strict";

	var _ = __webpack_require__(217);
	var StanzaIo = __webpack_require__(221);
	var StayDown = __webpack_require__(647);
	var BasePage = __webpack_require__(645);
	var templates = __webpack_require__(626);
	var MUCRosterItem = __webpack_require__(652);
	var Message = __webpack_require__(653);
	var MessageModel = __webpack_require__(625);
	var embedIt = __webpack_require__(649);
	var htmlify = __webpack_require__(629);
	var tempSubject = '';

	module.exports = BasePage.extend({
	    template: templates.pages.groupchat,
	    initialize: function initialize(spec) {
	        this.editMode = false;

	        this.listenTo(this, 'pageloaded', this.handlePageLoaded);
	        this.listenTo(this, 'pageunloaded', this.handlePageUnloaded);

	        this.listenTo(this.model.messages, 'change', this.refreshModel);
	        this.listenTo(this.model.messages, 'reset', this.renderMessages);
	        this.listenTo(this.model, 'refresh', this.renderMessages);

	        app.state.bind('change:connected', this.connectionChange, this);

	        this.render();
	    },
	    events: {
	        'keydown textarea': 'handleKeyDown',
	        'keyup textarea': 'handleKeyUp',
	        'click .status': 'clickStatusChange',
	        'blur .status': 'blurStatusChange',
	        'keydown .status': 'keyDownStatusChange',
	        'click #members_toggle': 'clickMembersToggle'
	    },
	    classBindings: {
	        joined: '.controls'
	    },
	    textBindings: {
	        displayName: 'header .name',
	        subject: 'header .status',
	        membersCount: '#members_toggle_count'
	    },
	    show: function show(animation) {
	        BasePage.prototype.show.apply(this, [animation]);
	        client.sendMessage({
	            type: 'groupchat',
	            to: this.model.jid,
	            chatState: 'active'
	        });

	        this.firstChanged = true;
	        var self = this;
	        $('.messages').scroll(function () {
	            var firstMessage = $(".messages li:first-child");
	            var offset = firstMessage.offset();
	            if (self.firstChanged && offset && offset.top > 0) {
	                self.firstChanged = false;
	                self.model.fetchHistory();
	            }
	        });

	        this.$chatInput.focus();
	    },
	    hide: function hide() {
	        BasePage.prototype.hide.apply(this);
	        client.sendMessage({
	            type: 'groupchat',
	            to: this.model.jid,
	            chatState: 'inactive'
	        });
	    },
	    render: function render() {
	        if (this.rendered) return this;
	        this.rendered = true;

	        this.renderAndBind();
	        this.$chatInput = this.$('.chatBox textarea');
	        this.$chatInput.val(app.composing[this.model.jid] || '');
	        this.$chatBox = this.$('.chatBox');
	        this.$messageList = this.$('.messages');
	        this.$autoComplete = this.$('.autoComplete');

	        this.staydown = new StayDown({ target: this.$messageList[0], interval: 500 });

	        this.renderMessages();

	        this.renderCollection(this.model.resources, MUCRosterItem, this.$('.groupRoster'));

	        this.listenTo(this, 'rosterItemClicked', this.rosterItemSelected);
	        this.listenTo(this.model.messages, 'add', this.handleChatAdded);
	        this.listenTo(this.model.resources, 'add', this.handleResourceAdded);

	        $(window).on('resize', _.bind(this.resizeInput, this));

	        this.registerBindings();

	        return this;
	    },
	    renderMessages: function renderMessages() {
	        var self = this;

	        this.$messageList.empty();
	        delete this.firstModel;
	        delete this.firstDate;
	        delete this.lastModel;
	        delete this.lastDate;

	        this.model.messages.each(function (model, i) {
	            self.appendModel(model);
	        });
	        this.staydown.checkdown();
	    },
	    handleChatAdded: function handleChatAdded(model) {
	        this.appendModel(model, true);
	    },
	    handleResourceAdded: function handleResourceAdded(model) {
	        var xmppContact = me.getContact(model.id.split('/')[1]);
	        if (xmppContact) {
	            xmppContact.bind('change:avatar', this.handleAvatarChanged, this);
	        }
	    },
	    handleAvatarChanged: function handleAvatarChanged(contact, uri) {
	        if (!me.isMe(contact.jid)) {
	            $('.' + contact.jid.substr(0, contact.jid.indexOf('@')) + ' .messageAvatar img').attr('src', uri);
	        }
	    },
	    handlePageLoaded: function handlePageLoaded() {
	        this.staydown.checkdown();
	        this.resizeInput();
	    },
	    handleKeyDown: function handleKeyDown(e) {
	        if ((e.which === 13 || e.which === 9) && !e.shiftKey) {
	            // Enter or Tab
	            if (this.$autoComplete.css('display') != 'none') {
	                var nickname = this.$autoComplete.find(">:nth-child(" + this.autoCompletePos + ")>:first-child").text();
	                this.rosterItemSelected(nickname);
	            } else if (e.which === 13) {
	                app.composing[this.model.jid] = '';
	                this.sendChat();
	            }
	            e.preventDefault();
	            return false;
	        } else if (e.which === 38) {
	            // Up arrow

	            if (this.$autoComplete.css('display') != 'none') {
	                var count = this.$autoComplete.find(">li").length;
	                var oldPos = this.autoCompletePos;
	                this.autoCompletePos = oldPos - 1 < 1 ? count : oldPos - 1;

	                this.$autoComplete.find(">:nth-child(" + oldPos + ")").removeClass('selected');
	                this.$autoComplete.find(">:nth-child(" + this.autoCompletePos + ")").addClass('selected');
	            } else if (this.$chatInput.val() === '' && this.model.lastSentMessage) {
	                this.editMode = true;
	                this.$chatInput.addClass('editing');
	                this.$chatInput.val(this.model.lastSentMessage.body);
	            }
	            e.preventDefault();
	            return false;
	        } else if (e.which === 40) {
	            // Down arrow

	            if (this.$autoComplete.css('display') != 'none') {
	                var count = this.$autoComplete.find(">li").length;
	                var oldPos = this.autoCompletePos;
	                this.autoCompletePos = oldPos + 1 > count ? 1 : oldPos + 1;

	                this.$autoComplete.find(">:nth-child(" + oldPos + ")").removeClass('selected');
	                this.$autoComplete.find(">:nth-child(" + this.autoCompletePos + ")").addClass('selected');
	            } else if (this.editMode) {
	                this.editMode = false;
	                this.$chatInput.removeClass('editing');
	            }
	            e.preventDefault();
	            return false;
	        } else if (!e.ctrlKey && !e.metaKey) {
	            if (!this.typing || this.paused) {
	                this.typing = true;
	                this.paused = false;
	                client.sendMessage({
	                    type: 'groupchat',
	                    to: this.model.jid,
	                    chatState: 'composing'
	                });
	            }
	        }
	    },
	    handleKeyUp: function handleKeyUp(e) {
	        this.resizeInput();
	        app.composing[this.model.jid] = this.$chatInput.val();
	        if (this.typing && this.$chatInput.val().length === 0) {
	            this.typing = false;
	            this.paused = false;
	            client.sendMessage({
	                type: 'groupchat',
	                to: this.model.jid,
	                chatState: 'active'
	            });
	        } else if (this.typing) {
	            this.pausedTyping();
	        }

	        if ([38, 40, 13].indexOf(e.which) === -1) {
	            var lastWord = this.$chatInput.val().split(' ').pop();
	            if (lastWord.charAt(0) === '@') {
	                var models = this.model.resources.search(lastWord.substr(1) || '', true, true);
	                if (models.length) {
	                    this.renderCollection(models, MUCRosterItem, this.$autoComplete);
	                    this.autoCompletePos = 1;
	                    this.$autoComplete.find(">:nth-child(" + this.autoCompletePos + ")").addClass('selected');
	                    this.$autoComplete.show();
	                } else this.$autoComplete.hide();
	            }

	            if (this.$autoComplete.css('display') != 'none') {
	                if (lastWord === '') {
	                    this.$autoComplete.hide();
	                    return;
	                }
	            }
	        }
	    },
	    rosterItemSelected: function rosterItemSelected(nickName) {
	        if (nickName == me.nick) nickName = 'me';
	        var val = this.$chatInput.val();
	        var splited = val.split(' ');
	        var length = splited.length - 1;
	        var lastWord = splited.pop();
	        if (('@' + nickName).indexOf(lastWord) > -1) splited[length] = nickName + ', ';else splited.push(nickName + ', ');
	        this.$chatInput.val(splited.join(' '));
	        this.$autoComplete.hide();
	        this.$chatInput.focus();
	    },
	    resizeInput: _.throttle(function () {
	        var height;
	        var scrollHeight;
	        var heightDiff;
	        var newHeight;
	        var newMargin;
	        var marginDelta;
	        var maxHeight = parseInt(this.$chatInput.css('max-height'), 10);

	        this.$chatInput.removeAttr('style');
	        height = this.$chatInput.outerHeight(), scrollHeight = this.$chatInput.get(0).scrollHeight, newHeight = Math.max(height, scrollHeight);
	        heightDiff = height - this.$chatInput.innerHeight();

	        if (newHeight > maxHeight) newHeight = maxHeight;
	        if (newHeight > height) {
	            this.$chatInput.css('height', newHeight + heightDiff);
	            this.$chatInput.scrollTop(this.$chatInput[0].scrollHeight - this.$chatInput.height());
	            newMargin = newHeight - height + heightDiff;
	            marginDelta = newMargin - parseInt(this.$messageList.css('marginBottom'), 10);
	            if (!!marginDelta) {
	                this.$messageList.css('marginBottom', newMargin);
	            }
	        } else {
	            this.$messageList.css('marginBottom', 0);
	        }
	    }, 300),
	    pausedTyping: _.debounce(function () {
	        if (this.typing && !this.paused) {
	            this.paused = true;
	            client.sendMessage({
	                type: 'groupchat',
	                to: this.model.jid,
	                chatState: 'paused'
	            });
	        }
	    }, 3000),
	    sendChat: function sendChat() {
	        var message;
	        var val = this.$chatInput.val();

	        if (val) {
	            this.staydown.intend_down = true;

	            var links = _.map(htmlify.collectLinks(val), function (link) {
	                return { url: link };
	            });

	            message = {
	                to: this.model.jid,
	                type: 'groupchat',
	                body: val,
	                chatState: 'active',
	                oobURIs: links
	            };
	            if (this.editMode) {
	                message.replace = this.model.lastSentMessage.mid || this.model.lastSentMessage.cid;
	            }

	            var id = client.sendMessage(message);
	            message.mid = id;
	            message.from = new StanzaIo.JID(this.model.jid.bare + '/' + this.model.nick);

	            if (this.editMode) {
	                this.model.lastSentMessage.correct(message);
	            } else {
	                var msgModel = new MessageModel(message);
	                this.model.addMessage(msgModel, false);
	                this.model.lastSentMessage = msgModel;
	            }
	        }
	        this.editMode = false;
	        this.typing = false;
	        this.paused = false;
	        this.$chatInput.removeClass('editing');
	        this.$chatInput.val('');
	    },
	    clickStatusChange: function clickStatusChange(e) {
	        tempSubject = e.target.textContent;
	    },
	    blurStatusChange: function blurStatusChange(e) {
	        var subject = e.target.textContent;
	        if (subject == '') subject = true;
	        client.setSubject(this.model.jid, subject);
	        e.target.textContent = tempSubject;
	    },
	    keyDownStatusChange: function keyDownStatusChange(e) {
	        if (e.which === 13 && !e.shiftKey) {
	            e.target.blur();
	            return false;
	        }
	    },
	    clickMembersToggle: function clickMembersToggle(e) {
	        var roster = $('.groupRoster'); // TODO: check for active roster not for any
	        var pages = roster.closest('.page');
	        var toggleVisible = roster.css('visibility') == 'hidden';

	        if (toggleVisible) roster.css('visibility', 'visible');else roster.css('visibility', 'hidden');

	        pages.toggleClass('visibleGroupRoster', toggleVisible);
	    },
	    appendModel: function appendModel(model, preload) {
	        var newEl, first, last;
	        var msgDate = Date.create(model.timestamp);
	        var messageDay = msgDate.format('{month} {ord}, {yyyy}');

	        if (this.firstModel === undefined || msgDate > Date.create(this.firstModel.timestamp)) {
	            if (this.firstModel === undefined) {
	                this.firstModel = model;
	                this.firstDate = messageDay;
	            }

	            if (messageDay !== this.lastDate) {
	                var dayDivider = $(templates.includes.dayDivider({ day_name: messageDay }));
	                this.staydown.append(dayDivider[0]);
	                this.lastDate = messageDay;
	            }

	            var isGrouped = model.shouldGroupWith(this.lastModel);
	            if (isGrouped) {
	                newEl = $(model.partialTemplateHtml);
	                last = this.$messageList.find('li').last();
	                last.find('.messageWrapper').append(newEl);
	                last.addClass('chatGroup');
	                this.staydown.checkdown();
	            } else {
	                newEl = $(model.templateHtml);
	                newEl.addClass(model.sender.getNickname(model.from.full));
	                this.staydown.append(newEl[0]);
	                this.lastModel = model;
	            }
	            if (!model.pending) embedIt(newEl);
	        } else {
	            var scrollDown = this.$messageList.prop('scrollHeight') - this.$messageList.scrollTop();
	            var firstEl = this.$messageList.find('li').first();

	            if (messageDay !== this.firstDate) {
	                var dayDivider = $(templates.includes.dayDivider({ day_name: messageDay }));
	                firstEl.before(dayDivider[0]);
	                var firstEl = this.$messageList.find('li').first();
	                this.firstDate = messageDay;
	            }

	            var isGrouped = model.shouldGroupWith(this.firstModel);
	            if (isGrouped) {
	                newEl = $(model.partialTemplateHtml);
	                first = this.$messageList.find('li').first().next();
	                first.find('.messageWrapper div:first').after(newEl);
	                first.addClass('chatGroup');
	            } else {
	                newEl = $(model.templateHtml);
	                newEl.addClass(model.sender.getNickname(model.from.full));
	                firstEl.after(newEl[0]);
	                this.firstModel = model;
	            }
	            if (!model.pending) embedIt(newEl);

	            this.$messageList.scrollTop(this.$messageList.prop('scrollHeight') - scrollDown);
	            this.firstChanged = true;
	        }
	    },
	    refreshModel: function refreshModel(model) {
	        var existing = this.$('#chat' + model.cid);
	        existing.replaceWith(model.bareMessageTemplate(existing.prev().hasClass('message_header')));
	    },
	    connectionChange: function connectionChange() {
	        if (app.state.connected) {
	            this.$chatInput.attr("disabled", false);
	        } else {
	            this.$chatInput.attr("disabled", "disabled");
	        }
	    }
	});

/***/ },
/* 652 */
/***/ function(module, exports, __webpack_require__) {

	/*global $, app, me*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.mucRosterItem,
	    events: {
	        'click': 'handleClick'
	    },
	    classBindings: {
	        show: '',
	        chatState: '',
	        idle: ''
	    },
	    textBindings: {
	        mucDisplayName: '.name'
	    },
	    render: function render() {
	        this.renderAndBind({ contact: this.model });
	        return this;
	    },
	    handleClick: function handleClick(e) {
	        this.parent.trigger('rosterItemClicked', this.model.mucDisplayName);
	    }
	});

/***/ },
/* 653 */
/***/ function(module, exports, __webpack_require__) {

	/*global $*/
	"use strict";

	var _ = __webpack_require__(217);
	var HumanView = __webpack_require__(638);
	var templates = __webpack_require__(626);

	module.exports = HumanView.extend({
	    template: templates.includes.mucMessage,
	    initialize: function initialize(opts) {
	        this.render();
	    },
	    classBindings: {
	        mine: '.message',
	        pending: '.message',
	        delayed: '.message',
	        edited: '.message',
	        meAction: '.message'
	    },
	    textBindings: {
	        body: '.body',
	        nick: '.nick',
	        formattedTime: '.timestamp'
	    },
	    render: function render() {
	        this.renderAndBind({ message: this.model });
	        return this;
	    }
	});

/***/ },
/* 654 */
/***/ function(module, exports, __webpack_require__) {

	/*global indexedDB*/
	"use strict";

	var AvatarStorage = __webpack_require__(655);
	var RosterStorage = __webpack_require__(656);
	var DiscoStorage = __webpack_require__(657);
	var ArchiveStorage = __webpack_require__(658);
	var ProfileStorage = __webpack_require__(659);

	function Storage() {
	    this.db = null;
	    this.init = [];

	    this.avatars = new AvatarStorage(this);
	    this.roster = new RosterStorage(this);
	    this.disco = new DiscoStorage(this);
	    this.archive = new ArchiveStorage(this);
	    this.profiles = new ProfileStorage(this);
	}
	Storage.prototype = {
	    constructor: {
	        value: Storage
	    },
	    version: 3,
	    open: function open(cb) {
	        cb = cb || function () {};

	        var self = this;
	        var request = indexedDB.open('datastorage', this.version);
	        request.onsuccess = function (e) {
	            self.db = e.target.result;
	            cb(false, self.db);
	        };
	        request.onupgradeneeded = function (e) {
	            var db = e.target.result;
	            self.avatars.setup(db);
	            self.roster.setup(db);
	            self.disco.setup(db);
	            self.archive.setup(db);
	            self.profiles.setup(db);
	        };
	        request.onerror = cb;
	    }
	};

	module.exports = Storage;

/***/ },
/* 655 */
/***/ function(module, exports) {

	"use strict";

	// SCHEMA
	//    id: 'sha1 hash',
	//    dataURI: '...'

	function AvatarStorage(storage) {
	    this.storage = storage;
	}

	AvatarStorage.prototype = {
	    constructor: {
	        value: AvatarStorage
	    },
	    setup: function setup(db) {
	        if (db.objectStoreNames.contains('avatars')) {
	            db.deleteObjectStore('avatars');
	        }
	        db.createObjectStore('avatars', {
	            keyPath: 'id'
	        });
	    },
	    transaction: function transaction(mode) {
	        var trans = this.storage.db.transaction('avatars', mode);
	        return trans.objectStore('avatars');
	    },
	    add: function add(avatar, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite').put(avatar);
	        request.onsuccess = function () {
	            cb(false, avatar);
	        };
	        request.onerror = cb;
	    },
	    get: function get(id, cb) {
	        cb = cb || function () {};
	        if (!id) {
	            return cb('not-found');
	        }
	        var request = this.transaction('readonly').get(id);
	        request.onsuccess = function (e) {
	            var res = request.result;
	            if (res === undefined) {
	                return cb('not-found');
	            }
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    },
	    remove: function remove(id, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite')['delete'](id);
	        request.onsuccess = function (e) {
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    }
	};

	module.exports = AvatarStorage;

/***/ },
/* 656 */
/***/ function(module, exports) {

	/*global, IDBKeyRange*/
	"use strict";

	// SCHEMA
	//    jid: string
	//    name: string
	//    subscription: string
	//    groups: array
	//    rosterID: string

	function RosterStorage(storage) {
	    this.storage = storage;
	}

	RosterStorage.prototype = {
	    constructor: {
	        value: RosterStorage
	    },
	    setup: function setup(db) {
	        if (db.objectStoreNames.contains('roster')) {
	            db.deleteObjectStore('roster');
	        }
	        var store = db.createObjectStore('roster', {
	            keyPath: 'storageId'
	        });
	        store.createIndex("owner", "owner", { unique: false });
	    },
	    transaction: function transaction(mode) {
	        var trans = this.storage.db.transaction('roster', mode);
	        return trans.objectStore('roster');
	    },
	    add: function add(contact, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite').put(contact);
	        request.onsuccess = function () {
	            cb(false, contact);
	        };
	        request.onerror = cb;
	    },
	    get: function get(id, cb) {
	        cb = cb || function () {};
	        if (!id) {
	            return cb('not-found');
	        }
	        var request = this.transaction('readonly').get(id);
	        request.onsuccess = function (e) {
	            var res = request.result;
	            if (res === undefined) {
	                return cb('not-found');
	            }
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    },
	    getAll: function getAll(owner, cb) {
	        cb = cb || function () {};
	        var results = [];

	        var store = this.transaction('readonly');
	        var request = store.index('owner').openCursor(IDBKeyRange.only(owner));
	        request.onsuccess = function (e) {
	            var cursor = e.target.result;
	            if (cursor) {
	                results.push(cursor.value);
	                cursor.continue();
	            } else {
	                cb(false, results);
	            }
	        };
	        request.onerror = cb;
	    },
	    remove: function remove(id, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite')['delete'](id);
	        request.onsuccess = function (e) {
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    },
	    clear: function clear(cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite').clear();
	        request.onsuccess = function () {
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    }
	};

	module.exports = RosterStorage;

/***/ },
/* 657 */
/***/ function(module, exports) {

	"use strict";

	function DiscoStorage(storage) {
	    this.storage = storage;
	}

	DiscoStorage.prototype = {
	    constructor: {
	        value: DiscoStorage
	    },
	    setup: function setup(db) {
	        if (db.objectStoreNames.contains('disco')) {
	            db.deleteObjectStore('disco');
	        }
	        db.createObjectStore('disco', {
	            keyPath: 'ver'
	        });
	    },
	    transaction: function transaction(mode) {
	        var trans = this.storage.db.transaction('disco', mode);
	        return trans.objectStore('disco');
	    },
	    add: function add(ver, disco, cb) {
	        cb = cb || function () {};
	        var data = {
	            ver: ver,
	            disco: disco
	        };
	        var request = this.transaction('readwrite').put(data);
	        request.onsuccess = function () {
	            cb(false, data);
	        };
	        request.onerror = cb;
	    },
	    get: function get(ver, cb) {
	        cb = cb || function () {};
	        if (!ver) {
	            return cb('not-found');
	        }
	        var request = this.transaction('readonly').get(ver);
	        request.onsuccess = function (e) {
	            var res = request.result;
	            if (res === undefined) {
	                return cb('not-found');
	            }
	            cb(false, res.disco);
	        };
	        request.onerror = cb;
	    }
	};

	module.exports = DiscoStorage;

/***/ },
/* 658 */
/***/ function(module, exports) {

	/*global, IDBKeyRange*/
	"use strict";

	function ArchiveStorage(storage) {
	    this.storage = storage;
	}

	ArchiveStorage.prototype = {
	    constructor: {
	        value: ArchiveStorage
	    },
	    setup: function setup(db) {
	        if (db.objectStoreNames.contains('archive')) {
	            db.deleteObjectStore('archive');
	        }
	        var store = db.createObjectStore('archive', {
	            keyPath: 'archivedId'
	        });
	        store.createIndex("owner", "owner", { unique: false });
	    },
	    transaction: function transaction(mode) {
	        var trans = this.storage.db.transaction('archive', mode);
	        return trans.objectStore('archive');
	    },
	    add: function add(message, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite').put(message);
	        request.onsuccess = function () {
	            cb(false, message);
	        };
	        request.onerror = cb;
	    },
	    get: function get(id, cb) {
	        cb = cb || function () {};
	        if (!id) {
	            return cb('not-found');
	        }
	        var request = this.transaction('readonly').get(id);
	        request.onsuccess = function (e) {
	            var res = request.result;
	            if (res === undefined) {
	                return cb('not-found');
	            }
	            request.result.acked = true;
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    },
	    getAll: function getAll(owner, cb) {
	        cb = cb || function () {};
	        var results = [];

	        var store = this.transaction('readonly');
	        var request = store.index('owner').openCursor(IDBKeyRange.only(owner));
	        request.onsuccess = function (e) {
	            var cursor = e.target.result;
	            if (cursor) {
	                cursor.value.acked = true;
	                results.push(cursor.value);
	                cursor.continue();
	            } else {
	                cb(false, results);
	            }
	        };
	        request.onerror = cb;
	    }

	};

	module.exports = ArchiveStorage;

/***/ },
/* 659 */
/***/ function(module, exports) {

	/*global, IDBKeyRange*/
	"use strict";

	// SCHEMA
	//    jid: string
	//    name: string
	//    avatarID: string
	//    status: string
	//    rosterVer: string

	function ProfileStorage(storage) {
	    this.storage = storage;
	}

	ProfileStorage.prototype = {
	    constructor: {
	        value: ProfileStorage
	    },
	    setup: function setup(db) {
	        if (db.objectStoreNames.contains('profiles')) {
	            db.deleteObjectStore('profiles');
	        }
	        var store = db.createObjectStore('profiles', {
	            keyPath: 'jid'
	        });
	    },
	    transaction: function transaction(mode) {
	        var trans = this.storage.db.transaction('profiles', mode);
	        return trans.objectStore('profiles');
	    },
	    set: function set(profile, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite').put(profile);
	        request.onsuccess = function () {
	            cb(false, profile);
	        };
	        request.onerror = cb;
	    },
	    get: function get(id, cb) {
	        cb = cb || function () {};
	        if (!id) {
	            return cb('not-found');
	        }
	        var request = this.transaction('readonly').get(id);
	        request.onsuccess = function (e) {
	            var res = request.result;
	            if (res === undefined) {
	                return cb('not-found');
	            }
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    },
	    remove: function remove(id, cb) {
	        cb = cb || function () {};
	        var request = this.transaction('readwrite')['delete'](id);
	        request.onsuccess = function (e) {
	            cb(false, request.result);
	        };
	        request.onerror = cb;
	    }
	};

	module.exports = ProfileStorage;

/***/ },
/* 660 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*global me, app, client*/
	"use strict";

	var _stringify = __webpack_require__(661);

	var _stringify2 = _interopRequireDefault(_stringify);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _ = __webpack_require__(217);
	var async = __webpack_require__(218);
	var crypto = __webpack_require__(513);
	var bows = __webpack_require__(663);
	var uuid = __webpack_require__(620);
	var HumanModel = __webpack_require__(505);
	var Contact = __webpack_require__(512);
	var Resource = __webpack_require__(622);
	var Message = __webpack_require__(625);
	var Call = __webpack_require__(632);
	var StanzaIo = __webpack_require__(221);

	var log = bows('Otalk');
	var ioLogIn = bows('<< in');
	var ioLogOut = bows('>> out');

	var discoCapsQueue = async.queue(function (pres, cb) {
	    var jid = pres.from;
	    var caps = pres.caps;

	    log.info('Checking storage for ' + caps.ver);

	    var contact = me.getContact(jid);
	    var resource = null;
	    if (contact) {
	        resource = contact.resources.get(jid);
	    }

	    app.storage.disco.get(caps.ver, function (err, existing) {
	        if (existing) {
	            log.info('Already found info for ' + caps.ver);
	            if (resource) resource.discoInfo = existing;
	            return cb();
	        }
	        log.info('getting info for ' + caps.ver + ' from ' + jid);
	        client.getDiscoInfo(jid, caps.node + '#' + caps.ver, function (err, result) {
	            if (err || !result.discoInfo.features) {
	                log.info('Couldnt get info for ' + caps.ver);
	                return cb();
	            }
	            if (client.verifyVerString(result.discoInfo, caps.hash, caps.ver)) {
	                log.info('Saving info for ' + caps.ver);
	                var data = result.discoInfo;
	                app.storage.disco.add(caps.ver, data, function () {
	                    if (resource) resource.discoInfo = data;
	                    cb();
	                });
	            } else {
	                log.info('Couldnt verify info for ' + caps.ver + ' from ' + jid);
	                cb();
	            }
	        });
	    });
	});

	module.exports = function (client, app) {

	    client.on('*', function (name, data) {
	        if (name === 'raw:incoming') {
	            ioLogIn.debug(data.toString());
	        } else if (name === 'raw:outgoing') {
	            ioLogOut.debug(data.toString());
	        }
	    });

	    client.on('credentials:update', function (creds) {
	        client.config.credentials = creds;
	        if (!client.config.saveCredentials) {
	            delete localStorage.config;
	            return;
	        }

	        if (SERVER_CONFIG.securePasswordStorage) {
	            if (creds.clientKey && creds.serverKey) {
	                delete creds.password;
	                delete creds.saltedPassword;
	            } else if (creds.saltedPassword) {
	                delete creds.password;
	            }
	        } else {
	            creds = {
	                password: creds.password
	            };
	        }

	        localStorage.config = (0, _stringify2.default)({
	            jid: client.config.jid.bare,
	            server: client.config.server,
	            wsURL: client.config.wsURL,
	            transports: client.config.transports,
	            saveCredentials: client.config.saveCredentials,
	            credentials: creds
	        });
	    });

	    client.on('disconnected', function (err) {
	        app.state.connected = false;
	        if (err) {
	            console.error(err);
	        }
	        if (!app.state.hasConnected) {
	            window.location = 'login.html';
	        }
	    });

	    client.on('auth:failed', function () {
	        log.warn('auth failed');
	        window.location = 'login.html';
	    });

	    client.on('stream:management:resumed', function () {
	        app.state.connected = true;
	    });

	    client.on('session:started', function (jid) {
	        me.updateJid(jid);

	        app.state.connected = true;
	        window.readyForDeviceID = true;

	        client.getRoster(function (err, resp) {
	            if (resp.roster && resp.roster.items && resp.roster.items.length) {
	                app.storage.roster.clear(function () {
	                    me.contacts.reset();
	                    me.rosterVer = resp.roster.ver;

	                    _.each(resp.roster.items, function (item) {
	                        me.setContact(item, true);
	                    });
	                });
	            }

	            var caps = client.updateCaps();
	            app.storage.disco.add(caps.ver, caps.discoInfo, function () {
	                client.sendPresence({
	                    status: me.status,
	                    caps: client.disco.caps
	                });
	                client.enableCarbons();
	            });

	            me.mucs.fetch();
	        });

	        var keepalive = SERVER_CONFIG.keepalive;
	        if (keepalive) {
	            client.enableKeepAlive(keepalive);
	        }
	    });

	    client.on('roster:update', function (iq) {
	        var items = iq.roster.items;

	        me.rosterVer = iq.roster.ver;

	        _.each(items, function (item) {
	            var contact = me.getContact(item.jid);

	            if (item.subscription === 'remove') {
	                if (contact) {
	                    me.removeContact(item.jid);
	                }
	                return;
	            }

	            me.setContact(item, true);
	        });
	    });

	    client.on('subscribe', function (pres) {
	        me.contactRequests.add({
	            jid: pres.from.bare
	        });
	    });

	    client.on('available', function (pres) {
	        var contact = me.getContact(pres.from);
	        if (contact) {
	            delete pres.id;
	            pres.show = pres.show || '';
	            pres.status = pres.status || '';
	            pres.priority = pres.priority || 0;

	            var resource = contact.resources.get(pres.from);
	            if (resource) {
	                pres.from = pres.from.full;
	                // Explicitly set idleSince to null to clear
	                // the model's value.
	                if (!pres.idleSince) {
	                    pres.idleSince = null;
	                }
	                resource.set(pres);
	            } else {
	                resource = new Resource(pres);
	                resource.id = pres.from.full;
	                contact.resources.add(resource);

	                if (!pres.caps) {
	                    resource.fetchDisco();
	                }
	                resource.fetchTimezone();
	            }

	            var muc = pres.muc || {};
	            if (muc.codes && muc.codes.indexOf('110') >= 0) {
	                contact.joined = true;
	            }
	        }
	    });

	    client.on('unavailable', function (pres) {
	        var contact = me.getContact(pres.from);
	        if (contact) {
	            var resource = contact.resources.get(pres.from.full);
	            if (resource) {
	                if (resource.id === contact.lockedResource) {
	                    contact.lockedResource = '';
	                }

	                if (contact.resources.length === 1) {
	                    contact.offlineStatus = pres.status;
	                }
	                contact.resources.remove(resource);
	            }

	            var muc = pres.muc || {};
	            if (muc.codes && muc.codes.indexOf('110') >= 0) {
	                contact.joined = false;
	            }
	        }
	    });

	    client.on('avatar', function (info) {
	        var contact = me.getContact(info.jid);
	        if (!contact) {
	            if (me.isMe(info.jid)) {
	                contact = me;
	            } else {
	                return;
	            }
	        }

	        var id = '';
	        var type = 'image/png';
	        if (info.avatars.length > 0) {
	            id = info.avatars[0].id;
	            type = info.avatars[0].type || 'image/png';
	        }

	        if (contact.type === 'muc') {
	            var resource = contact.resources.get(info.jid.full);
	            if (resource) {
	                resource.setAvatar(id, type, info.source);
	            }
	        }

	        if (contact.setAvatar) {
	            contact.setAvatar(id, type, info.source);
	        }
	    });

	    client.on('chatState', function (info) {
	        var contact = me.getContact(info.from);
	        if (contact) {
	            var resource = contact.resources.get(info.from.full);
	            if (resource) {
	                resource.chatState = info.chatState;
	                if (info.chatState === 'gone') {
	                    contact.lockedResource = undefined;
	                } else {
	                    contact.lockedResource = info.from.full;
	                }
	            }
	        } else if (me.isMe(info.from)) {
	            if (info.chatState === 'active' || info.chatState === 'composing') {
	                contact = me.getContact(info.to);
	                if (contact) {
	                    contact.unreadCount = 0;
	                }
	            }
	        }
	    });

	    client.on('chat', function (msg) {
	        msg.mid = msg.id;
	        delete msg.id;

	        var contact = me.getContact(msg.from, msg.to);
	        if (contact && !msg.replace) {
	            var message = new Message(msg);

	            if (msg.archived) {
	                msg.archived.forEach(function (archived) {
	                    if (me.isMe(archived.by)) {
	                        message.archivedId = archived.id;
	                    }
	                });
	            }

	            if (msg.carbon) msg.delay.stamp = new Date(Date.now() + app.timeInterval);

	            message.acked = true;
	            var localTime = new Date(Date.now() + app.timeInterval);
	            var notify = Math.round((localTime - message.created) / 1000) < 5;
	            contact.addMessage(message, notify);
	            if (msg.from.bare == contact.jid.bare) {
	                contact.lockedResource = msg.from.full;
	            }
	        }
	    });

	    client.on('groupchat', function (msg) {
	        msg.mid = msg.id;
	        delete msg.id;

	        var contact = me.getContact(msg.from, msg.to);
	        if (contact && !msg.replace) {
	            var message = new Message(msg);
	            message.acked = true;
	            var localTime = new Date(Date.now() + app.timeInterval);
	            var notify = Math.round((localTime - message.created) / 1000) < 5;
	            contact.addMessage(message, notify);
	        }
	    });

	    client.on('muc:subject', function (msg) {
	        var contact = me.getContact(msg.from, msg.to);
	        if (contact) {
	            contact.subject = msg.subject === 'true' ? '' : msg.subject;
	        }
	    });

	    client.on('replace', function (msg) {
	        msg.mid = msg.id;
	        delete msg.id;

	        var contact = me.getContact(msg.from, msg.to);
	        if (!contact) return;

	        var original = Message.idLookup(msg.from[msg.type === 'groupchat' ? 'full' : 'bare'], msg.replace);

	        if (!original) return;

	        original.correct(msg);
	    });

	    client.on('receipt', function (msg) {
	        var contact = me.getContact(msg.from, msg.to);
	        if (!contact) return;

	        var original = Message.idLookup(msg.to[msg.type === 'groupchat' ? 'full' : 'bare'], msg.receipt);

	        if (!original) return;

	        original.receiptReceived = true;
	    });

	    client.on('message:sent', function (msg) {
	        if (msg.carbon) {
	            msg.delay.stamp = new Date(Date.now() + app.timeInterval);

	            client.emit('message', msg);
	        }
	    });

	    client.on('disco:caps', function (pres) {
	        if (pres.caps.hash) {
	            log.info('Caps from ' + pres.from + ' ver: ' + pres.caps.ver);
	            discoCapsQueue.push(pres);
	        }
	    });

	    client.on('stanza:acked', function (stanza) {
	        if (stanza.body) {
	            var contact = me.getContact(stanza.to, stanza.from);
	            if (contact) {
	                var msg = Message.idLookup(me.jid.bare, stanza.id);
	                if (msg) {
	                    msg.acked = true;
	                }
	            }
	        }
	    });

	    client.on('jingle:incoming', function (session) {
	        var contact = me.getContact(session.peer);
	        if (!contact) {
	            contact = new Contact({ jid: new StanzaIo.JID(session.peer).bare });
	            contact.resources.add({ id: session.peer });
	            me.contacts.add(contact);
	        }

	        var call = new Call({
	            contact: contact,
	            state: 'incoming',
	            jingleSession: session
	        });
	        contact.jingleCall = call;
	        contact.callState = 'incoming';
	        me.calls.add(call);
	        // FIXME: send directed presence if not on roster
	    });

	    client.on('jingle:outgoing', function (session) {
	        var contact = me.getContact(session.peer);
	        var call = new Call({
	            contact: contact,
	            state: 'outgoing',
	            jingleSession: session
	        });
	        contact.jingleCall = call;
	        me.calls.add(call);
	    });

	    client.on('jingle:terminated', function (session) {
	        var contact = me.getContact(session.peer);
	        contact.callState = '';
	        contact.jingleCall = null;
	        contact.onCall = false;
	        if (me.calls.length == 1) {
	            // this is the last call
	            client.jingle.stopLocalMedia();
	            client.jingle.localStream = null;
	        }
	    });

	    client.on('jingle:accepted', function (session) {
	        var contact = me.getContact(session.peer);
	        contact.callState = 'activeCall';
	        contact.onCall = true;
	    });

	    client.on('jingle:localstream:added', function (stream) {
	        me.stream = stream;
	    });

	    client.on('jingle:localstream:removed', function () {
	        me.stream = null;
	    });

	    client.on('jingle:remotestream:added', function (session) {
	        var contact = me.getContact(session.peer);
	        if (!contact) {
	            contact.resources.add({ id: session.peer });
	            me.contacts.add(contact);
	        }
	        contact.stream = session.streams[0];
	    });

	    client.on('jingle:remotestream:removed', function (session) {
	        var contact = me.getContact(session.peer);
	        contact.stream = null;
	    });

	    client.on('jingle:ringing', function (session) {
	        var contact = me.getContact(session.peer);
	        contact.callState = 'ringing';
	    });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(196)))

/***/ },
/* 661 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(662), __esModule: true };

/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(356);
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return (core.JSON && core.JSON.stringify || JSON.stringify).apply(JSON, arguments);
	};

/***/ },
/* 663 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  function checkColorSupport() {
	    if (typeof window === 'undefined' || typeof navigator === 'undefined') {
	      return false;
	    }
	    var chrome = !!window.chrome,
	        firefox = /firefox/i.test(navigator.userAgent),
	        firefoxVersion;

	    if (firefox) {
	        var match = navigator.userAgent.match(/Firefox\/(\d+\.\d+)/);
	        if (match && match[1] && Number(match[1])) {
	            firefoxVersion = Number(match[1]);
	        }
	    }
	    return chrome || firefoxVersion >= 31.0;
	  }

	  var yieldColor = function() {
	    var goldenRatio = 0.618033988749895;
	    hue += goldenRatio;
	    hue = hue % 1;
	    return hue * 360;
	  };

	  var inNode = typeof window === 'undefined',
	      ls = !inNode && window.localStorage,
	      debugKey = ls.andlogKey || 'debug',
	      debug = ls[debugKey],
	      logger = __webpack_require__(630),
	      bind = Function.prototype.bind,
	      hue = 0,
	      padLength = 15,
	      noop = function() {},
	      colorsSupported = ls.debugColors || checkColorSupport(),
	      bows = null,
	      debugRegex = null,
	      invertRegex = false,
	      moduleColorsMap = {};

	  if (debug && debug[0] === '!' && debug[1] === '/') {
	    invertRegex = true;
	    debug = debug.slice(1);
	  }
	  debugRegex = debug && debug[0]==='/' && new RegExp(debug.substring(1,debug.length-1));

	  var logLevels = ['log', 'debug', 'warn', 'error', 'info'];

	  //Noop should noop
	  for (var i = 0, ii = logLevels.length; i < ii; i++) {
	      noop[ logLevels[i] ] = noop;
	  }

	  bows = function(str) {
	    var msg, colorString, logfn;
	    msg = (str.slice(0, padLength));
	    msg += Array(padLength + 3 - msg.length).join(' ') + '|';

	    if (debugRegex) {
	        var matches = str.match(debugRegex);
	        if (
	            (!invertRegex && !matches) ||
	            (invertRegex && matches)
	        ) return noop;
	    }

	    if (!bind) return noop;

	    var logArgs = [logger];
	    if (colorsSupported) {
	      if(!moduleColorsMap[str]){
	        moduleColorsMap[str]= yieldColor();
	      }
	      var color = moduleColorsMap[str];
	      msg = "%c" + msg;
	      colorString = "color: hsl(" + (color) + ",99%,40%); font-weight: bold";

	      logArgs.push(msg, colorString);
	    }else{
	      logArgs.push(msg);
	    }

	    if(arguments.length>1){
	        var args = Array.prototype.slice.call(arguments, 1);
	        logArgs = logArgs.concat(args);
	    }

	    logfn = bind.apply(logger.log, logArgs);

	    logLevels.forEach(function (f) {
	      logfn[f] = bind.apply(logger[f] || logfn, logArgs);
	    });
	    return logfn;
	  };

	  bows.config = function(config) {
	    if (config.padLength) {
	      padLength = config.padLength;
	    }
	  };

	  if (true) {
	    module.exports = bows;
	  } else {
	    window.bows = bows;
	  }
	}).call();


/***/ },
/* 664 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (client, stanzas) {
	    var types = stanzas.utils;

	    var PushNotification = stanzas.define({
	        name: 'pushNotification',
	        namespace: 'urn:xmpp:push:0',
	        element: 'push',
	        fields: {
	            body: types.subText('urn:xmpp:push:0', 'body')
	        }
	    });

	    stanzas.withMessage(function (Message) {
	        stanzas.extend(Message, PushNotification);
	    });

	    var RegisterPush = stanzas.define({
	        name: 'registerPush',
	        namespace: 'urn:xmpp:push:0',
	        element: 'register',
	        fields: {
	            service: types.text()
	        }
	    });

	    var UnregisterPush = stanzas.define({
	        name: 'unregisterPush',
	        namespace: 'urn:xmpp:push:0',
	        element: 'unregister',
	        fields: {
	            service: types.text()
	        }
	    });

	    var OtalkRegister = stanzas.define({
	        name: 'otalkRegister',
	        namespace: 'http://otalk.im/protocol/push',
	        element: 'register',
	        fields: {
	            deviceID: types.text()
	        }
	    });

	    stanzas.withIq(function (Iq) {
	        stanzas.extend(Iq, RegisterPush);
	        stanzas.extend(Iq, UnregisterPush);
	        stanzas.extend(Iq, OtalkRegister);
	    });

	    client.registerPushService = function (jid, cb) {
	        return client.sendIq({
	            type: 'set',
	            registerPush: {
	                service: jid
	            }
	        }, cb);
	    };

	    client.getPushServices = function (cb) {
	        return client.getDiscoItems('', 'urn:xmpp:push', cb);
	    };

	    client.unregisterPushService = function (jid, cb) {
	        return client.sendIq({
	            type: 'set',
	            unregisterPush: {
	                service: jid
	            }
	        }, cb);
	    };

	    client.otalkRegister = function (deviceID, cb) {
	        return client.sendIq({
	            type: 'set',
	            to: 'push@push.otalk.im/prod',
	            otalkRegister: {
	                deviceID: deviceID
	            }
	        }, cb);
	    };
	};

/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(666);


	function Notifications(opts, fallback) {
	    this.permission = '';
	    this.opts = _.extend({
	        icon: '/images/applogo.png',
	        dir: 'auto',
	        lang: '',
	        body: '',
	        tag: ''
	    }, opts);

	    this.fallback = _.extend({
	        permission: 'default',
	        requestPermission: function (cb) {
	            cb('default');
	        },
	        create: function (title, opts) {
	        }
	    });
	}

	Notifications.prototype.create = function (title, opts) {
	    opts = _.extend(this.opts, opts);
	    var notice;

	    if (window.macgap) {
	        window.macgap.growl.notify(_.extend({
	            title: title,
	            description: opts.body
	        }, opts));
	    } else if (window.fluid) {
	        window.fluid.showGrowlNotification(_.extend({
	            title: title,
	            description: opts.body
	        }, opts));
	    } else if (window.Notification) {
	        notice = new window.Notification(title, opts);
	        setTimeout(function () {
	            notice.close();
	        }, 5000);
	    } else if (window.webkitNotifications) {
	        notice = window.webkitNotifications.createNotification(opts.icon, title, opts.body);
	        _.extend(notice, opts);
	        notice.show();
	        setTimeout(function () {
	            notice.close();
	        }, 5000);
	    } else {
	        this.fallback.create(title, opts);
	    }
	};

	Notifications.prototype.permissionNeeded = function () {
	    if (window.macgap) {
	        return false;
	    } else if (window.fluid) {
	        return false;
	    } else if (window.Notification) {
	        return window.Notification.permission !== 'granted';
	    } else if (window.webkitNotifications) {
	        return window.webkitNotifications.checkPermission() !== 1;
	    } else {
	        return this.fallback.permission !== 'granted';
	    }
	};

	Notifications.prototype.allowed = function () {
	    if (window.macgap) {
	        return true;
	    } else if (window.fluid) {
	        return true;
	    } else if (window.Notification) {
	        return window.Notification.permission === 'granted';
	    } else if (window.webkitNotifications) {
	        return window.webkitNoticications.checkPermission() === 0;
	    } else {
	        return this.fallback.permission === 'granted';
	    }
	};

	Notifications.prototype.requestPermission = function (cb) {
	    if (window.macgap) {
	        cb('granted');
	    } else if (window.fluid) {
	        cb('granted');
	    } else if (window.Notification) {
	        if (window.Notification.permission !== 'denied') {
	            window.Notification.requestPermission(cb);
	        } else {
	            cb('denied');
	        }
	    } else if (window.webkitNotifications) {
	        var perm = window.webKitNotifications.checkPermission();
	        if (perm === 1) {
	            window.webkitNotification.requestPermission(function (perm) {
	                if (perm === 0) {
	                    cb('granted');
	                } else if (perm === 1) {
	                    cb('default');
	                } else {
	                    cb('denied');
	                }
	            });
	        }
	    } else {
	        this.fallback.requestPermission(cb);
	    }
	};

	module.exports = Notifications;


/***/ },
/* 666 */
/***/ function(module, exports, __webpack_require__) {

	//     Underscore.js 1.5.2
	//     http://underscorejs.org
	//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Establish the object that gets returned to break out of a loop iteration.
	  var breaker = {};

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    concat           = ArrayProto.concat,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeForEach      = ArrayProto.forEach,
	    nativeMap          = ArrayProto.map,
	    nativeReduce       = ArrayProto.reduce,
	    nativeReduceRight  = ArrayProto.reduceRight,
	    nativeFilter       = ArrayProto.filter,
	    nativeEvery        = ArrayProto.every,
	    nativeSome         = ArrayProto.some,
	    nativeIndexOf      = ArrayProto.indexOf,
	    nativeLastIndexOf  = ArrayProto.lastIndexOf,
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind;

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object via a string identifier,
	  // for Closure Compiler "advanced" mode.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.5.2';

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles objects with the built-in `forEach`, arrays, and raw objects.
	  // Delegates to **ECMAScript 5**'s native `forEach` if available.
	  var each = _.each = _.forEach = function(obj, iterator, context) {
	    if (obj == null) return;
	    if (nativeForEach && obj.forEach === nativeForEach) {
	      obj.forEach(iterator, context);
	    } else if (obj.length === +obj.length) {
	      for (var i = 0, length = obj.length; i < length; i++) {
	        if (iterator.call(context, obj[i], i, obj) === breaker) return;
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (var i = 0, length = keys.length; i < length; i++) {
	        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
	      }
	    }
	  };

	  // Return the results of applying the iterator to each element.
	  // Delegates to **ECMAScript 5**'s native `map` if available.
	  _.map = _.collect = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	    each(obj, function(value, index, list) {
	      results.push(iterator.call(context, value, index, list));
	    });
	    return results;
	  };

	  var reduceError = 'Reduce of empty array with no initial value';

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduce && obj.reduce === nativeReduce) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	    }
	    each(obj, function(value, index, list) {
	      if (!initial) {
	        memo = value;
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, value, index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // The right-associative version of reduce, also known as `foldr`.
	  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
	    var initial = arguments.length > 2;
	    if (obj == null) obj = [];
	    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
	      if (context) iterator = _.bind(iterator, context);
	      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
	    }
	    var length = obj.length;
	    if (length !== +length) {
	      var keys = _.keys(obj);
	      length = keys.length;
	    }
	    each(obj, function(value, index, list) {
	      index = keys ? keys[--length] : --length;
	      if (!initial) {
	        memo = obj[index];
	        initial = true;
	      } else {
	        memo = iterator.call(context, memo, obj[index], index, list);
	      }
	    });
	    if (!initial) throw new TypeError(reduceError);
	    return memo;
	  };

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, iterator, context) {
	    var result;
	    any(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) {
	        result = value;
	        return true;
	      }
	    });
	    return result;
	  };

	  // Return all the elements that pass a truth test.
	  // Delegates to **ECMAScript 5**'s native `filter` if available.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, iterator, context) {
	    var results = [];
	    if (obj == null) return results;
	    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
	    each(obj, function(value, index, list) {
	      if (iterator.call(context, value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, iterator, context) {
	    return _.filter(obj, function(value, index, list) {
	      return !iterator.call(context, value, index, list);
	    }, context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Delegates to **ECMAScript 5**'s native `every` if available.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = true;
	    if (obj == null) return result;
	    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
	    each(obj, function(value, index, list) {
	      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Delegates to **ECMAScript 5**'s native `some` if available.
	  // Aliased as `any`.
	  var any = _.some = _.any = function(obj, iterator, context) {
	    iterator || (iterator = _.identity);
	    var result = false;
	    if (obj == null) return result;
	    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
	    each(obj, function(value, index, list) {
	      if (result || (result = iterator.call(context, value, index, list))) return breaker;
	    });
	    return !!result;
	  };

	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `include`.
	  _.contains = _.include = function(obj, target) {
	    if (obj == null) return false;
	    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
	    return any(obj, function(value) {
	      return value === target;
	    });
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      return (isFunc ? method : value[method]).apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, function(value){ return value[key]; });
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs, first) {
	    if (_.isEmpty(attrs)) return first ? void 0 : [];
	    return _[first ? 'find' : 'filter'](obj, function(value) {
	      for (var key in attrs) {
	        if (attrs[key] !== value[key]) return false;
	      }
	      return true;
	    });
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.where(obj, attrs, true);
	  };

	  // Return the maximum element or (element-based computation).
	  // Can't optimize arrays of integers longer than 65,535 elements.
	  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
	  _.max = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.max.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return -Infinity;
	    var result = {computed : -Infinity, value: -Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed > result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iterator, context) {
	    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
	      return Math.min.apply(Math, obj);
	    }
	    if (!iterator && _.isEmpty(obj)) return Infinity;
	    var result = {computed : Infinity, value: Infinity};
	    each(obj, function(value, index, list) {
	      var computed = iterator ? iterator.call(context, value, index, list) : value;
	      computed < result.computed && (result = {value : value, computed : computed});
	    });
	    return result.value;
	  };

	  // Shuffle an array, using the modern version of the 
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var rand;
	    var index = 0;
	    var shuffled = [];
	    each(obj, function(value) {
	      rand = _.random(index++);
	      shuffled[index - 1] = shuffled[rand];
	      shuffled[rand] = value;
	    });
	    return shuffled;
	  };

	  // Sample **n** random values from an array.
	  // If **n** is not specified, returns a single random element from the array.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (arguments.length < 2 || guard) {
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // An internal function to generate lookup iterators.
	  var lookupIterator = function(value) {
	    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
	  };

	  // Sort the object's values by a criterion produced by an iterator.
	  _.sortBy = function(obj, value, context) {
	    var iterator = lookupIterator(value);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iterator.call(context, value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, value, context) {
	      var result = {};
	      var iterator = value == null ? _.identity : lookupIterator(value);
	      each(obj, function(value, index) {
	        var key = iterator.call(context, value, index, obj);
	        behavior(result, key, value);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, key, value) {
	    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, key, value) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, key) {
	    _.has(result, key) ? result[key]++ : result[key] = 1;
	  });

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iterator, context) {
	    iterator = iterator == null ? _.identity : lookupIterator(iterator);
	    var value = iterator.call(context, obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
	    }
	    return low;
	  };

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (obj.length === +obj.length) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N. The **guard** check allows it to work with
	  // `_.map`.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array. The **guard** check allows it to work with `_.map`.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if ((n == null) || guard) {
	      return array[array.length - 1];
	    } else {
	      return slice.call(array, Math.max(array.length - n, 0));
	    }
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array. The **guard**
	  // check allows it to work with `_.map`.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, (n == null) || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, output) {
	    if (shallow && _.every(input, _.isArray)) {
	      return concat.apply(output, input);
	    }
	    each(input, function(value) {
	      if (_.isArray(value) || _.isArguments(value)) {
	        shallow ? push.apply(output, value) : flatten(value, shallow, output);
	      } else {
	        output.push(value);
	      }
	    });
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, []);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iterator, context) {
	    if (_.isFunction(isSorted)) {
	      context = iterator;
	      iterator = isSorted;
	      isSorted = false;
	    }
	    var initial = iterator ? _.map(array, iterator, context) : array;
	    var results = [];
	    var seen = [];
	    each(initial, function(value, index) {
	      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
	        seen.push(value);
	        results.push(array[index]);
	      }
	    });
	    return results;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(_.flatten(arguments, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var rest = slice.call(arguments, 1);
	    return _.filter(_.uniq(array), function(item) {
	      return _.every(rest, function(other) {
	        return _.indexOf(other, item) >= 0;
	      });
	    });
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
	    return _.filter(array, function(value){ return !_.contains(rest, value); });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    var length = _.max(_.pluck(arguments, "length").concat(0));
	    var results = new Array(length);
	    for (var i = 0; i < length; i++) {
	      results[i] = _.pluck(arguments, '' + i);
	    }
	    return results;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    if (list == null) return {};
	    var result = {};
	    for (var i = 0, length = list.length; i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	  // we need this function. Return the position of the first occurrence of an
	  // item in an array, or -1 if the item is not included in the array.
	  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    if (array == null) return -1;
	    var i = 0, length = array.length;
	    if (isSorted) {
	      if (typeof isSorted == 'number') {
	        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
	      } else {
	        i = _.sortedIndex(array, item);
	        return array[i] === item ? i : -1;
	      }
	    }
	    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
	    for (; i < length; i++) if (array[i] === item) return i;
	    return -1;
	  };

	  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	  _.lastIndexOf = function(array, item, from) {
	    if (array == null) return -1;
	    var hasIndex = from != null;
	    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
	      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
	    }
	    var i = (hasIndex ? from : array.length);
	    while (i--) if (array[i] === item) return i;
	    return -1;
	  };

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = arguments[2] || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var idx = 0;
	    var range = new Array(length);

	    while(idx < length) {
	      range[idx++] = start;
	      start += step;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Reusable constructor function for prototype setting.
	  var ctor = function(){};

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    var args, bound;
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError;
	    args = slice.call(arguments, 2);
	    return bound = function() {
	      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
	      ctor.prototype = func.prototype;
	      var self = new ctor;
	      ctor.prototype = null;
	      var result = func.apply(self, args.concat(slice.call(arguments)));
	      if (Object(result) === result) return result;
	      return self;
	    };
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context.
	  _.partial = function(func) {
	    var args = slice.call(arguments, 1);
	    return function() {
	      return func.apply(this, args.concat(slice.call(arguments)));
	    };
	  };

	  // Bind all of an object's methods to that object. Useful for ensuring that
	  // all callbacks defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var funcs = slice.call(arguments, 1);
	    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
	    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memo = {};
	    hasher || (hasher = _.identity);
	    return function() {
	      var key = hasher.apply(this, arguments);
	      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
	    };
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){ return func.apply(null, args); }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = function(func) {
	    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	  };

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    options || (options = {});
	    var later = function() {
	      previous = options.leading === false ? 0 : new Date;
	      timeout = null;
	      result = func.apply(context, args);
	    };
	    return function() {
	      var now = new Date;
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0) {
	        clearTimeout(timeout);
	        timeout = null;
	        previous = now;
	        result = func.apply(context, args);
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = new Date();
	      var later = function() {
	        var last = (new Date()) - timestamp;
	        if (last < wait) {
	          timeout = setTimeout(later, wait - last);
	        } else {
	          timeout = null;
	          if (!immediate) result = func.apply(context, args);
	        }
	      };
	      var callNow = immediate && !timeout;
	      if (!timeout) {
	        timeout = setTimeout(later, wait);
	      }
	      if (callNow) result = func.apply(context, args);
	      return result;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = function(func) {
	    var ran = false, memo;
	    return function() {
	      if (ran) return memo;
	      ran = true;
	      memo = func.apply(this, arguments);
	      func = null;
	      return memo;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return function() {
	      var args = [func];
	      push.apply(args, arguments);
	      return wrapper.apply(this, args);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments;
	      for (var i = funcs.length - 1; i >= 0; i--) {
	        args = [funcs[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  };

	  // Returns a function that will only be executed after being called N times.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Object Functions
	  // ----------------

	  // Retrieve the names of an object's properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = nativeKeys || function(obj) {
	    if (obj !== Object(obj)) throw new TypeError('Invalid object');
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = new Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = new Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    each(keys, function(key) {
	      if (key in obj) copy[key] = obj[key];
	    });
	    return copy;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj) {
	    var copy = {};
	    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
	    for (var key in obj) {
	      if (!_.contains(keys, key)) copy[key] = obj[key];
	    }
	    return copy;
	  };

	  // Fill in a given object with default properties.
	  _.defaults = function(obj) {
	    each(slice.call(arguments, 1), function(source) {
	      if (source) {
	        for (var prop in source) {
	          if (obj[prop] === void 0) obj[prop] = source[prop];
	        }
	      }
	    });
	    return obj;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a == 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className != toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, dates, and booleans are compared by value.
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return a == String(b);
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
	        // other numeric values.
	        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a == +b;
	      // RegExps are compared by their source patterns and flags.
	      case '[object RegExp]':
	        return a.source == b.source &&
	               a.global == b.global &&
	               a.multiline == b.multiline &&
	               a.ignoreCase == b.ignoreCase;
	    }
	    if (typeof a != 'object' || typeof b != 'object') return false;
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] == a) return bStack[length] == b;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s
	    // from different frames are.
	    var aCtor = a.constructor, bCtor = b.constructor;
	    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
	                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
	      return false;
	    }
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	    var size = 0, result = true;
	    // Recursively compare objects and arrays.
	    if (className == '[object Array]') {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      size = a.length;
	      result = size == b.length;
	      if (result) {
	        // Deep compare the contents, ignoring non-numeric properties.
	        while (size--) {
	          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
	        }
	      }
	    } else {
	      // Deep compare objects.
	      for (var key in a) {
	        if (_.has(a, key)) {
	          // Count the expected number of properties.
	          size++;
	          // Deep compare each member.
	          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
	        }
	      }
	      // Ensure that both objects contain the same number of properties.
	      if (result) {
	        for (key in b) {
	          if (_.has(b, key) && !(size--)) break;
	        }
	        result = !size;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return result;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b, [], []);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
	    for (var key in obj) if (_.has(obj, key)) return false;
	    return true;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    return obj === Object(obj);
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) == '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return !!(obj && _.has(obj, 'callee'));
	    };
	  }

	  // Optimize `isFunction` if appropriate.
	  if (true) {
	    _.isFunction = function(obj) {
	      return typeof obj === 'function';
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj != +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iterators.
	  _.identity = function(value) {
	    return value;
	  };

	  // Run a function **n** times.
	  _.times = function(n, iterator, context) {
	    var accum = Array(Math.max(0, n));
	    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // List of HTML entities for escaping.
	  var entityMap = {
	    escape: {
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      "'": '&#x27;'
	    }
	  };
	  entityMap.unescape = _.invert(entityMap.escape);

	  // Regexes containing the keys and values listed immediately above.
	  var entityRegexes = {
	    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
	    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	  };

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  _.each(['escape', 'unescape'], function(method) {
	    _[method] = function(string) {
	      if (string == null) return '';
	      return ('' + string).replace(entityRegexes[method], function(match) {
	        return entityMap[method][match];
	      });
	    };
	  });

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property) {
	    if (object == null) return void 0;
	    var value = object[property];
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result.call(this, func.apply(_, args));
	      };
	    });
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\t':     't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  _.template = function(text, data, settings) {
	    var render;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = new RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset)
	        .replace(escaper, function(match) { return '\\' + escapes[match]; });

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      }
	      if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      }
	      if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	      index = offset + match.length;
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + "return __p;\n";

	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    if (data) return render(data, _);
	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled function source as a convenience for precompilation.
	    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function, which will delegate to the wrapper.
	  _.chain = function(obj) {
	    return _(obj).chain();
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(obj) {
	    return this._chain ? _(obj).chain() : obj;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
	      return result.call(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result.call(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  _.extend(_.prototype, {

	    // Start chaining a wrapped Underscore object.
	    chain: function() {
	      this._chain = true;
	      return this;
	    },

	    // Extracts the result from a wrapped and chained object.
	    value: function() {
	      return this._wrapped;
	    }

	  });

	}).call(this);


/***/ },
/* 667 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _create = __webpack_require__(668);

	var _create2 = _interopRequireDefault(_create);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var WildEmitter = __webpack_require__(670);

	function DesktopApp(opts) {
	    WildEmitter.call(this);

	    var self = this;
	    opts = opts || {};

	    this.mozAppManifest = opts.manifest || window.location.origin + '/manifest.webapp';

	    this.installed = !!window.macgap || !!window.fluid;
	    this.installable = !!window.macgap || !!window.fluid || !!navigator.mozApps;
	    this.uninstallable = false;

	    if (window.macgap || this.fluid) {
	        this.installed = true;
	    } else if (navigator.mozApps) {
	        var req = navigator.mozApps.getSelf();
	        req.onsuccess = function (e) {
	            self.mozApp = e.result;
	            if (e.result) {
	                self.installed = true;
	                self.uninstallable = true;
	            }
	        };
	    }

	    if (window.macgap) {
	        document.addEventListener('sleep', function () {
	            self.emit('sleep');
	        }, true);

	        document.addEventListener('wake', function () {
	            self.emit('wake');
	        }, true);
	    }
	}

	DesktopApp.prototype = (0, _create2.default)(WildEmitter.prototype, {
	    constructor: {
	        value: DesktopApp
	    }
	});

	DesktopApp.prototype.isRunning = function () {
	    return !!window.macgap || !!window.fluid || !!this.mozApp;
	};

	DesktopApp.prototype.install = function (cb) {
	    if (navigator.mozApps) {
	        var req = navigator.mozApps.install(this.mozAppManifest);
	        req.onsuccess = function (e) {
	            cb(null, e);
	        };
	        req.onerror = function (e) {
	            cb(e);
	        };
	    }
	};

	DesktopApp.prototype.uninstall = function () {
	    if (this.mozApp) {
	        return this.mozApp.uninstall();
	    }
	};

	DesktopApp.prototype.updateBadge = function (badge) {
	    if (window.macgap) {
	        window.macgap.dock.badge = badge || '';
	    } else if (window.fluid) {
	        window.fluid.dockBadge = badge || '';
	    }
	};

	module.exports = DesktopApp;

/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(669), __esModule: true };

/***/ },
/* 669 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(213);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ },
/* 670 */
/***/ function(module, exports) {

	/*
	WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
	on @visionmedia's Emitter from UI Kit.

	Why? I wanted it standalone.

	I also wanted support for wildcard emitters like this:

	emitter.on('*', function (eventName, other, event, payloads) {

	});

	emitter.on('somenamespace*', function (eventName, payloads) {

	});

	Please note that callbacks triggered by wildcard registered events also get
	the event name as the first argument.
	*/

	module.exports = WildEmitter;

	function WildEmitter() { }

	WildEmitter.mixin = function (constructor) {
	    var prototype = constructor.prototype || constructor;

	    prototype.isWildEmitter= true;

	    // Listen on the given `event` with `fn`. Store a group name if present.
	    prototype.on = function (event, groupName, fn) {
	        this.callbacks = this.callbacks || {};
	        var hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        func._groupName = group;
	        (this.callbacks[event] = this.callbacks[event] || []).push(func);
	        return this;
	    };

	    // Adds an `event` listener that will be invoked a single
	    // time then automatically removed.
	    prototype.once = function (event, groupName, fn) {
	        var self = this,
	            hasGroup = (arguments.length === 3),
	            group = hasGroup ? arguments[1] : undefined,
	            func = hasGroup ? arguments[2] : arguments[1];
	        function on() {
	            self.off(event, on);
	            func.apply(this, arguments);
	        }
	        this.on(event, group, on);
	        return this;
	    };

	    // Unbinds an entire group
	    prototype.releaseGroup = function (groupName) {
	        this.callbacks = this.callbacks || {};
	        var item, i, len, handlers;
	        for (item in this.callbacks) {
	            handlers = this.callbacks[item];
	            for (i = 0, len = handlers.length; i < len; i++) {
	                if (handlers[i]._groupName === groupName) {
	                    //console.log('removing');
	                    // remove it and shorten the array we're looping through
	                    handlers.splice(i, 1);
	                    i--;
	                    len--;
	                }
	            }
	        }
	        return this;
	    };

	    // Remove the given callback for `event` or all
	    // registered callbacks.
	    prototype.off = function (event, fn) {
	        this.callbacks = this.callbacks || {};
	        var callbacks = this.callbacks[event],
	            i;

	        if (!callbacks) return this;

	        // remove all handlers
	        if (arguments.length === 1) {
	            delete this.callbacks[event];
	            return this;
	        }

	        // remove specific handler
	        i = callbacks.indexOf(fn);
	        callbacks.splice(i, 1);
	        if (callbacks.length === 0) {
	            delete this.callbacks[event];
	        }
	        return this;
	    };

	    /// Emit `event` with the given args.
	    // also calls any `*` handlers
	    prototype.emit = function (event) {
	        this.callbacks = this.callbacks || {};
	        var args = [].slice.call(arguments, 1),
	            callbacks = this.callbacks[event],
	            specialCallbacks = this.getWildcardCallbacks(event),
	            i,
	            len,
	            item,
	            listeners;

	        if (callbacks) {
	            listeners = callbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, args);
	            }
	        }

	        if (specialCallbacks) {
	            len = specialCallbacks.length;
	            listeners = specialCallbacks.slice();
	            for (i = 0, len = listeners.length; i < len; ++i) {
	                if (!listeners[i]) {
	                    break;
	                }
	                listeners[i].apply(this, [event].concat(args));
	            }
	        }

	        return this;
	    };

	    // Helper for for finding special wildcard event handlers that match the event
	    prototype.getWildcardCallbacks = function (eventName) {
	        this.callbacks = this.callbacks || {};
	        var item,
	            split,
	            result = [];

	        for (item in this.callbacks) {
	            split = item.split('*');
	            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
	                result = result.concat(this.callbacks[item]);
	            }
	        }
	        return result;
	    };

	};

	WildEmitter.mixin(WildEmitter);


/***/ },
/* 671 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _create = __webpack_require__(668);

	var _create2 = _interopRequireDefault(_create);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var WildEmitter = __webpack_require__(670);
	var STATES = ['uncached', 'idle', 'checking', 'downloading', 'updateReady', 'obsolete'];

	function AppCache() {
	    WildEmitter.call(this);

	    var self = this;
	    this.cache = window.applicationCache;
	    this.state = STATES[this.cache.status];
	    this.emit('change', this.state);

	    function mapevent(name, altName) {
	        self.cache.addEventListener(name, function (e) {
	            var newState = STATES[self.cache.status];
	            if (newState !== self.state) {
	                self.state = newState;
	                self.emit('change', newState);
	            }
	            self.emit(altName || name, e);
	        }, false);
	    }
	    mapevent('cached');
	    mapevent('checking');
	    mapevent('downloading');
	    mapevent('error');
	    mapevent('noupdate', 'noUpdate');
	    mapevent('obsolete');
	    mapevent('progress');
	    mapevent('updateready', 'updateReady');
	}

	AppCache.prototype = (0, _create2.default)(WildEmitter.prototype, {
	    constructor: {
	        value: AppCache
	    }
	});

	AppCache.prototype.update = function () {
	    this.cache.update();
	};

	module.exports = AppCache;

/***/ },
/* 672 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(673);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(674);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 673 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215)(module), (function() { return this; }())))

/***/ },
/* 674 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(675);
	exports.encode = exports.stringify = __webpack_require__(676);


/***/ },
/* 675 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 676 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 677 */
/***/ function(module, exports) {

	/*
	SoundEffectManager

	Loads and plays sound effects useing
	HTML5 Web Audio API (as only available in webkit, at the moment).

	By @HenrikJoreteg from &yet
	*/


	function SoundEffectManager () {
	    this.AudioContext = window.AudioContext || window.webkitAudioContext;

	    this.support = !!this.AudioContext;
	    if (this.support) {
	        this.context = new this.AudioContext();
	    }

	    this.sounds = {};
	    this.sources = {};
	}

	// async load a file at a given URL, store it as 'name'.
	SoundEffectManager.prototype.loadFile = function (url, name, delay, cb) {
	    if (this.support) {
	        this._loadWebAudioFile(url, name, delay, cb);
	    } else {
	        this._loadWaveFile(url.replace('.mp3', '.wav'), name, delay, 3, cb);
	    }
	};

	// async load a file at a given URL, store it as 'name'.
	SoundEffectManager.prototype._loadWebAudioFile = function (url, name, delay, cb) {
	    if (!this.support) {
	        return;
	    }

	    var self = this;
	    var request = new XMLHttpRequest();

	    request.open('GET', url, true);
	    request.responseType = 'arraybuffer';
	    request.onload = function () {
	        self.context.decodeAudioData(request.response,
	            function (data) { // Success
	                self.sounds[name] = data;
	                if (cb) {
	                    cb(null, data);
	                }
	            },
	            function (err) { // Error
	                if (cb) {
	                    cb(err);
	                }
	            }
	        );
	    };

	    setTimeout(function () {
	        request.send();
	    }, delay || 0);
	};

	SoundEffectManager.prototype._loadWaveFile = function (url, name, delay, multiplexLimit, cb) {
	    var self = this;
	    var limit = multiplexLimit || 3;

	    setTimeout(function () {
	        var a, i = 0;

	        self.sounds[name] = [];
	        while (i < limit) {
	            a = new Audio();
	            a.src = url;
	            // for our callback
	            if (i === 0 && cb) {
	                a.addEventListener('canplaythrough', cb, false);
	            }
	            a.load();
	            self.sounds[name][i++] = a;
	        }
	    }, delay || 0);
	};

	SoundEffectManager.prototype._playWebAudio = function (soundName, loop) {
	    var buffer = this.sounds[soundName];

	    if (!buffer) {
	        return;
	    }

	    if (loop && this.sources[soundName]) {
	        // Only start the sound once if it's looping
	        return;
	    }

	    var source = this.context.createBufferSource();
	    source.buffer = buffer;
	    source.loop = loop;
	    source.connect(this.context.destination);

	    if (loop) {
	        this.sources[soundName] = source;
	    }

	    source.start(0);
	};

	SoundEffectManager.prototype._playWavAudio = function (soundName, loop) {
	    var audio = this.sounds[soundName];
	    var howMany = audio && audio.length || 0;
	    var i = 0;
	    var currSound;

	    if (!audio) {
	        return;
	    }

	    while (i < howMany) {
	        currSound = audio[i++];
	        // this covers case where we loaded an unplayable file type
	        if (currSound.error) {
	            return;
	        }
	        if (currSound.currentTime === 0 || currSound.currentTime === currSound.duration) {
	            currSound.currentTime = 0;
	            currSound.loop = !!loop;
	            i = howMany;
	            return currSound.play();
	        }
	    }
	};

	SoundEffectManager.prototype.play = function (soundName, loop) {
	    if (this.support) {
	        this._playWebAudio(soundName, loop);
	    } else {
	        return this._playWavAudio(soundName, loop);
	    }
	};

	SoundEffectManager.prototype.stop = function (soundName) {
	    if (this.support) {
	        if (this.sources[soundName]) {
	            this.sources[soundName].stop(0);
	            delete this.sources[soundName];
	        }
	    } else {
	        var soundArray = this.sounds[soundName];
	        var howMany = soundArray && soundArray.length || 0;
	        var i = 0;
	        var currSound;

	        while (i < howMany) {
	            currSound = soundArray[i++];
	            currSound.pause();
	            currSound.currentTime = 0;
	        }
	    }
	};


	module.exports = SoundEffectManager;


/***/ }
/******/ ]);
//# sourceMappingURL=app.js.map
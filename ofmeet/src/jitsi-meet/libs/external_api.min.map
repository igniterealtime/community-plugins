{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///external_api.min.js","webpack:///webpack/bootstrap 9ea5a98f463c17f1aa36","webpack:///./modules/API/external/external_api.js","webpack:///./~/jitsi-meet-logger/lib/Logger.js","webpack:///./~/jitsi-meet-logger/lib/LogCollector.js","webpack:///./~/jitsi-meet-logger/lib/index.js","webpack:///./~/postis/src/index.js"],"names":["root","factory","exports","module","define","amd","JitsiMeetExternalAPI","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__filename","sendMessage","postis","object","send","changeParticipantNumber","APIInstance","number","numberOfParticipants","domain","room_name","width","height","parentNode","configOverwrite","interfaceConfigOverwrite","noSsl","MIN_WIDTH","MIN_HEIGHT","scriptTag","document","scripts","length","iframeHolder","appendChild","createElement","style","frameName","url","key","hasOwnProperty","frame","src","name","setAttribute","postisInit","window","contentWindow","scope","eventHandlers","postisListeners","_setupListeners","logger","getLogger","commands","displayName","toggleAudio","toggleVideo","toggleFilmStrip","toggleChat","toggleContactList","toggleShareScreen","hangup","email","avatarUrl","events","incomingMessage","outgoingMessage","displayNameChange","participantJoined","participantLeft","videoConferenceJoined","videoConferenceLeft","readyToClose","prototype","executeCommand","_len","arguments","argumentsList","Array","_key","method","params","error","executeCommands","addEventListeners","i","addEventListener","event","listener","listen","data","bind","removeEventListener","removeEventListeners","getNumberOfParticipants","dispose","destroy","getElementById","self","setTimeout","removeChild","getCallerInfo","callerInfo","methodName","fileLocation","line","column","Error","stack","split","match","indexOf","substr","log","level","args","slice","levels","transports","globalTransports","concat","t","l","u","apply","Logger","format","methods","Object","keys","trace","debug","info","warn","consoleTransport","console","addGlobalTransport","transport","push","removeGlobalTransport","transportIdx","splice","setLevel","TRACE","DEBUG","INFO","LOG","WARN","ERROR","LogCollector","logStorage","options","stringifyObjects","storeInterval","maxEntryLength","forEach","logLevel","_log","storeLogsIntervalID","queue","totalLen","outputCache","stringify","someObject","JSON","formatLogMessage","msg","len","arg","prevMessage","undefined","prevMessageText","text","count","_flush","start","_reschedulePublishInterval","clearTimeout","flush","force","reschedule","isReady","cachedQueue","storeLogs","stop","idLoggers","loggers","curLevel","setLogLevelById","setLogLevel","Postis","readynessCheck","targetWindow","windowForEventListening","listeners","sendBuffer","listenBuffer","ready","readyMethod","parse","e","listenersForMethod","callback","listenBufferForMethod","j","opts","postMessage","clearInterval","readyCheckID","Date","Math","random","setInterval"],"mappings":"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","file":"external_api.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetExternalAPI\"] = factory();\n\telse\n\t\troot[\"JitsiMeetExternalAPI\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetExternalAPI\"] = factory();\n\telse\n\t\troot[\"JitsiMeetExternalAPI\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/libs/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {\"use strict\";\n\t\n\tvar logger = __webpack_require__(3).getLogger(__filename);\n\t\n\t/**\n\t * Implements API class that embeds Jitsi Meet in external applications.\n\t */\n\t\n\tvar postisInit = __webpack_require__(4);\n\t\n\t/**\n\t * The minimum width for the Jitsi Meet frame\n\t * @type {number}\n\t */\n\tvar MIN_WIDTH = 790;\n\t\n\t/**\n\t * The minimum height for the Jitsi Meet frame\n\t * @type {number}\n\t */\n\tvar MIN_HEIGHT = 300;\n\t\n\t/**\n\t * Last id of api object\n\t * @type {number}\n\t */\n\tvar id = 0;\n\t\n\t/**\n\t * Maps the names of the commands expected by the API with the name of the\n\t * commands expected by jitsi-meet\n\t */\n\tvar commands = {\n\t    \"displayName\": \"display-name\",\n\t    \"toggleAudio\": \"toggle-audio\",\n\t    \"toggleVideo\": \"toggle-video\",\n\t    \"toggleFilmStrip\": \"toggle-film-strip\",\n\t    \"toggleChat\": \"toggle-chat\",\n\t    \"toggleContactList\": \"toggle-contact-list\",\n\t    \"toggleShareScreen\": \"toggle-share-screen\",\n\t    \"hangup\": \"video-hangup\",\n\t    \"email\": \"email\",\n\t    \"avatarUrl\": \"avatar-url\"\n\t};\n\t\n\t/**\n\t * Maps the names of the events expected by the API with the name of the\n\t * events expected by jitsi-meet\n\t */\n\tvar events = {\n\t    \"incomingMessage\": \"incoming-message\",\n\t    \"outgoingMessage\": \"outgoing-message\",\n\t    \"displayNameChange\": \"display-name-change\",\n\t    \"participantJoined\": \"participant-joined\",\n\t    \"participantLeft\": \"participant-left\",\n\t    \"videoConferenceJoined\": \"video-conference-joined\",\n\t    \"videoConferenceLeft\": \"video-conference-left\",\n\t    \"readyToClose\": \"video-ready-to-close\"\n\t};\n\t\n\t/**\n\t * Sends the passed object to Jitsi Meet\n\t * @param postis {Postis object} the postis instance that is going to be used\n\t * to send the message\n\t * @param object the object to be sent\n\t * - method {sting}\n\t * - params {object}\n\t */\n\tfunction sendMessage(postis, object) {\n\t    postis.send(object);\n\t}\n\t\n\t/**\n\t * Adds given number to the numberOfParticipants property of given APIInstance.\n\t * @param {JitsiMeetExternalAPI} APIInstance the instance of the\n\t * JitsiMeetExternalAPI\n\t * @param {int} number - the number of participants to be added to\n\t * numberOfParticipants property (this parameter can be negative number if the\n\t * numberOfParticipants should be decreased).\n\t */\n\tfunction changeParticipantNumber(APIInstance, number) {\n\t    APIInstance.numberOfParticipants += number;\n\t}\n\t\n\t/**\n\t * Constructs new API instance. Creates iframe element that loads\n\t * Jitsi Meet.\n\t * @param domain the domain name of the server that hosts the conference\n\t * @param room_name the name of the room to join\n\t * @param width width of the iframe\n\t * @param height height of the iframe\n\t * @param parent_node the node that will contain the iframe\n\t * @param configOverwrite object containing configuration options defined in\n\t * config.js to be overridden.\n\t * @param interfaceConfigOverwrite object containing configuration options\n\t * defined in interface_config.js to be overridden.\n\t * @param noSsl if the value is true https won't be used\n\t * @constructor\n\t */\n\tfunction JitsiMeetExternalAPI(domain, room_name, width, height, parentNode, configOverwrite, interfaceConfigOverwrite, noSsl) {\n\t    if (!width || width < MIN_WIDTH) width = MIN_WIDTH;\n\t    if (!height || height < MIN_HEIGHT) height = MIN_HEIGHT;\n\t\n\t    this.parentNode = null;\n\t    if (parentNode) {\n\t        this.parentNode = parentNode;\n\t    } else {\n\t        var scriptTag = document.scripts[document.scripts.length - 1];\n\t        this.parentNode = scriptTag.parentNode;\n\t    }\n\t\n\t    this.iframeHolder = this.parentNode.appendChild(document.createElement(\"div\"));\n\t    this.iframeHolder.id = \"jitsiConference\" + id;\n\t    if (width) this.iframeHolder.style.width = width + \"px\";\n\t    if (height) this.iframeHolder.style.height = height + \"px\";\n\t    this.frameName = \"jitsiConferenceFrame\" + id;\n\t    this.url = noSsl ? \"http\" : \"https\" + \"://\" + domain + \"/\";\n\t    if (room_name) this.url += room_name;\n\t    this.url += \"#jitsi_meet_external_api_id=\" + id;\n\t\n\t    var key;\n\t    if (configOverwrite) {\n\t        for (key in configOverwrite) {\n\t            if (!configOverwrite.hasOwnProperty(key) || typeof key !== 'string') continue;\n\t            this.url += \"&config.\" + key + \"=\" + configOverwrite[key];\n\t        }\n\t    }\n\t\n\t    if (interfaceConfigOverwrite) {\n\t        for (key in interfaceConfigOverwrite) {\n\t            if (!interfaceConfigOverwrite.hasOwnProperty(key) || typeof key !== 'string') continue;\n\t            this.url += \"&interfaceConfig.\" + key + \"=\" + interfaceConfigOverwrite[key];\n\t        }\n\t    }\n\t\n\t    this.frame = document.createElement(\"iframe\");\n\t    this.frame.src = this.url;\n\t    this.frame.name = this.frameName;\n\t    this.frame.id = this.frameName;\n\t    this.frame.width = \"100%\";\n\t    this.frame.height = \"100%\";\n\t    this.frame.setAttribute(\"allowFullScreen\", \"true\");\n\t    this.frame = this.iframeHolder.appendChild(this.frame);\n\t    this.postis = postisInit({\n\t        window: this.frame.contentWindow,\n\t        scope: \"jitsi_meet_external_api_\" + id\n\t    });\n\t\n\t    this.eventHandlers = {};\n\t\n\t    // Map<{string} event_name, {boolean} postis_listener_added>\n\t    this.postisListeners = {};\n\t\n\t    this.numberOfParticipants = 1;\n\t    this._setupListeners();\n\t\n\t    id++;\n\t}\n\t\n\t/**\n\t * Executes command. The available commands are:\n\t * displayName - sets the display name of the local participant to the value\n\t * passed in the arguments array.\n\t * toggleAudio - mutes / unmutes audio with no arguments\n\t * toggleVideo - mutes / unmutes video with no arguments\n\t * filmStrip - hides / shows the film strip with no arguments\n\t * If the command doesn't require any arguments the parameter should be set\n\t * to empty array or it may be omitted.\n\t * @param name the name of the command\n\t * @param arguments array of arguments\n\t */\n\tJitsiMeetExternalAPI.prototype.executeCommand = function (name) {\n\t    for (var _len = arguments.length, argumentsList = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        argumentsList[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    if (!(name in commands)) {\n\t        logger.error(\"Not supported command name.\");\n\t        return;\n\t    }\n\t    sendMessage(this.postis, { method: commands[name], params: argumentsList });\n\t};\n\t\n\t/**\n\t * Executes commands. The available commands are:\n\t * displayName - sets the display name of the local participant to the value\n\t * passed in the arguments array.\n\t * toggleAudio - mutes / unmutes audio. no arguments\n\t * toggleVideo - mutes / unmutes video. no arguments\n\t * filmStrip - hides / shows the film strip. no arguments\n\t * toggleChat - hides / shows chat. no arguments.\n\t * toggleContactList - hides / shows contact list. no arguments.\n\t * toggleShareScreen - starts / stops screen sharing. no arguments.\n\t * @param object the object with commands to be executed. The keys of the\n\t * object are the commands that will be executed and the values are the\n\t * arguments for the command.\n\t */\n\tJitsiMeetExternalAPI.prototype.executeCommands = function (object) {\n\t    for (var key in object) {\n\t        this.executeCommand(key, object[key]);\n\t    }\n\t};\n\t\n\t/**\n\t * Adds event listeners to Meet Jitsi. The object key should be the name of\n\t * the event and value - the listener.\n\t * Currently we support the following\n\t * events:\n\t * incomingMessage - receives event notifications about incoming\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"from\": from,//JID of the user that sent the message\n\t *  \"nick\": nick,//the nickname of the user that sent the message\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * outgoingMessage - receives event notifications about outgoing\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * displayNameChanged - receives event notifications about display name\n\t * change. The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid,//the JID of the participant that changed his display name\n\t * displayname: displayName //the new display name\n\t * }}\n\t * participantJoined - receives event notifications about new participant.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * participantLeft - receives event notifications about the participant that\n\t * left the room.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * video-conference-joined - receives event notifications about the local user\n\t * has successfully joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * video-conference-left - receives event notifications about the local user\n\t * has left the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * readyToClose - all hangup operations are completed and Jitsi Meet is ready\n\t * to be disposed.\n\t * @param object\n\t */\n\tJitsiMeetExternalAPI.prototype.addEventListeners = function (object) {\n\t    for (var i in object) {\n\t        this.addEventListener(i, object[i]);\n\t    }\n\t};\n\t\n\t/**\n\t * Adds event listeners to Meet Jitsi. Currently we support the following\n\t * events:\n\t * incomingMessage - receives event notifications about incoming\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"from\": from,//JID of the user that sent the message\n\t *  \"nick\": nick,//the nickname of the user that sent the message\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * outgoingMessage - receives event notifications about outgoing\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * displayNameChanged - receives event notifications about display name\n\t * change. The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid,//the JID of the participant that changed his display name\n\t * displayname: displayName //the new display name\n\t * }}\n\t * participantJoined - receives event notifications about new participant.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * participantLeft - receives event notifications about participant the that\n\t * left the room.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * video-conference-joined - receives event notifications fired when the local\n\t * user has joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * video-conference-left - receives event notifications fired when the local\n\t * user has joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * @param event the name of the event\n\t * @param listener the listener\n\t */\n\tJitsiMeetExternalAPI.prototype.addEventListener = function (event, listener) {\n\t    if (!(event in events)) {\n\t        logger.error(\"Not supported event name.\");\n\t        return;\n\t    }\n\t    // We cannot remove listeners from postis that's why we are handling the\n\t    // callback that way.\n\t    if (!this.postisListeners[event]) {\n\t        this.postis.listen(events[event], function (data) {\n\t            if (event in this.eventHandlers && typeof this.eventHandlers[event] === \"function\") this.eventHandlers[event].call(null, data);\n\t        }.bind(this));\n\t        this.postisListeners[event] = true;\n\t    }\n\t    this.eventHandlers[event] = listener;\n\t};\n\t\n\t/**\n\t * Removes event listener.\n\t * @param event the name of the event.\n\t */\n\tJitsiMeetExternalAPI.prototype.removeEventListener = function (event) {\n\t    if (!(event in this.eventHandlers)) {\n\t        logger.error(\"The event \" + event + \" is not registered.\");\n\t        return;\n\t    }\n\t    delete this.eventHandlers[event];\n\t};\n\t\n\t/**\n\t * Removes event listeners.\n\t * @param events array with the names of the events.\n\t */\n\tJitsiMeetExternalAPI.prototype.removeEventListeners = function (events) {\n\t    for (var i = 0; i < events.length; i++) {\n\t        this.removeEventListener(events[i]);\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the number of participants in the conference.\n\t * NOTE: the local participant is included.\n\t * @returns {int} the number of participants in the conference.\n\t */\n\tJitsiMeetExternalAPI.prototype.getNumberOfParticipants = function () {\n\t    return this.numberOfParticipants;\n\t};\n\t\n\t/**\n\t * Setups listeners that are used internally for JitsiMeetExternalAPI.\n\t */\n\tJitsiMeetExternalAPI.prototype._setupListeners = function () {\n\t    this.postis.listen(\"participant-joined\", changeParticipantNumber.bind(null, this, 1));\n\t    this.postis.listen(\"participant-left\", changeParticipantNumber.bind(null, this, -1));\n\t};\n\t\n\t/**\n\t * Removes the listeners and removes the Jitsi Meet frame.\n\t */\n\tJitsiMeetExternalAPI.prototype.dispose = function () {\n\t    this.postis.destroy();\n\t    var frame = document.getElementById(this.frameName);\n\t    if (frame) frame.src = 'about:blank';\n\t    var self = this;\n\t    window.setTimeout(function () {\n\t        self.iframeHolder.removeChild(self.frame);\n\t        self.iframeHolder.parentNode.removeChild(self.iframeHolder);\n\t    }, 10);\n\t};\n\t\n\tmodule.exports = JitsiMeetExternalAPI;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/API/external/external_api.js\"))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Ordered log levels.\n\t */\n\tvar levels = {\n\t    \"trace\": 0,\n\t    \"debug\": 1,\n\t    \"info\": 2,\n\t    \"log\": 3,\n\t    \"warn\": 4,\n\t    \"error\": 5\n\t};\n\t\n\t/**\n\t * The default transport - console\n\t * @type LoggerTransport\n\t */\n\tLogger.consoleTransport = console;\n\t\n\t/**\n\t * The array which stores currently registered global transports.\n\t * @type {[LoggerTransport]}\n\t */\n\tvar globalTransports = [ Logger.consoleTransport ];\n\t\n\t/**\n\t * Adds given {@link LoggerTransport} instance to the list of global\n\t * transports which means that it'll be used by all {@link Logger}s\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.addGlobalTransport = function(transport) {\n\t    if (globalTransports.indexOf(transport) === -1) {\n\t        globalTransports.push(transport);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes given {@link LoggerTransport} instance from the list of global\n\t * transports\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.removeGlobalTransport = function(transport) {\n\t    var transportIdx = globalTransports.indexOf(transport);\n\t    if (transportIdx !== -1) {\n\t        globalTransports.splice(transportIdx, 1);\n\t    }\n\t};\n\t\n\t/**\n\t * Parses Error's object stack trace and extracts information about the last\n\t * caller before the log method was called.\n\t * @returns JS object with info about the caller - method name, file location,\n\t * line and column.\n\t */\n\tfunction getCallerInfo() {\n\t    var callerInfo = {\n\t        methodName: \"\",\n\t        fileLocation: \"\",\n\t        line: null,\n\t        column: null\n\t    };\n\t    //gets the part of the stack without the logger wrappers\n\t    var error = new Error();\n\t    var stack = error.stack? error.stack.split(\"\\n\") : [];\n\t    if(!stack || stack.length < 1) {\n\t        return callerInfo;\n\t    }\n\t    var m = null;\n\t    if(stack[3]) {\n\t        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n\t    }\n\t    if(!m || m.length <= 4) {\n\t        //Firefox && Safari\n\t        if(stack[2].indexOf(\"log@\") === 0){\n\t            //Safari\n\t            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n\t        } else {\n\t            //Firefox\n\t            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n\t        }\n\t        return callerInfo;\n\t    }\n\t\n\t    callerInfo.methodName = m[1];\n\t    callerInfo.fileLocation = m[2];\n\t    callerInfo.line = m[3];\n\t    callerInfo.column = m[4];\n\t    return callerInfo;\n\t}\n\t\n\t/**\n\t * Logs messages using the transports and level from the logger.\n\t * @param logger a logger instance.\n\t * @param level the log level of the message. See the levels variable.\n\t * @param arguments array with arguments that will be logged.\n\t */\n\tfunction log() {\n\t    var logger = arguments[0], level = arguments[1],\n\t        args = Array.prototype.slice.call(arguments, 2);\n\t    if(levels[level] < logger.level) {\n\t        return;\n\t    }\n\t\n\t    var callerInfo = getCallerInfo();\n\t    var transports = globalTransports.concat(logger.transports);\n\t    for(var i = 0; i < transports.length; i++) {\n\t        var t = transports[i];\n\t        var l = t[level];\n\t        if(l && typeof(l) === \"function\") {\n\t            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n\t                .apply(t, args);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t *\n\t * Constructs new logger object.\n\t * @param level the logging level for the new logger\n\t * @param id optional identifier for the logger instance.\n\t * @param {LoggerTransport} transports optional list of handlers(objects) for\n\t * the logs. The handlers must support - log, warn, error, debug, info, trace.\n\t * @param format optional (NOT implemented) string.\n\t */\n\tfunction Logger(level, id, transports, format) {\n\t    this.id = id;\n\t    this.format = format;\n\t    this.transports = transports;\n\t    if(!this.transports) {\n\t        this.transports = [];\n\t    }\n\t    this.level = levels[level];\n\t    var methods = Object.keys(levels);\n\t    for(var i = 0; i < methods.length; i++){\n\t        this[methods[i]] =\n\t            log.bind(null, this, methods[i]);\n\t    }\n\t}\n\t\n\t/**\n\t * Sets the log level for the logger.\n\t * @param level the new log level.\n\t */\n\tLogger.prototype.setLevel = function (level) {\n\t    this.level = levels[level];\n\t};\n\tmodule.exports = Logger;\n\t\n\t/**\n\t * Enum for the supported log levels.\n\t */\n\tLogger.levels = {\n\t    TRACE: \"trace\",\n\t    DEBUG: \"debug\",\n\t    INFO: \"info\",\n\t    LOG: \"log\",\n\t    WARN: \"warn\",\n\t    ERROR: \"error\"\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2016 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(1);\n\t\n\t/**\n\t * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n\t * and thus can be added as global transport in order to capture all the logs.\n\t *\n\t * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n\t * a message and stores them in a queue in order to batch log entries. There are\n\t * time and size limit constraints which determine how often batch entries are\n\t * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n\t * will use the <tt>logStorage</tt> object given as an argument to save\n\t * the batch log entry.\n\t *\n\t * @param {Object} logStorage an object which allows to store the logs collected\n\t * @param {function(string|object[])} logStorage.storeLogs a method called when\n\t * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n\t * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n\t * item is an object it means that it's an aggregated message. That is a message\n\t * which is the same as the previous one and it's representation has\n\t * the following format:\n\t * {\n\t *   {string} text: 'the text of some duplicated message'\n\t *   {number} count: 3 // how many times the message appeared in a row\n\t * }\n\t * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n\t * the sequence of \"A\". Which means that even if the next message \"C\" is\n\t * the same as \"A\" it will start a new aggregated message \"C\".\n\t * @param {function()} logStorage.isReady a method which should return\n\t * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n\t * time storage is not ready log batches will be cached and stored on the next\n\t * occasion (flush or interval timeout).\n\t *\n\t * @param {Object} options the <tt>LogCollector</tt> configuration options.\n\t * @param {number} options.maxEntryLength the size limit for a single log entry\n\t * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n\t * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n\t * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n\t * storage becomes ready. Note that the \"is ready\" condition is checked every\n\t * <tt>options.storeInterval</tt> milliseconds.\n\t * @param {number} options.storeInterval how often the logs should be stored in\n\t * case <tt>maxEntryLength</tt> was not exceeded.\n\t * @param {boolean} options.stringifyObjects indicates whether or not object\n\t * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n\t * message is composed. Note that objects logged on the error log level are\n\t * always stringified.\n\t *\n\t * @constructor\n\t */\n\tfunction LogCollector(logStorage, options) {\n\t    this.logStorage = logStorage;\n\t    this.stringifyObjects\n\t        = options && options.stringifyObjects\n\t            ? options.stringifyObjects : false;\n\t    this.storeInterval\n\t        = options && options.storeInterval\n\t            ? options.storeInterval: 30000;\n\t    this.maxEntryLength\n\t        = options && options.maxEntryLength\n\t            ? options.maxEntryLength : 10000;\n\t    // Bind the log method for each level to the corresponding method name\n\t    // in order to implement \"global log transport\" object.\n\t    Object.keys(Logger.levels).forEach(\n\t    function (logLevel) {\n\t        var methodName = Logger.levels[logLevel];\n\t        this[methodName] = function (logLevel) {\n\t            this._log.apply(this, arguments);\n\t        }.bind(this, logLevel);\n\t    }.bind(this));\n\t    /**\n\t     * The ID of store logs interval if one is currently scheduled or\n\t     * <tt>null</tt> otherwise.\n\t     * @type {number|null}\n\t     */\n\t    this.storeLogsIntervalID = null;\n\t    /**\n\t     * The log messages that are to be batched into log entry when\n\t     * {@link LogCollector._flush} method is called.\n\t     * @type {string[]}\n\t     */\n\t    this.queue = [];\n\t    /**\n\t     * The total length of all messages currently stored in the {@link queue}.\n\t     * @type {number}\n\t     */\n\t    this.totalLen = 0;\n\t    /**\n\t     * An array used to temporarily store log batches, before the storage gets\n\t     * ready.\n\t     * @type {string[]}\n\t     */\n\t    this.outputCache = [];\n\t}\n\t\n\t/**\n\t * Method called inside of {@link formatLogMessage} in order to covert an\n\t * <tt>Object</tt> argument to string. The conversion will happen when either\n\t * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n\t * log level. The default implementation uses <tt>JSON.stringify</tt> and\n\t * returns \"[object with circular refs?]\" instead of an object if it fails.\n\t *\n\t * @param {object} someObject the <tt>object</tt> to be stringified.\n\t *\n\t * @return {string} the result of <tt>JSON.stringify</tt> or\n\t * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.stringify = function (someObject) {\n\t    try {\n\t        return JSON.stringify(someObject);\n\t    } catch (error) {\n\t        return \"[object with circular refs?]\";\n\t    }\n\t};\n\t\n\t/**\n\t * Formats log entry for the given logging level and arguments passed to the\n\t * <tt>Logger</tt>'s log method. The first argument is log level and the next\n\t * arguments have to be captured using JS built-in 'arguments' variable.\n\t *\n\t * @param {Logger.levels} logLevel provides the logging level of the message to\n\t * be logged.\n\t *\n\t * @return {string|null} a non-empty string representation of the log entry\n\t * crafted from the log arguments. If the return value is <tt>null</tt> then\n\t * the message wil be discarded by this <tt>LogCollector</tt>.\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.formatLogMessage\n\t= function (logLevel/*, arg1, arg2, arg3... */) {\n\t    var msg = '';\n\t    for (var i = 1, len = arguments.length; i < len; i++) {\n\t        var arg = arguments[i];\n\t        // objects logged on error level are always converted to JSON\n\t        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n\t            && typeof arg === 'object') {\n\t            arg = this.stringify(arg);\n\t        }\n\t        msg += arg;\n\t        if (i != len - 1) {\n\t            msg += ' ';\n\t        }\n\t    }\n\t    return msg.length ? msg : null;\n\t};\n\t\n\t/**\n\t * The log method bound to each of the logging levels in order to implement\n\t * \"global log transport\" object.\n\t *\n\t * @private\n\t */\n\tLogCollector.prototype._log = function() {\n\t\n\t    // var logLevel = arguments[0]; first argument is the log level\n\t    var msg = this.formatLogMessage.apply(this, arguments);\n\t    if (msg) {\n\t        // The same as the previous message aggregation logic\n\t        var prevMessage\n\t            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n\t        // NOTE that typeof undefined is 'undefined'\n\t        var prevMessageText\n\t            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n\t        // Is it the same as the previous one ?\n\t        if (prevMessageText == msg) {\n\t            if (typeof prevMessage === 'object') {\n\t                prevMessage.count += 1;\n\t            } else {\n\t                this.queue[this.queue.length-1] = {\n\t                    text: msg,\n\t                    count: 2\n\t                }\n\t            }\n\t        } else {\n\t            this.queue.push(msg);\n\t            this.totalLen += msg.length;\n\t        }\n\t    }\n\t\n\t    if (this.totalLen >= this.maxEntryLength) {\n\t        this._flush(true /* force */, true /* reschedule */);\n\t    }\n\t};\n\t\n\t/**\n\t * Starts periodical \"store logs\" task which will be triggered at the interval\n\t * specified in the constructor options.\n\t */\n\tLogCollector.prototype.start = function () {\n\t    this._reschedulePublishInterval();\n\t};\n\t\n\t/**\n\t * Reschedules the periodical \"store logs\" task which will store the next batch\n\t * log entry in the storage.\n\t * @private\n\t */\n\tLogCollector.prototype._reschedulePublishInterval = function () {\n\t    if (this.storeLogsIntervalID) {\n\t        window.clearTimeout(this.storeLogsIntervalID);\n\t        this.storeLogsIntervalID = null;\n\t    }\n\t    // It's actually a timeout, because it is rescheduled on every flush\n\t    this.storeLogsIntervalID\n\t        = window.setTimeout(\n\t            this._flush.bind(\n\t                this, false /* do not force */, true /* reschedule */),\n\t            this.storeInterval);\n\t};\n\t\n\t/**\n\t * Call this method to flush the log entry buffer and store it in the log\n\t * storage immediately (given that the storage is ready).\n\t */\n\tLogCollector.prototype.flush = function() {\n\t    this._flush(\n\t        false /* do not force, as it will not be stored anyway */,\n\t        true /* reschedule next update */ )\n\t};\n\t\n\t/**\n\t * Stores the next batch log entry in the log storage.\n\t * @param {boolean} force enforce current logs batch to be stored or cached if\n\t * there is anything to be logged, but the storage is not ready yet. One of\n\t * legitimate reasons to force is when the logs length exceeds size limit which\n\t * could result in truncation.\n\t * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n\t * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n\t * task cycle.\n\t * @private\n\t */\n\tLogCollector.prototype._flush = function(force, reschedule) {\n\t    // Publish only if there's anything to be logged\n\t    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n\t        //FIXME avoid truncating\n\t        // right now we don't care if the message size is \"slightly\" exceeded\n\t        if (this.logStorage.isReady()) {\n\t            // Sends all cached logs\n\t            if (this.outputCache.length) {\n\t                this.outputCache.forEach(\n\t                    function (cachedQueue) {\n\t                        this.logStorage.storeLogs(cachedQueue);\n\t                    }.bind(this)\n\t                );\n\t                // Clear the cache\n\t                this.outputCache = [];\n\t            }\n\t            // Send current batch\n\t            this.logStorage.storeLogs(this.queue);\n\t        } else {\n\t            this.outputCache.push(this.queue);\n\t        }\n\t\n\t        this.queue = [];\n\t        this.totalLen = 0;\n\t    }\n\t\n\t    if (reschedule) {\n\t        this._reschedulePublishInterval();\n\t    }\n\t};\n\t\n\t/**\n\t * Stops the periodical \"store logs\" task and immediately stores any pending\n\t * log entries as a batch.\n\t */\n\tLogCollector.prototype.stop = function() {\n\t    // Flush and stop publishing logs\n\t    this._flush(false /* do not force */, false /* do not reschedule */);\n\t};\n\t\n\tmodule.exports = LogCollector;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(1);\n\tvar LogCollector = __webpack_require__(2);\n\t\n\t/**\n\t * Definition of the log method\n\t * @name log_method\n\t * @function\n\t * @param {...*} log_args the arguments to be logged\n\t */\n\t/**\n\t * The logger's transport type definition.\n\t *\n\t * @typedef {object} LoggerTransport\n\t *\n\t * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n\t * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n\t * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n\t * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n\t * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n\t * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n\t */\n\t\n\t/**\n\t * Map with the created loggers with ID.\n\t */\n\tvar idLoggers = {};\n\t\n\t/**\n\t * Array with the loggers without id.\n\t */\n\tvar loggers = [];\n\t\n\t/**\n\t * Log level for the lbrary.\n\t */\n\tvar curLevel = Logger.levels.TRACE;\n\t\n\t\n\tmodule.exports = {\n\t    /**\n\t     * Adds given {@link LoggerTransport} instance to the list of global\n\t     * transports which means that it'll be used by all {@link Logger}s\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    addGlobalTransport: function(transport) {\n\t        Logger.addGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Removes given {@link LoggerTransport} instance from the list of global\n\t     * transports\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    removeGlobalTransport: function(transport) {\n\t        Logger.removeGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Creates new logger.\n\t     * @arguments the same as Logger constructor\n\t     */\n\t    getLogger: function(id, transports, format) {\n\t        var logger = new Logger(curLevel, id, transports, format);\n\t        if(id) {\n\t            idLoggers[id] = idLoggers[id] || [];\n\t            idLoggers[id].push(logger);\n\t        } else {\n\t            loggers.push(logger);\n\t        }\n\t        return logger;\n\t    },\n\t    /**\n\t     * Changes the log level for the existing loggers by id.\n\t     * @param level the new log level.\n\t     * @param id if specified the level will be changed only for loggers with the\n\t     * same id. Otherwise the operation will affect all loggers that don't\n\t     * have id.\n\t     */\n\t    setLogLevelById: function(level, id) {\n\t        var l = id? (idLoggers[id] || []) : loggers;\n\t        for(var i = 0; i < l.length; i++) {\n\t            l[i].setLevel(level);\n\t        }\n\t    },\n\t    /**\n\t     * Changes the log level for all existing loggers.\n\t     * @param level the new log level.\n\t     */\n\t    setLogLevel: function (level) {\n\t        curLevel = level;\n\t        var i = 0;\n\t        for(; i < loggers.length; i++) {\n\t            loggers[i].setLevel(level);\n\t        }\n\t\n\t        for(var id in idLoggers) {\n\t            var l = idLoggers[id] || [];\n\t            for(i = 0; i < l.length; i++) {\n\t                l[i].setLevel(level);\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     * The supported log levels.\n\t     */\n\t    levels: Logger.levels,\n\t    /**\n\t     * Exports the <tt>LogCollector</tt>.\n\t     */\n\t    LogCollector: LogCollector\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tfunction Postis(options) {\n\t  var scope = options.scope;\n\t  var targetWindow = options.window;\n\t  var windowForEventListening = options.windowForEventListening || window;\n\t  var listeners = {};\n\t  var sendBuffer = [];\n\t  var listenBuffer = {};\n\t  var ready = false;\n\t  var readyMethod = \"__ready__\";\n\t  var readynessCheck;\n\t\n\t  var listener = function(event) {\n\t    var data;\n\t    try {\n\t      data = JSON.parse(event.data);\n\t    } catch (e) {\n\t      return;\n\t    }\n\t\n\t    if (data.postis && data.scope === scope) {\n\t      var listenersForMethod = listeners[data.method];\n\t      if (listenersForMethod) {\n\t        for (var i = 0; i < listenersForMethod.length; i++) {\n\t          listenersForMethod[i].call(null, data.params);\n\t        }\n\t      } else {\n\t        listenBuffer[data.method] = listenBuffer[data.method] || [];\n\t        listenBuffer[data.method].push(data.params);\n\t      }\n\t    }\n\t  };\n\t\n\t  windowForEventListening.addEventListener(\"message\", listener, false);\n\t\n\t  var postis = {\n\t    listen: function (method, callback) {\n\t      listeners[method] = listeners[method] || [];\n\t      listeners[method].push(callback);\n\t\n\t      var listenBufferForMethod = listenBuffer[method];\n\t      if (listenBufferForMethod) {\n\t        var listenersForMethod = listeners[method];\n\t        for (var i = 0; i < listenersForMethod.length; i++) {\n\t          for (var j = 0; j < listenBufferForMethod.length; j++) {\n\t            listenersForMethod[i].call(null, listenBufferForMethod[j]);\n\t          }\n\t        }\n\t      }\n\t      delete listenBuffer[method];\n\t    },\n\t\n\t    send: function (opts) {\n\t      var method = opts.method;\n\t\n\t      if ((ready || opts.method === readyMethod) && (targetWindow && typeof targetWindow.postMessage === \"function\")) {\n\t        targetWindow.postMessage(JSON.stringify({\n\t          postis: true,\n\t          scope: scope,\n\t          method: method,\n\t          params: opts.params\n\t        }), \"*\");\n\t      } else {\n\t        sendBuffer.push(opts);\n\t      }\n\t    },\n\t\n\t    ready: function (callback) {\n\t      if (ready) {\n\t        callback();\n\t      } else {\n\t        setTimeout(function () { postis.ready(callback); }, 50);\n\t      }\n\t    },\n\t\n\t    destroy: function (callback) {\n\t      clearInterval(readynessCheck);\n\t      ready = false;\n\t      if (windowForEventListening && typeof windowForEventListening.removeEventListener === \"function\") {\n\t        windowForEventListening.removeEventListener(\"message\", listener);\n\t      }\n\t      callback && callback();\n\t    }\n\t  };\n\t\n\t  var readyCheckID = +new Date() + Math.random() + \"\";\n\t\n\t  readynessCheck = setInterval(function () {\n\t    postis.send({\n\t      method: readyMethod,\n\t      params: readyCheckID\n\t    });\n\t  }, 50);\n\t\n\t  postis.listen(readyMethod, function (id) {\n\t    if (id === readyCheckID) {\n\t      clearInterval(readynessCheck);\n\t      ready = true;\n\t\n\t      for (var i = 0; i < sendBuffer.length; i++) {\n\t        postis.send(sendBuffer[i]);\n\t      }\n\t      sendBuffer = [];\n\t    } else {\n\t      postis.send({\n\t        method: readyMethod,\n\t        params: id\n\t      });\n\t    }\n\t  });\n\t\n\t  return postis;\n\t}\n\t\n\tmodule.exports = Postis;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// external_api.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9ea5a98f463c17f1aa36","const logger = require(\"jitsi-meet-logger\").getLogger(__filename);\n\n/**\n * Implements API class that embeds Jitsi Meet in external applications.\n */\n\nvar postisInit = require(\"postis\");\n\n/**\n * The minimum width for the Jitsi Meet frame\n * @type {number}\n */\nvar MIN_WIDTH = 790;\n\n/**\n * The minimum height for the Jitsi Meet frame\n * @type {number}\n */\nvar MIN_HEIGHT = 300;\n\n/**\n * Last id of api object\n * @type {number}\n */\nvar id = 0;\n\n/**\n * Maps the names of the commands expected by the API with the name of the\n * commands expected by jitsi-meet\n */\nvar commands = {\n    \"displayName\": \"display-name\",\n    \"toggleAudio\": \"toggle-audio\",\n    \"toggleVideo\": \"toggle-video\",\n    \"toggleFilmStrip\": \"toggle-film-strip\",\n    \"toggleChat\": \"toggle-chat\",\n    \"toggleContactList\": \"toggle-contact-list\",\n    \"toggleShareScreen\": \"toggle-share-screen\",\n    \"hangup\": \"video-hangup\",\n    \"email\": \"email\",\n    \"avatarUrl\": \"avatar-url\"\n};\n\n/**\n * Maps the names of the events expected by the API with the name of the\n * events expected by jitsi-meet\n */\nvar events = {\n    \"incomingMessage\": \"incoming-message\",\n    \"outgoingMessage\": \"outgoing-message\",\n    \"displayNameChange\": \"display-name-change\",\n    \"participantJoined\": \"participant-joined\",\n    \"participantLeft\": \"participant-left\",\n    \"videoConferenceJoined\": \"video-conference-joined\",\n    \"videoConferenceLeft\": \"video-conference-left\",\n    \"readyToClose\": \"video-ready-to-close\"\n};\n\n/**\n * Sends the passed object to Jitsi Meet\n * @param postis {Postis object} the postis instance that is going to be used\n * to send the message\n * @param object the object to be sent\n * - method {sting}\n * - params {object}\n */\nfunction sendMessage(postis, object) {\n    postis.send(object);\n}\n\n/**\n * Adds given number to the numberOfParticipants property of given APIInstance.\n * @param {JitsiMeetExternalAPI} APIInstance the instance of the\n * JitsiMeetExternalAPI\n * @param {int} number - the number of participants to be added to\n * numberOfParticipants property (this parameter can be negative number if the\n * numberOfParticipants should be decreased).\n */\nfunction changeParticipantNumber(APIInstance, number) {\n    APIInstance.numberOfParticipants += number;\n}\n\n/**\n * Constructs new API instance. Creates iframe element that loads\n * Jitsi Meet.\n * @param domain the domain name of the server that hosts the conference\n * @param room_name the name of the room to join\n * @param width width of the iframe\n * @param height height of the iframe\n * @param parent_node the node that will contain the iframe\n * @param configOverwrite object containing configuration options defined in\n * config.js to be overridden.\n * @param interfaceConfigOverwrite object containing configuration options\n * defined in interface_config.js to be overridden.\n * @param noSsl if the value is true https won't be used\n * @constructor\n */\nfunction JitsiMeetExternalAPI(domain, room_name, width, height, parentNode,\n    configOverwrite, interfaceConfigOverwrite, noSsl) {\n    if (!width || width < MIN_WIDTH)\n        width = MIN_WIDTH;\n    if (!height || height < MIN_HEIGHT)\n        height = MIN_HEIGHT;\n\n    this.parentNode = null;\n    if (parentNode) {\n        this.parentNode = parentNode;\n    } else {\n        var scriptTag = document.scripts[document.scripts.length - 1];\n        this.parentNode = scriptTag.parentNode;\n    }\n\n    this.iframeHolder =\n        this.parentNode.appendChild(document.createElement(\"div\"));\n    this.iframeHolder.id = \"jitsiConference\" + id;\n    if(width)\n        this.iframeHolder.style.width = width + \"px\";\n    if(height)\n        this.iframeHolder.style.height = height + \"px\";\n    this.frameName = \"jitsiConferenceFrame\" + id;\n    this.url = (noSsl) ? \"http\" : \"https\" +\"://\" + domain + \"/\";\n    if(room_name)\n        this.url += room_name;\n    this.url += \"#jitsi_meet_external_api_id=\" + id;\n\n    var key;\n    if (configOverwrite) {\n        for (key in configOverwrite) {\n            if (!configOverwrite.hasOwnProperty(key) ||\n                typeof key !== 'string')\n                continue;\n            this.url += \"&config.\" + key + \"=\" + configOverwrite[key];\n        }\n    }\n\n    if (interfaceConfigOverwrite) {\n        for (key in interfaceConfigOverwrite) {\n            if (!interfaceConfigOverwrite.hasOwnProperty(key) ||\n                typeof key !== 'string')\n                continue;\n            this.url += \"&interfaceConfig.\" + key + \"=\" +\n                interfaceConfigOverwrite[key];\n        }\n    }\n\n    this.frame = document.createElement(\"iframe\");\n    this.frame.src = this.url;\n    this.frame.name = this.frameName;\n    this.frame.id = this.frameName;\n    this.frame.width = \"100%\";\n    this.frame.height = \"100%\";\n    this.frame.setAttribute(\"allowFullScreen\",\"true\");\n    this.frame = this.iframeHolder.appendChild(this.frame);\n    this.postis = postisInit({\n        window: this.frame.contentWindow,\n        scope: \"jitsi_meet_external_api_\" + id\n    });\n\n    this.eventHandlers = {};\n\n    // Map<{string} event_name, {boolean} postis_listener_added>\n    this.postisListeners = {};\n\n    this.numberOfParticipants = 1;\n    this._setupListeners();\n\n    id++;\n}\n\n/**\n * Executes command. The available commands are:\n * displayName - sets the display name of the local participant to the value\n * passed in the arguments array.\n * toggleAudio - mutes / unmutes audio with no arguments\n * toggleVideo - mutes / unmutes video with no arguments\n * filmStrip - hides / shows the film strip with no arguments\n * If the command doesn't require any arguments the parameter should be set\n * to empty array or it may be omitted.\n * @param name the name of the command\n * @param arguments array of arguments\n */\nJitsiMeetExternalAPI.prototype.executeCommand\n= function(name, ...argumentsList) {\n    if(!(name in commands)) {\n        logger.error(\"Not supported command name.\");\n        return;\n    }\n    sendMessage(this.postis, {method: commands[name], params: argumentsList});\n};\n\n/**\n * Executes commands. The available commands are:\n * displayName - sets the display name of the local participant to the value\n * passed in the arguments array.\n * toggleAudio - mutes / unmutes audio. no arguments\n * toggleVideo - mutes / unmutes video. no arguments\n * filmStrip - hides / shows the film strip. no arguments\n * toggleChat - hides / shows chat. no arguments.\n * toggleContactList - hides / shows contact list. no arguments.\n * toggleShareScreen - starts / stops screen sharing. no arguments.\n * @param object the object with commands to be executed. The keys of the\n * object are the commands that will be executed and the values are the\n * arguments for the command.\n */\nJitsiMeetExternalAPI.prototype.executeCommands = function(object) {\n    for(var key in object)\n        this.executeCommand(key, object[key]);\n};\n\n/**\n * Adds event listeners to Meet Jitsi. The object key should be the name of\n * the event and value - the listener.\n * Currently we support the following\n * events:\n * incomingMessage - receives event notifications about incoming\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"from\": from,//JID of the user that sent the message\n *  \"nick\": nick,//the nickname of the user that sent the message\n *  \"message\": txt//the text of the message\n * }}\n * outgoingMessage - receives event notifications about outgoing\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"message\": txt//the text of the message\n * }}\n * displayNameChanged - receives event notifications about display name\n * change. The listener will receive object with the following structure:\n * {{\n * jid: jid,//the JID of the participant that changed his display name\n * displayname: displayName //the new display name\n * }}\n * participantJoined - receives event notifications about new participant.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * participantLeft - receives event notifications about the participant that\n * left the room.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * video-conference-joined - receives event notifications about the local user\n * has successfully joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * video-conference-left - receives event notifications about the local user\n * has left the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * readyToClose - all hangup operations are completed and Jitsi Meet is ready\n * to be disposed.\n * @param object\n */\nJitsiMeetExternalAPI.prototype.addEventListeners = function(object) {\n    for(var i in object)\n        this.addEventListener(i, object[i]);\n};\n\n/**\n * Adds event listeners to Meet Jitsi. Currently we support the following\n * events:\n * incomingMessage - receives event notifications about incoming\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"from\": from,//JID of the user that sent the message\n *  \"nick\": nick,//the nickname of the user that sent the message\n *  \"message\": txt//the text of the message\n * }}\n * outgoingMessage - receives event notifications about outgoing\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"message\": txt//the text of the message\n * }}\n * displayNameChanged - receives event notifications about display name\n * change. The listener will receive object with the following structure:\n * {{\n * jid: jid,//the JID of the participant that changed his display name\n * displayname: displayName //the new display name\n * }}\n * participantJoined - receives event notifications about new participant.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * participantLeft - receives event notifications about participant the that\n * left the room.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * video-conference-joined - receives event notifications fired when the local\n * user has joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * video-conference-left - receives event notifications fired when the local\n * user has joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * @param event the name of the event\n * @param listener the listener\n */\nJitsiMeetExternalAPI.prototype.addEventListener = function(event, listener) {\n    if(!(event in events)) {\n        logger.error(\"Not supported event name.\");\n        return;\n    }\n    // We cannot remove listeners from postis that's why we are handling the\n    // callback that way.\n    if(!this.postisListeners[event]) {\n        this.postis.listen(events[event], function(data) {\n            if((event in this.eventHandlers) &&\n                typeof this.eventHandlers[event] === \"function\")\n                this.eventHandlers[event].call(null, data);\n        }.bind(this));\n        this.postisListeners[event] = true;\n    }\n    this.eventHandlers[event] = listener;\n};\n\n/**\n * Removes event listener.\n * @param event the name of the event.\n */\nJitsiMeetExternalAPI.prototype.removeEventListener = function(event) {\n    if(!(event in this.eventHandlers))\n    {\n        logger.error(\"The event \" + event + \" is not registered.\");\n        return;\n    }\n    delete this.eventHandlers[event];\n};\n\n/**\n * Removes event listeners.\n * @param events array with the names of the events.\n */\nJitsiMeetExternalAPI.prototype.removeEventListeners = function(events) {\n    for(var i = 0; i < events.length; i++)\n        this.removeEventListener(events[i]);\n};\n\n/**\n * Returns the number of participants in the conference.\n * NOTE: the local participant is included.\n * @returns {int} the number of participants in the conference.\n */\nJitsiMeetExternalAPI.prototype.getNumberOfParticipants = function() {\n    return this.numberOfParticipants;\n};\n\n/**\n * Setups listeners that are used internally for JitsiMeetExternalAPI.\n */\nJitsiMeetExternalAPI.prototype._setupListeners = function() {\n    this.postis.listen(\"participant-joined\",\n        changeParticipantNumber.bind(null, this, 1));\n    this.postis.listen(\"participant-left\",\n        changeParticipantNumber.bind(null, this, -1));\n};\n\n/**\n * Removes the listeners and removes the Jitsi Meet frame.\n */\nJitsiMeetExternalAPI.prototype.dispose = function() {\n    this.postis.destroy();\n    var frame = document.getElementById(this.frameName);\n    if(frame)\n        frame.src = 'about:blank';\n    var self = this;\n    window.setTimeout(function () {\n        self.iframeHolder.removeChild(self.frame);\n        self.iframeHolder.parentNode.removeChild(self.iframeHolder);\n    }, 10);\n};\n\nmodule.exports = JitsiMeetExternalAPI;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/API/external/external_api.js","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Ordered log levels.\n */\nvar levels = {\n    \"trace\": 0,\n    \"debug\": 1,\n    \"info\": 2,\n    \"log\": 3,\n    \"warn\": 4,\n    \"error\": 5\n};\n\n/**\n * The default transport - console\n * @type LoggerTransport\n */\nLogger.consoleTransport = console;\n\n/**\n * The array which stores currently registered global transports.\n * @type {[LoggerTransport]}\n */\nvar globalTransports = [ Logger.consoleTransport ];\n\n/**\n * Adds given {@link LoggerTransport} instance to the list of global\n * transports which means that it'll be used by all {@link Logger}s\n * @param {LoggerTransport} transport\n */\nLogger.addGlobalTransport = function(transport) {\n    if (globalTransports.indexOf(transport) === -1) {\n        globalTransports.push(transport);\n    }\n};\n\n/**\n * Removes given {@link LoggerTransport} instance from the list of global\n * transports\n * @param {LoggerTransport} transport\n */\nLogger.removeGlobalTransport = function(transport) {\n    var transportIdx = globalTransports.indexOf(transport);\n    if (transportIdx !== -1) {\n        globalTransports.splice(transportIdx, 1);\n    }\n};\n\n/**\n * Parses Error's object stack trace and extracts information about the last\n * caller before the log method was called.\n * @returns JS object with info about the caller - method name, file location,\n * line and column.\n */\nfunction getCallerInfo() {\n    var callerInfo = {\n        methodName: \"\",\n        fileLocation: \"\",\n        line: null,\n        column: null\n    };\n    //gets the part of the stack without the logger wrappers\n    var error = new Error();\n    var stack = error.stack? error.stack.split(\"\\n\") : [];\n    if(!stack || stack.length < 1) {\n        return callerInfo;\n    }\n    var m = null;\n    if(stack[3]) {\n        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n    }\n    if(!m || m.length <= 4) {\n        //Firefox && Safari\n        if(stack[2].indexOf(\"log@\") === 0){\n            //Safari\n            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n        } else {\n            //Firefox\n            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n        }\n        return callerInfo;\n    }\n\n    callerInfo.methodName = m[1];\n    callerInfo.fileLocation = m[2];\n    callerInfo.line = m[3];\n    callerInfo.column = m[4];\n    return callerInfo;\n}\n\n/**\n * Logs messages using the transports and level from the logger.\n * @param logger a logger instance.\n * @param level the log level of the message. See the levels variable.\n * @param arguments array with arguments that will be logged.\n */\nfunction log() {\n    var logger = arguments[0], level = arguments[1],\n        args = Array.prototype.slice.call(arguments, 2);\n    if(levels[level] < logger.level) {\n        return;\n    }\n\n    var callerInfo = getCallerInfo();\n    var transports = globalTransports.concat(logger.transports);\n    for(var i = 0; i < transports.length; i++) {\n        var t = transports[i];\n        var l = t[level];\n        if(l && typeof(l) === \"function\") {\n            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n                .apply(t, args);\n        }\n    }\n}\n\n/**\n *\n * Constructs new logger object.\n * @param level the logging level for the new logger\n * @param id optional identifier for the logger instance.\n * @param {LoggerTransport} transports optional list of handlers(objects) for\n * the logs. The handlers must support - log, warn, error, debug, info, trace.\n * @param format optional (NOT implemented) string.\n */\nfunction Logger(level, id, transports, format) {\n    this.id = id;\n    this.format = format;\n    this.transports = transports;\n    if(!this.transports) {\n        this.transports = [];\n    }\n    this.level = levels[level];\n    var methods = Object.keys(levels);\n    for(var i = 0; i < methods.length; i++){\n        this[methods[i]] =\n            log.bind(null, this, methods[i]);\n    }\n}\n\n/**\n * Sets the log level for the logger.\n * @param level the new log level.\n */\nLogger.prototype.setLevel = function (level) {\n    this.level = levels[level];\n};\nmodule.exports = Logger;\n\n/**\n * Enum for the supported log levels.\n */\nLogger.levels = {\n    TRACE: \"trace\",\n    DEBUG: \"debug\",\n    INFO: \"info\",\n    LOG: \"log\",\n    WARN: \"warn\",\n    ERROR: \"error\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/Logger.js\n// module id = 1\n// module chunks = 0","/* Copyright @ 2016 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require('./Logger.js');\n\n/**\n * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n * and thus can be added as global transport in order to capture all the logs.\n *\n * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n * a message and stores them in a queue in order to batch log entries. There are\n * time and size limit constraints which determine how often batch entries are\n * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n * will use the <tt>logStorage</tt> object given as an argument to save\n * the batch log entry.\n *\n * @param {Object} logStorage an object which allows to store the logs collected\n * @param {function(string|object[])} logStorage.storeLogs a method called when\n * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n * item is an object it means that it's an aggregated message. That is a message\n * which is the same as the previous one and it's representation has\n * the following format:\n * {\n *   {string} text: 'the text of some duplicated message'\n *   {number} count: 3 // how many times the message appeared in a row\n * }\n * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n * the sequence of \"A\". Which means that even if the next message \"C\" is\n * the same as \"A\" it will start a new aggregated message \"C\".\n * @param {function()} logStorage.isReady a method which should return\n * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n * time storage is not ready log batches will be cached and stored on the next\n * occasion (flush or interval timeout).\n *\n * @param {Object} options the <tt>LogCollector</tt> configuration options.\n * @param {number} options.maxEntryLength the size limit for a single log entry\n * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n * storage becomes ready. Note that the \"is ready\" condition is checked every\n * <tt>options.storeInterval</tt> milliseconds.\n * @param {number} options.storeInterval how often the logs should be stored in\n * case <tt>maxEntryLength</tt> was not exceeded.\n * @param {boolean} options.stringifyObjects indicates whether or not object\n * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n * message is composed. Note that objects logged on the error log level are\n * always stringified.\n *\n * @constructor\n */\nfunction LogCollector(logStorage, options) {\n    this.logStorage = logStorage;\n    this.stringifyObjects\n        = options && options.stringifyObjects\n            ? options.stringifyObjects : false;\n    this.storeInterval\n        = options && options.storeInterval\n            ? options.storeInterval: 30000;\n    this.maxEntryLength\n        = options && options.maxEntryLength\n            ? options.maxEntryLength : 10000;\n    // Bind the log method for each level to the corresponding method name\n    // in order to implement \"global log transport\" object.\n    Object.keys(Logger.levels).forEach(\n    function (logLevel) {\n        var methodName = Logger.levels[logLevel];\n        this[methodName] = function (logLevel) {\n            this._log.apply(this, arguments);\n        }.bind(this, logLevel);\n    }.bind(this));\n    /**\n     * The ID of store logs interval if one is currently scheduled or\n     * <tt>null</tt> otherwise.\n     * @type {number|null}\n     */\n    this.storeLogsIntervalID = null;\n    /**\n     * The log messages that are to be batched into log entry when\n     * {@link LogCollector._flush} method is called.\n     * @type {string[]}\n     */\n    this.queue = [];\n    /**\n     * The total length of all messages currently stored in the {@link queue}.\n     * @type {number}\n     */\n    this.totalLen = 0;\n    /**\n     * An array used to temporarily store log batches, before the storage gets\n     * ready.\n     * @type {string[]}\n     */\n    this.outputCache = [];\n}\n\n/**\n * Method called inside of {@link formatLogMessage} in order to covert an\n * <tt>Object</tt> argument to string. The conversion will happen when either\n * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n * log level. The default implementation uses <tt>JSON.stringify</tt> and\n * returns \"[object with circular refs?]\" instead of an object if it fails.\n *\n * @param {object} someObject the <tt>object</tt> to be stringified.\n *\n * @return {string} the result of <tt>JSON.stringify</tt> or\n * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n *\n * @protected\n */\nLogCollector.prototype.stringify = function (someObject) {\n    try {\n        return JSON.stringify(someObject);\n    } catch (error) {\n        return \"[object with circular refs?]\";\n    }\n};\n\n/**\n * Formats log entry for the given logging level and arguments passed to the\n * <tt>Logger</tt>'s log method. The first argument is log level and the next\n * arguments have to be captured using JS built-in 'arguments' variable.\n *\n * @param {Logger.levels} logLevel provides the logging level of the message to\n * be logged.\n *\n * @return {string|null} a non-empty string representation of the log entry\n * crafted from the log arguments. If the return value is <tt>null</tt> then\n * the message wil be discarded by this <tt>LogCollector</tt>.\n *\n * @protected\n */\nLogCollector.prototype.formatLogMessage\n= function (logLevel/*, arg1, arg2, arg3... */) {\n    var msg = '';\n    for (var i = 1, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        // objects logged on error level are always converted to JSON\n        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n            && typeof arg === 'object') {\n            arg = this.stringify(arg);\n        }\n        msg += arg;\n        if (i != len - 1) {\n            msg += ' ';\n        }\n    }\n    return msg.length ? msg : null;\n};\n\n/**\n * The log method bound to each of the logging levels in order to implement\n * \"global log transport\" object.\n *\n * @private\n */\nLogCollector.prototype._log = function() {\n\n    // var logLevel = arguments[0]; first argument is the log level\n    var msg = this.formatLogMessage.apply(this, arguments);\n    if (msg) {\n        // The same as the previous message aggregation logic\n        var prevMessage\n            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n        // NOTE that typeof undefined is 'undefined'\n        var prevMessageText\n            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n        // Is it the same as the previous one ?\n        if (prevMessageText == msg) {\n            if (typeof prevMessage === 'object') {\n                prevMessage.count += 1;\n            } else {\n                this.queue[this.queue.length-1] = {\n                    text: msg,\n                    count: 2\n                }\n            }\n        } else {\n            this.queue.push(msg);\n            this.totalLen += msg.length;\n        }\n    }\n\n    if (this.totalLen >= this.maxEntryLength) {\n        this._flush(true /* force */, true /* reschedule */);\n    }\n};\n\n/**\n * Starts periodical \"store logs\" task which will be triggered at the interval\n * specified in the constructor options.\n */\nLogCollector.prototype.start = function () {\n    this._reschedulePublishInterval();\n};\n\n/**\n * Reschedules the periodical \"store logs\" task which will store the next batch\n * log entry in the storage.\n * @private\n */\nLogCollector.prototype._reschedulePublishInterval = function () {\n    if (this.storeLogsIntervalID) {\n        window.clearTimeout(this.storeLogsIntervalID);\n        this.storeLogsIntervalID = null;\n    }\n    // It's actually a timeout, because it is rescheduled on every flush\n    this.storeLogsIntervalID\n        = window.setTimeout(\n            this._flush.bind(\n                this, false /* do not force */, true /* reschedule */),\n            this.storeInterval);\n};\n\n/**\n * Call this method to flush the log entry buffer and store it in the log\n * storage immediately (given that the storage is ready).\n */\nLogCollector.prototype.flush = function() {\n    this._flush(\n        false /* do not force, as it will not be stored anyway */,\n        true /* reschedule next update */ )\n};\n\n/**\n * Stores the next batch log entry in the log storage.\n * @param {boolean} force enforce current logs batch to be stored or cached if\n * there is anything to be logged, but the storage is not ready yet. One of\n * legitimate reasons to force is when the logs length exceeds size limit which\n * could result in truncation.\n * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n * task cycle.\n * @private\n */\nLogCollector.prototype._flush = function(force, reschedule) {\n    // Publish only if there's anything to be logged\n    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n        //FIXME avoid truncating\n        // right now we don't care if the message size is \"slightly\" exceeded\n        if (this.logStorage.isReady()) {\n            // Sends all cached logs\n            if (this.outputCache.length) {\n                this.outputCache.forEach(\n                    function (cachedQueue) {\n                        this.logStorage.storeLogs(cachedQueue);\n                    }.bind(this)\n                );\n                // Clear the cache\n                this.outputCache = [];\n            }\n            // Send current batch\n            this.logStorage.storeLogs(this.queue);\n        } else {\n            this.outputCache.push(this.queue);\n        }\n\n        this.queue = [];\n        this.totalLen = 0;\n    }\n\n    if (reschedule) {\n        this._reschedulePublishInterval();\n    }\n};\n\n/**\n * Stops the periodical \"store logs\" task and immediately stores any pending\n * log entries as a batch.\n */\nLogCollector.prototype.stop = function() {\n    // Flush and stop publishing logs\n    this._flush(false /* do not force */, false /* do not reschedule */);\n};\n\nmodule.exports = LogCollector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/LogCollector.js\n// module id = 2\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require(\"./Logger\");\nvar LogCollector = require(\"./LogCollector\");\n\n/**\n * Definition of the log method\n * @name log_method\n * @function\n * @param {...*} log_args the arguments to be logged\n */\n/**\n * The logger's transport type definition.\n *\n * @typedef {object} LoggerTransport\n *\n * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n */\n\n/**\n * Map with the created loggers with ID.\n */\nvar idLoggers = {};\n\n/**\n * Array with the loggers without id.\n */\nvar loggers = [];\n\n/**\n * Log level for the lbrary.\n */\nvar curLevel = Logger.levels.TRACE;\n\n\nmodule.exports = {\n    /**\n     * Adds given {@link LoggerTransport} instance to the list of global\n     * transports which means that it'll be used by all {@link Logger}s\n     * @param {LoggerTransport} transport\n     */\n    addGlobalTransport: function(transport) {\n        Logger.addGlobalTransport(transport);\n    },\n    /**\n     * Removes given {@link LoggerTransport} instance from the list of global\n     * transports\n     * @param {LoggerTransport} transport\n     */\n    removeGlobalTransport: function(transport) {\n        Logger.removeGlobalTransport(transport);\n    },\n    /**\n     * Creates new logger.\n     * @arguments the same as Logger constructor\n     */\n    getLogger: function(id, transports, format) {\n        var logger = new Logger(curLevel, id, transports, format);\n        if(id) {\n            idLoggers[id] = idLoggers[id] || [];\n            idLoggers[id].push(logger);\n        } else {\n            loggers.push(logger);\n        }\n        return logger;\n    },\n    /**\n     * Changes the log level for the existing loggers by id.\n     * @param level the new log level.\n     * @param id if specified the level will be changed only for loggers with the\n     * same id. Otherwise the operation will affect all loggers that don't\n     * have id.\n     */\n    setLogLevelById: function(level, id) {\n        var l = id? (idLoggers[id] || []) : loggers;\n        for(var i = 0; i < l.length; i++) {\n            l[i].setLevel(level);\n        }\n    },\n    /**\n     * Changes the log level for all existing loggers.\n     * @param level the new log level.\n     */\n    setLogLevel: function (level) {\n        curLevel = level;\n        var i = 0;\n        for(; i < loggers.length; i++) {\n            loggers[i].setLevel(level);\n        }\n\n        for(var id in idLoggers) {\n            var l = idLoggers[id] || [];\n            for(i = 0; i < l.length; i++) {\n                l[i].setLevel(level);\n            }\n        }\n    },\n    /**\n     * The supported log levels.\n     */\n    levels: Logger.levels,\n    /**\n     * Exports the <tt>LogCollector</tt>.\n     */\n    LogCollector: LogCollector\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/index.js\n// module id = 3\n// module chunks = 0","function Postis(options) {\n  var scope = options.scope;\n  var targetWindow = options.window;\n  var windowForEventListening = options.windowForEventListening || window;\n  var listeners = {};\n  var sendBuffer = [];\n  var listenBuffer = {};\n  var ready = false;\n  var readyMethod = \"__ready__\";\n  var readynessCheck;\n\n  var listener = function(event) {\n    var data;\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {\n      return;\n    }\n\n    if (data.postis && data.scope === scope) {\n      var listenersForMethod = listeners[data.method];\n      if (listenersForMethod) {\n        for (var i = 0; i < listenersForMethod.length; i++) {\n          listenersForMethod[i].call(null, data.params);\n        }\n      } else {\n        listenBuffer[data.method] = listenBuffer[data.method] || [];\n        listenBuffer[data.method].push(data.params);\n      }\n    }\n  };\n\n  windowForEventListening.addEventListener(\"message\", listener, false);\n\n  var postis = {\n    listen: function (method, callback) {\n      listeners[method] = listeners[method] || [];\n      listeners[method].push(callback);\n\n      var listenBufferForMethod = listenBuffer[method];\n      if (listenBufferForMethod) {\n        var listenersForMethod = listeners[method];\n        for (var i = 0; i < listenersForMethod.length; i++) {\n          for (var j = 0; j < listenBufferForMethod.length; j++) {\n            listenersForMethod[i].call(null, listenBufferForMethod[j]);\n          }\n        }\n      }\n      delete listenBuffer[method];\n    },\n\n    send: function (opts) {\n      var method = opts.method;\n\n      if ((ready || opts.method === readyMethod) && (targetWindow && typeof targetWindow.postMessage === \"function\")) {\n        targetWindow.postMessage(JSON.stringify({\n          postis: true,\n          scope: scope,\n          method: method,\n          params: opts.params\n        }), \"*\");\n      } else {\n        sendBuffer.push(opts);\n      }\n    },\n\n    ready: function (callback) {\n      if (ready) {\n        callback();\n      } else {\n        setTimeout(function () { postis.ready(callback); }, 50);\n      }\n    },\n\n    destroy: function (callback) {\n      clearInterval(readynessCheck);\n      ready = false;\n      if (windowForEventListening && typeof windowForEventListening.removeEventListener === \"function\") {\n        windowForEventListening.removeEventListener(\"message\", listener);\n      }\n      callback && callback();\n    }\n  };\n\n  var readyCheckID = +new Date() + Math.random() + \"\";\n\n  readynessCheck = setInterval(function () {\n    postis.send({\n      method: readyMethod,\n      params: readyCheckID\n    });\n  }, 50);\n\n  postis.listen(readyMethod, function (id) {\n    if (id === readyCheckID) {\n      clearInterval(readynessCheck);\n      ready = true;\n\n      for (var i = 0; i < sendBuffer.length; i++) {\n        postis.send(sendBuffer[i]);\n      }\n      sendBuffer = [];\n    } else {\n      postis.send({\n        method: readyMethod,\n        params: id\n      });\n    }\n  });\n\n  return postis;\n}\n\nmodule.exports = Postis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/postis/src/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}
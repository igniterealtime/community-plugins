/**
 * OfMeet API
 */
 
var ofmeet = (function(of)
{
	/*! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */

	!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.1",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+-new Date,v=a.document,w=0,x=0,y=gb(),z=gb(),A=gb(),B=function(a,b){return a===b&&(l=!0),0},C="undefined",D=1<<31,E={}.hasOwnProperty,F=[],G=F.pop,H=F.push,I=F.push,J=F.slice,K=F.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},L="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",N="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=N.replace("w","w#"),P="\\["+M+"*("+N+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+O+"))|)"+M+"*\\]",Q=":("+N+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+P+")*)|.*)\\)|)",R=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),S=new RegExp("^"+M+"*,"+M+"*"),T=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),V=new RegExp(Q),W=new RegExp("^"+O+"$"),X={ID:new RegExp("^#("+N+")"),CLASS:new RegExp("^\\.("+N+")"),TAG:new RegExp("^("+N.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+Q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+L+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{I.apply(F=J.call(v.childNodes),v.childNodes),F[v.childNodes.length].nodeType}catch(eb){I={apply:F.length?function(a,b){H.apply(a,J.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],!a||"string"!=typeof a)return d;if(1!==(k=b.nodeType)&&9!==k)return[];if(p&&!e){if(f=_.exec(a))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return I.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return I.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=9===k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+qb(o[l]);w=ab.test(a)&&ob(b.parentNode)||b,x=o.join(",")}if(x)try{return I.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function gb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function hb(a){return a[u]=!0,a}function ib(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function jb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function kb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||D)-(~a.sourceIndex||D);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function lb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function nb(a){return hb(function(b){return b=+b,hb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function ob(a){return a&&typeof a.getElementsByTagName!==C&&a}c=fb.support={},f=fb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fb.setDocument=function(a){var b,e=a?a.ownerDocument||a:v,g=e.defaultView;return e!==n&&9===e.nodeType&&e.documentElement?(n=e,o=e.documentElement,p=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){m()},!1):g.attachEvent&&g.attachEvent("onunload",function(){m()})),c.attributes=ib(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ib(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(e.getElementsByClassName)&&ib(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=ib(function(a){return o.appendChild(a).id=u,!e.getElementsByName||!e.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==C&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=typeof a.getAttributeNode!==C&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==C?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==C&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(e.querySelectorAll))&&(ib(function(a){a.innerHTML="<select msallowclip=''><option selected=''></option></select>",a.querySelectorAll("[msallowclip^='']").length&&q.push("[*^$]="+M+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+M+"*(?:value|"+L+")"),a.querySelectorAll(":checked").length||q.push(":checked")}),ib(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+M+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ib(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",Q)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===v&&t(v,a)?-1:b===e||b.ownerDocument===v&&t(v,b)?1:k?K.call(k,a)-K.call(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],i=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:k?K.call(k,a)-K.call(k,b):0;if(f===g)return kb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?kb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},e):n},fb.matches=function(a,b){return fb(a,null,null,b)},fb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fb(b,n,null,[a]).length>0},fb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&E.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fb.selectors={cacheLength:50,createPseudo:hb,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+M+")"+a+"("+M+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==C&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?hb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=K.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:hb(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?hb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:hb(function(a){return function(b){return fb(a,b).length>0}}),contains:hb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:hb(function(a){return W.test(a||"")||fb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:nb(function(){return[0]}),last:nb(function(a,b){return[b-1]}),eq:nb(function(a,b,c){return[0>c?c+b:c]}),even:nb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:nb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:nb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:nb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=lb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=mb(b);function pb(){}pb.prototype=d.filters=d.pseudos,d.setFilters=new pb,g=fb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fb.error(a):z(a,i).slice(0)};function qb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function rb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function sb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function tb(a,b,c){for(var d=0,e=b.length;e>d;d++)fb(a,b[d],c);return c}function ub(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function vb(a,b,c,d,e,f){return d&&!d[u]&&(d=vb(d)),e&&!e[u]&&(e=vb(e,f)),hb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||tb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ub(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ub(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?K.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ub(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):I.apply(g,r)})}function wb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=rb(function(a){return a===b},h,!0),l=rb(function(a){return K.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>i;i++)if(c=d.relative[a[i].type])m=[rb(sb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return vb(i>1&&sb(m),i>1&&qb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&wb(a.slice(i,e)),f>e&&wb(a=a.slice(e)),f>e&&qb(a))}m.push(c)}return sb(m)}function xb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=G.call(i));s=ub(s)}I.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&fb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?hb(f):f}return h=fb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xb(e,d)),f.selector=a}return f},i=fb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&ob(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qb(j),!a)return I.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&ob(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ib(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ib(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||jb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ib(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||jb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ib(function(a){return null==a.getAttribute("disabled")})||jb(L,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+Math.random()}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)
	},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
	},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec,fc,gc=/#.*$/,hc=/([?&])_=[^&]*/,ic=/^(.*?):[ \t]*([^\r\n]*)$/gm,jc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,kc=/^(?:GET|HEAD)$/,lc=/^\/\//,mc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,nc={},oc={},pc="*/".concat("*");try{fc=location.href}catch(qc){fc=l.createElement("a"),fc.href="",fc=fc.href}ec=mc.exec(fc.toLowerCase())||[];function rc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function sc(a,b,c,d){var e={},f=a===oc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function tc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function uc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function vc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:fc,type:"GET",isLocal:jc.test(ec[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":pc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?tc(tc(a,n.ajaxSettings),b):tc(n.ajaxSettings,a)},ajaxPrefilter:rc(nc),ajaxTransport:rc(oc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=ic.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||fc)+"").replace(gc,"").replace(lc,ec[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=mc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===ec[1]&&h[2]===ec[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(ec[3]||("http:"===ec[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),sc(nc,k,b,v),2===t)return v;i=k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!kc.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=hc.test(d)?d.replace(hc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+pc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=sc(oc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=uc(k,v,f)),u=vc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var wc=/%20/g,xc=/\[\]$/,yc=/\r?\n/g,zc=/^(?:submit|button|image|reset|file)$/i,Ac=/^(?:input|select|textarea|keygen)/i;function Bc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||xc.test(a)?d(a,e):Bc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Bc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Bc(c,a[c],b,e);return d.join("&").replace(wc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Ac.test(this.nodeName)&&!zc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(yc,"\r\n")}}):{name:b.name,value:c.replace(yc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Cc=0,Dc={},Ec={0:200,1223:204},Fc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Dc)Dc[a]()}),k.cors=!!Fc&&"withCredentials"in Fc,k.ajax=Fc=!!Fc,n.ajaxTransport(function(a){var b;return k.cors||Fc&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Cc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Dc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Ec[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Dc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Gc=[],Hc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Gc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Hc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Hc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Hc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Gc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Ic=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Ic)return Ic.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Jc=a.document.documentElement;function Kc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Kc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Jc;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Jc})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Kc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Lc=a.jQuery,Mc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Mc),b&&a.jQuery===n&&(a.jQuery=Lc),n},typeof b===U&&(a.jQuery=a.$=n),n});


	/*! jQuery UI - v1.10.4 - 2014-01-17
	* http://jqueryui.com
	* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.progressbar.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.slider.js, jquery.ui.sortable.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
	* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT 
	*/

	//! moment.js
	//! version : 2.10.3
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){"use strict";function a(){return Dc.apply(null,arguments)}function b(a){Dc=a}function c(a){return"[object Array]"===Object.prototype.toString.call(a)}function d(a){return a instanceof Date||"[object Date]"===Object.prototype.toString.call(a)}function e(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function f(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function g(a,b){for(var c in b)f(b,c)&&(a[c]=b[c]);return f(b,"toString")&&(a.toString=b.toString),f(b,"valueOf")&&(a.valueOf=b.valueOf),a}function h(a,b,c,d){return za(a,b,c,d,!0).utc()}function i(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function j(a){return null==a._pf&&(a._pf=i()),a._pf}function k(a){if(null==a._isValid){var b=j(a);a._isValid=!isNaN(a._d.getTime())&&b.overflow<0&&!b.empty&&!b.invalidMonth&&!b.nullInput&&!b.invalidFormat&&!b.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour)}return a._isValid}function l(a){var b=h(0/0);return null!=a?g(j(b),a):j(b).userInvalidated=!0,b}function m(a,b){var c,d,e;if("undefined"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),"undefined"!=typeof b._i&&(a._i=b._i),"undefined"!=typeof b._f&&(a._f=b._f),"undefined"!=typeof b._l&&(a._l=b._l),"undefined"!=typeof b._strict&&(a._strict=b._strict),"undefined"!=typeof b._tzm&&(a._tzm=b._tzm),"undefined"!=typeof b._isUTC&&(a._isUTC=b._isUTC),"undefined"!=typeof b._offset&&(a._offset=b._offset),"undefined"!=typeof b._pf&&(a._pf=j(b)),"undefined"!=typeof b._locale&&(a._locale=b._locale),Fc.length>0)for(c in Fc)d=Fc[c],e=b[d],"undefined"!=typeof e&&(a[d]=e);return a}function n(b){m(this,b),this._d=new Date(+b._d),Gc===!1&&(Gc=!0,a.updateOffset(this),Gc=!1)}function o(a){return a instanceof n||null!=a&&null!=a._isAMomentObject}function p(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function q(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&p(a[d])!==p(b[d]))&&g++;return g+f}function r(){}function s(a){return a?a.toLowerCase().replace("_","-"):a}function t(a){for(var b,c,d,e,f=0;f<a.length;){for(e=s(a[f]).split("-"),b=e.length,c=s(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=u(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&q(e,c,!0)>=b-1)break;b--}f++}return null}function u(a){var b=null;if(!Hc[a]&&"undefined"!=typeof module&&module&&module.exports)try{b=Ec._abbr,require("./locale/"+a),v(b)}catch(c){}return Hc[a]}function v(a,b){var c;return a&&(c="undefined"==typeof b?x(a):w(a,b),c&&(Ec=c)),Ec._abbr}function w(a,b){return null!==b?(b.abbr=a,Hc[a]||(Hc[a]=new r),Hc[a].set(b),v(a),Hc[a]):(delete Hc[a],null)}function x(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return Ec;if(!c(a)){if(b=u(a))return b;a=[a]}return t(a)}function y(a,b){var c=a.toLowerCase();Ic[c]=Ic[c+"s"]=Ic[b]=a}function z(a){return"string"==typeof a?Ic[a]||Ic[a.toLowerCase()]:void 0}function A(a){var b,c,d={};for(c in a)f(a,c)&&(b=z(c),b&&(d[b]=a[c]));return d}function B(b,c){return function(d){return null!=d?(D(this,b,d),a.updateOffset(this,c),this):C(this,b)}}function C(a,b){return a._d["get"+(a._isUTC?"UTC":"")+b]()}function D(a,b,c){return a._d["set"+(a._isUTC?"UTC":"")+b](c)}function E(a,b){var c;if("object"==typeof a)for(c in a)this.set(c,a[c]);else if(a=z(a),"function"==typeof this[a])return this[a](b);return this}function F(a,b,c){for(var d=""+Math.abs(a),e=a>=0;d.length<b;)d="0"+d;return(e?c?"+":"":"-")+d}function G(a,b,c,d){var e=d;"string"==typeof d&&(e=function(){return this[d]()}),a&&(Mc[a]=e),b&&(Mc[b[0]]=function(){return F(e.apply(this,arguments),b[1],b[2])}),c&&(Mc[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function H(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function I(a){var b,c,d=a.match(Jc);for(b=0,c=d.length;c>b;b++)Mc[d[b]]?d[b]=Mc[d[b]]:d[b]=H(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function J(a,b){return a.isValid()?(b=K(b,a.localeData()),Lc[b]||(Lc[b]=I(b)),Lc[b](a)):a.localeData().invalidDate()}function K(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Kc.lastIndex=0;d>=0&&Kc.test(a);)a=a.replace(Kc,c),Kc.lastIndex=0,d-=1;return a}function L(a,b,c){_c[a]="function"==typeof b?b:function(a){return a&&c?c:b}}function M(a,b){return f(_c,a)?_c[a](b._strict,b._locale):new RegExp(N(a))}function N(a){return a.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e}).replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function O(a,b){var c,d=b;for("string"==typeof a&&(a=[a]),"number"==typeof b&&(d=function(a,c){c[b]=p(a)}),c=0;c<a.length;c++)ad[a[c]]=d}function P(a,b){O(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function Q(a,b,c){null!=b&&f(ad,a)&&ad[a](b,c._a,c,a)}function R(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function S(a){return this._months[a.month()]}function T(a){return this._monthsShort[a.month()]}function U(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=h([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}function V(a,b){var c;return"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),R(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a)}function W(b){return null!=b?(V(this,b),a.updateOffset(this,!0),this):C(this,"Month")}function X(){return R(this.year(),this.month())}function Y(a){var b,c=a._a;return c&&-2===j(a).overflow&&(b=c[cd]<0||c[cd]>11?cd:c[dd]<1||c[dd]>R(c[bd],c[cd])?dd:c[ed]<0||c[ed]>24||24===c[ed]&&(0!==c[fd]||0!==c[gd]||0!==c[hd])?ed:c[fd]<0||c[fd]>59?fd:c[gd]<0||c[gd]>59?gd:c[hd]<0||c[hd]>999?hd:-1,j(a)._overflowDayOfYear&&(bd>b||b>dd)&&(b=dd),j(a).overflow=b),a}function Z(b){a.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+b)}function $(a,b){var c=!0,d=a+"\n"+(new Error).stack;return g(function(){return c&&(Z(d),c=!1),b.apply(this,arguments)},b)}function _(a,b){kd[a]||(Z(b),kd[a]=!0)}function aa(a){var b,c,d=a._i,e=ld.exec(d);if(e){for(j(a).iso=!0,b=0,c=md.length;c>b;b++)if(md[b][1].exec(d)){a._f=md[b][0]+(e[6]||" ");break}for(b=0,c=nd.length;c>b;b++)if(nd[b][1].exec(d)){a._f+=nd[b][0];break}d.match(Yc)&&(a._f+="Z"),ta(a)}else a._isValid=!1}function ba(b){var c=od.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(aa(b),void(b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b))))}function ca(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function da(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function ea(a){return fa(a)?366:365}function fa(a){return a%4===0&&a%100!==0||a%400===0}function ga(){return fa(this.year())}function ha(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=Aa(a).add(f,"d"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function ia(a){return ha(a,this._week.dow,this._week.doy).week}function ja(){return this._week.dow}function ka(){return this._week.doy}function la(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")}function ma(a){var b=ha(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")}function na(a,b,c,d,e){var f,g,h=da(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:ea(a-1)+g}}function oa(a){var b=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")}function pa(a,b,c){return null!=a?a:null!=b?b:c}function qa(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function ra(a){var b,c,d,e,f=[];if(!a._d){for(d=qa(a),a._w&&null==a._a[dd]&&null==a._a[cd]&&sa(a),a._dayOfYear&&(e=pa(a._a[bd],d[bd]),a._dayOfYear>ea(e)&&(j(a)._overflowDayOfYear=!0),c=da(e,0,a._dayOfYear),a._a[cd]=c.getUTCMonth(),a._a[dd]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=f[b]=d[b];for(;7>b;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];24===a._a[ed]&&0===a._a[fd]&&0===a._a[gd]&&0===a._a[hd]&&(a._nextDay=!0,a._a[ed]=0),a._d=(a._useUTC?da:ca).apply(null,f),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[ed]=24)}}function sa(a){var b,c,d,e,f,g,h;b=a._w,null!=b.GG||null!=b.W||null!=b.E?(f=1,g=4,c=pa(b.GG,a._a[bd],ha(Aa(),1,4).year),d=pa(b.W,1),e=pa(b.E,1)):(f=a._locale._week.dow,g=a._locale._week.doy,c=pa(b.gg,a._a[bd],ha(Aa(),f,g).year),d=pa(b.w,1),null!=b.d?(e=b.d,f>e&&++d):e=null!=b.e?b.e+f:f),h=na(c,d,e,g,f),a._a[bd]=h.year,a._dayOfYear=h.dayOfYear}function ta(b){if(b._f===a.ISO_8601)return void aa(b);b._a=[],j(b).empty=!0;var c,d,e,f,g,h=""+b._i,i=h.length,k=0;for(e=K(b._f,b._locale).match(Jc)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(M(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&j(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),k+=d.length),Mc[f]?(d?j(b).empty=!1:j(b).unusedTokens.push(f),Q(f,d,b)):b._strict&&!d&&j(b).unusedTokens.push(f);j(b).charsLeftOver=i-k,h.length>0&&j(b).unusedInput.push(h),j(b).bigHour===!0&&b._a[ed]<=12&&b._a[ed]>0&&(j(b).bigHour=void 0),b._a[ed]=ua(b._locale,b._a[ed],b._meridiem),ra(b),Y(b)}function ua(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function va(a){var b,c,d,e,f;if(0===a._f.length)return j(a).invalidFormat=!0,void(a._d=new Date(0/0));for(e=0;e<a._f.length;e++)f=0,b=m({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],ta(b),k(b)&&(f+=j(b).charsLeftOver,f+=10*j(b).unusedTokens.length,j(b).score=f,(null==d||d>f)&&(d=f,c=b));g(a,c||b)}function wa(a){if(!a._d){var b=A(a._i);a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],ra(a)}}function xa(a){var b,e=a._i,f=a._f;return a._locale=a._locale||x(a._l),null===e||void 0===f&&""===e?l({nullInput:!0}):("string"==typeof e&&(a._i=e=a._locale.preparse(e)),o(e)?new n(Y(e)):(c(f)?va(a):f?ta(a):d(e)?a._d=e:ya(a),b=new n(Y(a)),b._nextDay&&(b.add(1,"d"),b._nextDay=void 0),b))}function ya(b){var f=b._i;void 0===f?b._d=new Date:d(f)?b._d=new Date(+f):"string"==typeof f?ba(b):c(f)?(b._a=e(f.slice(0),function(a){return parseInt(a,10)}),ra(b)):"object"==typeof f?wa(b):"number"==typeof f?b._d=new Date(f):a.createFromInputFallback(b)}function za(a,b,c,d,e){var f={};return"boolean"==typeof c&&(d=c,c=void 0),f._isAMomentObject=!0,f._useUTC=f._isUTC=e,f._l=c,f._i=a,f._f=b,f._strict=d,xa(f)}function Aa(a,b,c,d){return za(a,b,c,d,!1)}function Ba(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return Aa();for(d=b[0],e=1;e<b.length;++e)b[e][a](d)&&(d=b[e]);return d}function Ca(){var a=[].slice.call(arguments,0);return Ba("isBefore",a)}function Da(){var a=[].slice.call(arguments,0);return Ba("isAfter",a)}function Ea(a){var b=A(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=x(),this._bubble()}function Fa(a){return a instanceof Ea}function Ga(a,b){G(a,0,0,function(){var a=this.utcOffset(),c="+";return 0>a&&(a=-a,c="-"),c+F(~~(a/60),2)+b+F(~~a%60,2)})}function Ha(a){var b=(a||"").match(Yc)||[],c=b[b.length-1]||[],d=(c+"").match(td)||["-",0,0],e=+(60*d[1])+p(d[2]);return"+"===d[0]?e:-e}function Ia(b,c){var e,f;return c._isUTC?(e=c.clone(),f=(o(b)||d(b)?+b:+Aa(b))-+e,e._d.setTime(+e._d+f),a.updateOffset(e,!1),e):Aa(b).local();return c._isUTC?Aa(b).zone(c._offset||0):Aa(b).local()}function Ja(a){return 15*-Math.round(a._d.getTimezoneOffset()/15)}function Ka(b,c){var d,e=this._offset||0;return null!=b?("string"==typeof b&&(b=Ha(b)),Math.abs(b)<16&&(b=60*b),!this._isUTC&&c&&(d=Ja(this)),this._offset=b,this._isUTC=!0,null!=d&&this.add(d,"m"),e!==b&&(!c||this._changeInProgress?$a(this,Va(b-e,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?e:Ja(this)}function La(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Ma(a){return this.utcOffset(0,a)}function Na(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Ja(this),"m")),this}function Oa(){return this._tzm?this.utcOffset(this._tzm):"string"==typeof this._i&&this.utcOffset(Ha(this._i)),this}function Pa(a){return a=a?Aa(a).utcOffset():0,(this.utcOffset()-a)%60===0}function Qa(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Ra(){if(this._a){var a=this._isUTC?h(this._a):Aa(this._a);return this.isValid()&&q(this._a,a.toArray())>0}return!1}function Sa(){return!this._isUTC}function Ta(){return this._isUTC}function Ua(){return this._isUTC&&0===this._offset}function Va(a,b){var c,d,e,g=a,h=null;return Fa(a)?g={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(g={},b?g[b]=a:g.milliseconds=a):(h=ud.exec(a))?(c="-"===h[1]?-1:1,g={y:0,d:p(h[dd])*c,h:p(h[ed])*c,m:p(h[fd])*c,s:p(h[gd])*c,ms:p(h[hd])*c}):(h=vd.exec(a))?(c="-"===h[1]?-1:1,g={y:Wa(h[2],c),M:Wa(h[3],c),d:Wa(h[4],c),h:Wa(h[5],c),m:Wa(h[6],c),s:Wa(h[7],c),w:Wa(h[8],c)}):null==g?g={}:"object"==typeof g&&("from"in g||"to"in g)&&(e=Ya(Aa(g.from),Aa(g.to)),g={},g.ms=e.milliseconds,g.M=e.months),d=new Ea(g),Fa(a)&&f(a,"_locale")&&(d._locale=a._locale),d}function Wa(a,b){var c=a&&parseFloat(a.replace(",","."));return(isNaN(c)?0:c)*b}function Xa(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function Ya(a,b){var c;return b=Ia(b,a),a.isBefore(b)?c=Xa(a,b):(c=Xa(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function Za(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(_(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=Va(c,d),$a(this,e,a),this}}function $a(b,c,d,e){var f=c._milliseconds,g=c._days,h=c._months;e=null==e?!0:e,f&&b._d.setTime(+b._d+f*d),g&&D(b,"Date",C(b,"Date")+g*d),h&&V(b,C(b,"Month")+h*d),e&&a.updateOffset(b,g||h)}function _a(a){var b=a||Aa(),c=Ia(b,this).startOf("day"),d=this.diff(c,"days",!0),e=-6>d?"sameElse":-1>d?"lastWeek":0>d?"lastDay":1>d?"sameDay":2>d?"nextDay":7>d?"nextWeek":"sameElse";return this.format(this.localeData().calendar(e,this,Aa(b)))}function ab(){return new n(this)}function bb(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=o(a)?a:Aa(a),+this>+a):(c=o(a)?+a:+Aa(a),c<+this.clone().startOf(b))}function cb(a,b){var c;return b=z("undefined"!=typeof b?b:"millisecond"),"millisecond"===b?(a=o(a)?a:Aa(a),+a>+this):(c=o(a)?+a:+Aa(a),+this.clone().endOf(b)<c)}function db(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)}function eb(a,b){var c;return b=z(b||"millisecond"),"millisecond"===b?(a=o(a)?a:Aa(a),+this===+a):(c=+Aa(a),+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))}function fb(a){return 0>a?Math.ceil(a):Math.floor(a)}function gb(a,b,c){var d,e,f=Ia(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=z(b),"year"===b||"month"===b||"quarter"===b?(e=hb(this,f),"quarter"===b?e/=3:"year"===b&&(e/=12)):(d=this-f,e="second"===b?d/1e3:"minute"===b?d/6e4:"hour"===b?d/36e5:"day"===b?(d-g)/864e5:"week"===b?(d-g)/6048e5:d),c?e:fb(e)}function hb(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,"months");return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)}function ib(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function jb(){var a=this.clone().utc();return 0<a.year()&&a.year()<=9999?"function"==typeof Date.prototype.toISOString?this.toDate().toISOString():J(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):J(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}function kb(b){var c=J(this,b||a.defaultFormat);return this.localeData().postformat(c)}function lb(a,b){return this.isValid()?Va({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function mb(a){return this.from(Aa(),a)}function nb(a,b){return this.isValid()?Va({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function ob(a){return this.to(Aa(),a)}function pb(a){var b;return void 0===a?this._locale._abbr:(b=x(a),null!=b&&(this._locale=b),this)}function qb(){return this._locale}function rb(a){switch(a=z(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a&&this.weekday(0),"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this}function sb(a){return a=z(a),void 0===a||"millisecond"===a?this:this.startOf(a).add(1,"isoWeek"===a?"week":a).subtract(1,"ms")}function tb(){return+this._d-6e4*(this._offset||0)}function ub(){return Math.floor(+this/1e3)}function vb(){return this._offset?new Date(+this):this._d}function wb(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function xb(){return k(this)}function yb(){return g({},j(this))}function zb(){return j(this).overflow}function Ab(a,b){G(0,[a,a.length],0,b)}function Bb(a,b,c){return ha(Aa([a,11,31+b-c]),b,c).week}function Cb(a){var b=ha(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,"y")}function Db(a){var b=ha(this,1,4).year;return null==a?b:this.add(a-b,"y")}function Eb(){return Bb(this.year(),1,4)}function Fb(){var a=this.localeData()._week;return Bb(this.year(),a.dow,a.doy)}function Gb(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}function Hb(a,b){if("string"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),"number"!=typeof a)return null}else a=parseInt(a,10);return a}function Ib(a){return this._weekdays[a.day()]}function Jb(a){return this._weekdaysShort[a.day()]}function Kb(a){return this._weekdaysMin[a.day()]}function Lb(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=Aa([2e3,1]).day(b),d="^"+this.weekdays(c,"")+"|^"+this.weekdaysShort(c,"")+"|^"+this.weekdaysMin(c,""),this._weekdaysParse[b]=new RegExp(d.replace(".",""),"i")),this._weekdaysParse[b].test(a))return b}function Mb(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Hb(a,this.localeData()),this.add(a-b,"d")):b}function Nb(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")}function Ob(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)}function Pb(a,b){G(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}function Qb(a,b){return b._meridiemParse}function Rb(a){return"p"===(a+"").toLowerCase().charAt(0)}function Sb(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"}function Tb(a){G(0,[a,3],0,"millisecond")}function Ub(){return this._isUTC?"UTC":""}function Vb(){return this._isUTC?"Coordinated Universal Time":""}function Wb(a){return Aa(1e3*a)}function Xb(){return Aa.apply(null,arguments).parseZone()}function Yb(a,b,c){var d=this._calendar[a];return"function"==typeof d?d.call(b,c):d}function Zb(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b}function $b(){return this._invalidDate}function _b(a){return this._ordinal.replace("%d",a)}function ac(a){return a}function bc(a,b,c,d){var e=this._relativeTime[c];return"function"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)}function cc(a,b){var c=this._relativeTime[a>0?"future":"past"];return"function"==typeof c?c(b):c.replace(/%s/i,b)}function dc(a){var b,c;for(c in a)b=a[c],"function"==typeof b?this[c]=b:this["_"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function ec(a,b,c,d){var e=x(),f=h().set(d,b);return e[c](f,a)}function fc(a,b,c,d,e){if("number"==typeof a&&(b=a,a=void 0),a=a||"",null!=b)return ec(a,b,c,e);var f,g=[];for(f=0;d>f;f++)g[f]=ec(a,f,c,e);return g}function gc(a,b){return fc(a,b,"months",12,"month")}function hc(a,b){return fc(a,b,"monthsShort",12,"month")}function ic(a,b){return fc(a,b,"weekdays",7,"day")}function jc(a,b){return fc(a,b,"weekdaysShort",7,"day")}function kc(a,b){return fc(a,b,"weekdaysMin",7,"day")}function lc(){var a=this._data;return this._milliseconds=Rd(this._milliseconds),this._days=Rd(this._days),this._months=Rd(this._months),a.milliseconds=Rd(a.milliseconds),a.seconds=Rd(a.seconds),a.minutes=Rd(a.minutes),a.hours=Rd(a.hours),a.months=Rd(a.months),a.years=Rd(a.years),this}function mc(a,b,c,d){var e=Va(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}function nc(a,b){return mc(this,a,b,1)}function oc(a,b){return mc(this,a,b,-1)}function pc(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;return g.milliseconds=d%1e3,a=fb(d/1e3),g.seconds=a%60,b=fb(a/60),g.minutes=b%60,c=fb(b/60),g.hours=c%24,e+=fb(c/24),h=fb(qc(e)),e-=fb(rc(h)),f+=fb(e/30),e%=30,h+=fb(f/12),f%=12,g.days=e,g.months=f,g.years=h,this}function qc(a){return 400*a/146097}function rc(a){return 146097*a/400}function sc(a){var b,c,d=this._milliseconds;if(a=z(a),"month"===a||"year"===a)return b=this._days+d/864e5,c=this._months+12*qc(b),"month"===a?c:c/12;switch(b=this._days+Math.round(rc(this._months/12)),a){case"week":return b/7+d/6048e5;case"day":return b+d/864e5;case"hour":return 24*b+d/36e5;case"minute":return 1440*b+d/6e4;case"second":return 86400*b+d/1e3;case"millisecond":return Math.floor(864e5*b)+d;default:throw new Error("Unknown unit "+a)}}function tc(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*p(this._months/12)}function uc(a){return function(){return this.as(a)}}function vc(a){return a=z(a),this[a+"s"]()}function wc(a){return function(){return this._data[a]}}function xc(){return fb(this.days()/7)}function yc(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function zc(a,b,c){var d=Va(a).abs(),e=fe(d.as("s")),f=fe(d.as("m")),g=fe(d.as("h")),h=fe(d.as("d")),i=fe(d.as("M")),j=fe(d.as("y")),k=e<ge.s&&["s",e]||1===f&&["m"]||f<ge.m&&["mm",f]||1===g&&["h"]||g<ge.h&&["hh",g]||1===h&&["d"]||h<ge.d&&["dd",h]||1===i&&["M"]||i<ge.M&&["MM",i]||1===j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,yc.apply(null,k)}function Ac(a,b){return void 0===ge[a]?!1:void 0===b?ge[a]:(ge[a]=b,!0)}function Bc(a){var b=this.localeData(),c=zc(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function Cc(){var a=he(this.years()),b=he(this.months()),c=he(this.days()),d=he(this.hours()),e=he(this.minutes()),f=he(this.seconds()+this.milliseconds()/1e3),g=this.asSeconds();return g?(0>g?"-":"")+"P"+(a?a+"Y":"")+(b?b+"M":"")+(c?c+"D":"")+(d||e||f?"T":"")+(d?d+"H":"")+(e?e+"M":"")+(f?f+"S":""):"P0D"}var Dc,Ec,Fc=a.momentProperties=[],Gc=!1,Hc={},Ic={},Jc=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,Kc=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Lc={},Mc={},Nc=/\d/,Oc=/\d\d/,Pc=/\d{3}/,Qc=/\d{4}/,Rc=/[+-]?\d{6}/,Sc=/\d\d?/,Tc=/\d{1,3}/,Uc=/\d{1,4}/,Vc=/[+-]?\d{1,6}/,Wc=/\d+/,Xc=/[+-]?\d+/,Yc=/Z|[+-]\d\d:?\d\d/gi,Zc=/[+-]?\d+(\.\d{1,3})?/,$c=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,_c={},ad={},bd=0,cd=1,dd=2,ed=3,fd=4,gd=5,hd=6;G("M",["MM",2],"Mo",function(){return this.month()+1}),G("MMM",0,0,function(a){return this.localeData().monthsShort(this,a)}),G("MMMM",0,0,function(a){return this.localeData().months(this,a)}),y("month","M"),L("M",Sc),L("MM",Sc,Oc),L("MMM",$c),L("MMMM",$c),O(["M","MM"],function(a,b){b[cd]=p(a)-1}),O(["MMM","MMMM"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[cd]=e:j(c).invalidMonth=a});var id="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),jd="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),kd={};a.suppressDeprecationWarnings=!1;var ld=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,md=[["YYYYYY-MM-DD",/[+-]\d{6}-\d{2}-\d{2}/],["YYYY-MM-DD",/\d{4}-\d{2}-\d{2}/],["GGGG-[W]WW-E",/\d{4}-W\d{2}-\d/],["GGGG-[W]WW",/\d{4}-W\d{2}/],["YYYY-DDD",/\d{4}-\d{3}/]],nd=[["HH:mm:ss.SSSS",/(T| )\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss",/(T| )\d\d:\d\d:\d\d/],["HH:mm",/(T| )\d\d:\d\d/],["HH",/(T| )\d\d/]],od=/^\/?Date\((\-?\d+)/i;a.createFromInputFallback=$("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),G(0,["YY",2],0,function(){return this.year()%100}),G(0,["YYYY",4],0,"year"),G(0,["YYYYY",5],0,"year"),G(0,["YYYYYY",6,!0],0,"year"),y("year","y"),L("Y",Xc),L("YY",Sc,Oc),L("YYYY",Uc,Qc),L("YYYYY",Vc,Rc),L("YYYYYY",Vc,Rc),O(["YYYY","YYYYY","YYYYYY"],bd),O("YY",function(b,c){c[bd]=a.parseTwoDigitYear(b)}),a.parseTwoDigitYear=function(a){return p(a)+(p(a)>68?1900:2e3)};var pd=B("FullYear",!1);G("w",["ww",2],"wo","week"),G("W",["WW",2],"Wo","isoWeek"),y("week","w"),y("isoWeek","W"),L("w",Sc),L("ww",Sc,Oc),L("W",Sc),L("WW",Sc,Oc),P(["w","ww","W","WW"],function(a,b,c,d){b[d.substr(0,1)]=p(a)});var qd={dow:0,doy:6};G("DDD",["DDDD",3],"DDDo","dayOfYear"),y("dayOfYear","DDD"),L("DDD",Tc),L("DDDD",Pc),O(["DDD","DDDD"],function(a,b,c){c._dayOfYear=p(a)}),a.ISO_8601=function(){};var rd=$("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(){var a=Aa.apply(null,arguments);return this>a?this:a}),sd=$("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(){var a=Aa.apply(null,arguments);return a>this?this:a});Ga("Z",":"),Ga("ZZ",""),L("Z",Yc),L("ZZ",Yc),O(["Z","ZZ"],function(a,b,c){c._useUTC=!0,c._tzm=Ha(a)});var td=/([\+\-]|\d\d)/gi;a.updateOffset=function(){};var ud=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,vd=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;Va.fn=Ea.prototype;var wd=Za(1,"add"),xd=Za(-1,"subtract");a.defaultFormat="YYYY-MM-DDTHH:mm:ssZ";var yd=$("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(a){return void 0===a?this.localeData():this.locale(a)});G(0,["gg",2],0,function(){return this.weekYear()%100}),G(0,["GG",2],0,function(){return this.isoWeekYear()%100}),Ab("gggg","weekYear"),Ab("ggggg","weekYear"),Ab("GGGG","isoWeekYear"),Ab("GGGGG","isoWeekYear"),y("weekYear","gg"),y("isoWeekYear","GG"),L("G",Xc),L("g",Xc),L("GG",Sc,Oc),L("gg",Sc,Oc),L("GGGG",Uc,Qc),L("gggg",Uc,Qc),L("GGGGG",Vc,Rc),L("ggggg",Vc,Rc),P(["gggg","ggggg","GGGG","GGGGG"],function(a,b,c,d){b[d.substr(0,2)]=p(a)}),P(["gg","GG"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),G("Q",0,0,"quarter"),y("quarter","Q"),L("Q",Nc),O("Q",function(a,b){b[cd]=3*(p(a)-1)}),G("D",["DD",2],"Do","date"),y("date","D"),L("D",Sc),L("DD",Sc,Oc),L("Do",function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),O(["D","DD"],dd),O("Do",function(a,b){b[dd]=p(a.match(Sc)[0],10)});var zd=B("Date",!0);G("d",0,"do","day"),G("dd",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),G("ddd",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),G("dddd",0,0,function(a){return this.localeData().weekdays(this,a)}),G("e",0,0,"weekday"),G("E",0,0,"isoWeekday"),y("day","d"),y("weekday","e"),y("isoWeekday","E"),L("d",Sc),L("e",Sc),L("E",Sc),L("dd",$c),L("ddd",$c),L("dddd",$c),P(["dd","ddd","dddd"],function(a,b,c){var d=c._locale.weekdaysParse(a);null!=d?b.d=d:j(c).invalidWeekday=a}),P(["d","e","E"],function(a,b,c,d){b[d]=p(a)});var Ad="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Bd="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Cd="Su_Mo_Tu_We_Th_Fr_Sa".split("_");G("H",["HH",2],0,"hour"),G("h",["hh",2],0,function(){return this.hours()%12||12}),Pb("a",!0),Pb("A",!1),y("hour","h"),L("a",Qb),L("A",Qb),L("H",Sc),L("h",Sc),L("HH",Sc,Oc),L("hh",Sc,Oc),O(["H","HH"],ed),O(["a","A"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),O(["h","hh"],function(a,b,c){b[ed]=p(a),j(c).bigHour=!0});var Dd=/[ap]\.?m?\.?/i,Ed=B("Hours",!0);G("m",["mm",2],0,"minute"),y("minute","m"),L("m",Sc),L("mm",Sc,Oc),O(["m","mm"],fd);var Fd=B("Minutes",!1);G("s",["ss",2],0,"second"),y("second","s"),L("s",Sc),L("ss",Sc,Oc),O(["s","ss"],gd);var Gd=B("Seconds",!1);G("S",0,0,function(){return~~(this.millisecond()/100)}),G(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),Tb("SSS"),Tb("SSSS"),y("millisecond","ms"),L("S",Tc,Nc),L("SS",Tc,Oc),L("SSS",Tc,Pc),L("SSSS",Wc),O(["S","SS","SSS","SSSS"],function(a,b){b[hd]=p(1e3*("0."+a))});var Hd=B("Milliseconds",!1);G("z",0,0,"zoneAbbr"),G("zz",0,0,"zoneName");var Id=n.prototype;Id.add=wd,Id.calendar=_a,Id.clone=ab,Id.diff=gb,Id.endOf=sb,Id.format=kb,Id.from=lb,Id.fromNow=mb,Id.to=nb,Id.toNow=ob,Id.get=E,Id.invalidAt=zb,Id.isAfter=bb,Id.isBefore=cb,Id.isBetween=db,Id.isSame=eb,Id.isValid=xb,Id.lang=yd,Id.locale=pb,Id.localeData=qb,Id.max=sd,Id.min=rd,Id.parsingFlags=yb,Id.set=E,Id.startOf=rb,Id.subtract=xd,Id.toArray=wb,Id.toDate=vb,Id.toISOString=jb,Id.toJSON=jb,Id.toString=ib,Id.unix=ub,Id.valueOf=tb,Id.year=pd,Id.isLeapYear=ga,Id.weekYear=Cb,Id.isoWeekYear=Db,Id.quarter=Id.quarters=Gb,Id.month=W,Id.daysInMonth=X,Id.week=Id.weeks=la,Id.isoWeek=Id.isoWeeks=ma,Id.weeksInYear=Fb,Id.isoWeeksInYear=Eb,Id.date=zd,Id.day=Id.days=Mb,Id.weekday=Nb,Id.isoWeekday=Ob,Id.dayOfYear=oa,Id.hour=Id.hours=Ed,Id.minute=Id.minutes=Fd,Id.second=Id.seconds=Gd,Id.millisecond=Id.milliseconds=Hd,Id.utcOffset=Ka,Id.utc=Ma,Id.local=Na,Id.parseZone=Oa,Id.hasAlignedHourOffset=Pa,Id.isDST=Qa,Id.isDSTShifted=Ra,Id.isLocal=Sa,Id.isUtcOffset=Ta,Id.isUtc=Ua,Id.isUTC=Ua,Id.zoneAbbr=Ub,Id.zoneName=Vb,Id.dates=$("dates accessor is deprecated. Use date instead.",zd),Id.months=$("months accessor is deprecated. Use month instead",W),Id.years=$("years accessor is deprecated. Use year instead",pd),Id.zone=$("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",La);var Jd=Id,Kd={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},Ld={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY LT",LLLL:"dddd, MMMM D, YYYY LT"},Md="Invalid date",Nd="%d",Od=/\d{1,2}/,Pd={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",
	hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Qd=r.prototype;Qd._calendar=Kd,Qd.calendar=Yb,Qd._longDateFormat=Ld,Qd.longDateFormat=Zb,Qd._invalidDate=Md,Qd.invalidDate=$b,Qd._ordinal=Nd,Qd.ordinal=_b,Qd._ordinalParse=Od,Qd.preparse=ac,Qd.postformat=ac,Qd._relativeTime=Pd,Qd.relativeTime=bc,Qd.pastFuture=cc,Qd.set=dc,Qd.months=S,Qd._months=id,Qd.monthsShort=T,Qd._monthsShort=jd,Qd.monthsParse=U,Qd.week=ia,Qd._week=qd,Qd.firstDayOfYear=ka,Qd.firstDayOfWeek=ja,Qd.weekdays=Ib,Qd._weekdays=Ad,Qd.weekdaysMin=Kb,Qd._weekdaysMin=Cd,Qd.weekdaysShort=Jb,Qd._weekdaysShort=Bd,Qd.weekdaysParse=Lb,Qd.isPM=Rb,Qd._meridiemParse=Dd,Qd.meridiem=Sb,v("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===p(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),a.lang=$("moment.lang is deprecated. Use moment.locale instead.",v),a.langData=$("moment.langData is deprecated. Use moment.localeData instead.",x);var Rd=Math.abs,Sd=uc("ms"),Td=uc("s"),Ud=uc("m"),Vd=uc("h"),Wd=uc("d"),Xd=uc("w"),Yd=uc("M"),Zd=uc("y"),$d=wc("milliseconds"),_d=wc("seconds"),ae=wc("minutes"),be=wc("hours"),ce=wc("days"),de=wc("months"),ee=wc("years"),fe=Math.round,ge={s:45,m:45,h:22,d:26,M:11},he=Math.abs,ie=Ea.prototype;ie.abs=lc,ie.add=nc,ie.subtract=oc,ie.as=sc,ie.asMilliseconds=Sd,ie.asSeconds=Td,ie.asMinutes=Ud,ie.asHours=Vd,ie.asDays=Wd,ie.asWeeks=Xd,ie.asMonths=Yd,ie.asYears=Zd,ie.valueOf=tc,ie._bubble=pc,ie.get=vc,ie.milliseconds=$d,ie.seconds=_d,ie.minutes=ae,ie.hours=be,ie.days=ce,ie.weeks=xc,ie.months=de,ie.years=ee,ie.humanize=Bc,ie.toISOString=Cc,ie.toString=Cc,ie.toJSON=Cc,ie.locale=pb,ie.localeData=qb,ie.toIsoString=$("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Cc),ie.lang=yd,G("X",0,0,"unix"),G("x",0,0,"valueOf"),L("x",Xc),L("X",Zc),O("X",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),O("x",function(a,b,c){c._d=new Date(p(a))}),a.version="2.10.3",b(Aa),a.fn=Jd,a.min=Ca,a.max=Da,a.utc=h,a.unix=Wb,a.months=gc,a.isDate=d,a.locale=v,a.invalid=l,a.duration=Va,a.isMoment=o,a.weekdays=ic,a.parseZone=Xb,a.localeData=x,a.isDuration=Fa,a.monthsShort=hc,a.weekdaysMin=kc,a.defineLocale=w,a.weekdaysShort=jc,a.normalizeUnits=z,a.relativeTimeThreshold=Ac;var je=a;return je});


	(function( $, undefined ) {

	var uuid = 0,
		runiqueId = /^ui-id-\d+$/;

	// $.ui might exist from components with no dependencies, e.g., $.ui.position
	$.ui = $.ui || {};

	$.extend( $.ui, {
		version: "1.10.4",

		keyCode: {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			LEFT: 37,
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		}
	});

	// plugins
	$.fn.extend({
		focus: (function( orig ) {
			return function( delay, fn ) {
				return typeof delay === "number" ?
					this.each(function() {
						var elem = this;
						setTimeout(function() {
							$( elem ).focus();
							if ( fn ) {
								fn.call( elem );
							}
						}, delay );
					}) :
					orig.apply( this, arguments );
			};
		})( $.fn.focus ),

		scrollParent: function() {
			var scrollParent;
			if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
				scrollParent = this.parents().filter(function() {
					return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
				}).eq(0);
			} else {
				scrollParent = this.parents().filter(function() {
					return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
				}).eq(0);
			}

			return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
		},

		zIndex: function( zIndex ) {
			if ( zIndex !== undefined ) {
				return this.css( "zIndex", zIndex );
			}

			if ( this.length ) {
				var elem = $( this[ 0 ] ), position, value;
				while ( elem.length && elem[ 0 ] !== document ) {
					// Ignore z-index if position is set to a value where z-index is ignored by the browser
					// This makes behavior of this function consistent across browsers
					// WebKit always returns auto if the element is positioned
					position = elem.css( "position" );
					if ( position === "absolute" || position === "relative" || position === "fixed" ) {
						// IE returns 0 when zIndex is not specified
						// other browsers return a string
						// we ignore the case of nested elements with an explicit value of 0
						// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
						value = parseInt( elem.css( "zIndex" ), 10 );
						if ( !isNaN( value ) && value !== 0 ) {
							return value;
						}
					}
					elem = elem.parent();
				}
			}

			return 0;
		},

		uniqueId: function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + (++uuid);
				}
			});
		},

		removeUniqueId: function() {
			return this.each(function() {
				if ( runiqueId.test( this.id ) ) {
					$( this ).removeAttr( "id" );
				}
			});
		}
	});

	// selectors
	function focusable( element, isTabIndexNotNaN ) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			map = element.parentNode;
			mapName = map.name;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap=#" + mapName + "]" )[0];
			return !!img && visible( img );
		}
		return ( /input|select|textarea|button|object/.test( nodeName ) ?
			!element.disabled :
			"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible( element );
	}

	function visible( element ) {
		return $.expr.filters.visible( element ) &&
			!$( element ).parents().addBack().filter(function() {
				return $.css( this, "visibility" ) === "hidden";
			}).length;
	}

	$.extend( $.expr[ ":" ], {
		data: $.expr.createPseudo ?
			$.expr.createPseudo(function( dataName ) {
				return function( elem ) {
					return !!$.data( elem, dataName );
				};
			}) :
			// support: jQuery <1.8
			function( elem, i, match ) {
				return !!$.data( elem, match[ 3 ] );
			},

		focusable: function( element ) {
			return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
		},

		tabbable: function( element ) {
			var tabIndex = $.attr( element, "tabindex" ),
				isTabIndexNaN = isNaN( tabIndex );
			return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
		}
	});

	// support: jQuery <1.8
	if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
		$.each( [ "Width", "Height" ], function( i, name ) {
			var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
				type = name.toLowerCase(),
				orig = {
					innerWidth: $.fn.innerWidth,
					innerHeight: $.fn.innerHeight,
					outerWidth: $.fn.outerWidth,
					outerHeight: $.fn.outerHeight
				};

			function reduce( elem, size, border, margin ) {
				$.each( side, function() {
					size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
					if ( border ) {
						size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
					}
					if ( margin ) {
						size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
					}
				});
				return size;
			}

			$.fn[ "inner" + name ] = function( size ) {
				if ( size === undefined ) {
					return orig[ "inner" + name ].call( this );
				}

				return this.each(function() {
					$( this ).css( type, reduce( this, size ) + "px" );
				});
			};

			$.fn[ "outer" + name] = function( size, margin ) {
				if ( typeof size !== "number" ) {
					return orig[ "outer" + name ].call( this, size );
				}

				return this.each(function() {
					$( this).css( type, reduce( this, size, true, margin ) + "px" );
				});
			};
		});
	}

	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}

	// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
	if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
		$.fn.removeData = (function( removeData ) {
			return function( key ) {
				if ( arguments.length ) {
					return removeData.call( this, $.camelCase( key ) );
				} else {
					return removeData.call( this );
				}
			};
		})( $.fn.removeData );
	}





	// deprecated
	$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

	$.support.selectstart = "onselectstart" in document.createElement( "div" );
	$.fn.extend({
		disableSelection: function() {
			return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
				".ui-disableSelection", function( event ) {
					event.preventDefault();
				});
		},

		enableSelection: function() {
			return this.unbind( ".ui-disableSelection" );
		}
	});

	$.extend( $.ui, {
		// $.ui.plugin is deprecated. Use $.widget() extensions instead.
		plugin: {
			add: function( module, option, set ) {
				var i,
					proto = $.ui[ module ].prototype;
				for ( i in set ) {
					proto.plugins[ i ] = proto.plugins[ i ] || [];
					proto.plugins[ i ].push( [ option, set[ i ] ] );
				}
			},
			call: function( instance, name, args ) {
				var i,
					set = instance.plugins[ name ];
				if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
					return;
				}

				for ( i = 0; i < set.length; i++ ) {
					if ( instance.options[ set[ i ][ 0 ] ] ) {
						set[ i ][ 1 ].apply( instance.element, args );
					}
				}
			}
		},

		// only used by resizable
		hasScroll: function( el, a ) {

			//If overflow is hidden, the element might have extra content, but the user wants to hide it
			if ( $( el ).css( "overflow" ) === "hidden") {
				return false;
			}

			var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
				has = false;

			if ( el[ scroll ] > 0 ) {
				return true;
			}

			// TODO: determine which cases actually cause this to happen
			// if the element doesn't have the scroll set, see if it's possible to
			// set the scroll
			el[ scroll ] = 1;
			has = ( el[ scroll ] > 0 );
			el[ scroll ] = 0;
			return has;
		}
	});

	})( jQuery );
	(function( $, undefined ) {

	var uuid = 0,
		slice = Array.prototype.slice,
		_cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};

	$.widget = function( name, base, prototype ) {
		var fullName, existingConstructor, constructor, basePrototype,
			// proxiedPrototype allows the provided prototype to remain unmodified
			// so that it can be used as a mixin for multiple widgets (#8876)
			proxiedPrototype = {},
			namespace = name.split( "." )[ 0 ];

		name = name.split( "." )[ 1 ];
		fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		// create selector for plugin
		$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};
		existingConstructor = $[ namespace ][ name ];
		constructor = $[ namespace ][ name ] = function( options, element ) {
			// allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		// extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,
			// copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend( {}, prototype ),
			// track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		});

		basePrototype = new base();
		// we need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		});
		constructor.prototype = $.widget.extend( basePrototype, {
			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		});

		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
			});
			// remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push( constructor );
		}

		$.widget.bridge( name, constructor );
	};

	$.widget.extend = function( target ) {
		var input = slice.call( arguments, 1 ),
			inputIndex = 0,
			inputLength = input.length,
			key,
			value;
		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :
							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );
					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};

	$.widget.bridge = function( name, object ) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[ name ] = function( options ) {
			var isMethodCall = typeof options === "string",
				args = slice.call( arguments, 1 ),
				returnValue = this;

			// allow multiple hashes to be passed on init
			options = !isMethodCall && args.length ?
				$.widget.extend.apply( null, [ options ].concat(args) ) :
				options;

			if ( isMethodCall ) {
				this.each(function() {
					var methodValue,
						instance = $.data( this, fullName );
					if ( !instance ) {
						return $.error( "cannot call methods on " + name + " prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}
					if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name + " widget instance" );
					}
					methodValue = instance[ options ].apply( instance, args );
					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				});
			} else {
				this.each(function() {
					var instance = $.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} )._init();
					} else {
						$.data( this, fullName, new object( options, this ) );
					}
				});
			}

			return returnValue;
		};
	};

	$.Widget = function( /* options, element */ ) {};
	$.Widget._childConstructors = [];

	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			disabled: false,

			// callbacks
			create: null
		},
		_createWidget: function( options, element ) {
			element = $( element || this.defaultElement || this )[ 0 ];
			this.element = $( element );
			this.uuid = uuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;
			this.options = $.widget.extend( {},
				this.options,
				this._getCreateOptions(),
				options );

			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();

			if ( element !== this ) {
				$.data( element, this.widgetFullName, this );
				this._on( true, this.element, {
					remove: function( event ) {
						if ( event.target === element ) {
							this.destroy();
						}
					}
				});
				this.document = $( element.style ?
					// element within the document
					element.ownerDocument :
					// element is window or document
					element.document || element );
				this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
			}

			this._create();
			this._trigger( "create", null, this._getCreateEventData() );
			this._init();
		},
		_getCreateOptions: $.noop,
		_getCreateEventData: $.noop,
		_create: $.noop,
		_init: $.noop,

		destroy: function() {
			this._destroy();
			// we can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element
				.unbind( this.eventNamespace )
				// 1.9 BC for #7810
				// TODO remove dual storage
				.removeData( this.widgetName )
				.removeData( this.widgetFullName )
				// support: jquery <1.6.3
				// http://bugs.jquery.com/ticket/9413
				.removeData( $.camelCase( this.widgetFullName ) );
			this.widget()
				.unbind( this.eventNamespace )
				.removeAttr( "aria-disabled" )
				.removeClass(
					this.widgetFullName + "-disabled " +
					"ui-state-disabled" );

			// clean up events and states
			this.bindings.unbind( this.eventNamespace );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		},
		_destroy: $.noop,

		widget: function() {
			return this.element;
		},

		option: function( key, value ) {
			var options = key,
				parts,
				curOption,
				i;

			if ( arguments.length === 0 ) {
				// don't return a reference to the internal hash
				return $.widget.extend( {}, this.options );
			}

			if ( typeof key === "string" ) {
				// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split( "." );
				key = parts.shift();
				if ( parts.length ) {
					curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
					for ( i = 0; i < parts.length - 1; i++ ) {
						curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
						curOption = curOption[ parts[ i ] ];
					}
					key = parts.pop();
					if ( arguments.length === 1 ) {
						return curOption[ key ] === undefined ? null : curOption[ key ];
					}
					curOption[ key ] = value;
				} else {
					if ( arguments.length === 1 ) {
						return this.options[ key ] === undefined ? null : this.options[ key ];
					}
					options[ key ] = value;
				}
			}

			this._setOptions( options );

			return this;
		},
		_setOptions: function( options ) {
			var key;

			for ( key in options ) {
				this._setOption( key, options[ key ] );
			}

			return this;
		},
		_setOption: function( key, value ) {
			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this.widget()
					.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
					.attr( "aria-disabled", value );
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}

			return this;
		},

		enable: function() {
			return this._setOption( "disabled", false );
		},
		disable: function() {
			return this._setOption( "disabled", true );
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement,
				instance = this;

			// no suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// no element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				// accept selectors, DOM elements
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			$.each( handlers, function( event, handler ) {
				function handlerProxy() {
					// allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
								$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^(\w+)\s*(.*)$/ ),
					eventName = match[1] + instance.eventNamespace,
					selector = match[2];
				if ( selector ) {
					delegateElement.delegate( selector, eventName, handlerProxy );
				} else {
					element.bind( eventName, handlerProxy );
				}
			});
		},

		_off: function( element, eventName ) {
			eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
			element.unbind( eventName ).undelegate( eventName );
		},

		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-hover" );
				},
				mouseleave: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-hover" );
				}
			});
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-focus" );
				},
				focusout: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-focus" );
				}
			});
		},

		_trigger: function( type, event, data ) {
			var prop, orig,
				callback = this.options[ type ];

			data = data || {};
			event = $.Event( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();
			// the original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( $.isFunction( callback ) &&
				callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}
	};

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}
			var hasOptions,
				effectName = !options ?
					method :
					options === true || typeof options === "number" ?
						defaultEffect :
						options.effect || defaultEffect;
			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}
			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;
			if ( options.delay ) {
				element.delay( options.delay );
			}
			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue(function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				});
			}
		};
	});

	})( jQuery );
	(function( $, undefined ) {

	var mouseHandled = false;
	$( document ).mouseup( function() {
		mouseHandled = false;
	});

	$.widget("ui.mouse", {
		version: "1.10.4",
		options: {
			cancel: "input,textarea,button,select,option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function() {
			var that = this;

			this.element
				.bind("mousedown."+this.widgetName, function(event) {
					return that._mouseDown(event);
				})
				.bind("click."+this.widgetName, function(event) {
					if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
						$.removeData(event.target, that.widgetName + ".preventClickEvent");
						event.stopImmediatePropagation();
						return false;
					}
				});

			this.started = false;
		},

		// TODO: make sure destroying one instance of mouse doesn't mess with
		// other instances of mouse
		_mouseDestroy: function() {
			this.element.unbind("."+this.widgetName);
			if ( this._mouseMoveDelegate ) {
				$(document)
					.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
					.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
			}
		},

		_mouseDown: function(event) {
			// don't let more than one widget handle mouseStart
			if( mouseHandled ) { return; }

			// we may have missed mouseup (out of window)
			(this._mouseStarted && this._mouseUp(event));

			this._mouseDownEvent = event;

			var that = this,
				btnIsLeft = (event.which === 1),
				// event.target.nodeName works around a bug in IE 8 with
				// disabled inputs (#7620)
				elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
			if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
				return true;
			}

			this.mouseDelayMet = !this.options.delay;
			if (!this.mouseDelayMet) {
				this._mouseDelayTimer = setTimeout(function() {
					that.mouseDelayMet = true;
				}, this.options.delay);
			}

			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted = (this._mouseStart(event) !== false);
				if (!this._mouseStarted) {
					event.preventDefault();
					return true;
				}
			}

			// Click event may never have fired (Gecko & Opera)
			if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
				$.removeData(event.target, this.widgetName + ".preventClickEvent");
			}

			// these delegates are required to keep context
			this._mouseMoveDelegate = function(event) {
				return that._mouseMove(event);
			};
			this._mouseUpDelegate = function(event) {
				return that._mouseUp(event);
			};
			$(document)
				.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

			event.preventDefault();

			mouseHandled = true;
			return true;
		},

		_mouseMove: function(event) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);
			}

			if (this._mouseStarted) {
				this._mouseDrag(event);
				return event.preventDefault();
			}

			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted =
					(this._mouseStart(this._mouseDownEvent, event) !== false);
				(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
			}

			return !this._mouseStarted;
		},

		_mouseUp: function(event) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

			if (this._mouseStarted) {
				this._mouseStarted = false;

				if (event.target === this._mouseDownEvent.target) {
					$.data(event.target, this.widgetName + ".preventClickEvent", true);
				}

				this._mouseStop(event);
			}

			return false;
		},

		_mouseDistanceMet: function(event) {
			return (Math.max(
					Math.abs(this._mouseDownEvent.pageX - event.pageX),
					Math.abs(this._mouseDownEvent.pageY - event.pageY)
				) >= this.options.distance
			);
		},

		_mouseDelayMet: function(/* event */) {
			return this.mouseDelayMet;
		},

		// These are placeholder methods, to be overriden by extending plugin
		_mouseStart: function(/* event */) {},
		_mouseDrag: function(/* event */) {},
		_mouseStop: function(/* event */) {},
		_mouseCapture: function(/* event */) { return true; }
	});

	})(jQuery);
	(function( $, undefined ) {

	$.ui = $.ui || {};

	var cachedScrollbarWidth,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;

	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}

	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}

	function getDimensions( elem ) {
		var raw = elem[0];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}

	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[0];

			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );

			w2 = innerDiv.offsetWidth;

			if ( w1 === w2 ) {
				w2 = div[0].clientWidth;
			}

			div.remove();

			return (cachedScrollbarWidth = w1 - w2);
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-x" ),
				overflowY = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[0].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[0] ),
				isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
			return {
				element: withinElement,
				isWindow: isWindow,
				isDocument: isDocument,
				offset: withinElement.offset() || { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
				width: isWindow ? withinElement.width() : withinElement.outerWidth(),
				height: isWindow ? withinElement.height() : withinElement.outerHeight()
			};
		}
	};

	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}

		// make a copy, we don't want to modify arguments
		options = $.extend( {}, options );

		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};

		dimensions = getDimensions( target );
		if ( target[0].preventDefault ) {
			// force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;
		// clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );

		// force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;

			if ( pos.length === 1) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

			// calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];

			// reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		});

		// normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}

		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}

		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}

		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];

		return this.each(function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}

			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}

			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];

			// if the browser doesn't support fractions, then round for consistent results
			if ( !$.support.offsetFractions ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}

			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};

			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem : elem
					});
				}
			});

			if ( options.using ) {
				// adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}

			elem.offset( $.extend( position, { using: using } ) );
		});
	};

	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;

				// element is wider than within
				if ( data.collisionWidth > outerWidth ) {
					// element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
						position.left += overLeft - newOverRight;
					// element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;
					// element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}
				// too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;
				// too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;
				// adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;

				// element is taller than within
				if ( data.collisionHeight > outerHeight ) {
					// element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
						position.top += overTop - newOverBottom;
					// element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;
					// element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}
				// too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;
				// too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;
				// adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;

				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				}
				else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
					if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
						position.top += myOffset + atOffset + offset;
					}
				}
				else if ( overBottom > 0 ) {
					newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
					if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};

	// fraction support test
	(function () {
		var testElement, testElementParent, testElementStyle, offsetLeft, i,
			body = document.getElementsByTagName( "body" )[ 0 ],
			div = document.createElement( "div" );

		//Create a "fake body" for testing based on method used in jQuery.support
		testElement = document.createElement( body ? "div" : "body" );
		testElementStyle = {
			visibility: "hidden",
			width: 0,
			height: 0,
			border: 0,
			margin: 0,
			background: "none"
		};
		if ( body ) {
			$.extend( testElementStyle, {
				position: "absolute",
				left: "-1000px",
				top: "-1000px"
			});
		}
		for ( i in testElementStyle ) {
			testElement.style[ i ] = testElementStyle[ i ];
		}
		testElement.appendChild( div );
		testElementParent = body || document.documentElement;
		testElementParent.insertBefore( testElement, testElementParent.firstChild );

		div.style.cssText = "position: absolute; left: 10.7432222px;";

		offsetLeft = $( div ).offset().left;
		$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

		testElement.innerHTML = "";
		testElementParent.removeChild( testElement );
	})();

	}( jQuery ) );
	(function( $, undefined ) {

	var uid = 0,
		hideProps = {},
		showProps = {};

	hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
		hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
	showProps.height = showProps.paddingTop = showProps.paddingBottom =
		showProps.borderTopWidth = showProps.borderBottomWidth = "show";

	$.widget( "ui.accordion", {
		version: "1.10.4",
		options: {
			active: 0,
			animate: {},
			collapsible: false,
			event: "click",
			header: "> li > :first-child,> :not(li):even",
			heightStyle: "auto",
			icons: {
				activeHeader: "ui-icon-triangle-1-s",
				header: "ui-icon-triangle-1-e"
			},

			// callbacks
			activate: null,
			beforeActivate: null
		},

		_create: function() {
			var options = this.options;
			this.prevShow = this.prevHide = $();
			this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
				// ARIA
				.attr( "role", "tablist" );

			// don't allow collapsible: false and active: false / null
			if ( !options.collapsible && (options.active === false || options.active == null) ) {
				options.active = 0;
			}

			this._processPanels();
			// handle negative values
			if ( options.active < 0 ) {
				options.active += this.headers.length;
			}
			this._refresh();
		},

		_getCreateEventData: function() {
			return {
				header: this.active,
				panel: !this.active.length ? $() : this.active.next(),
				content: !this.active.length ? $() : this.active.next()
			};
		},

		_createIcons: function() {
			var icons = this.options.icons;
			if ( icons ) {
				$( "<span>" )
					.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
					.prependTo( this.headers );
				this.active.children( ".ui-accordion-header-icon" )
					.removeClass( icons.header )
					.addClass( icons.activeHeader );
				this.headers.addClass( "ui-accordion-icons" );
			}
		},

		_destroyIcons: function() {
			this.headers
				.removeClass( "ui-accordion-icons" )
				.children( ".ui-accordion-header-icon" )
					.remove();
		},

		_destroy: function() {
			var contents;

			// clean up main element
			this.element
				.removeClass( "ui-accordion ui-widget ui-helper-reset" )
				.removeAttr( "role" );

			// clean up headers
			this.headers
				.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
				.removeAttr( "role" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-selected" )
				.removeAttr( "aria-controls" )
				.removeAttr( "tabIndex" )
				.each(function() {
					if ( /^ui-accordion/.test( this.id ) ) {
						this.removeAttribute( "id" );
					}
				});
			this._destroyIcons();

			// clean up content panels
			contents = this.headers.next()
				.css( "display", "" )
				.removeAttr( "role" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-labelledby" )
				.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
				.each(function() {
					if ( /^ui-accordion/.test( this.id ) ) {
						this.removeAttribute( "id" );
					}
				});
			if ( this.options.heightStyle !== "content" ) {
				contents.css( "height", "" );
			}
		},

		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}

			if ( key === "event" ) {
				if ( this.options.event ) {
					this._off( this.headers, this.options.event );
				}
				this._setupEvents( value );
			}

			this._super( key, value );

			// setting collapsible: false while collapsed; open first panel
			if ( key === "collapsible" && !value && this.options.active === false ) {
				this._activate( 0 );
			}

			if ( key === "icons" ) {
				this._destroyIcons();
				if ( value ) {
					this._createIcons();
				}
			}

			// #5332 - opacity doesn't cascade to positioned elements in IE
			// so we need to add the disabled class to the headers and panels
			if ( key === "disabled" ) {
				this.headers.add( this.headers.next() )
					.toggleClass( "ui-state-disabled", !!value );
			}
		},

		_keydown: function( event ) {
			if ( event.altKey || event.ctrlKey ) {
				return;
			}

			var keyCode = $.ui.keyCode,
				length = this.headers.length,
				currentIndex = this.headers.index( event.target ),
				toFocus = false;

			switch ( event.keyCode ) {
				case keyCode.RIGHT:
				case keyCode.DOWN:
					toFocus = this.headers[ ( currentIndex + 1 ) % length ];
					break;
				case keyCode.LEFT:
				case keyCode.UP:
					toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
					break;
				case keyCode.SPACE:
				case keyCode.ENTER:
					this._eventHandler( event );
					break;
				case keyCode.HOME:
					toFocus = this.headers[ 0 ];
					break;
				case keyCode.END:
					toFocus = this.headers[ length - 1 ];
					break;
			}

			if ( toFocus ) {
				$( event.target ).attr( "tabIndex", -1 );
				$( toFocus ).attr( "tabIndex", 0 );
				toFocus.focus();
				event.preventDefault();
			}
		},

		_panelKeyDown : function( event ) {
			if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
				$( event.currentTarget ).prev().focus();
			}
		},

		refresh: function() {
			var options = this.options;
			this._processPanels();

			// was collapsed or no panel
			if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
				options.active = false;
				this.active = $();
			// active false only when collapsible is true
			} else if ( options.active === false ) {
				this._activate( 0 );
			// was active, but active panel is gone
			} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				// all remaining panel are disabled
				if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
					options.active = false;
					this.active = $();
				// activate previous panel
				} else {
					this._activate( Math.max( 0, options.active - 1 ) );
				}
			// was active, active panel still exists
			} else {
				// make sure active index is correct
				options.active = this.headers.index( this.active );
			}

			this._destroyIcons();

			this._refresh();
		},

		_processPanels: function() {
			this.headers = this.element.find( this.options.header )
				.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );

			this.headers.next()
				.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
				.filter(":not(.ui-accordion-content-active)")
				.hide();
		},

		_refresh: function() {
			var maxHeight,
				options = this.options,
				heightStyle = options.heightStyle,
				parent = this.element.parent(),
				accordionId = this.accordionId = "ui-accordion-" +
					(this.element.attr( "id" ) || ++uid);

			this.active = this._findActive( options.active )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
				.removeClass( "ui-corner-all" );
			this.active.next()
				.addClass( "ui-accordion-content-active" )
				.show();

			this.headers
				.attr( "role", "tab" )
				.each(function( i ) {
					var header = $( this ),
						headerId = header.attr( "id" ),
						panel = header.next(),
						panelId = panel.attr( "id" );
					if ( !headerId ) {
						headerId = accordionId + "-header-" + i;
						header.attr( "id", headerId );
					}
					if ( !panelId ) {
						panelId = accordionId + "-panel-" + i;
						panel.attr( "id", panelId );
					}
					header.attr( "aria-controls", panelId );
					panel.attr( "aria-labelledby", headerId );
				})
				.next()
					.attr( "role", "tabpanel" );

			this.headers
				.not( this.active )
				.attr({
					"aria-selected": "false",
					"aria-expanded": "false",
					tabIndex: -1
				})
				.next()
					.attr({
						"aria-hidden": "true"
					})
					.hide();

			// make sure at least one header is in the tab order
			if ( !this.active.length ) {
				this.headers.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				})
				.next()
					.attr({
						"aria-hidden": "false"
					});
			}

			this._createIcons();

			this._setupEvents( options.event );

			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );

					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});

				this.headers.each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});

				this.headers.next()
					.each(function() {
						$( this ).height( Math.max( 0, maxHeight -
							$( this ).innerHeight() + $( this ).height() ) );
					})
					.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.headers.next()
					.each(function() {
						maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					})
					.height( maxHeight );
			}
		},

		_activate: function( index ) {
			var active = this._findActive( index )[ 0 ];

			// trying to activate the already active panel
			if ( active === this.active[ 0 ] ) {
				return;
			}

			// trying to collapse, simulate a click on the currently active header
			active = active || this.active[ 0 ];

			this._eventHandler({
				target: active,
				currentTarget: active,
				preventDefault: $.noop
			});
		},

		_findActive: function( selector ) {
			return typeof selector === "number" ? this.headers.eq( selector ) : $();
		},

		_setupEvents: function( event ) {
			var events = {
				keydown: "_keydown"
			};
			if ( event ) {
				$.each( event.split(" "), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}

			this._off( this.headers.add( this.headers.next() ) );
			this._on( this.headers, events );
			this._on( this.headers.next(), { keydown: "_panelKeyDown" });
			this._hoverable( this.headers );
			this._focusable( this.headers );
		},

		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				clicked = $( event.currentTarget ),
				clickedIsActive = clicked[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : clicked.next(),
				toHide = active.next(),
				eventData = {
					oldHeader: active,
					oldPanel: toHide,
					newHeader: collapsing ? $() : clicked,
					newPanel: toShow
				};

			event.preventDefault();

			if (
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}

			options.active = collapsing ? false : this.headers.index( clicked );

			// when the call to ._toggle() comes after the class changes
			// it causes a very odd bug in IE 8 (see #6720)
			this.active = clickedIsActive ? $() : clicked;
			this._toggle( eventData );

			// switch classes
			// corner classes on the previously active header stay after the animation
			active.removeClass( "ui-accordion-header-active ui-state-active" );
			if ( options.icons ) {
				active.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.activeHeader )
					.addClass( options.icons.header );
			}

			if ( !clickedIsActive ) {
				clicked
					.removeClass( "ui-corner-all" )
					.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
				if ( options.icons ) {
					clicked.children( ".ui-accordion-header-icon" )
						.removeClass( options.icons.header )
						.addClass( options.icons.activeHeader );
				}

				clicked
					.next()
					.addClass( "ui-accordion-content-active" );
			}
		},

		_toggle: function( data ) {
			var toShow = data.newPanel,
				toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

			// handle activating a panel during the animation for another activation
			this.prevShow.add( this.prevHide ).stop( true, true );
			this.prevShow = toShow;
			this.prevHide = toHide;

			if ( this.options.animate ) {
				this._animate( toShow, toHide, data );
			} else {
				toHide.hide();
				toShow.show();
				this._toggleComplete( data );
			}

			toHide.attr({
				"aria-hidden": "true"
			});
			toHide.prev().attr( "aria-selected", "false" );
			// if we're switching panels, remove the old header from the tab order
			// if we're opening from collapsed state, remove the previous header from the tab order
			// if we're collapsing, then keep the collapsing header in the tab order
			if ( toShow.length && toHide.length ) {
				toHide.prev().attr({
					"tabIndex": -1,
					"aria-expanded": "false"
				});
			} else if ( toShow.length ) {
				this.headers.filter(function() {
					return $( this ).attr( "tabIndex" ) === 0;
				})
				.attr( "tabIndex", -1 );
			}

			toShow
				.attr( "aria-hidden", "false" )
				.prev()
					.attr({
						"aria-selected": "true",
						tabIndex: 0,
						"aria-expanded": "true"
					});
		},

		_animate: function( toShow, toHide, data ) {
			var total, easing, duration,
				that = this,
				adjust = 0,
				down = toShow.length &&
					( !toHide.length || ( toShow.index() < toHide.index() ) ),
				animate = this.options.animate || {},
				options = down && animate.down || animate,
				complete = function() {
					that._toggleComplete( data );
				};

			if ( typeof options === "number" ) {
				duration = options;
			}
			if ( typeof options === "string" ) {
				easing = options;
			}
			// fall back from options to animation in case of partial down settings
			easing = easing || options.easing || animate.easing;
			duration = duration || options.duration || animate.duration;

			if ( !toHide.length ) {
				return toShow.animate( showProps, duration, easing, complete );
			}
			if ( !toShow.length ) {
				return toHide.animate( hideProps, duration, easing, complete );
			}

			total = toShow.show().outerHeight();
			toHide.animate( hideProps, {
				duration: duration,
				easing: easing,
				step: function( now, fx ) {
					fx.now = Math.round( now );
				}
			});
			toShow
				.hide()
				.animate( showProps, {
					duration: duration,
					easing: easing,
					complete: complete,
					step: function( now, fx ) {
						fx.now = Math.round( now );
						if ( fx.prop !== "height" ) {
							adjust += fx.now;
						} else if ( that.options.heightStyle !== "content" ) {
							fx.now = Math.round( total - toHide.outerHeight() - adjust );
							adjust = 0;
						}
					}
				});
		},

		_toggleComplete: function( data ) {
			var toHide = data.oldPanel;

			toHide
				.removeClass( "ui-accordion-content-active" )
				.prev()
					.removeClass( "ui-corner-top" )
					.addClass( "ui-corner-all" );

			// Work around for rendering bug in IE (#5421)
			if ( toHide.length ) {
				toHide.parent()[0].className = toHide.parent()[0].className;
			}
			this._trigger( "activate", null, data );
		}
	});

	})( jQuery );
	(function( $, undefined ) {

	$.widget( "ui.autocomplete", {
		version: "1.10.4",
		defaultElement: "<input>",
		options: {
			appendTo: null,
			autoFocus: false,
			delay: 300,
			minLength: 1,
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			source: null,

			// callbacks
			change: null,
			close: null,
			focus: null,
			open: null,
			response: null,
			search: null,
			select: null
		},

		requestIndex: 0,
		pending: 0,

		_create: function() {
			// Some browsers only repeat keydown events, not keypress events,
			// so we use the suppressKeyPress flag to determine if we've already
			// handled the keydown event. #7269
			// Unfortunately the code for & in keypress is the same as the up arrow,
			// so we use the suppressKeyPressRepeat flag to avoid handling keypress
			// events when we know the keydown event was used to modify the
			// search term. #7799
			var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
				nodeName = this.element[0].nodeName.toLowerCase(),
				isTextarea = nodeName === "textarea",
				isInput = nodeName === "input";

			this.isMultiLine =
				// Textareas are always multi-line
				isTextarea ? true :
				// Inputs are always single-line, even if inside a contentEditable element
				// IE also treats inputs as contentEditable
				isInput ? false :
				// All other element types are determined by whether or not they're contentEditable
				this.element.prop( "isContentEditable" );

			this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
			this.isNewMenu = true;

			this.element
				.addClass( "ui-autocomplete-input" )
				.attr( "autocomplete", "off" );

			this._on( this.element, {
				keydown: function( event ) {
					if ( this.element.prop( "readOnly" ) ) {
						suppressKeyPress = true;
						suppressInput = true;
						suppressKeyPressRepeat = true;
						return;
					}

					suppressKeyPress = false;
					suppressInput = false;
					suppressKeyPressRepeat = false;
					var keyCode = $.ui.keyCode;
					switch( event.keyCode ) {
					case keyCode.PAGE_UP:
						suppressKeyPress = true;
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						suppressKeyPress = true;
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						suppressKeyPress = true;
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						suppressKeyPress = true;
						this._keyEvent( "next", event );
						break;
					case keyCode.ENTER:
					case keyCode.NUMPAD_ENTER:
						// when menu is open and has focus
						if ( this.menu.active ) {
							// #6055 - Opera still allows the keypress to occur
							// which causes forms to submit
							suppressKeyPress = true;
							event.preventDefault();
							this.menu.select( event );
						}
						break;
					case keyCode.TAB:
						if ( this.menu.active ) {
							this.menu.select( event );
						}
						break;
					case keyCode.ESCAPE:
						if ( this.menu.element.is( ":visible" ) ) {
							this._value( this.term );
							this.close( event );
							// Different browsers have different default behavior for escape
							// Single press can mean undo or clear
							// Double press in IE means clear the whole form
							event.preventDefault();
						}
						break;
					default:
						suppressKeyPressRepeat = true;
						// search timeout should be triggered before the input value is changed
						this._searchTimeout( event );
						break;
					}
				},
				keypress: function( event ) {
					if ( suppressKeyPress ) {
						suppressKeyPress = false;
						if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
							event.preventDefault();
						}
						return;
					}
					if ( suppressKeyPressRepeat ) {
						return;
					}

					// replicate some key handlers to allow them to repeat in Firefox and Opera
					var keyCode = $.ui.keyCode;
					switch( event.keyCode ) {
					case keyCode.PAGE_UP:
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						this._keyEvent( "next", event );
						break;
					}
				},
				input: function( event ) {
					if ( suppressInput ) {
						suppressInput = false;
						event.preventDefault();
						return;
					}
					this._searchTimeout( event );
				},
				focus: function() {
					this.selectedItem = null;
					this.previous = this._value();
				},
				blur: function( event ) {
					if ( this.cancelBlur ) {
						delete this.cancelBlur;
						return;
					}

					clearTimeout( this.searching );
					this.close( event );
					this._change( event );
				}
			});

			this._initSource();
			this.menu = $( "<ul>" )
				.addClass( "ui-autocomplete ui-front" )
				.appendTo( this._appendTo() )
				.menu({
					// disable ARIA support, the live region takes care of that
					role: null
				})
				.hide()
				.data( "ui-menu" );

			this._on( this.menu.element, {
				mousedown: function( event ) {
					// prevent moving focus out of the text field
					event.preventDefault();

					// IE doesn't prevent moving focus even with event.preventDefault()
					// so we set a flag to know when we should ignore the blur event
					this.cancelBlur = true;
					this._delay(function() {
						delete this.cancelBlur;
					});

					// clicking on the scrollbar causes focus to shift to the body
					// but we can't detect a mouseup or a click immediately afterward
					// so we have to track the next mousedown and close the menu if
					// the user clicks somewhere outside of the autocomplete
					var menuElement = this.menu.element[ 0 ];
					if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
						this._delay(function() {
							var that = this;
							this.document.one( "mousedown", function( event ) {
								if ( event.target !== that.element[ 0 ] &&
										event.target !== menuElement &&
										!$.contains( menuElement, event.target ) ) {
									that.close();
								}
							});
						});
					}
				},
				menufocus: function( event, ui ) {
					// support: Firefox
					// Prevent accidental activation of menu items in Firefox (#7024 #9118)
					if ( this.isNewMenu ) {
						this.isNewMenu = false;
						if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
							this.menu.blur();

							this.document.one( "mousemove", function() {
								$( event.target ).trigger( event.originalEvent );
							});

							return;
						}
					}

					var item = ui.item.data( "ui-autocomplete-item" );
					if ( false !== this._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
							this._value( item.value );
						}
					} else {
						// Normally the input is populated with the item's value as the
						// menu is navigated, causing screen readers to notice a change and
						// announce the item. Since the focus event was canceled, this doesn't
						// happen, so we update the live region so that screen readers can
						// still notice the change and announce it.
						this.liveRegion.text( item.value );
					}
				},
				menuselect: function( event, ui ) {
					var item = ui.item.data( "ui-autocomplete-item" ),
						previous = this.previous;

					// only trigger when focus was lost (click on menu)
					if ( this.element[0] !== this.document[0].activeElement ) {
						this.element.focus();
						this.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						this._delay(function() {
							this.previous = previous;
							this.selectedItem = item;
						});
					}

					if ( false !== this._trigger( "select", event, { item: item } ) ) {
						this._value( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					this.term = this._value();

					this.close( event );
					this.selectedItem = item;
				}
			});

			this.liveRegion = $( "<span>", {
					role: "status",
					"aria-live": "polite"
				})
				.addClass( "ui-helper-hidden-accessible" )
				.insertBefore( this.element );

			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},

		_destroy: function() {
			clearTimeout( this.searching );
			this.element
				.removeClass( "ui-autocomplete-input" )
				.removeAttr( "autocomplete" );
			this.menu.element.remove();
			this.liveRegion.remove();
		},

		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "source" ) {
				this._initSource();
			}
			if ( key === "appendTo" ) {
				this.menu.element.appendTo( this._appendTo() );
			}
			if ( key === "disabled" && value && this.xhr ) {
				this.xhr.abort();
			}
		},

		_appendTo: function() {
			var element = this.options.appendTo;

			if ( element ) {
				element = element.jquery || element.nodeType ?
					$( element ) :
					this.document.find( element ).eq( 0 );
			}

			if ( !element ) {
				element = this.element.closest( ".ui-front" );
			}

			if ( !element.length ) {
				element = this.document[0].body;
			}

			return element;
		},

		_initSource: function() {
			var array, url,
				that = this;
			if ( $.isArray(this.options.source) ) {
				array = this.options.source;
				this.source = function( request, response ) {
					response( $.ui.autocomplete.filter( array, request.term ) );
				};
			} else if ( typeof this.options.source === "string" ) {
				url = this.options.source;
				this.source = function( request, response ) {
					if ( that.xhr ) {
						that.xhr.abort();
					}
					that.xhr = $.ajax({
						url: url,
						data: request,
						dataType: "json",
						success: function( data ) {
							response( data );
						},
						error: function() {
							response( [] );
						}
					});
				};
			} else {
				this.source = this.options.source;
			}
		},

		_searchTimeout: function( event ) {
			clearTimeout( this.searching );
			this.searching = this._delay(function() {
				// only search if the value has changed
				if ( this.term !== this._value() ) {
					this.selectedItem = null;
					this.search( null, event );
				}
			}, this.options.delay );
		},

		search: function( value, event ) {
			value = value != null ? value : this._value();

			// always save the actual value, not the one passed as an argument
			this.term = this._value();

			if ( value.length < this.options.minLength ) {
				return this.close( event );
			}

			if ( this._trigger( "search", event ) === false ) {
				return;
			}

			return this._search( value );
		},

		_search: function( value ) {
			this.pending++;
			this.element.addClass( "ui-autocomplete-loading" );
			this.cancelSearch = false;

			this.source( { term: value }, this._response() );
		},

		_response: function() {
			var index = ++this.requestIndex;

			return $.proxy(function( content ) {
				if ( index === this.requestIndex ) {
					this.__response( content );
				}

				this.pending--;
				if ( !this.pending ) {
					this.element.removeClass( "ui-autocomplete-loading" );
				}
			}, this );
		},

		__response: function( content ) {
			if ( content ) {
				content = this._normalize( content );
			}
			this._trigger( "response", null, { content: content } );
			if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
				this._suggest( content );
				this._trigger( "open" );
			} else {
				// use ._close() instead of .close() so we don't cancel future searches
				this._close();
			}
		},

		close: function( event ) {
			this.cancelSearch = true;
			this._close( event );
		},

		_close: function( event ) {
			if ( this.menu.element.is( ":visible" ) ) {
				this.menu.element.hide();
				this.menu.blur();
				this.isNewMenu = true;
				this._trigger( "close", event );
			}
		},

		_change: function( event ) {
			if ( this.previous !== this._value() ) {
				this._trigger( "change", event, { item: this.selectedItem } );
			}
		},

		_normalize: function( items ) {
			// assume all items have the right format when the first item is complete
			if ( items.length && items[0].label && items[0].value ) {
				return items;
			}
			return $.map( items, function( item ) {
				if ( typeof item === "string" ) {
					return {
						label: item,
						value: item
					};
				}
				return $.extend({
					label: item.label || item.value,
					value: item.value || item.label
				}, item );
			});
		},

		_suggest: function( items ) {
			var ul = this.menu.element.empty();
			this._renderMenu( ul, items );
			this.isNewMenu = true;
			this.menu.refresh();

			// size and position menu
			ul.show();
			this._resizeMenu();
			ul.position( $.extend({
				of: this.element
			}, this.options.position ));

			if ( this.options.autoFocus ) {
				this.menu.next();
			}
		},

		_resizeMenu: function() {
			var ul = this.menu.element;
			ul.outerWidth( Math.max(
				// Firefox wraps long text (possibly a rounding bug)
				// so we add 1px to avoid the wrapping (#7513)
				ul.width( "" ).outerWidth() + 1,
				this.element.outerWidth()
			) );
		},

		_renderMenu: function( ul, items ) {
			var that = this;
			$.each( items, function( index, item ) {
				that._renderItemData( ul, item );
			});
		},

		_renderItemData: function( ul, item ) {
			return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
		},

		_renderItem: function( ul, item ) {
			return $( "<li>" )
				.append( $( "<a>" ).text( item.label ) )
				.appendTo( ul );
		},

		_move: function( direction, event ) {
			if ( !this.menu.element.is( ":visible" ) ) {
				this.search( null, event );
				return;
			}
			if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
					this.menu.isLastItem() && /^next/.test( direction ) ) {
				this._value( this.term );
				this.menu.blur();
				return;
			}
			this.menu[ direction ]( event );
		},

		widget: function() {
			return this.menu.element;
		},

		_value: function() {
			return this.valueMethod.apply( this.element, arguments );
		},

		_keyEvent: function( keyEvent, event ) {
			if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
				this._move( keyEvent, event );

				// prevents moving cursor to beginning/end of the text field in some browsers
				event.preventDefault();
			}
		}
	});

	$.extend( $.ui.autocomplete, {
		escapeRegex: function( value ) {
			return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
		},
		filter: function(array, term) {
			var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
			return $.grep( array, function(value) {
				return matcher.test( value.label || value.value || value );
			});
		}
	});


	// live region extension, adding a `messages` option
	// NOTE: This is an experimental API. We are still investigating
	// a full solution for string manipulation and internationalization.
	$.widget( "ui.autocomplete", $.ui.autocomplete, {
		options: {
			messages: {
				noResults: "No search results.",
				results: function( amount ) {
					return amount + ( amount > 1 ? " results are" : " result is" ) +
						" available, use up and down arrow keys to navigate.";
				}
			}
		},

		__response: function( content ) {
			var message;
			this._superApply( arguments );
			if ( this.options.disabled || this.cancelSearch ) {
				return;
			}
			if ( content && content.length ) {
				message = this.options.messages.results( content.length );
			} else {
				message = this.options.messages.noResults;
			}
			this.liveRegion.text( message );
		}
	});

	}( jQuery ));
	(function( $, undefined ) {

	var lastActive,
		baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
		typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
		formResetHandler = function() {
			var form = $( this );
			setTimeout(function() {
				form.find( ":ui-button" ).button( "refresh" );
			}, 1 );
		},
		radioGroup = function( radio ) {
			var name = radio.name,
				form = radio.form,
				radios = $( [] );
			if ( name ) {
				name = name.replace( /'/g, "\\'" );
				if ( form ) {
					radios = $( form ).find( "[name='" + name + "']" );
				} else {
					radios = $( "[name='" + name + "']", radio.ownerDocument )
						.filter(function() {
							return !this.form;
						});
				}
			}
			return radios;
		};

	$.widget( "ui.button", {
		version: "1.10.4",
		defaultElement: "<button>",
		options: {
			disabled: null,
			text: true,
			label: null,
			icons: {
				primary: null,
				secondary: null
			}
		},
		_create: function() {
			this.element.closest( "form" )
				.unbind( "reset" + this.eventNamespace )
				.bind( "reset" + this.eventNamespace, formResetHandler );

			if ( typeof this.options.disabled !== "boolean" ) {
				this.options.disabled = !!this.element.prop( "disabled" );
			} else {
				this.element.prop( "disabled", this.options.disabled );
			}

			this._determineButtonType();
			this.hasTitle = !!this.buttonElement.attr( "title" );

			var that = this,
				options = this.options,
				toggleButton = this.type === "checkbox" || this.type === "radio",
				activeClass = !toggleButton ? "ui-state-active" : "";

			if ( options.label === null ) {
				options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
			}

			this._hoverable( this.buttonElement );

			this.buttonElement
				.addClass( baseClasses )
				.attr( "role", "button" )
				.bind( "mouseenter" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					if ( this === lastActive ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "mouseleave" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					$( this ).removeClass( activeClass );
				})
				.bind( "click" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						event.preventDefault();
						event.stopImmediatePropagation();
					}
				});

			// Can't use _focusable() because the element that receives focus
			// and the element that gets the ui-state-focus class are different
			this._on({
				focus: function() {
					this.buttonElement.addClass( "ui-state-focus" );
				},
				blur: function() {
					this.buttonElement.removeClass( "ui-state-focus" );
				}
			});

			if ( toggleButton ) {
				this.element.bind( "change" + this.eventNamespace, function() {
					that.refresh();
				});
			}

			if ( this.type === "checkbox" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
				});
			} else if ( this.type === "radio" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					that.buttonElement.attr( "aria-pressed", "true" );

					var radio = that.element[ 0 ];
					radioGroup( radio )
						.not( radio )
						.map(function() {
							return $( this ).button( "widget" )[ 0 ];
						})
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				});
			} else {
				this.buttonElement
					.bind( "mousedown" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).addClass( "ui-state-active" );
						lastActive = this;
						that.document.one( "mouseup", function() {
							lastActive = null;
						});
					})
					.bind( "mouseup" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).removeClass( "ui-state-active" );
					})
					.bind( "keydown" + this.eventNamespace, function(event) {
						if ( options.disabled ) {
							return false;
						}
						if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
							$( this ).addClass( "ui-state-active" );
						}
					})
					// see #8559, we bind to blur here in case the button element loses
					// focus between keydown and keyup, it would be left in an "active" state
					.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
						$( this ).removeClass( "ui-state-active" );
					});

				if ( this.buttonElement.is("a") ) {
					this.buttonElement.keyup(function(event) {
						if ( event.keyCode === $.ui.keyCode.SPACE ) {
							// TODO pass through original event correctly (just as 2nd argument doesn't work)
							$( this ).click();
						}
					});
				}
			}

			// TODO: pull out $.Widget's handling for the disabled option into
			// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
			// be overridden by individual plugins
			this._setOption( "disabled", options.disabled );
			this._resetButton();
		},

		_determineButtonType: function() {
			var ancestor, labelSelector, checked;

			if ( this.element.is("[type=checkbox]") ) {
				this.type = "checkbox";
			} else if ( this.element.is("[type=radio]") ) {
				this.type = "radio";
			} else if ( this.element.is("input") ) {
				this.type = "input";
			} else {
				this.type = "button";
			}

			if ( this.type === "checkbox" || this.type === "radio" ) {
				// we don't search against the document in case the element
				// is disconnected from the DOM
				ancestor = this.element.parents().last();
				labelSelector = "label[for='" + this.element.attr("id") + "']";
				this.buttonElement = ancestor.find( labelSelector );
				if ( !this.buttonElement.length ) {
					ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
					this.buttonElement = ancestor.filter( labelSelector );
					if ( !this.buttonElement.length ) {
						this.buttonElement = ancestor.find( labelSelector );
					}
				}
				this.element.addClass( "ui-helper-hidden-accessible" );

				checked = this.element.is( ":checked" );
				if ( checked ) {
					this.buttonElement.addClass( "ui-state-active" );
				}
				this.buttonElement.prop( "aria-pressed", checked );
			} else {
				this.buttonElement = this.element;
			}
		},

		widget: function() {
			return this.buttonElement;
		},

		_destroy: function() {
			this.element
				.removeClass( "ui-helper-hidden-accessible" );
			this.buttonElement
				.removeClass( baseClasses + " ui-state-active " + typeClasses )
				.removeAttr( "role" )
				.removeAttr( "aria-pressed" )
				.html( this.buttonElement.find(".ui-button-text").html() );

			if ( !this.hasTitle ) {
				this.buttonElement.removeAttr( "title" );
			}
		},

		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "disabled" ) {
				this.element.prop( "disabled", !!value );
				if ( value ) {
					this.buttonElement.removeClass( "ui-state-focus" );
				}
				return;
			}
			this._resetButton();
		},

		refresh: function() {
			//See #8237 & #8828
			var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

			if ( isDisabled !== this.options.disabled ) {
				this._setOption( "disabled", isDisabled );
			}
			if ( this.type === "radio" ) {
				radioGroup( this.element[0] ).each(function() {
					if ( $( this ).is( ":checked" ) ) {
						$( this ).button( "widget" )
							.addClass( "ui-state-active" )
							.attr( "aria-pressed", "true" );
					} else {
						$( this ).button( "widget" )
							.removeClass( "ui-state-active" )
							.attr( "aria-pressed", "false" );
					}
				});
			} else if ( this.type === "checkbox" ) {
				if ( this.element.is( ":checked" ) ) {
					this.buttonElement
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					this.buttonElement
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			}
		},

		_resetButton: function() {
			if ( this.type === "input" ) {
				if ( this.options.label ) {
					this.element.val( this.options.label );
				}
				return;
			}
			var buttonElement = this.buttonElement.removeClass( typeClasses ),
				buttonText = $( "<span></span>", this.document[0] )
					.addClass( "ui-button-text" )
					.html( this.options.label )
					.appendTo( buttonElement.empty() )
					.text(),
				icons = this.options.icons,
				multipleIcons = icons.primary && icons.secondary,
				buttonClasses = [];

			if ( icons.primary || icons.secondary ) {
				if ( this.options.text ) {
					buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
				}

				if ( icons.primary ) {
					buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
				}

				if ( icons.secondary ) {
					buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
				}

				if ( !this.options.text ) {
					buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

					if ( !this.hasTitle ) {
						buttonElement.attr( "title", $.trim( buttonText ) );
					}
				}
			} else {
				buttonClasses.push( "ui-button-text-only" );
			}
			buttonElement.addClass( buttonClasses.join( " " ) );
		}
	});

	$.widget( "ui.buttonset", {
		version: "1.10.4",
		options: {
			items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
		},

		_create: function() {
			this.element.addClass( "ui-buttonset" );
		},

		_init: function() {
			this.refresh();
		},

		_setOption: function( key, value ) {
			if ( key === "disabled" ) {
				this.buttons.button( "option", key, value );
			}

			this._super( key, value );
		},

		refresh: function() {
			var rtl = this.element.css( "direction" ) === "rtl";

			this.buttons = this.element.find( this.options.items )
				.filter( ":ui-button" )
					.button( "refresh" )
				.end()
				.not( ":ui-button" )
					.button()
				.end()
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
					.filter( ":first" )
						.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
					.end()
					.filter( ":last" )
						.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
					.end()
				.end();
		},

		_destroy: function() {
			this.element.removeClass( "ui-buttonset" );
			this.buttons
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-left ui-corner-right" )
				.end()
				.button( "destroy" );
		}
	});

	}( jQuery ) );
	(function( $, undefined ) {

	$.extend($.ui, { datepicker: { version: "1.10.4" } });

	var PROP_NAME = "datepicker",
		instActive;

	/* Date picker manager.
	   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
	   Settings for (groups of) date pickers are maintained in an instance object,
	   allowing multiple different settings on the same page. */

	function Datepicker() {
		this._curInst = null; // The current instance in use
		this._keyEvent = false; // If the last event was a key event
		this._disabledInputs = []; // List of date picker inputs that have been disabled
		this._datepickerShowing = false; // True if the popup picker is showing , false if not
		this._inDialog = false; // True if showing within a "dialog", false if not
		this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
		this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
		this._appendClass = "ui-datepicker-append"; // The name of the append marker class
		this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
		this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
		this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
		this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
		this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
		this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[""] = { // Default regional settings
			closeText: "Done", // Display text for close link
			prevText: "Prev", // Display text for previous month link
			nextText: "Next", // Display text for next month link
			currentText: "Today", // Display text for current month link
			monthNames: ["January","February","March","April","May","June",
				"July","August","September","October","November","December"], // Names of months for drop-down and formatting
			monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
			dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
			dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
			dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
			weekHeader: "Wk", // Column header for week of the year
			dateFormat: "mm/dd/yy", // See format options on parseDate
			firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
			isRTL: false, // True if right-to-left language, false if left-to-right
			showMonthAfterYear: false, // True if the year select precedes month, false for month then year
			yearSuffix: "" // Additional text to append to the year in the month headers
		};
		this._defaults = { // Global defaults for all the date picker instances
			showOn: "focus", // "focus" for popup on focus,
				// "button" for trigger button, or "both" for either
			showAnim: "fadeIn", // Name of jQuery animation for popup
			showOptions: {}, // Options for enhanced animations
			defaultDate: null, // Used when field is blank: actual date,
				// +/-number for offset from today, null for today
			appendText: "", // Display text following the input box, e.g. showing the format
			buttonText: "...", // Text for trigger button
			buttonImage: "", // URL for trigger button image
			buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
			hideIfNoPrevNext: false, // True to hide next/previous month links
				// if not applicable, false to just disable them
			navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
			gotoCurrent: false, // True if today link goes back to current selection instead
			changeMonth: false, // True if month can be selected directly, false if only prev/next
			changeYear: false, // True if year can be selected directly, false if only prev/next
			yearRange: "c-10:c+10", // Range of years to display in drop-down,
				// either relative to today's year (-nn:+nn), relative to currently displayed year
				// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
			showOtherMonths: false, // True to show dates in other months, false to leave blank
			selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
			showWeek: false, // True to show week of the year, false to not show it
			calculateWeek: this.iso8601Week, // How to calculate the week of the year,
				// takes a Date and returns the number of the week for it
			shortYearCutoff: "+10", // Short year values < this are in the current century,
				// > this are in the previous century,
				// string value starting with "+" for current year + value
			minDate: null, // The earliest selectable date, or null for no limit
			maxDate: null, // The latest selectable date, or null for no limit
			duration: "fast", // Duration of display/closure
			beforeShowDay: null, // Function that takes a date and returns an array with
				// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
				// [2] = cell title (optional), e.g. $.datepicker.noWeekends
			beforeShow: null, // Function that takes an input field and
				// returns a set of custom settings for the date picker
			onSelect: null, // Define a callback function when a date is selected
			onChangeMonthYear: null, // Define a callback function when the month or year is changed
			onClose: null, // Define a callback function when the datepicker is closed
			numberOfMonths: 1, // Number of months to show at a time
			showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
			stepMonths: 1, // Number of months to step back/forward
			stepBigMonths: 12, // Number of months to step back/forward for the big links
			altField: "", // Selector for an alternate field to store selected dates into
			altFormat: "", // The date format to use for the alternate field
			constrainInput: true, // The input is constrained by the current date format
			showButtonPanel: false, // True to show button panel, false to not show it
			autoSize: false, // True to size the input for the date format, false to leave as is
			disabled: false // The initial disabled state
		};
		$.extend(this._defaults, this.regional[""]);
		this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
	}

	$.extend(Datepicker.prototype, {
		/* Class name added to elements to indicate already configured with a date picker. */
		markerClassName: "hasDatepicker",

		//Keep track of the maximum number of rows displayed (see #7043)
		maxRows: 4,

		// TODO rename to "widget" when switching to widget factory
		_widgetDatepicker: function() {
			return this.dpDiv;
		},

		/* Override the default settings for all instances of the date picker.
		 * @param  settings  object - the new settings to use as defaults (anonymous object)
		 * @return the manager object
		 */
		setDefaults: function(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/* Attach the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
		 */
		_attachDatepicker: function(target, settings) {
			var nodeName, inline, inst;
			nodeName = target.nodeName.toLowerCase();
			inline = (nodeName === "div" || nodeName === "span");
			if (!target.id) {
				this.uuid += 1;
				target.id = "dp" + this.uuid;
			}
			inst = this._newInst($(target), inline);
			inst.settings = $.extend({}, settings || {});
			if (nodeName === "input") {
				this._connectDatepicker(target, inst);
			} else if (inline) {
				this._inlineDatepicker(target, inst);
			}
		},

		/* Create a new instance object. */
		_newInst: function(target, inline) {
			var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
			return {id: id, input: target, // associated target
				selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
				drawMonth: 0, drawYear: 0, // month being drawn
				inline: inline, // is datepicker inline or not
				dpDiv: (!inline ? this.dpDiv : // presentation div
				bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
		},

		/* Attach the date picker to an input field. */
		_connectDatepicker: function(target, inst) {
			var input = $(target);
			inst.append = $([]);
			inst.trigger = $([]);
			if (input.hasClass(this.markerClassName)) {
				return;
			}
			this._attachments(input, inst);
			input.addClass(this.markerClassName).keydown(this._doKeyDown).
				keypress(this._doKeyPress).keyup(this._doKeyUp);
			this._autoSize(inst);
			$.data(target, PROP_NAME, inst);
			//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
		},

		/* Make attachments based on settings. */
		_attachments: function(input, inst) {
			var showOn, buttonText, buttonImage,
				appendText = this._get(inst, "appendText"),
				isRTL = this._get(inst, "isRTL");

			if (inst.append) {
				inst.append.remove();
			}
			if (appendText) {
				inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
				input[isRTL ? "before" : "after"](inst.append);
			}

			input.unbind("focus", this._showDatepicker);

			if (inst.trigger) {
				inst.trigger.remove();
			}

			showOn = this._get(inst, "showOn");
			if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
				input.focus(this._showDatepicker);
			}
			if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
				buttonText = this._get(inst, "buttonText");
				buttonImage = this._get(inst, "buttonImage");
				inst.trigger = $(this._get(inst, "buttonImageOnly") ?
					$("<img/>").addClass(this._triggerClass).
						attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
					$("<button type='button'></button>").addClass(this._triggerClass).
						html(!buttonImage ? buttonText : $("<img/>").attr(
						{ src:buttonImage, alt:buttonText, title:buttonText })));
				input[isRTL ? "before" : "after"](inst.trigger);
				inst.trigger.click(function() {
					if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
						$.datepicker._hideDatepicker();
					} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
						$.datepicker._hideDatepicker();
						$.datepicker._showDatepicker(input[0]);
					} else {
						$.datepicker._showDatepicker(input[0]);
					}
					return false;
				});
			}
		},

		/* Apply the maximum length for the date format. */
		_autoSize: function(inst) {
			if (this._get(inst, "autoSize") && !inst.inline) {
				var findMax, max, maxI, i,
					date = new Date(2009, 12 - 1, 20), // Ensure double digits
					dateFormat = this._get(inst, "dateFormat");

				if (dateFormat.match(/[DM]/)) {
					findMax = function(names) {
						max = 0;
						maxI = 0;
						for (i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
						"monthNames" : "monthNamesShort"))));
					date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
						"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
				}
				inst.input.attr("size", this._formatDate(inst, date).length);
			}
		},

		/* Attach an inline date picker to a div. */
		_inlineDatepicker: function(target, inst) {
			var divSpan = $(target);
			if (divSpan.hasClass(this.markerClassName)) {
				return;
			}
			divSpan.addClass(this.markerClassName).append(inst.dpDiv);
			$.data(target, PROP_NAME, inst);
			this._setDate(inst, this._getDefaultDate(inst), true);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
			//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
			// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
			// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
			inst.dpDiv.css( "display", "block" );
		},

		/* Pop-up the date picker in a "dialog" box.
		 * @param  input element - ignored
		 * @param  date	string or Date - the initial date to display
		 * @param  onSelect  function - the function to call when a date is selected
		 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
		 * @param  pos int[2] - coordinates for the dialog's position within the screen or
		 *					event - with x/y coordinates or
		 *					leave empty for default (screen centre)
		 * @return the manager object
		 */
		_dialogDatepicker: function(input, date, onSelect, settings, pos) {
			var id, browserWidth, browserHeight, scrollX, scrollY,
				inst = this._dialogInst; // internal instance

			if (!inst) {
				this.uuid += 1;
				id = "dp" + this.uuid;
				this._dialogInput = $("<input type='text' id='" + id +
					"' style='position: absolute; top: -100px; width: 0px;'/>");
				this._dialogInput.keydown(this._doKeyDown);
				$("body").append(this._dialogInput);
				inst = this._dialogInst = this._newInst(this._dialogInput, false);
				inst.settings = {};
				$.data(this._dialogInput[0], PROP_NAME, inst);
			}
			extendRemove(inst.settings, settings || {});
			date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
			this._dialogInput.val(date);

			this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
			if (!this._pos) {
				browserWidth = document.documentElement.clientWidth;
				browserHeight = document.documentElement.clientHeight;
				scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
				scrollY = document.documentElement.scrollTop || document.body.scrollTop;
				this._pos = // should use actual width/height below
					[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
			}

			// move input on screen for focus, but hidden behind dialog
			this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
			inst.settings.onSelect = onSelect;
			this._inDialog = true;
			this.dpDiv.addClass(this._dialogClass);
			this._showDatepicker(this._dialogInput[0]);
			if ($.blockUI) {
				$.blockUI(this.dpDiv);
			}
			$.data(this._dialogInput[0], PROP_NAME, inst);
			return this;
		},

		/* Detach a datepicker from its control.
		 * @param  target	element - the target input field or division or span
		 */
		_destroyDatepicker: function(target) {
			var nodeName,
				$target = $(target),
				inst = $.data(target, PROP_NAME);

			if (!$target.hasClass(this.markerClassName)) {
				return;
			}

			nodeName = target.nodeName.toLowerCase();
			$.removeData(target, PROP_NAME);
			if (nodeName === "input") {
				inst.append.remove();
				inst.trigger.remove();
				$target.removeClass(this.markerClassName).
					unbind("focus", this._showDatepicker).
					unbind("keydown", this._doKeyDown).
					unbind("keypress", this._doKeyPress).
					unbind("keyup", this._doKeyUp);
			} else if (nodeName === "div" || nodeName === "span") {
				$target.removeClass(this.markerClassName).empty();
			}
		},

		/* Enable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_enableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, PROP_NAME);

			if (!$target.hasClass(this.markerClassName)) {
				return;
			}

			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = false;
				inst.trigger.filter("button").
					each(function() { this.disabled = false; }).end().
					filter("img").css({opacity: "1.0", cursor: ""});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().removeClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", false);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
		},

		/* Disable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_disableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, PROP_NAME);

			if (!$target.hasClass(this.markerClassName)) {
				return;
			}

			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = true;
				inst.trigger.filter("button").
					each(function() { this.disabled = true; }).end().
					filter("img").css({opacity: "0.5", cursor: "default"});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().addClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", true);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
			this._disabledInputs[this._disabledInputs.length] = target;
		},

		/* Is the first field in a jQuery collection disabled as a datepicker?
		 * @param  target	element - the target input field or division or span
		 * @return boolean - true if disabled, false if enabled
		 */
		_isDisabledDatepicker: function(target) {
			if (!target) {
				return false;
			}
			for (var i = 0; i < this._disabledInputs.length; i++) {
				if (this._disabledInputs[i] === target) {
					return true;
				}
			}
			return false;
		},

		/* Retrieve the instance data for the target control.
		 * @param  target  element - the target input field or division or span
		 * @return  object - the associated instance data
		 * @throws  error if a jQuery problem getting data
		 */
		_getInst: function(target) {
			try {
				return $.data(target, PROP_NAME);
			}
			catch (err) {
				throw "Missing instance data for this datepicker";
			}
		},

		/* Update or retrieve the settings for a date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 * @param  name	object - the new settings to update or
		 *				string - the name of the setting to change or retrieve,
		 *				when retrieving also "all" for all instance settings or
		 *				"defaults" for all global defaults
		 * @param  value   any - the new value for the setting
		 *				(omit if above is an object or to retrieve a value)
		 */
		_optionDatepicker: function(target, name, value) {
			var settings, date, minDate, maxDate,
				inst = this._getInst(target);

			if (arguments.length === 2 && typeof name === "string") {
				return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
					(inst ? (name === "all" ? $.extend({}, inst.settings) :
					this._get(inst, name)) : null));
			}

			settings = name || {};
			if (typeof name === "string") {
				settings = {};
				settings[name] = value;
			}

			if (inst) {
				if (this._curInst === inst) {
					this._hideDatepicker();
				}

				date = this._getDateDatepicker(target, true);
				minDate = this._getMinMaxDate(inst, "min");
				maxDate = this._getMinMaxDate(inst, "max");
				extendRemove(inst.settings, settings);
				// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
				if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
					inst.settings.minDate = this._formatDate(inst, minDate);
				}
				if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
					inst.settings.maxDate = this._formatDate(inst, maxDate);
				}
				if ( "disabled" in settings ) {
					if ( settings.disabled ) {
						this._disableDatepicker(target);
					} else {
						this._enableDatepicker(target);
					}
				}
				this._attachments($(target), inst);
				this._autoSize(inst);
				this._setDate(inst, date);
				this._updateAlternate(inst);
				this._updateDatepicker(inst);
			}
		},

		// change method deprecated
		_changeDatepicker: function(target, name, value) {
			this._optionDatepicker(target, name, value);
		},

		/* Redraw the date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 */
		_refreshDatepicker: function(target) {
			var inst = this._getInst(target);
			if (inst) {
				this._updateDatepicker(inst);
			}
		},

		/* Set the dates for a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  date	Date - the new date
		 */
		_setDateDatepicker: function(target, date) {
			var inst = this._getInst(target);
			if (inst) {
				this._setDate(inst, date);
				this._updateDatepicker(inst);
				this._updateAlternate(inst);
			}
		},

		/* Get the date(s) for the first entry in a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  noDefault boolean - true if no default date is to be used
		 * @return Date - the current date
		 */
		_getDateDatepicker: function(target, noDefault) {
			var inst = this._getInst(target);
			if (inst && !inst.inline) {
				this._setDateFromField(inst, noDefault);
			}
			return (inst ? this._getDate(inst) : null);
		},

		/* Handle keystrokes. */
		_doKeyDown: function(event) {
			var onSelect, dateStr, sel,
				inst = $.datepicker._getInst(event.target),
				handled = true,
				isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

			inst._keyEvent = true;
			if ($.datepicker._datepickerShowing) {
				switch (event.keyCode) {
					case 9: $.datepicker._hideDatepicker();
							handled = false;
							break; // hide on tab out
					case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
										$.datepicker._currentClass + ")", inst.dpDiv);
							if (sel[0]) {
								$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							}

							onSelect = $.datepicker._get(inst, "onSelect");
							if (onSelect) {
								dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							} else {
								$.datepicker._hideDatepicker();
							}

							return false; // don't submit the form
					case 27: $.datepicker._hideDatepicker();
							break; // hide on escape
					case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
							break; // previous month/year on page up/+ ctrl
					case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
							break; // next month/year on page down/+ ctrl
					case 35: if (event.ctrlKey || event.metaKey) {
								$.datepicker._clearDate(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // clear on ctrl or command +end
					case 36: if (event.ctrlKey || event.metaKey) {
								$.datepicker._gotoToday(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // current on ctrl or command +home
					case 37: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// -1 day on ctrl or command +left
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, "stepBigMonths") :
									-$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +left on Mac
							break;
					case 38: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, -7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // -1 week on ctrl or command +up
					case 39: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// +1 day on ctrl or command +right
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, "stepBigMonths") :
									+$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +right
							break;
					case 40: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, +7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // +1 week on ctrl or command +down
					default: handled = false;
				}
			} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
				$.datepicker._showDatepicker(this);
			} else {
				handled = false;
			}

			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
		},

		/* Filter entered characters - based on date format. */
		_doKeyPress: function(event) {
			var chars, chr,
				inst = $.datepicker._getInst(event.target);

			if ($.datepicker._get(inst, "constrainInput")) {
				chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
				chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
				return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
			}
		},

		/* Synchronise manual entry and field/alternate field. */
		_doKeyUp: function(event) {
			var date,
				inst = $.datepicker._getInst(event.target);

			if (inst.input.val() !== inst.lastVal) {
				try {
					date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						(inst.input ? inst.input.val() : null),
						$.datepicker._getFormatConfig(inst));

					if (date) { // only if valid
						$.datepicker._setDateFromField(inst);
						$.datepicker._updateAlternate(inst);
						$.datepicker._updateDatepicker(inst);
					}
				}
				catch (err) {
				}
			}
			return true;
		},

		/* Pop-up the date picker for a given input field.
		 * If false returned from beforeShow event handler do not show.
		 * @param  input  element - the input field attached to the date picker or
		 *					event - if triggered by focus
		 */
		_showDatepicker: function(input) {
			input = input.target || input;
			if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
				input = $("input", input.parentNode)[0];
			}

			if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
				return;
			}

			var inst, beforeShow, beforeShowSettings, isFixed,
				offset, showAnim, duration;

			inst = $.datepicker._getInst(input);
			if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
				$.datepicker._curInst.dpDiv.stop(true, true);
				if ( inst && $.datepicker._datepickerShowing ) {
					$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
				}
			}

			beforeShow = $.datepicker._get(inst, "beforeShow");
			beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
			if(beforeShowSettings === false){
				return;
			}
			extendRemove(inst.settings, beforeShowSettings);

			inst.lastVal = null;
			$.datepicker._lastInput = input;
			$.datepicker._setDateFromField(inst);

			if ($.datepicker._inDialog) { // hide cursor
				input.value = "";
			}
			if (!$.datepicker._pos) { // position below input
				$.datepicker._pos = $.datepicker._findPos(input);
				$.datepicker._pos[1] += input.offsetHeight; // add the height
			}

			isFixed = false;
			$(input).parents().each(function() {
				isFixed |= $(this).css("position") === "fixed";
				return !isFixed;
			});

			offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
			$.datepicker._pos = null;
			//to avoid flashes on Firefox
			inst.dpDiv.empty();
			// determine sizing offscreen
			inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
			$.datepicker._updateDatepicker(inst);
			// fix width for dynamic number of date pickers
			// and adjust position before showing
			offset = $.datepicker._checkOffset(inst, offset, isFixed);
			inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
				"static" : (isFixed ? "fixed" : "absolute")), display: "none",
				left: offset.left + "px", top: offset.top + "px"});

			if (!inst.inline) {
				showAnim = $.datepicker._get(inst, "showAnim");
				duration = $.datepicker._get(inst, "duration");
				inst.dpDiv.zIndex($(input).zIndex()+1);
				$.datepicker._datepickerShowing = true;

				if ( $.effects && $.effects.effect[ showAnim ] ) {
					inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
				} else {
					inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
				}

				if ( $.datepicker._shouldFocusInput( inst ) ) {
					inst.input.focus();
				}

				$.datepicker._curInst = inst;
			}
		},

		/* Generate the date picker content. */
		_updateDatepicker: function(inst) {
			this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
			instActive = inst; // for delegate hover events
			inst.dpDiv.empty().append(this._generateHTML(inst));
			this._attachHandlers(inst);
			inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

			var origyearshtml,
				numMonths = this._getNumberOfMonths(inst),
				cols = numMonths[1],
				width = 17;

			inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
			if (cols > 1) {
				inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
			}
			inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
				"Class"]("ui-datepicker-multi");
			inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
				"Class"]("ui-datepicker-rtl");

			if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			// deffered render of the years select (to avoid flashes on Firefox)
			if( inst.yearshtml ){
				origyearshtml = inst.yearshtml;
				setTimeout(function(){
					//assure that inst.yearshtml didn't change.
					if( origyearshtml === inst.yearshtml && inst.yearshtml ){
						inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
					}
					origyearshtml = inst.yearshtml = null;
				}, 0);
			}
		},

		// #6694 - don't focus the input if it's already focused
		// this breaks the change event in IE
		// Support: IE and jQuery <1.9
		_shouldFocusInput: function( inst ) {
			return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
		},

		/* Check positioning to remain on screen. */
		_checkOffset: function(inst, offset, isFixed) {
			var dpWidth = inst.dpDiv.outerWidth(),
				dpHeight = inst.dpDiv.outerHeight(),
				inputWidth = inst.input ? inst.input.outerWidth() : 0,
				inputHeight = inst.input ? inst.input.outerHeight() : 0,
				viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
				viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

			offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
			offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
			offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

			// now check if datepicker is showing outside window viewport - move to a better place if so.
			offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
				Math.abs(offset.left + dpWidth - viewWidth) : 0);
			offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
				Math.abs(dpHeight + inputHeight) : 0);

			return offset;
		},

		/* Find an object's position on the screen. */
		_findPos: function(obj) {
			var position,
				inst = this._getInst(obj),
				isRTL = this._get(inst, "isRTL");

			while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
				obj = obj[isRTL ? "previousSibling" : "nextSibling"];
			}

			position = $(obj).offset();
			return [position.left, position.top];
		},

		/* Hide the date picker from view.
		 * @param  input  element - the input field attached to the date picker
		 */
		_hideDatepicker: function(input) {
			var showAnim, duration, postProcess, onClose,
				inst = this._curInst;

			if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
				return;
			}

			if (this._datepickerShowing) {
				showAnim = this._get(inst, "showAnim");
				duration = this._get(inst, "duration");
				postProcess = function() {
					$.datepicker._tidyDialog(inst);
				};

				// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
				if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
					inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
				} else {
					inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
						(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
				}

				if (!showAnim) {
					postProcess();
				}
				this._datepickerShowing = false;

				onClose = this._get(inst, "onClose");
				if (onClose) {
					onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
				}

				this._lastInput = null;
				if (this._inDialog) {
					this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
					if ($.blockUI) {
						$.unblockUI();
						$("body").append(this.dpDiv);
					}
				}
				this._inDialog = false;
			}
		},

		/* Tidy up after a dialog display. */
		_tidyDialog: function(inst) {
			inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
		},

		/* Close date picker if clicked elsewhere. */
		_checkExternalClick: function(event) {
			if (!$.datepicker._curInst) {
				return;
			}

			var $target = $(event.target),
				inst = $.datepicker._getInst($target[0]);

			if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
					$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
					!$target.hasClass($.datepicker.markerClassName) &&
					!$target.closest("." + $.datepicker._triggerClass).length &&
					$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
				( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
					$.datepicker._hideDatepicker();
			}
		},

		/* Adjust one of the date sub-fields. */
		_adjustDate: function(id, offset, period) {
			var target = $(id),
				inst = this._getInst(target[0]);

			if (this._isDisabledDatepicker(target[0])) {
				return;
			}
			this._adjustInstDate(inst, offset +
				(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
				period);
			this._updateDatepicker(inst);
		},

		/* Action for current link. */
		_gotoToday: function(id) {
			var date,
				target = $(id),
				inst = this._getInst(target[0]);

			if (this._get(inst, "gotoCurrent") && inst.currentDay) {
				inst.selectedDay = inst.currentDay;
				inst.drawMonth = inst.selectedMonth = inst.currentMonth;
				inst.drawYear = inst.selectedYear = inst.currentYear;
			} else {
				date = new Date();
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
			}
			this._notifyChange(inst);
			this._adjustDate(target);
		},

		/* Action for selecting a new month/year. */
		_selectMonthYear: function(id, select, period) {
			var target = $(id),
				inst = this._getInst(target[0]);

			inst["selected" + (period === "M" ? "Month" : "Year")] =
			inst["draw" + (period === "M" ? "Month" : "Year")] =
				parseInt(select.options[select.selectedIndex].value,10);

			this._notifyChange(inst);
			this._adjustDate(target);
		},

		/* Action for selecting a day. */
		_selectDay: function(id, month, year, td) {
			var inst,
				target = $(id);

			if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
				return;
			}

			inst = this._getInst(target[0]);
			inst.selectedDay = inst.currentDay = $("a", td).html();
			inst.selectedMonth = inst.currentMonth = month;
			inst.selectedYear = inst.currentYear = year;
			this._selectDate(id, this._formatDate(inst,
				inst.currentDay, inst.currentMonth, inst.currentYear));
		},

		/* Erase the input field and hide the date picker. */
		_clearDate: function(id) {
			var target = $(id);
			this._selectDate(target, "");
		},

		/* Update the input field with the selected date. */
		_selectDate: function(id, dateStr) {
			var onSelect,
				target = $(id),
				inst = this._getInst(target[0]);

			dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
			if (inst.input) {
				inst.input.val(dateStr);
			}
			this._updateAlternate(inst);

			onSelect = this._get(inst, "onSelect");
			if (onSelect) {
				onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
			} else if (inst.input) {
				inst.input.trigger("change"); // fire the change event
			}

			if (inst.inline){
				this._updateDatepicker(inst);
			} else {
				this._hideDatepicker();
				this._lastInput = inst.input[0];
				if (typeof(inst.input[0]) !== "object") {
					inst.input.focus(); // restore focus
				}
				this._lastInput = null;
			}
		},

		/* Update any alternate field to synchronise with the main field. */
		_updateAlternate: function(inst) {
			var altFormat, date, dateStr,
				altField = this._get(inst, "altField");

			if (altField) { // update alternate field too
				altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
				date = this._getDate(inst);
				dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
				$(altField).each(function() { $(this).val(dateStr); });
			}
		},

		/* Set as beforeShowDay function to prevent selection of weekends.
		 * @param  date  Date - the date to customise
		 * @return [boolean, string] - is this date selectable?, what is its CSS class?
		 */
		noWeekends: function(date) {
			var day = date.getDay();
			return [(day > 0 && day < 6), ""];
		},

		/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
		 * @param  date  Date - the date to get the week for
		 * @return  number - the number of the week within the year that contains this date
		 */
		iso8601Week: function(date) {
			var time,
				checkDate = new Date(date.getTime());

			// Find Thursday of this week starting on Monday
			checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

			time = checkDate.getTime();
			checkDate.setMonth(0); // Compare with Jan 1
			checkDate.setDate(1);
			return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
		},

		/* Parse a string value into a date object.
		 * See formatDate below for the possible formats.
		 *
		 * @param  format string - the expected format of the date
		 * @param  value string - the date in the above format
		 * @param  settings Object - attributes include:
		 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  Date - the extracted date value or null if value is blank
		 */
		parseDate: function (format, value, settings) {
			if (format == null || value == null) {
				throw "Invalid arguments";
			}

			value = (typeof value === "object" ? value.toString() : value + "");
			if (value === "") {
				return null;
			}

			var iFormat, dim, extra,
				iValue = 0,
				shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
				shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
					new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				year = -1,
				month = -1,
				day = -1,
				doy = -1,
				literal = false,
				date,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Extract a number from the string value
				getNumber = function(match) {
					var isDoubled = lookAhead(match),
						size = (match === "@" ? 14 : (match === "!" ? 20 :
						(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
						digits = new RegExp("^\\d{1," + size + "}"),
						num = value.substring(iValue).match(digits);
					if (!num) {
						throw "Missing number at position " + iValue;
					}
					iValue += num[0].length;
					return parseInt(num[0], 10);
				},
				// Extract a name from the string value and convert to an index
				getName = function(match, shortNames, longNames) {
					var index = -1,
						names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
							return [ [k, v] ];
						}).sort(function (a, b) {
							return -(a[1].length - b[1].length);
						});

					$.each(names, function (i, pair) {
						var name = pair[1];
						if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
							index = pair[0];
							iValue += name.length;
							return false;
						}
					});
					if (index !== -1) {
						return index + 1;
					} else {
						throw "Unknown name at position " + iValue;
					}
				},
				// Confirm that a literal character matches the string value
				checkLiteral = function() {
					if (value.charAt(iValue) !== format.charAt(iFormat)) {
						throw "Unexpected literal at position " + iValue;
					}
					iValue++;
				};

			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						checkLiteral();
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							day = getNumber("d");
							break;
						case "D":
							getName("D", dayNamesShort, dayNames);
							break;
						case "o":
							doy = getNumber("o");
							break;
						case "m":
							month = getNumber("m");
							break;
						case "M":
							month = getName("M", monthNamesShort, monthNames);
							break;
						case "y":
							year = getNumber("y");
							break;
						case "@":
							date = new Date(getNumber("@"));
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "!":
							date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "'":
							if (lookAhead("'")){
								checkLiteral();
							} else {
								literal = true;
							}
							break;
						default:
							checkLiteral();
					}
				}
			}

			if (iValue < value.length){
				extra = value.substr(iValue);
				if (!/^\s+/.test(extra)) {
					throw "Extra/unparsed characters found in date: " + extra;
				}
			}

			if (year === -1) {
				year = new Date().getFullYear();
			} else if (year < 100) {
				year += new Date().getFullYear() - new Date().getFullYear() % 100 +
					(year <= shortYearCutoff ? 0 : -100);
			}

			if (doy > -1) {
				month = 1;
				day = doy;
				do {
					dim = this._getDaysInMonth(year, month - 1);
					if (day <= dim) {
						break;
					}
					month++;
					day -= dim;
				} while (true);
			}

			date = this._daylightSavingAdjust(new Date(year, month - 1, day));
			if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
				throw "Invalid date"; // E.g. 31/02/00
			}
			return date;
		},

		/* Standard date formats. */
		ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
		COOKIE: "D, dd M yy",
		ISO_8601: "yy-mm-dd",
		RFC_822: "D, d M y",
		RFC_850: "DD, dd-M-y",
		RFC_1036: "D, d M y",
		RFC_1123: "D, d M yy",
		RFC_2822: "D, d M yy",
		RSS: "D, d M y", // RFC 822
		TICKS: "!",
		TIMESTAMP: "@",
		W3C: "yy-mm-dd", // ISO 8601

		_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
			Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

		/* Format a date object into a string value.
		 * The format can be combinations of the following:
		 * d  - day of month (no leading zero)
		 * dd - day of month (two digit)
		 * o  - day of year (no leading zeros)
		 * oo - day of year (three digit)
		 * D  - day name short
		 * DD - day name long
		 * m  - month of year (no leading zero)
		 * mm - month of year (two digit)
		 * M  - month name short
		 * MM - month name long
		 * y  - year (two digit)
		 * yy - year (four digit)
		 * @ - Unix timestamp (ms since 01/01/1970)
		 * ! - Windows ticks (100ns since 01/01/0001)
		 * "..." - literal text
		 * '' - single quote
		 *
		 * @param  format string - the desired format of the date
		 * @param  date Date - the date value to format
		 * @param  settings Object - attributes include:
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  string - the date in the above format
		 */
		formatDate: function (format, date, settings) {
			if (!date) {
				return "";
			}

			var iFormat,
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Format a number, with leading zero if necessary
				formatNumber = function(match, value, len) {
					var num = "" + value;
					if (lookAhead(match)) {
						while (num.length < len) {
							num = "0" + num;
						}
					}
					return num;
				},
				// Format a name, short or long as requested
				formatName = function(match, value, shortNames, longNames) {
					return (lookAhead(match) ? longNames[value] : shortNames[value]);
				},
				output = "",
				literal = false;

			if (date) {
				for (iFormat = 0; iFormat < format.length; iFormat++) {
					if (literal) {
						if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
							literal = false;
						} else {
							output += format.charAt(iFormat);
						}
					} else {
						switch (format.charAt(iFormat)) {
							case "d":
								output += formatNumber("d", date.getDate(), 2);
								break;
							case "D":
								output += formatName("D", date.getDay(), dayNamesShort, dayNames);
								break;
							case "o":
								output += formatNumber("o",
									Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
								break;
							case "m":
								output += formatNumber("m", date.getMonth() + 1, 2);
								break;
							case "M":
								output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
								break;
							case "y":
								output += (lookAhead("y") ? date.getFullYear() :
									(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
								break;
							case "@":
								output += date.getTime();
								break;
							case "!":
								output += date.getTime() * 10000 + this._ticksTo1970;
								break;
							case "'":
								if (lookAhead("'")) {
									output += "'";
								} else {
									literal = true;
								}
								break;
							default:
								output += format.charAt(iFormat);
						}
					}
				}
			}
			return output;
		},

		/* Extract all possible characters from the date format. */
		_possibleChars: function (format) {
			var iFormat,
				chars = "",
				literal = false,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				};

			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						chars += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d": case "m": case "y": case "@":
							chars += "0123456789";
							break;
						case "D": case "M":
							return null; // Accept anything
						case "'":
							if (lookAhead("'")) {
								chars += "'";
							} else {
								literal = true;
							}
							break;
						default:
							chars += format.charAt(iFormat);
					}
				}
			}
			return chars;
		},

		/* Get a setting value, defaulting if necessary. */
		_get: function(inst, name) {
			return inst.settings[name] !== undefined ?
				inst.settings[name] : this._defaults[name];
		},

		/* Parse existing date and initialise date picker. */
		_setDateFromField: function(inst, noDefault) {
			if (inst.input.val() === inst.lastVal) {
				return;
			}

			var dateFormat = this._get(inst, "dateFormat"),
				dates = inst.lastVal = inst.input ? inst.input.val() : null,
				defaultDate = this._getDefaultDate(inst),
				date = defaultDate,
				settings = this._getFormatConfig(inst);

			try {
				date = this.parseDate(dateFormat, dates, settings) || defaultDate;
			} catch (event) {
				dates = (noDefault ? "" : dates);
			}
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			inst.currentDay = (dates ? date.getDate() : 0);
			inst.currentMonth = (dates ? date.getMonth() : 0);
			inst.currentYear = (dates ? date.getFullYear() : 0);
			this._adjustInstDate(inst);
		},

		/* Retrieve the default date shown on opening. */
		_getDefaultDate: function(inst) {
			return this._restrictMinMax(inst,
				this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
		},

		/* A date may be specified as an exact value or a relative one. */
		_determineDate: function(inst, date, defaultDate) {
			var offsetNumeric = function(offset) {
					var date = new Date();
					date.setDate(date.getDate() + offset);
					return date;
				},
				offsetString = function(offset) {
					try {
						return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
							offset, $.datepicker._getFormatConfig(inst));
					}
					catch (e) {
						// Ignore
					}

					var date = (offset.toLowerCase().match(/^c/) ?
						$.datepicker._getDate(inst) : null) || new Date(),
						year = date.getFullYear(),
						month = date.getMonth(),
						day = date.getDate(),
						pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
						matches = pattern.exec(offset);

					while (matches) {
						switch (matches[2] || "d") {
							case "d" : case "D" :
								day += parseInt(matches[1],10); break;
							case "w" : case "W" :
								day += parseInt(matches[1],10) * 7; break;
							case "m" : case "M" :
								month += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
							case "y": case "Y" :
								year += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
						}
						matches = pattern.exec(offset);
					}
					return new Date(year, month, day);
				},
				newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
					(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

			newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
			if (newDate) {
				newDate.setHours(0);
				newDate.setMinutes(0);
				newDate.setSeconds(0);
				newDate.setMilliseconds(0);
			}
			return this._daylightSavingAdjust(newDate);
		},

		/* Handle switch to/from daylight saving.
		 * Hours may be non-zero on daylight saving cut-over:
		 * > 12 when midnight changeover, but then cannot generate
		 * midnight datetime, so jump to 1AM, otherwise reset.
		 * @param  date  (Date) the date to check
		 * @return  (Date) the corrected date
		 */
		_daylightSavingAdjust: function(date) {
			if (!date) {
				return null;
			}
			date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
			return date;
		},

		/* Set the date(s) directly. */
		_setDate: function(inst, date, noChange) {
			var clear = !date,
				origMonth = inst.selectedMonth,
				origYear = inst.selectedYear,
				newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

			inst.selectedDay = inst.currentDay = newDate.getDate();
			inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
			inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
			if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
				this._notifyChange(inst);
			}
			this._adjustInstDate(inst);
			if (inst.input) {
				inst.input.val(clear ? "" : this._formatDate(inst));
			}
		},

		/* Retrieve the date(s) directly. */
		_getDate: function(inst) {
			var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
				this._daylightSavingAdjust(new Date(
				inst.currentYear, inst.currentMonth, inst.currentDay)));
				return startDate;
		},

		/* Attach the onxxx handlers.  These are declared statically so
		 * they work with static code transformers like Caja.
		 */
		_attachHandlers: function(inst) {
			var stepMonths = this._get(inst, "stepMonths"),
				id = "#" + inst.id.replace( /\\\\/g, "\\" );
			inst.dpDiv.find("[data-handler]").map(function () {
				var handler = {
					prev: function () {
						$.datepicker._adjustDate(id, -stepMonths, "M");
					},
					next: function () {
						$.datepicker._adjustDate(id, +stepMonths, "M");
					},
					hide: function () {
						$.datepicker._hideDatepicker();
					},
					today: function () {
						$.datepicker._gotoToday(id);
					},
					selectDay: function () {
						$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
						return false;
					},
					selectMonth: function () {
						$.datepicker._selectMonthYear(id, this, "M");
						return false;
					},
					selectYear: function () {
						$.datepicker._selectMonthYear(id, this, "Y");
						return false;
					}
				};
				$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
			});
		},

		/* Generate the HTML for the current state of the date picker. */
		_generateHTML: function(inst) {
			var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
				controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
				monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
				selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
				cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
				printDate, dRow, tbody, daySettings, otherMonth, unselectable,
				tempDate = new Date(),
				today = this._daylightSavingAdjust(
					new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
				isRTL = this._get(inst, "isRTL"),
				showButtonPanel = this._get(inst, "showButtonPanel"),
				hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
				navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
				numMonths = this._getNumberOfMonths(inst),
				showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
				stepMonths = this._get(inst, "stepMonths"),
				isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
				currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
					new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				drawMonth = inst.drawMonth - showCurrentAtPos,
				drawYear = inst.drawYear;

			if (drawMonth < 0) {
				drawMonth += 12;
				drawYear--;
			}
			if (maxDate) {
				maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
					maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
				maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
				while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
					drawMonth--;
					if (drawMonth < 0) {
						drawMonth = 11;
						drawYear--;
					}
				}
			}
			inst.drawMonth = drawMonth;
			inst.drawYear = drawYear;

			prevText = this._get(inst, "prevText");
			prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
				this._getFormatConfig(inst)));

			prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
				" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

			nextText = this._get(inst, "nextText");
			nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
				this._getFormatConfig(inst)));

			next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
				" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

			currentText = this._get(inst, "currentText");
			gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
			currentText = (!navigationAsDateFormat ? currentText :
				this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

			controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
				this._get(inst, "closeText") + "</button>" : "");

			buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
				(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
				">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

			firstDay = parseInt(this._get(inst, "firstDay"),10);
			firstDay = (isNaN(firstDay) ? 0 : firstDay);

			showWeek = this._get(inst, "showWeek");
			dayNames = this._get(inst, "dayNames");
			dayNamesMin = this._get(inst, "dayNamesMin");
			monthNames = this._get(inst, "monthNames");
			monthNamesShort = this._get(inst, "monthNamesShort");
			beforeShowDay = this._get(inst, "beforeShowDay");
			showOtherMonths = this._get(inst, "showOtherMonths");
			selectOtherMonths = this._get(inst, "selectOtherMonths");
			defaultDate = this._getDefaultDate(inst);
			html = "";
			dow;
			for (row = 0; row < numMonths[0]; row++) {
				group = "";
				this.maxRows = 4;
				for (col = 0; col < numMonths[1]; col++) {
					selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
					cornerClass = " ui-corner-all";
					calender = "";
					if (isMultiMonth) {
						calender += "<div class='ui-datepicker-group";
						if (numMonths[1] > 1) {
							switch (col) {
								case 0: calender += " ui-datepicker-group-first";
									cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
								case numMonths[1]-1: calender += " ui-datepicker-group-last";
									cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
								default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
							}
						}
						calender += "'>";
					}
					calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
						(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
						(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
						this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
						row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
						"</div><table class='ui-datepicker-calendar'><thead>" +
						"<tr>";
					thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
					for (dow = 0; dow < 7; dow++) { // days of the week
						day = (dow + firstDay) % 7;
						thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
							"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
					}
					calender += thead + "</tr></thead><tbody>";
					daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
					if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
						inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
					}
					leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
					curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
					numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
					this.maxRows = numRows;
					printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
					for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
						calender += "<tr>";
						tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
							this._get(inst, "calculateWeek")(printDate) + "</td>");
						for (dow = 0; dow < 7; dow++) { // create date picker days
							daySettings = (beforeShowDay ?
								beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
							otherMonth = (printDate.getMonth() !== drawMonth);
							unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
								(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
							tbody += "<td class='" +
								((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
								(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
								((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
								(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
								// or defaultDate is current printedDate and defaultDate is selectedDate
								" " + this._dayOverClass : "") + // highlight selected day
								(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
								(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
								(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
								(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
								((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
								(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
								(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
								(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
								(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
								(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
								(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
								"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
							printDate.setDate(printDate.getDate() + 1);
							printDate = this._daylightSavingAdjust(printDate);
						}
						calender += tbody + "</tr>";
					}
					drawMonth++;
					if (drawMonth > 11) {
						drawMonth = 0;
						drawYear++;
					}
					calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
								((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
					group += calender;
				}
				html += group;
			}
			html += buttonPanel;
			inst._keyEvent = false;
			return html;
		},

		/* Generate the month and year header. */
		_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
				secondary, monthNames, monthNamesShort) {

			var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
				changeMonth = this._get(inst, "changeMonth"),
				changeYear = this._get(inst, "changeYear"),
				showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
				html = "<div class='ui-datepicker-title'>",
				monthHtml = "";

			// month selection
			if (secondary || !changeMonth) {
				monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
			} else {
				inMinYear = (minDate && minDate.getFullYear() === drawYear);
				inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
				monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
				for ( month = 0; month < 12; month++) {
					if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
						monthHtml += "<option value='" + month + "'" +
							(month === drawMonth ? " selected='selected'" : "") +
							">" + monthNamesShort[month] + "</option>";
					}
				}
				monthHtml += "</select>";
			}

			if (!showMonthAfterYear) {
				html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
			}

			// year selection
			if ( !inst.yearshtml ) {
				inst.yearshtml = "";
				if (secondary || !changeYear) {
					html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
				} else {
					// determine range of years to display
					years = this._get(inst, "yearRange").split(":");
					thisYear = new Date().getFullYear();
					determineYear = function(value) {
						var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
							(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
							parseInt(value, 10)));
						return (isNaN(year) ? thisYear : year);
					};
					year = determineYear(years[0]);
					endYear = Math.max(year, determineYear(years[1] || ""));
					year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
					endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
					inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
					for (; year <= endYear; year++) {
						inst.yearshtml += "<option value='" + year + "'" +
							(year === drawYear ? " selected='selected'" : "") +
							">" + year + "</option>";
					}
					inst.yearshtml += "</select>";

					html += inst.yearshtml;
					inst.yearshtml = null;
				}
			}

			html += this._get(inst, "yearSuffix");
			if (showMonthAfterYear) {
				html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
			}
			html += "</div>"; // Close datepicker_header
			return html;
		},

		/* Adjust one of the date sub-fields. */
		_adjustInstDate: function(inst, offset, period) {
			var year = inst.drawYear + (period === "Y" ? offset : 0),
				month = inst.drawMonth + (period === "M" ? offset : 0),
				day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
				date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			if (period === "M" || period === "Y") {
				this._notifyChange(inst);
			}
		},

		/* Ensure a date is within any min/max bounds. */
		_restrictMinMax: function(inst, date) {
			var minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				newDate = (minDate && date < minDate ? minDate : date);
			return (maxDate && newDate > maxDate ? maxDate : newDate);
		},

		/* Notify change of month/year. */
		_notifyChange: function(inst) {
			var onChange = this._get(inst, "onChangeMonthYear");
			if (onChange) {
				onChange.apply((inst.input ? inst.input[0] : null),
					[inst.selectedYear, inst.selectedMonth + 1, inst]);
			}
		},

		/* Determine the number of months to show. */
		_getNumberOfMonths: function(inst) {
			var numMonths = this._get(inst, "numberOfMonths");
			return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
		},

		/* Determine the current maximum date - ensure no time components are set. */
		_getMinMaxDate: function(inst, minMax) {
			return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
		},

		/* Find the number of days in a given month. */
		_getDaysInMonth: function(year, month) {
			return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
		},

		/* Find the day of the week of the first of a month. */
		_getFirstDayOfMonth: function(year, month) {
			return new Date(year, month, 1).getDay();
		},

		/* Determines if we should allow a "next/prev" month display change. */
		_canAdjustMonth: function(inst, offset, curYear, curMonth) {
			var numMonths = this._getNumberOfMonths(inst),
				date = this._daylightSavingAdjust(new Date(curYear,
				curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

			if (offset < 0) {
				date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
			}
			return this._isInRange(inst, date);
		},

		/* Is the given date in the accepted range? */
		_isInRange: function(inst, date) {
			var yearSplit, currentYear,
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				minYear = null,
				maxYear = null,
				years = this._get(inst, "yearRange");
				if (years){
					yearSplit = years.split(":");
					currentYear = new Date().getFullYear();
					minYear = parseInt(yearSplit[0], 10);
					maxYear = parseInt(yearSplit[1], 10);
					if ( yearSplit[0].match(/[+\-].*/) ) {
						minYear += currentYear;
					}
					if ( yearSplit[1].match(/[+\-].*/) ) {
						maxYear += currentYear;
					}
				}

			return ((!minDate || date.getTime() >= minDate.getTime()) &&
				(!maxDate || date.getTime() <= maxDate.getTime()) &&
				(!minYear || date.getFullYear() >= minYear) &&
				(!maxYear || date.getFullYear() <= maxYear));
		},

		/* Provide the configuration settings for formatting/parsing. */
		_getFormatConfig: function(inst) {
			var shortYearCutoff = this._get(inst, "shortYearCutoff");
			shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
			return {shortYearCutoff: shortYearCutoff,
				dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
				monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
		},

		/* Format the given date for display. */
		_formatDate: function(inst, day, month, year) {
			if (!day) {
				inst.currentDay = inst.selectedDay;
				inst.currentMonth = inst.selectedMonth;
				inst.currentYear = inst.selectedYear;
			}
			var date = (day ? (typeof day === "object" ? day :
				this._daylightSavingAdjust(new Date(year, month, day))) :
				this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
			return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
		}
	});

	/*
	 * Bind hover events for datepicker elements.
	 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
	 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
	 */
	function bindHover(dpDiv) {
		var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
		return dpDiv.delegate(selector, "mouseout", function() {
				$(this).removeClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).removeClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).removeClass("ui-datepicker-next-hover");
				}
			})
			.delegate(selector, "mouseover", function(){
				if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
					$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
					$(this).addClass("ui-state-hover");
					if (this.className.indexOf("ui-datepicker-prev") !== -1) {
						$(this).addClass("ui-datepicker-prev-hover");
					}
					if (this.className.indexOf("ui-datepicker-next") !== -1) {
						$(this).addClass("ui-datepicker-next-hover");
					}
				}
			});
	}

	/* jQuery extend now ignores nulls! */
	function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] == null) {
				target[name] = props[name];
			}
		}
		return target;
	}

	/* Invoke the datepicker functionality.
	   @param  options  string - a command, optionally followed by additional parameters or
						Object - settings for attaching new datepicker functionality
	   @return  jQuery object */
	$.fn.datepicker = function(options){

		/* Verify an empty collection wasn't passed - Fixes #6976 */
		if ( !this.length ) {
			return this;
		}

		/* Initialise the date picker. */
		if (!$.datepicker.initialized) {
			$(document).mousedown($.datepicker._checkExternalClick);
			$.datepicker.initialized = true;
		}

		/* Append datepicker main container to body if not exist. */
		if ($("#"+$.datepicker._mainDivId).length === 0) {
			$("body").append($.datepicker.dpDiv);
		}

		var otherArgs = Array.prototype.slice.call(arguments, 1);
		if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		return this.each(function() {
			typeof options === "string" ?
				$.datepicker["_" + options + "Datepicker"].
					apply($.datepicker, [this].concat(otherArgs)) :
				$.datepicker._attachDatepicker(this, options);
		});
	};

	$.datepicker = new Datepicker(); // singleton instance
	$.datepicker.initialized = false;
	$.datepicker.uuid = new Date().getTime();
	$.datepicker.version = "1.10.4";

	})(jQuery);
	(function( $, undefined ) {

	var sizeRelatedOptions = {
			buttons: true,
			height: true,
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true,
			width: true
		},
		resizableRelatedOptions = {
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true
		};

	$.widget( "ui.dialog", {
		version: "1.10.4",
		options: {
			appendTo: "body",
			autoOpen: true,
			buttons: [],
			closeOnEscape: true,
			closeText: "close",
			dialogClass: "",
			draggable: true,
			hide: null,
			height: "auto",
			maxHeight: null,
			maxWidth: null,
			minHeight: 150,
			minWidth: 150,
			modal: false,
			position: {
				my: "center",
				at: "center",
				of: window,
				collision: "fit",
				// Ensure the titlebar is always visible
				using: function( pos ) {
					var topOffset = $( this ).css( pos ).offset().top;
					if ( topOffset < 0 ) {
						$( this ).css( "top", pos.top - topOffset );
					}
				}
			},
			resizable: true,
			show: null,
			title: null,
			width: 300,

			// callbacks
			beforeClose: null,
			close: null,
			drag: null,
			dragStart: null,
			dragStop: null,
			focus: null,
			open: null,
			resize: null,
			resizeStart: null,
			resizeStop: null
		},

		_create: function() {
			this.originalCss = {
				display: this.element[0].style.display,
				width: this.element[0].style.width,
				minHeight: this.element[0].style.minHeight,
				maxHeight: this.element[0].style.maxHeight,
				height: this.element[0].style.height
			};
			this.originalPosition = {
				parent: this.element.parent(),
				index: this.element.parent().children().index( this.element )
			};
			this.originalTitle = this.element.attr("title");
			this.options.title = this.options.title || this.originalTitle;

			this._createWrapper();

			this.element
				.show()
				.removeAttr("title")
				.addClass("ui-dialog-content ui-widget-content")
				.appendTo( this.uiDialog );

			this._createTitlebar();
			this._createButtonPane();

			if ( this.options.draggable && $.fn.draggable ) {
				this._makeDraggable();
			}
			if ( this.options.resizable && $.fn.resizable ) {
				this._makeResizable();
			}

			this._isOpen = false;
		},

		_init: function() {
			if ( this.options.autoOpen ) {
				this.open();
			}
		},

		_appendTo: function() {
			var element = this.options.appendTo;
			if ( element && (element.jquery || element.nodeType) ) {
				return $( element );
			}
			return this.document.find( element || "body" ).eq( 0 );
		},

		_destroy: function() {
			var next,
				originalPosition = this.originalPosition;

			this._destroyOverlay();

			this.element
				.removeUniqueId()
				.removeClass("ui-dialog-content ui-widget-content")
				.css( this.originalCss )
				// Without detaching first, the following becomes really slow
				.detach();

			this.uiDialog.stop( true, true ).remove();

			if ( this.originalTitle ) {
				this.element.attr( "title", this.originalTitle );
			}

			next = originalPosition.parent.children().eq( originalPosition.index );
			// Don't try to place the dialog next to itself (#8613)
			if ( next.length && next[0] !== this.element[0] ) {
				next.before( this.element );
			} else {
				originalPosition.parent.append( this.element );
			}
		},

		widget: function() {
			return this.uiDialog;
		},

		disable: $.noop,
		enable: $.noop,

		close: function( event ) {
			var activeElement,
				that = this;

			if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
				return;
			}

			this._isOpen = false;
			this._destroyOverlay();

			if ( !this.opener.filter(":focusable").focus().length ) {

				// support: IE9
				// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
				try {
					activeElement = this.document[ 0 ].activeElement;

					// Support: IE9, IE10
					// If the <body> is blurred, IE will switch windows, see #4520
					if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

						// Hiding a focused element doesn't trigger blur in WebKit
						// so in case we have nothing to focus on, explicitly blur the active element
						// https://bugs.webkit.org/show_bug.cgi?id=47182
						$( activeElement ).blur();
					}
				} catch ( error ) {}
			}

			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( "close", event );
			});
		},

		isOpen: function() {
			return this._isOpen;
		},

		moveToTop: function() {
			this._moveToTop();
		},

		_moveToTop: function( event, silent ) {
			var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
			if ( moved && !silent ) {
				this._trigger( "focus", event );
			}
			return moved;
		},

		open: function() {
			var that = this;
			if ( this._isOpen ) {
				if ( this._moveToTop() ) {
					this._focusTabbable();
				}
				return;
			}

			this._isOpen = true;
			this.opener = $( this.document[0].activeElement );

			this._size();
			this._position();
			this._createOverlay();
			this._moveToTop( null, true );
			this._show( this.uiDialog, this.options.show, function() {
				that._focusTabbable();
				that._trigger("focus");
			});

			this._trigger("open");
		},

		_focusTabbable: function() {
			// Set focus to the first match:
			// 1. First element inside the dialog matching [autofocus]
			// 2. Tabbable element inside the content element
			// 3. Tabbable element inside the buttonpane
			// 4. The close button
			// 5. The dialog itself
			var hasFocus = this.element.find("[autofocus]");
			if ( !hasFocus.length ) {
				hasFocus = this.element.find(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogButtonPane.find(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialog;
			}
			hasFocus.eq( 0 ).focus();
		},

		_keepFocus: function( event ) {
			function checkFocus() {
				var activeElement = this.document[0].activeElement,
					isActive = this.uiDialog[0] === activeElement ||
						$.contains( this.uiDialog[0], activeElement );
				if ( !isActive ) {
					this._focusTabbable();
				}
			}
			event.preventDefault();
			checkFocus.call( this );
			// support: IE
			// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
			// so we check again later
			this._delay( checkFocus );
		},

		_createWrapper: function() {
			this.uiDialog = $("<div>")
				.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
					this.options.dialogClass )
				.hide()
				.attr({
					// Setting tabIndex makes the div focusable
					tabIndex: -1,
					role: "dialog"
				})
				.appendTo( this._appendTo() );

			this._on( this.uiDialog, {
				keydown: function( event ) {
					if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						event.preventDefault();
						this.close( event );
						return;
					}

					// prevent tabbing out of dialogs
					if ( event.keyCode !== $.ui.keyCode.TAB ) {
						return;
					}
					var tabbables = this.uiDialog.find(":tabbable"),
						first = tabbables.filter(":first"),
						last  = tabbables.filter(":last");

					if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
						first.focus( 1 );
						event.preventDefault();
					} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
						last.focus( 1 );
						event.preventDefault();
					}
				},
				mousedown: function( event ) {
					if ( this._moveToTop( event ) ) {
						this._focusTabbable();
					}
				}
			});

			// We assume that any existing aria-describedby attribute means
			// that the dialog content is marked up properly
			// otherwise we brute force the content as the description
			if ( !this.element.find("[aria-describedby]").length ) {
				this.uiDialog.attr({
					"aria-describedby": this.element.uniqueId().attr("id")
				});
			}
		},

		_createTitlebar: function() {
			var uiDialogTitle;

			this.uiDialogTitlebar = $("<div>")
				.addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
				.prependTo( this.uiDialog );
			this._on( this.uiDialogTitlebar, {
				mousedown: function( event ) {
					// Don't prevent click on close button (#8838)
					// Focusing a dialog that is partially scrolled out of view
					// causes the browser to scroll it into view, preventing the click event
					if ( !$( event.target ).closest(".ui-dialog-titlebar-close") ) {
						// Dialog isn't getting focus when dragging (#8063)
						this.uiDialog.focus();
					}
				}
			});

			// support: IE
			// Use type="button" to prevent enter keypresses in textboxes from closing the
			// dialog in IE (#9312)
			this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
				.button({
					label: this.options.closeText,
					icons: {
						primary: "ui-icon-closethick"
					},
					text: false
				})
				.addClass("ui-dialog-titlebar-close")
				.appendTo( this.uiDialogTitlebar );
			this._on( this.uiDialogTitlebarClose, {
				click: function( event ) {
					event.preventDefault();
					this.close( event );
				}
			});

			uiDialogTitle = $("<span>")
				.uniqueId()
				.addClass("ui-dialog-title")
				.prependTo( this.uiDialogTitlebar );
			this._title( uiDialogTitle );

			this.uiDialog.attr({
				"aria-labelledby": uiDialogTitle.attr("id")
			});
		},

		_title: function( title ) {
			if ( !this.options.title ) {
				title.html("&#160;");
			}
			title.text( this.options.title );
		},

		_createButtonPane: function() {
			this.uiDialogButtonPane = $("<div>")
				.addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

			this.uiButtonSet = $("<div>")
				.addClass("ui-dialog-buttonset")
				.appendTo( this.uiDialogButtonPane );

			this._createButtons();
		},

		_createButtons: function() {
			var that = this,
				buttons = this.options.buttons;

			// if we already have a button pane, remove it
			this.uiDialogButtonPane.remove();
			this.uiButtonSet.empty();

			if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
				this.uiDialog.removeClass("ui-dialog-buttons");
				return;
			}

			$.each( buttons, function( name, props ) {
				var click, buttonOptions;
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				// Default to a non-submitting button
				props = $.extend( { type: "button" }, props );
				// Change the context for the click callback to be the main element
				click = props.click;
				props.click = function() {
					click.apply( that.element[0], arguments );
				};
				buttonOptions = {
					icons: props.icons,
					text: props.showText
				};
				delete props.icons;
				delete props.showText;
				$( "<button></button>", props )
					.button( buttonOptions )
					.appendTo( that.uiButtonSet );
			});
			this.uiDialog.addClass("ui-dialog-buttons");
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		},

		_makeDraggable: function() {
			var that = this,
				options = this.options;

			function filteredUi( ui ) {
				return {
					position: ui.position,
					offset: ui.offset
				};
			}

			this.uiDialog.draggable({
				cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
				handle: ".ui-dialog-titlebar",
				containment: "document",
				start: function( event, ui ) {
					$( this ).addClass("ui-dialog-dragging");
					that._blockFrames();
					that._trigger( "dragStart", event, filteredUi( ui ) );
				},
				drag: function( event, ui ) {
					that._trigger( "drag", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					options.position = [
						ui.position.left - that.document.scrollLeft(),
						ui.position.top - that.document.scrollTop()
					];
					$( this ).removeClass("ui-dialog-dragging");
					that._unblockFrames();
					that._trigger( "dragStop", event, filteredUi( ui ) );
				}
			});
		},

		_makeResizable: function() {
			var that = this,
				options = this.options,
				handles = options.resizable,
				// .ui-resizable has position: relative defined in the stylesheet
				// but dialogs have to use absolute or fixed positioning
				position = this.uiDialog.css("position"),
				resizeHandles = typeof handles === "string" ?
					handles	:
					"n,e,s,w,se,sw,ne,nw";

			function filteredUi( ui ) {
				return {
					originalPosition: ui.originalPosition,
					originalSize: ui.originalSize,
					position: ui.position,
					size: ui.size
				};
			}

			this.uiDialog.resizable({
				cancel: ".ui-dialog-content",
				containment: "document",
				alsoResize: this.element,
				maxWidth: options.maxWidth,
				maxHeight: options.maxHeight,
				minWidth: options.minWidth,
				minHeight: this._minHeight(),
				handles: resizeHandles,
				start: function( event, ui ) {
					$( this ).addClass("ui-dialog-resizing");
					that._blockFrames();
					that._trigger( "resizeStart", event, filteredUi( ui ) );
				},
				resize: function( event, ui ) {
					that._trigger( "resize", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					options.height = $( this ).height();
					options.width = $( this ).width();
					$( this ).removeClass("ui-dialog-resizing");
					that._unblockFrames();
					that._trigger( "resizeStop", event, filteredUi( ui ) );
				}
			})
			.css( "position", position );
		},

		_minHeight: function() {
			var options = this.options;

			return options.height === "auto" ?
				options.minHeight :
				Math.min( options.minHeight, options.height );
		},

		_position: function() {
			// Need to show the dialog to get the actual offset in the position plugin
			var isVisible = this.uiDialog.is(":visible");
			if ( !isVisible ) {
				this.uiDialog.show();
			}
			this.uiDialog.position( this.options.position );
			if ( !isVisible ) {
				this.uiDialog.hide();
			}
		},

		_setOptions: function( options ) {
			var that = this,
				resize = false,
				resizableOptions = {};

			$.each( options, function( key, value ) {
				that._setOption( key, value );

				if ( key in sizeRelatedOptions ) {
					resize = true;
				}
				if ( key in resizableRelatedOptions ) {
					resizableOptions[ key ] = value;
				}
			});

			if ( resize ) {
				this._size();
				this._position();
			}
			if ( this.uiDialog.is(":data(ui-resizable)") ) {
				this.uiDialog.resizable( "option", resizableOptions );
			}
		},

		_setOption: function( key, value ) {
			var isDraggable, isResizable,
				uiDialog = this.uiDialog;

			if ( key === "dialogClass" ) {
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}

			if ( key === "disabled" ) {
				return;
			}

			this._super( key, value );

			if ( key === "appendTo" ) {
				this.uiDialog.appendTo( this._appendTo() );
			}

			if ( key === "buttons" ) {
				this._createButtons();
			}

			if ( key === "closeText" ) {
				this.uiDialogTitlebarClose.button({
					// Ensure that we always pass a string
					label: "" + value
				});
			}

			if ( key === "draggable" ) {
				isDraggable = uiDialog.is(":data(ui-draggable)");
				if ( isDraggable && !value ) {
					uiDialog.draggable("destroy");
				}

				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
			}

			if ( key === "position" ) {
				this._position();
			}

			if ( key === "resizable" ) {
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is(":data(ui-resizable)");
				if ( isResizable && !value ) {
					uiDialog.resizable("destroy");
				}

				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}

				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable();
				}
			}

			if ( key === "title" ) {
				this._title( this.uiDialogTitlebar.find(".ui-dialog-title") );
			}
		},

		_size: function() {
			// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
			// divs will both have width and height set, so we need to reset them
			var nonContentHeight, minContentHeight, maxContentHeight,
				options = this.options;

			// Reset content sizing
			this.element.show().css({
				width: "auto",
				minHeight: 0,
				maxHeight: "none",
				height: 0
			});

			if ( options.minWidth > options.width ) {
				options.width = options.minWidth;
			}

			// reset wrapper sizing
			// determine the height of all the non-content elements
			nonContentHeight = this.uiDialog.css({
					height: "auto",
					width: options.width
				})
				.outerHeight();
			minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
			maxContentHeight = typeof options.maxHeight === "number" ?
				Math.max( 0, options.maxHeight - nonContentHeight ) :
				"none";

			if ( options.height === "auto" ) {
				this.element.css({
					minHeight: minContentHeight,
					maxHeight: maxContentHeight,
					height: "auto"
				});
			} else {
				this.element.height( Math.max( 0, options.height - nonContentHeight ) );
			}

			if (this.uiDialog.is(":data(ui-resizable)") ) {
				this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
			}
		},

		_blockFrames: function() {
			this.iframeBlocks = this.document.find( "iframe" ).map(function() {
				var iframe = $( this );

				return $( "<div>" )
					.css({
						position: "absolute",
						width: iframe.outerWidth(),
						height: iframe.outerHeight()
					})
					.appendTo( iframe.parent() )
					.offset( iframe.offset() )[0];
			});
		},

		_unblockFrames: function() {
			if ( this.iframeBlocks ) {
				this.iframeBlocks.remove();
				delete this.iframeBlocks;
			}
		},

		_allowInteraction: function( event ) {
			if ( $( event.target ).closest(".ui-dialog").length ) {
				return true;
			}

			// TODO: Remove hack when datepicker implements
			// the .ui-front logic (#8989)
			return !!$( event.target ).closest(".ui-datepicker").length;
		},

		_createOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}

			var that = this,
				widgetFullName = this.widgetFullName;
			if ( !$.ui.dialog.overlayInstances ) {
				// Prevent use of anchors and inputs.
				// We use a delay in case the overlay is created from an
				// event that we're going to be cancelling. (#2804)
				this._delay(function() {
					// Handle .dialog().dialog("close") (#4065)
					if ( $.ui.dialog.overlayInstances ) {
						this.document.bind( "focusin.dialog", function( event ) {
							if ( !that._allowInteraction( event ) ) {
								event.preventDefault();
								$(".ui-dialog:visible:last .ui-dialog-content")
									.data( widgetFullName )._focusTabbable();
							}
						});
					}
				});
			}

			this.overlay = $("<div>")
				.addClass("ui-widget-overlay ui-front")
				.appendTo( this._appendTo() );
			this._on( this.overlay, {
				mousedown: "_keepFocus"
			});
			$.ui.dialog.overlayInstances++;
		},

		_destroyOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}

			if ( this.overlay ) {
				$.ui.dialog.overlayInstances--;

				if ( !$.ui.dialog.overlayInstances ) {
					this.document.unbind( "focusin.dialog" );
				}
				this.overlay.remove();
				this.overlay = null;
			}
		}
	});

	$.ui.dialog.overlayInstances = 0;

	// DEPRECATED
	if ( $.uiBackCompat !== false ) {
		// position option with array notation
		// just override with old implementation
		$.widget( "ui.dialog", $.ui.dialog, {
			_position: function() {
				var position = this.options.position,
					myAt = [],
					offset = [ 0, 0 ],
					isVisible;

				if ( position ) {
					if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
						myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
						if ( myAt.length === 1 ) {
							myAt[1] = myAt[0];
						}

						$.each( [ "left", "top" ], function( i, offsetPosition ) {
							if ( +myAt[ i ] === myAt[ i ] ) {
								offset[ i ] = myAt[ i ];
								myAt[ i ] = offsetPosition;
							}
						});

						position = {
							my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
								myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
							at: myAt.join(" ")
						};
					}

					position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
				} else {
					position = $.ui.dialog.prototype.options.position;
				}

				// need to show the dialog to get the actual offset in the position plugin
				isVisible = this.uiDialog.is(":visible");
				if ( !isVisible ) {
					this.uiDialog.show();
				}
				this.uiDialog.position( position );
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
			}
		});
	}

	}( jQuery ) );
	(function( $, undefined ) {

	$.widget("ui.draggable", $.ui.mouse, {
		version: "1.10.4",
		widgetEventPrefix: "drag",
		options: {
			addClasses: true,
			appendTo: "parent",
			axis: false,
			connectToSortable: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			grid: false,
			handle: false,
			helper: "original",
			iframeFix: false,
			opacity: false,
			refreshPositions: false,
			revert: false,
			revertDuration: 500,
			scope: "default",
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			snap: false,
			snapMode: "both",
			snapTolerance: 20,
			stack: false,
			zIndex: false,

			// callbacks
			drag: null,
			start: null,
			stop: null
		},
		_create: function() {

			if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
				this.element[0].style.position = "relative";
			}
			if (this.options.addClasses){
				this.element.addClass("ui-draggable");
			}
			if (this.options.disabled){
				this.element.addClass("ui-draggable-disabled");
			}

			this._mouseInit();

		},

		_destroy: function() {
			this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
			this._mouseDestroy();
		},

		_mouseCapture: function(event) {

			var o = this.options;

			// among others, prevent a drag on a resizable-handle
			if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
				return false;
			}

			//Quit if we're not on a valid handle
			this.handle = this._getHandle(event);
			if (!this.handle) {
				return false;
			}

			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});

			return true;

		},

		_mouseStart: function(event) {

			var o = this.options;

			//Create and append the visible helper
			this.helper = this._createHelper(event);

			this.helper.addClass("ui-draggable-dragging");

			//Cache the helper size
			this._cacheHelperProportions();

			//If ddmanager is used for droppables, set the global draggable
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}

			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */

			//Cache the margins of the original element
			this._cacheMargins();

			//Store the helper's css position
			this.cssPosition = this.helper.css( "position" );
			this.scrollParent = this.helper.scrollParent();
			this.offsetParent = this.helper.offsetParent();
			this.offsetParentCssPosition = this.offsetParent.css( "position" );

			//The element's absolute position on the page minus margins
			this.offset = this.positionAbs = this.element.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};

			//Reset scroll cache
			this.offset.scroll = false;

			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});

			//Generate the original position
			this.originalPosition = this.position = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;

			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

			//Set a containment if given in the options
			this._setContainment();

			//Trigger event + callbacks
			if(this._trigger("start", event) === false) {
				this._clear();
				return false;
			}

			//Recache the helper size
			this._cacheHelperProportions();

			//Prepare the droppable offsets
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}


			this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

			//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStart(this, event);
			}

			return true;
		},

		_mouseDrag: function(event, noPropagation) {
			// reset any necessary cached properties (see #5009)
			if ( this.offsetParentCssPosition === "fixed" ) {
				this.offset.parent = this._getParentOffset();
			}

			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");

			//Call plugins and callbacks and use the resulting position if something is returned
			if (!noPropagation) {
				var ui = this._uiHash();
				if(this._trigger("drag", event, ui) === false) {
					this._mouseUp({});
					return false;
				}
				this.position = ui.position;
			}

			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}

			return false;
		},

		_mouseStop: function(event) {

			//If we are using droppables, inform the manager about the drop
			var that = this,
				dropped = false;
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				dropped = $.ui.ddmanager.drop(this, event);
			}

			//if a drop comes from outside (a sortable)
			if(this.dropped) {
				dropped = this.dropped;
				this.dropped = false;
			}

			//if the original element is no longer in the DOM don't bother to continue (see #8269)
			if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
				return false;
			}

			if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
				$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
					if(that._trigger("stop", event) !== false) {
						that._clear();
					}
				});
			} else {
				if(this._trigger("stop", event) !== false) {
					this._clear();
				}
			}

			return false;
		},

		_mouseUp: function(event) {
			//Remove frame helpers
			$("div.ui-draggable-iframeFix").each(function() {
				this.parentNode.removeChild(this);
			});

			//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
			if( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStop(this, event);
			}

			return $.ui.mouse.prototype._mouseUp.call(this, event);
		},

		cancel: function() {

			if(this.helper.is(".ui-draggable-dragging")) {
				this._mouseUp({});
			} else {
				this._clear();
			}

			return this;

		},

		_getHandle: function(event) {
			return this.options.handle ?
				!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
				true;
		},

		_createHelper: function(event) {

			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

			if(!helper.parents("body").length) {
				helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
			}

			if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
				helper.css("position", "absolute");
			}

			return helper;

		},

		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},

		_getParentOffset: function() {

			//Get the offsetParent and cache its position
			var po = this.offsetParent.offset();

			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}

			//This needs to be actually done for all browsers, since pageX/pageY includes this information
			//Ugly IE fix
			if((this.offsetParent[0] === document.body) ||
				(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}

			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};

		},

		_getRelativeOffset: function() {

			if(this.cssPosition === "relative") {
				var p = this.element.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}

		},

		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.element.css("marginLeft"),10) || 0),
				top: (parseInt(this.element.css("marginTop"),10) || 0),
				right: (parseInt(this.element.css("marginRight"),10) || 0),
				bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
			};
		},

		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},

		_setContainment: function() {

			var over, c, ce,
				o = this.options;

			if ( !o.containment ) {
				this.containment = null;
				return;
			}

			if ( o.containment === "window" ) {
				this.containment = [
					$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
					$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
					$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
					$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}

			if ( o.containment === "document") {
				this.containment = [
					0,
					0,
					$( document ).width() - this.helperProportions.width - this.margins.left,
					( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}

			if ( o.containment.constructor === Array ) {
				this.containment = o.containment;
				return;
			}

			if ( o.containment === "parent" ) {
				o.containment = this.helper[ 0 ].parentNode;
			}

			c = $( o.containment );
			ce = c[ 0 ];

			if( !ce ) {
				return;
			}

			over = c.css( "overflow" ) !== "hidden";

			this.containment = [
				( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
				( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
				( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
				( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;
		},

		_convertPositionTo: function(d, pos) {

			if(!pos) {
				pos = this.position;
			}

			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

			//Cache the scroll
			if (!this.offset.scroll) {
				this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
			}

			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
				)
			};

		},

		_generatePosition: function(event) {

			var containment, co, top, left,
				o = this.options,
				scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
				pageX = event.pageX,
				pageY = event.pageY;

			//Cache the scroll
			if (!this.offset.scroll) {
				this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
			}

			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */

			// If we are not dragging yet, we won't check for options
			if ( this.originalPosition ) {
				if ( this.containment ) {
					if ( this.relative_container ){
						co = this.relative_container.offset();
						containment = [
							this.containment[ 0 ] + co.left,
							this.containment[ 1 ] + co.top,
							this.containment[ 2 ] + co.left,
							this.containment[ 3 ] + co.top
						];
					}
					else {
						containment = this.containment;
					}

					if(event.pageX - this.offset.click.left < containment[0]) {
						pageX = containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < containment[1]) {
						pageY = containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > containment[2]) {
						pageX = containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > containment[3]) {
						pageY = containment[3] + this.offset.click.top;
					}
				}

				if(o.grid) {
					//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
					top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
					pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

					left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
					pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}

			}

			return {
				top: (
					pageY -																	// The absolute mouse position
					this.offset.click.top	-												// Click offset (relative to the element)
					this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
				),
				left: (
					pageX -																	// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
				)
			};

		},

		_clear: function() {
			this.helper.removeClass("ui-draggable-dragging");
			if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
				this.helper.remove();
			}
			this.helper = null;
			this.cancelHelperRemoval = false;
		},

		// From now on bulk stuff - mainly helpers

		_trigger: function(type, event, ui) {
			ui = ui || this._uiHash();
			$.ui.plugin.call(this, type, [event, ui]);
			//The absolute position has to be recalculated after plugins
			if(type === "drag") {
				this.positionAbs = this._convertPositionTo("absolute");
			}
			return $.Widget.prototype._trigger.call(this, type, event, ui);
		},

		plugins: {},

		_uiHash: function() {
			return {
				helper: this.helper,
				position: this.position,
				originalPosition: this.originalPosition,
				offset: this.positionAbs
			};
		}

	});

	$.ui.plugin.add("draggable", "connectToSortable", {
		start: function(event, ui) {

			var inst = $(this).data("ui-draggable"), o = inst.options,
				uiSortable = $.extend({}, ui, { item: inst.element });
			inst.sortables = [];
			$(o.connectToSortable).each(function() {
				var sortable = $.data(this, "ui-sortable");
				if (sortable && !sortable.options.disabled) {
					inst.sortables.push({
						instance: sortable,
						shouldRevert: sortable.options.revert
					});
					sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
					sortable._trigger("activate", event, uiSortable);
				}
			});

		},
		stop: function(event, ui) {

			//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
			var inst = $(this).data("ui-draggable"),
				uiSortable = $.extend({}, ui, { item: inst.element });

			$.each(inst.sortables, function() {
				if(this.instance.isOver) {

					this.instance.isOver = 0;

					inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
					this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

					//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
					if(this.shouldRevert) {
						this.instance.options.revert = this.shouldRevert;
					}

					//Trigger the stop of the sortable
					this.instance._mouseStop(event);

					this.instance.options.helper = this.instance.options._helper;

					//If the helper has been the original item, restore properties in the sortable
					if(inst.options.helper === "original") {
						this.instance.currentItem.css({ top: "auto", left: "auto" });
					}

				} else {
					this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
					this.instance._trigger("deactivate", event, uiSortable);
				}

			});

		},
		drag: function(event, ui) {

			var inst = $(this).data("ui-draggable"), that = this;

			$.each(inst.sortables, function() {

				var innermostIntersecting = false,
					thisSortable = this;

				//Copy over some variables to allow calling the sortable's native _intersectsWith
				this.instance.positionAbs = inst.positionAbs;
				this.instance.helperProportions = inst.helperProportions;
				this.instance.offset.click = inst.offset.click;

				if(this.instance._intersectsWith(this.instance.containerCache)) {
					innermostIntersecting = true;
					$.each(inst.sortables, function () {
						this.instance.positionAbs = inst.positionAbs;
						this.instance.helperProportions = inst.helperProportions;
						this.instance.offset.click = inst.offset.click;
						if (this !== thisSortable &&
							this.instance._intersectsWith(this.instance.containerCache) &&
							$.contains(thisSortable.instance.element[0], this.instance.element[0])
						) {
							innermostIntersecting = false;
						}
						return innermostIntersecting;
					});
				}


				if(innermostIntersecting) {
					//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
					if(!this.instance.isOver) {

						this.instance.isOver = 1;
						//Now we fake the start of dragging for the sortable instance,
						//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
						//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
						this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
						this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
						this.instance.options.helper = function() { return ui.helper[0]; };

						event.target = this.instance.currentItem[0];
						this.instance._mouseCapture(event, true);
						this.instance._mouseStart(event, true, true);

						//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
						this.instance.offset.click.top = inst.offset.click.top;
						this.instance.offset.click.left = inst.offset.click.left;
						this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
						this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

						inst._trigger("toSortable", event);
						inst.dropped = this.instance.element; //draggable revert needs that
						//hack so receive/update callbacks work (mostly)
						inst.currentItem = inst.element;
						this.instance.fromOutside = inst;

					}

					//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
					if(this.instance.currentItem) {
						this.instance._mouseDrag(event);
					}

				} else {

					//If it doesn't intersect with the sortable, and it intersected before,
					//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
					if(this.instance.isOver) {

						this.instance.isOver = 0;
						this.instance.cancelHelperRemoval = true;

						//Prevent reverting on this forced stop
						this.instance.options.revert = false;

						// The out event needs to be triggered independently
						this.instance._trigger("out", event, this.instance._uiHash(this.instance));

						this.instance._mouseStop(event, true);
						this.instance.options.helper = this.instance.options._helper;

						//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
						this.instance.currentItem.remove();
						if(this.instance.placeholder) {
							this.instance.placeholder.remove();
						}

						inst._trigger("fromSortable", event);
						inst.dropped = false; //draggable revert needs that
					}

				}

			});

		}
	});

	$.ui.plugin.add("draggable", "cursor", {
		start: function() {
			var t = $("body"), o = $(this).data("ui-draggable").options;
			if (t.css("cursor")) {
				o._cursor = t.css("cursor");
			}
			t.css("cursor", o.cursor);
		},
		stop: function() {
			var o = $(this).data("ui-draggable").options;
			if (o._cursor) {
				$("body").css("cursor", o._cursor);
			}
		}
	});

	$.ui.plugin.add("draggable", "opacity", {
		start: function(event, ui) {
			var t = $(ui.helper), o = $(this).data("ui-draggable").options;
			if(t.css("opacity")) {
				o._opacity = t.css("opacity");
			}
			t.css("opacity", o.opacity);
		},
		stop: function(event, ui) {
			var o = $(this).data("ui-draggable").options;
			if(o._opacity) {
				$(ui.helper).css("opacity", o._opacity);
			}
		}
	});

	$.ui.plugin.add("draggable", "scroll", {
		start: function() {
			var i = $(this).data("ui-draggable");
			if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
				i.overflowOffset = i.scrollParent.offset();
			}
		},
		drag: function( event ) {

			var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

			if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

				if(!o.axis || o.axis !== "x") {
					if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
						i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
					}
				}

				if(!o.axis || o.axis !== "y") {
					if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
						i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
				}

			} else {

				if(!o.axis || o.axis !== "x") {
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}
				}

				if(!o.axis || o.axis !== "y") {
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(i, event);
			}

		}
	});

	$.ui.plugin.add("draggable", "snap", {
		start: function() {

			var i = $(this).data("ui-draggable"),
				o = i.options;

			i.snapElements = [];

			$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
				var $t = $(this),
					$o = $t.offset();
				if(this !== i.element[0]) {
					i.snapElements.push({
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					});
				}
			});

		},
		drag: function(event, ui) {

			var ts, bs, ls, rs, l, r, t, b, i, first,
				inst = $(this).data("ui-draggable"),
				o = inst.options,
				d = o.snapTolerance,
				x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
				y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

			for (i = inst.snapElements.length - 1; i >= 0; i--){

				l = inst.snapElements[i].left;
				r = l + inst.snapElements[i].width;
				t = inst.snapElements[i].top;
				b = t + inst.snapElements[i].height;

				if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
					if(inst.snapElements[i].snapping) {
						(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
					}
					inst.snapElements[i].snapping = false;
					continue;
				}

				if(o.snapMode !== "inner") {
					ts = Math.abs(t - y2) <= d;
					bs = Math.abs(b - y1) <= d;
					ls = Math.abs(l - x2) <= d;
					rs = Math.abs(r - x1) <= d;
					if(ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
					}
					if(bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
					}
					if(ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
					}
					if(rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
					}
				}

				first = (ts || bs || ls || rs);

				if(o.snapMode !== "outer") {
					ts = Math.abs(t - y1) <= d;
					bs = Math.abs(b - y2) <= d;
					ls = Math.abs(l - x1) <= d;
					rs = Math.abs(r - x2) <= d;
					if(ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
					}
					if(bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
					}
					if(ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
					}
					if(rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
					}
				}

				if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
					(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

			}

		}
	});

	$.ui.plugin.add("draggable", "stack", {
		start: function() {
			var min,
				o = this.data("ui-draggable").options,
				group = $.makeArray($(o.stack)).sort(function(a,b) {
					return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
				});

			if (!group.length) { return; }

			min = parseInt($(group[0]).css("zIndex"), 10) || 0;
			$(group).each(function(i) {
				$(this).css("zIndex", min + i);
			});
			this.css("zIndex", (min + group.length));
		}
	});

	$.ui.plugin.add("draggable", "zIndex", {
		start: function(event, ui) {
			var t = $(ui.helper), o = $(this).data("ui-draggable").options;
			if(t.css("zIndex")) {
				o._zIndex = t.css("zIndex");
			}
			t.css("zIndex", o.zIndex);
		},
		stop: function(event, ui) {
			var o = $(this).data("ui-draggable").options;
			if(o._zIndex) {
				$(ui.helper).css("zIndex", o._zIndex);
			}
		}
	});

	})(jQuery);
	(function( $, undefined ) {

	function isOverAxis( x, reference, size ) {
		return ( x > reference ) && ( x < ( reference + size ) );
	}

	$.widget("ui.droppable", {
		version: "1.10.4",
		widgetEventPrefix: "drop",
		options: {
			accept: "*",
			activeClass: false,
			addClasses: true,
			greedy: false,
			hoverClass: false,
			scope: "default",
			tolerance: "intersect",

			// callbacks
			activate: null,
			deactivate: null,
			drop: null,
			out: null,
			over: null
		},
		_create: function() {

			var proportions,
				o = this.options,
				accept = o.accept;

			this.isover = false;
			this.isout = true;

			this.accept = $.isFunction(accept) ? accept : function(d) {
				return d.is(accept);
			};

			this.proportions = function( /* valueToWrite */ ) {
				if ( arguments.length ) {
					// Store the droppable's proportions
					proportions = arguments[ 0 ];
				} else {
					// Retrieve or derive the droppable's proportions
					return proportions ?
						proportions :
						proportions = {
							width: this.element[ 0 ].offsetWidth,
							height: this.element[ 0 ].offsetHeight
						};
				}
			};

			// Add the reference and positions to the manager
			$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
			$.ui.ddmanager.droppables[o.scope].push(this);

			(o.addClasses && this.element.addClass("ui-droppable"));

		},

		_destroy: function() {
			var i = 0,
				drop = $.ui.ddmanager.droppables[this.options.scope];

			for ( ; i < drop.length; i++ ) {
				if ( drop[i] === this ) {
					drop.splice(i, 1);
				}
			}

			this.element.removeClass("ui-droppable ui-droppable-disabled");
		},

		_setOption: function(key, value) {

			if(key === "accept") {
				this.accept = $.isFunction(value) ? value : function(d) {
					return d.is(value);
				};
			}
			$.Widget.prototype._setOption.apply(this, arguments);
		},

		_activate: function(event) {
			var draggable = $.ui.ddmanager.current;
			if(this.options.activeClass) {
				this.element.addClass(this.options.activeClass);
			}
			if(draggable){
				this._trigger("activate", event, this.ui(draggable));
			}
		},

		_deactivate: function(event) {
			var draggable = $.ui.ddmanager.current;
			if(this.options.activeClass) {
				this.element.removeClass(this.options.activeClass);
			}
			if(draggable){
				this._trigger("deactivate", event, this.ui(draggable));
			}
		},

		_over: function(event) {

			var draggable = $.ui.ddmanager.current;

			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return;
			}

			if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.hoverClass) {
					this.element.addClass(this.options.hoverClass);
				}
				this._trigger("over", event, this.ui(draggable));
			}

		},

		_out: function(event) {

			var draggable = $.ui.ddmanager.current;

			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return;
			}

			if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.hoverClass) {
					this.element.removeClass(this.options.hoverClass);
				}
				this._trigger("out", event, this.ui(draggable));
			}

		},

		_drop: function(event,custom) {

			var draggable = custom || $.ui.ddmanager.current,
				childrenIntersection = false;

			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return false;
			}

			this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
				var inst = $.data(this, "ui-droppable");
				if(
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
					$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
				) { childrenIntersection = true; return false; }
			});
			if(childrenIntersection) {
				return false;
			}

			if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.activeClass) {
					this.element.removeClass(this.options.activeClass);
				}
				if(this.options.hoverClass) {
					this.element.removeClass(this.options.hoverClass);
				}
				this._trigger("drop", event, this.ui(draggable));
				return this.element;
			}

			return false;

		},

		ui: function(c) {
			return {
				draggable: (c.currentItem || c.element),
				helper: c.helper,
				position: c.position,
				offset: c.positionAbs
			};
		}

	});

	$.ui.intersect = function(draggable, droppable, toleranceMode) {

		if (!droppable.offset) {
			return false;
		}

		var draggableLeft, draggableTop,
			x1 = (draggable.positionAbs || draggable.position.absolute).left,
			y1 = (draggable.positionAbs || draggable.position.absolute).top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch (toleranceMode) {
			case "fit":
				return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
			case "intersect":
				return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
					x2 - (draggable.helperProportions.width / 2) < r && // Left Half
					t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
					y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			case "pointer":
				draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
				return isOverAxis( draggableTop, t, droppable.proportions().height ) && isOverAxis( draggableLeft, l, droppable.proportions().width );
			case "touch":
				return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			default:
				return false;
			}

	};

	/*
		This manager tracks offsets of draggables and droppables
	*/
	$.ui.ddmanager = {
		current: null,
		droppables: { "default": [] },
		prepareOffsets: function(t, event) {

			var i, j,
				m = $.ui.ddmanager.droppables[t.options.scope] || [],
				type = event ? event.type : null, // workaround for #2317
				list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

			droppablesLoop: for (i = 0; i < m.length; i++) {

				//No disabled and non-accepted
				if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
					continue;
				}

				// Filter out elements in the current dragged item
				for (j=0; j < list.length; j++) {
					if(list[j] === m[i].element[0]) {
						m[i].proportions().height = 0;
						continue droppablesLoop;
					}
				}

				m[i].visible = m[i].element.css("display") !== "none";
				if(!m[i].visible) {
					continue;
				}

				//Activate the droppable if used directly from draggables
				if(type === "mousedown") {
					m[i]._activate.call(m[i], event);
				}

				m[ i ].offset = m[ i ].element.offset();
				m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

			}

		},
		drop: function(draggable, event) {

			var dropped = false;
			// Create a copy of the droppables in case the list changes during the drop (#9116)
			$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

				if(!this.options) {
					return;
				}
				if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
					dropped = this._drop.call(this, event) || dropped;
				}

				if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
					this.isout = true;
					this.isover = false;
					this._deactivate.call(this, event);
				}

			});
			return dropped;

		},
		dragStart: function( draggable, event ) {
			//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
			draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
				if( !draggable.options.refreshPositions ) {
					$.ui.ddmanager.prepareOffsets( draggable, event );
				}
			});
		},
		drag: function(draggable, event) {

			//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
			if(draggable.options.refreshPositions) {
				$.ui.ddmanager.prepareOffsets(draggable, event);
			}

			//Run through all droppables and check their positions based on specific tolerance options
			$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

				if(this.options.disabled || this.greedyChild || !this.visible) {
					return;
				}

				var parentInstance, scope, parent,
					intersects = $.ui.intersect(draggable, this, this.options.tolerance),
					c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
				if(!c) {
					return;
				}

				if (this.options.greedy) {
					// find droppable parents with same scope
					scope = this.options.scope;
					parent = this.element.parents(":data(ui-droppable)").filter(function () {
						return $.data(this, "ui-droppable").options.scope === scope;
					});

					if (parent.length) {
						parentInstance = $.data(parent[0], "ui-droppable");
						parentInstance.greedyChild = (c === "isover");
					}
				}

				// we just moved into a greedy child
				if (parentInstance && c === "isover") {
					parentInstance.isover = false;
					parentInstance.isout = true;
					parentInstance._out.call(parentInstance, event);
				}

				this[c] = true;
				this[c === "isout" ? "isover" : "isout"] = false;
				this[c === "isover" ? "_over" : "_out"].call(this, event);

				// we just moved out of a greedy child
				if (parentInstance && c === "isout") {
					parentInstance.isout = false;
					parentInstance.isover = true;
					parentInstance._over.call(parentInstance, event);
				}
			});

		},
		dragStop: function( draggable, event ) {
			draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
			//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
			if( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		}
	};

	})(jQuery);
	(function($, undefined) {

	var dataSpace = "ui-effects-";

	$.effects = {
		effect: {}
	};

	/*!
	 * jQuery Color Animations v2.1.2
	 * https://github.com/jquery/jquery-color
	 *
	 * Copyright 2013 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: Wed Jan 16 08:47:09 2013 -0600
	 */
	(function( jQuery, undefined ) {

		var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

		// plusequals test for += 100 -= 100
		rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
		// a set of RE's that can match strings and generate color tuples.
		stringParsers = [{
				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ],
						execResult[ 3 ],
						execResult[ 4 ]
					];
				}
			}, {
				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ] * 2.55,
						execResult[ 2 ] * 2.55,
						execResult[ 3 ] * 2.55,
						execResult[ 4 ]
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ], 16 )
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
					];
				}
			}, {
				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				space: "hsla",
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ] / 100,
						execResult[ 3 ] / 100,
						execResult[ 4 ]
					];
				}
			}],

		// jQuery.Color( )
		color = jQuery.Color = function( color, green, blue, alpha ) {
			return new jQuery.Color.fn.parse( color, green, blue, alpha );
		},
		spaces = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},

			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		propTypes = {
			"byte": {
				floor: true,
				max: 255
			},
			"percent": {
				max: 1
			},
			"degrees": {
				mod: 360,
				floor: true
			}
		},
		support = color.support = {},

		// element for support tests
		supportElem = jQuery( "<p>" )[ 0 ],

		// colors = jQuery.Color.names
		colors,

		// local aliases of functions called often
		each = jQuery.each;

	// determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

	// define cache name and alpha properties
	// for rgba and hsla spaces
	each( spaces, function( spaceName, space ) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	});

	function clamp( value, prop, allowEmpty ) {
		var type = propTypes[ prop.type ] || {};

		if ( value == null ) {
			return (allowEmpty || !prop.def) ? null : prop.def;
		}

		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat( value );

		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if ( isNaN( value ) ) {
			return prop.def;
		}

		if ( type.mod ) {
			// we add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return (value + type.mod) % type.mod;
		}

		// for now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}

	function stringParse( string ) {
		var inst = color(),
			rgba = inst._rgba = [];

		string = string.toLowerCase();

		each( stringParsers, function( i, parser ) {
			var parsed,
				match = parser.re.exec( string ),
				values = match && parser.parse( match ),
				spaceName = parser.space || "rgba";

			if ( values ) {
				parsed = inst[ spaceName ]( values );

				// if this was an rgba parse the assignment might happen twice
				// oh well....
				inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
				rgba = inst._rgba = parsed._rgba;

				// exit each( stringParsers ) here because we matched
				return false;
			}
		});

		// Found a stringParser that handled it
		if ( rgba.length ) {

			// if this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if ( rgba.join() === "0,0,0,0" ) {
				jQuery.extend( rgba, colors.transparent );
			}
			return inst;
		}

		// named colors
		return colors[ string ];
	}

	color.fn = jQuery.extend( color.prototype, {
		parse: function( red, green, blue, alpha ) {
			if ( red === undefined ) {
				this._rgba = [ null, null, null, null ];
				return this;
			}
			if ( red.jquery || red.nodeType ) {
				red = jQuery( red ).css( green );
				green = undefined;
			}

			var inst = this,
				type = jQuery.type( red ),
				rgba = this._rgba = [];

			// more than 1 argument specified - assume ( red, green, blue, alpha )
			if ( green !== undefined ) {
				red = [ red, green, blue, alpha ];
				type = "array";
			}

			if ( type === "string" ) {
				return this.parse( stringParse( red ) || colors._default );
			}

			if ( type === "array" ) {
				each( spaces.rgba.props, function( key, prop ) {
					rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
				});
				return this;
			}

			if ( type === "object" ) {
				if ( red instanceof color ) {
					each( spaces, function( spaceName, space ) {
						if ( red[ space.cache ] ) {
							inst[ space.cache ] = red[ space.cache ].slice();
						}
					});
				} else {
					each( spaces, function( spaceName, space ) {
						var cache = space.cache;
						each( space.props, function( key, prop ) {

							// if the cache doesn't exist, and we know how to convert
							if ( !inst[ cache ] && space.to ) {

								// if the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if ( key === "alpha" || red[ key ] == null ) {
									return;
								}
								inst[ cache ] = space.to( inst._rgba );
							}

							// this is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
						});

						// everything defined but alpha?
						if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
							// use the default of 1
							inst[ cache ][ 3 ] = 1;
							if ( space.from ) {
								inst._rgba = space.from( inst[ cache ] );
							}
						}
					});
				}
				return this;
			}
		},
		is: function( compare ) {
			var is = color( compare ),
				same = true,
				inst = this;

			each( spaces, function( _, space ) {
				var localCache,
					isCache = is[ space.cache ];
				if (isCache) {
					localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
					each( space.props, function( _, prop ) {
						if ( isCache[ prop.idx ] != null ) {
							same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
							return same;
						}
					});
				}
				return same;
			});
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each( spaces, function( spaceName, space ) {
				if ( inst[ space.cache ] ) {
					used.push( spaceName );
				}
			});
			return used.pop();
		},
		transition: function( other, distance ) {
			var end = color( other ),
				spaceName = end._space(),
				space = spaces[ spaceName ],
				startColor = this.alpha() === 0 ? color( "transparent" ) : this,
				start = startColor[ space.cache ] || space.to( startColor._rgba ),
				result = start.slice();

			end = end[ space.cache ];
			each( space.props, function( key, prop ) {
				var index = prop.idx,
					startValue = start[ index ],
					endValue = end[ index ],
					type = propTypes[ prop.type ] || {};

				// if null, don't override start value
				if ( endValue === null ) {
					return;
				}
				// if null - use end
				if ( startValue === null ) {
					result[ index ] = endValue;
				} else {
					if ( type.mod ) {
						if ( endValue - startValue > type.mod / 2 ) {
							startValue += type.mod;
						} else if ( startValue - endValue > type.mod / 2 ) {
							startValue -= type.mod;
						}
					}
					result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
				}
			});
			return this[ spaceName ]( result );
		},
		blend: function( opaque ) {
			// if we are already opaque - return ourself
			if ( this._rgba[ 3 ] === 1 ) {
				return this;
			}

			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color( opaque )._rgba;

			return color( jQuery.map( rgb, function( v, i ) {
				return ( 1 - a ) * blend[ i ] + a * v;
			}));
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map( this._rgba, function( v, i ) {
					return v == null ? ( i > 2 ? 1 : 0 ) : v;
				});

			if ( rgba[ 3 ] === 1 ) {
				rgba.pop();
				prefix = "rgb(";
			}

			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map( this.hsla(), function( v, i ) {
					if ( v == null ) {
						v = i > 2 ? 1 : 0;
					}

					// catch 1 and 2
					if ( i && i < 3 ) {
						v = Math.round( v * 100 ) + "%";
					}
					return v;
				});

			if ( hsla[ 3 ] === 1 ) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function( includeAlpha ) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();

			if ( includeAlpha ) {
				rgba.push( ~~( alpha * 255 ) );
			}

			return "#" + jQuery.map( rgba, function( v ) {

				// default to 0 when nulls exist
				v = ( v || 0 ).toString( 16 );
				return v.length === 1 ? "0" + v : v;
			}).join("");
		},
		toString: function() {
			return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
		}
	});
	color.fn.parse.prototype = color.fn;

	// hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

	function hue2rgb( p, q, h ) {
		h = ( h + 1 ) % 1;
		if ( h * 6 < 1 ) {
			return p + (q - p) * h * 6;
		}
		if ( h * 2 < 1) {
			return q;
		}
		if ( h * 3 < 2 ) {
			return p + (q - p) * ((2/3) - h) * 6;
		}
		return p;
	}

	spaces.hsla.to = function ( rgba ) {
		if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
			return [ null, null, null, rgba[ 3 ] ];
		}
		var r = rgba[ 0 ] / 255,
			g = rgba[ 1 ] / 255,
			b = rgba[ 2 ] / 255,
			a = rgba[ 3 ],
			max = Math.max( r, g, b ),
			min = Math.min( r, g, b ),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;

		if ( min === max ) {
			h = 0;
		} else if ( r === max ) {
			h = ( 60 * ( g - b ) / diff ) + 360;
		} else if ( g === max ) {
			h = ( 60 * ( b - r ) / diff ) + 120;
		} else {
			h = ( 60 * ( r - g ) / diff ) + 240;
		}

		// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
		// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
		if ( diff === 0 ) {
			s = 0;
		} else if ( l <= 0.5 ) {
			s = diff / add;
		} else {
			s = diff / ( 2 - add );
		}
		return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
	};

	spaces.hsla.from = function ( hsla ) {
		if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
			return [ null, null, null, hsla[ 3 ] ];
		}
		var h = hsla[ 0 ] / 360,
			s = hsla[ 1 ],
			l = hsla[ 2 ],
			a = hsla[ 3 ],
			q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
			p = 2 * l - q;

		return [
			Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
			Math.round( hue2rgb( p, q, h ) * 255 ),
			Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
			a
		];
	};


	each( spaces, function( spaceName, space ) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;

		// makes rgba() and hsla()
		color.fn[ spaceName ] = function( value ) {

			// generate a cache for this space if it doesn't exist
			if ( to && !this[ cache ] ) {
				this[ cache ] = to( this._rgba );
			}
			if ( value === undefined ) {
				return this[ cache ].slice();
			}

			var ret,
				type = jQuery.type( value ),
				arr = ( type === "array" || type === "object" ) ? value : arguments,
				local = this[ cache ].slice();

			each( props, function( key, prop ) {
				var val = arr[ type === "object" ? key : prop.idx ];
				if ( val == null ) {
					val = local[ prop.idx ];
				}
				local[ prop.idx ] = clamp( val, prop );
			});

			if ( from ) {
				ret = color( from( local ) );
				ret[ cache ] = local;
				return ret;
			} else {
				return color( local );
			}
		};

		// makes red() green() blue() alpha() hue() saturation() lightness()
		each( props, function( key, prop ) {
			// alpha is included in more than one space
			if ( color.fn[ key ] ) {
				return;
			}
			color.fn[ key ] = function( value ) {
				var vtype = jQuery.type( value ),
					fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
					local = this[ fn ](),
					cur = local[ prop.idx ],
					match;

				if ( vtype === "undefined" ) {
					return cur;
				}

				if ( vtype === "function" ) {
					value = value.call( this, cur );
					vtype = jQuery.type( value );
				}
				if ( value == null && prop.empty ) {
					return this;
				}
				if ( vtype === "string" ) {
					match = rplusequals.exec( value );
					if ( match ) {
						value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
					}
				}
				local[ prop.idx ] = value;
				return this[ fn ]( local );
			};
		});
	});

	// add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function( hook ) {
		var hooks = hook.split( " " );
		each( hooks, function( i, hook ) {
			jQuery.cssHooks[ hook ] = {
				set: function( elem, value ) {
					var parsed, curElem,
						backgroundColor = "";

					if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
						value = color( parsed || value );
						if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								(backgroundColor === "" || backgroundColor === "transparent") &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css( curElem, "backgroundColor" );
									curElem = curElem.parentNode;
								} catch ( e ) {
								}
							}

							value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default" );
						}

						value = value.toRgbaString();
					}
					try {
						elem.style[ hook ] = value;
					} catch( e ) {
						// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[ hook ] = function( fx ) {
				if ( !fx.colorInit ) {
					fx.start = color( fx.elem, hook );
					fx.end = color( fx.end );
					fx.colorInit = true;
				}
				jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
			};
		});

	};

	color.hook( stepHooks );

	jQuery.cssHooks.borderColor = {
		expand: function( value ) {
			var expanded = {};

			each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
				expanded[ "border" + part + "Color" ] = value;
			});
			return expanded;
		}
	};

	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",

		// 4.2.3. "transparent" color keyword
		transparent: [ null, null, null, 0 ],

		_default: "#ffffff"
	};

	})( jQuery );


	/******************************************************************************/
	/****************************** CLASS ANIMATIONS ******************************/
	/******************************************************************************/
	(function() {

	var classAnimationActions = [ "add", "remove", "toggle" ],
		shorthandStyles = {
			border: 1,
			borderBottom: 1,
			borderColor: 1,
			borderLeft: 1,
			borderRight: 1,
			borderTop: 1,
			borderWidth: 1,
			margin: 1,
			padding: 1
		};

	$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	});

	function getElementStyles( elem ) {
		var key, len,
			style = elem.ownerDocument.defaultView ?
				elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
				elem.currentStyle,
			styles = {};

		if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
			len = style.length;
			while ( len-- ) {
				key = style[ len ];
				if ( typeof style[ key ] === "string" ) {
					styles[ $.camelCase( key ) ] = style[ key ];
				}
			}
		// support: Opera, IE <9
		} else {
			for ( key in style ) {
				if ( typeof style[ key ] === "string" ) {
					styles[ key ] = style[ key ];
				}
			}
		}

		return styles;
	}


	function styleDifference( oldStyle, newStyle ) {
		var diff = {},
			name, value;

		for ( name in newStyle ) {
			value = newStyle[ name ];
			if ( oldStyle[ name ] !== value ) {
				if ( !shorthandStyles[ name ] ) {
					if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
						diff[ name ] = value;
					}
				}
			}
		}

		return diff;
	}

	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}

	$.effects.animateClass = function( value, duration, easing, callback ) {
		var o = $.speed( duration, easing, callback );

		return this.queue( function() {
			var animated = $( this ),
				baseClass = animated.attr( "class" ) || "",
				applyClassChange,
				allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

			// map the animated objects to store the original styles.
			allAnimations = allAnimations.map(function() {
				var el = $( this );
				return {
					el: el,
					start: getElementStyles( this )
				};
			});

			// apply class change
			applyClassChange = function() {
				$.each( classAnimationActions, function(i, action) {
					if ( value[ action ] ) {
						animated[ action + "Class" ]( value[ action ] );
					}
				});
			};
			applyClassChange();

			// map all animated objects again - calculate new styles and diff
			allAnimations = allAnimations.map(function() {
				this.end = getElementStyles( this.el[ 0 ] );
				this.diff = styleDifference( this.start, this.end );
				return this;
			});

			// apply original class
			animated.attr( "class", baseClass );

			// map all animated objects again - this time collecting a promise
			allAnimations = allAnimations.map(function() {
				var styleInfo = this,
					dfd = $.Deferred(),
					opts = $.extend({}, o, {
						queue: false,
						complete: function() {
							dfd.resolve( styleInfo );
						}
					});

				this.el.animate( this.diff, opts );
				return dfd.promise();
			});

			// once all animations have completed:
			$.when.apply( $, allAnimations.get() ).done(function() {

				// set the final class
				applyClassChange();

				// for each animated element,
				// clear all css properties that were animated
				$.each( arguments, function() {
					var el = this.el;
					$.each( this.diff, function(key) {
						el.css( key, "" );
					});
				});

				// this is guarnteed to be there if you use jQuery.speed()
				// it also handles dequeuing the next anim...
				o.complete.call( animated[ 0 ] );
			});
		});
	};

	$.fn.extend({
		addClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return speed ?
					$.effects.animateClass.call( this,
						{ add: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.addClass ),

		removeClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return arguments.length > 1 ?
					$.effects.animateClass.call( this,
						{ remove: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.removeClass ),

		toggleClass: (function( orig ) {
			return function( classNames, force, speed, easing, callback ) {
				if ( typeof force === "boolean" || force === undefined ) {
					if ( !speed ) {
						// without speed parameter
						return orig.apply( this, arguments );
					} else {
						return $.effects.animateClass.call( this,
							(force ? { add: classNames } : { remove: classNames }),
							speed, easing, callback );
					}
				} else {
					// without force parameter
					return $.effects.animateClass.call( this,
						{ toggle: classNames }, force, speed, easing );
				}
			};
		})( $.fn.toggleClass ),

		switchClass: function( remove, add, speed, easing, callback) {
			return $.effects.animateClass.call( this, {
				add: add,
				remove: remove
			}, speed, easing, callback );
		}
	});

	})();

	/******************************************************************************/
	/*********************************** EFFECTS **********************************/
	/******************************************************************************/

	(function() {

	$.extend( $.effects, {
		version: "1.10.4",

		// Saves a set of properties in a data storage
		save: function( element, set ) {
			for( var i=0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},

		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i;
			for( i=0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					// support: jQuery 1.6.2
					// http://bugs.jquery.com/ticket/9917
					// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
					// We can't differentiate between "" and 0 here, so we just assume
					// empty string since it's likely to be a more common value...
					if ( val === undefined ) {
						val = "";
					}
					element.css( set[ i ], val );
				}
			}
		},

		setMode: function( el, mode ) {
			if (mode === "toggle") {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},

		// Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		getBaseline: function( origin, original ) {
			var y, x;
			switch ( origin[ 0 ] ) {
				case "top": y = 0; break;
				case "middle": y = 0.5; break;
				case "bottom": y = 1; break;
				default: y = origin[ 0 ] / original.height;
			}
			switch ( origin[ 1 ] ) {
				case "left": x = 0; break;
				case "center": x = 0.5; break;
				case "right": x = 1; break;
				default: x = origin[ 1 ] / original.width;
			}
			return {
				x: x,
				y: y
			};
		},

		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {

			// if the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" )) {
				return element.parent();
			}

			// wrap the element
			var props = {
					width: element.outerWidth(true),
					height: element.outerHeight(true),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css({
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					}),
				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;

			// support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch( e ) {
				active = document.body;
			}

			element.wrap( wrapper );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}

			wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

			// transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css({ position: "relative" });
				element.css({ position: "relative" });
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				});
				$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				});
				element.css({
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				});
			}
			element.css(size);

			return wrapper.css( props ).show();
		},

		removeWrapper: function( element ) {
			var active = document.activeElement;

			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );

				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).focus();
				}
			}


			return element;
		},

		setTransition: function( element, list, factor, value ) {
			value = value || {};
			$.each( list, function( i, x ) {
				var unit = element.cssUnit( x );
				if ( unit[ 0 ] > 0 ) {
					value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
				}
			});
			return value;
		}
	});

	// return an effect options object for the given parameters:
	function _normalizeArguments( effect, options, speed, callback ) {

		// allow passing all options as the first parameter
		if ( $.isPlainObject( effect ) ) {
			options = effect;
			effect = effect.effect;
		}

		// convert to an object
		effect = { effect: effect };

		// catch (effect, null, ...)
		if ( options == null ) {
			options = {};
		}

		// catch (effect, callback)
		if ( $.isFunction( options ) ) {
			callback = options;
			speed = null;
			options = {};
		}

		// catch (effect, speed, ?)
		if ( typeof options === "number" || $.fx.speeds[ options ] ) {
			callback = speed;
			speed = options;
			options = {};
		}

		// catch (effect, options, callback)
		if ( $.isFunction( speed ) ) {
			callback = speed;
			speed = null;
		}

		// add options to effect
		if ( options ) {
			$.extend( effect, options );
		}

		speed = speed || options.duration;
		effect.duration = $.fx.off ? 0 :
			typeof speed === "number" ? speed :
			speed in $.fx.speeds ? $.fx.speeds[ speed ] :
			$.fx.speeds._default;

		effect.complete = callback || options.complete;

		return effect;
	}

	function standardAnimationOption( option ) {
		// Valid standard speeds (nothing, number, named speed)
		if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
			return true;
		}

		// Invalid strings - treat as "normal" speed
		if ( typeof option === "string" && !$.effects.effect[ option ] ) {
			return true;
		}

		// Complete callback
		if ( $.isFunction( option ) ) {
			return true;
		}

		// Options hash (but not naming an effect)
		if ( typeof option === "object" && !option.effect ) {
			return true;
		}

		// Didn't match any standard API
		return false;
	}

	$.fn.extend({
		effect: function( /* effect, options, speed, callback */ ) {
			var args = _normalizeArguments.apply( this, arguments ),
				mode = args.mode,
				queue = args.queue,
				effectMethod = $.effects.effect[ args.effect ];

			if ( $.fx.off || !effectMethod ) {
				// delegate to the original method (e.g., .show()) if possible
				if ( mode ) {
					return this[ mode ]( args.duration, args.complete );
				} else {
					return this.each( function() {
						if ( args.complete ) {
							args.complete.call( this );
						}
					});
				}
			}

			function run( next ) {
				var elem = $( this ),
					complete = args.complete,
					mode = args.mode;

				function done() {
					if ( $.isFunction( complete ) ) {
						complete.call( elem[0] );
					}
					if ( $.isFunction( next ) ) {
						next();
					}
				}

				// If the element already has the correct final state, delegate to
				// the core methods so the internal tracking of "olddisplay" works.
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[0], args, done );
				}
			}

			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		},

		show: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "show";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.show ),

		hide: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "hide";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.hide ),

		toggle: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "toggle";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.toggle ),

		// helper functions
		cssUnit: function(key) {
			var style = this.css( key ),
				val = [];

			$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
				if ( style.indexOf( unit ) > 0 ) {
					val = [ parseFloat( style ), unit ];
				}
			});
			return val;
		}
	});

	})();

	/******************************************************************************/
	/*********************************** EASING ***********************************/
	/******************************************************************************/

	(function() {

	// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

	var baseEasings = {};

	$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
		baseEasings[ name ] = function( p ) {
			return Math.pow( p, i + 2 );
		};
	});

	$.extend( baseEasings, {
		Sine: function ( p ) {
			return 1 - Math.cos( p * Math.PI / 2 );
		},
		Circ: function ( p ) {
			return 1 - Math.sqrt( 1 - p * p );
		},
		Elastic: function( p ) {
			return p === 0 || p === 1 ? p :
				-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
		},
		Back: function( p ) {
			return p * p * ( 3 * p - 2 );
		},
		Bounce: function ( p ) {
			var pow2,
				bounce = 4;

			while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
			return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
		}
	});

	$.each( baseEasings, function( name, easeIn ) {
		$.easing[ "easeIn" + name ] = easeIn;
		$.easing[ "easeOut" + name ] = function( p ) {
			return 1 - easeIn( 1 - p );
		};
		$.easing[ "easeInOut" + name ] = function( p ) {
			return p < 0.5 ?
				easeIn( p * 2 ) / 2 :
				1 - easeIn( p * -2 + 2 ) / 2;
		};
	});

	})();

	})(jQuery);
	(function( $, undefined ) {

	var rvertical = /up|down|vertical/,
		rpositivemotion = /up|left|vertical|horizontal/;

	$.effects.effect.blind = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			direction = o.direction || "up",
			vertical = rvertical.test( direction ),
			ref = vertical ? "height" : "width",
			ref2 = vertical ? "top" : "left",
			motion = rpositivemotion.test( direction ),
			animation = {},
			show = mode === "show",
			wrapper, distance, margin;

		// if already wrapped, the wrapper's properties are my property. #6245
		if ( el.parent().is( ".ui-effects-wrapper" ) ) {
			$.effects.save( el.parent(), props );
		} else {
			$.effects.save( el, props );
		}
		el.show();
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});

		distance = wrapper[ ref ]();
		margin = parseFloat( wrapper.css( ref2 ) ) || 0;

		animation[ ref ] = show ? distance : 0;
		if ( !motion ) {
			el
				.css( vertical ? "bottom" : "right", 0 )
				.css( vertical ? "top" : "left", "auto" )
				.css({ position: "absolute" });

			animation[ ref2 ] = show ? margin : distance + margin;
		}

		// start at 0 if we are showing
		if ( show ) {
			wrapper.css( ref, 0 );
			if ( ! motion ) {
				wrapper.css( ref2, margin + distance );
			}
		}

		// Animate
		wrapper.animate( animation, {
			duration: o.duration,
			easing: o.easing,
			queue: false,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.bounce = function( o, done ) {
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

			// defaults:
			mode = $.effects.setMode( el, o.mode || "effect" ),
			hide = mode === "hide",
			show = mode === "show",
			direction = o.direction || "up",
			distance = o.distance,
			times = o.times || 5,

			// number of internal animations
			anims = times * 2 + ( show || hide ? 1 : 0 ),
			speed = o.duration / anims,
			easing = o.easing,

			// utility:
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ),
			i,
			upAnim,
			downAnim,

			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;

		// Avoid touching opacity to prevent clearType and PNG issues in IE
		if ( show || hide ) {
			props.push( "opacity" );
		}

		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el ); // Create Wrapper

		// default distance for the BIGGEST bounce is the outer Distance / 3
		if ( !distance ) {
			distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
		}

		if ( show ) {
			downAnim = { opacity: 1 };
			downAnim[ ref ] = 0;

			// if we are showing, force opacity 0 and set the initial position
			// then do the "first" animation
			el.css( "opacity", 0 )
				.css( ref, motion ? -distance * 2 : distance * 2 )
				.animate( downAnim, speed, easing );
		}

		// start at the smallest distance if we are hiding
		if ( hide ) {
			distance = distance / Math.pow( 2, times - 1 );
		}

		downAnim = {};
		downAnim[ ref ] = 0;
		// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
		for ( i = 0; i < times; i++ ) {
			upAnim = {};
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

			el.animate( upAnim, speed, easing )
				.animate( downAnim, speed, easing );

			distance = hide ? distance * 2 : distance / 2;
		}

		// Last Bounce when Hiding
		if ( hide ) {
			upAnim = { opacity: 0 };
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

			el.animate( upAnim, speed, easing );
		}

		el.queue(function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.clip = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "vertical",
			vert = direction === "vertical",
			size = vert ? "height" : "width",
			position = vert ? "top" : "left",
			animation = {},
			wrapper, animate, distance;

		// Save & Show
		$.effects.save( el, props );
		el.show();

		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
		distance = animate[ size ]();

		// Shift
		if ( show ) {
			animate.css( size, 0 );
			animate.css( position, distance / 2 );
		}

		// Create Animation Object:
		animation[ size ] = show ? distance : 0;
		animation[ position ] = show ? 0 : distance / 2;

		// Animate
		animate.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( !show ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.drop = function( o, done ) {

		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
			animation = {
				opacity: show ? 1 : 0
			},
			distance;

		// Adjust
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );

		distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

		if ( show ) {
			el
				.css( "opacity", 0 )
				.css( ref, motion === "pos" ? -distance : distance );
		}

		// Animation
		animation[ ref ] = ( show ?
			( motion === "pos" ? "+=" : "-=" ) :
			( motion === "pos" ? "-=" : "+=" ) ) +
			distance;

		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.explode = function( o, done ) {

		var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
			cells = rows,
			el = $( this ),
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",

			// show and then visibility:hidden the element before calculating offset
			offset = el.show().css( "visibility", "hidden" ).offset(),

			// width and height of a piece
			width = Math.ceil( el.outerWidth() / cells ),
			height = Math.ceil( el.outerHeight() / rows ),
			pieces = [],

			// loop
			i, j, left, top, mx, my;

		// children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}

		// clone the element for each row and cell.
		for( i = 0; i < rows ; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2 ;

			for( j = 0; j < cells ; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2 ;

				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				el
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css({
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					})

				// select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
					.parent()
					.addClass( "ui-effects-explode" )
					.css({
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					}).animate({
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, o.duration || 500, o.easing, childComplete );
			}
		}

		function animComplete() {
			el.css({
				visibility: "visible"
			});
			$( pieces ).remove();
			if ( !show ) {
				el.hide();
			}
			done();
		}
	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.fade = function( o, done ) {
		var el = $( this ),
			mode = $.effects.setMode( el, o.mode || "toggle" );

		el.animate({
			opacity: mode
		}, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: done
		});
	};

	})( jQuery );
	(function( $, undefined ) {

	$.effects.effect.fold = function( o, done ) {

		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			hide = mode === "hide",
			size = o.size || 15,
			percent = /([0-9]+)%/.exec( size ),
			horizFirst = !!o.horizFirst,
			widthFirst = show !== horizFirst,
			ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
			duration = o.duration / 2,
			wrapper, distance,
			animation1 = {},
			animation2 = {};

		$.effects.save( el, props );
		el.show();

		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		distance = widthFirst ?
			[ wrapper.width(), wrapper.height() ] :
			[ wrapper.height(), wrapper.width() ];

		if ( percent ) {
			size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
		}
		if ( show ) {
			wrapper.css( horizFirst ? {
				height: 0,
				width: size
			} : {
				height: size,
				width: 0
			});
		}

		// Animation
		animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
		animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

		// Animate
		wrapper
			.animate( animation1, duration, o.easing )
			.animate( animation2, duration, o.easing, function() {
				if ( hide ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.highlight = function( o, done ) {
		var elem = $( this ),
			props = [ "backgroundImage", "backgroundColor", "opacity" ],
			mode = $.effects.setMode( elem, o.mode || "show" ),
			animation = {
				backgroundColor: elem.css( "backgroundColor" )
			};

		if (mode === "hide") {
			animation.opacity = 0;
		}

		$.effects.save( elem, props );

		elem
			.show()
			.css({
				backgroundImage: "none",
				backgroundColor: o.color || "#ffff99"
			})
			.animate( animation, {
				queue: false,
				duration: o.duration,
				easing: o.easing,
				complete: function() {
					if ( mode === "hide" ) {
						elem.hide();
					}
					$.effects.restore( elem, props );
					done();
				}
			});
	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.pulsate = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "show" ),
			show = mode === "show",
			hide = mode === "hide",
			showhide = ( show || mode === "hide" ),

			// showing or hiding leaves of the "last" animation
			anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = o.duration / anims,
			animateTo = 0,
			queue = elem.queue(),
			queuelen = queue.length,
			i;

		if ( show || !elem.is(":visible")) {
			elem.css( "opacity", 0 ).show();
			animateTo = 1;
		}

		// anims - 1 opacity "toggles"
		for ( i = 1; i < anims; i++ ) {
			elem.animate({
				opacity: animateTo
			}, duration, o.easing );
			animateTo = 1 - animateTo;
		}

		elem.animate({
			opacity: animateTo
		}, duration, o.easing);

		elem.queue(function() {
			if ( hide ) {
				elem.hide();
			}
			done();
		});

		// We just queued up "anims" animations, we need to put them next in the queue
		if ( queuelen > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		elem.dequeue();
	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.puff = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "hide" ),
			hide = mode === "hide",
			percent = parseInt( o.percent, 10 ) || 150,
			factor = percent / 100,
			original = {
				height: elem.height(),
				width: elem.width(),
				outerHeight: elem.outerHeight(),
				outerWidth: elem.outerWidth()
			};

		$.extend( o, {
			effect: "scale",
			queue: false,
			fade: true,
			mode: mode,
			complete: done,
			percent: hide ? percent : 100,
			from: hide ?
				original :
				{
					height: original.height * factor,
					width: original.width * factor,
					outerHeight: original.outerHeight * factor,
					outerWidth: original.outerWidth * factor
				}
		});

		elem.effect( o );
	};

	$.effects.effect.scale = function( o, done ) {

		// Create element
		var el = $( this ),
			options = $.extend( true, {}, o ),
			mode = $.effects.setMode( el, o.mode || "effect" ),
			percent = parseInt( o.percent, 10 ) ||
				( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
			direction = o.direction || "both",
			origin = o.origin,
			original = {
				height: el.height(),
				width: el.width(),
				outerHeight: el.outerHeight(),
				outerWidth: el.outerWidth()
			},
			factor = {
				y: direction !== "horizontal" ? (percent / 100) : 1,
				x: direction !== "vertical" ? (percent / 100) : 1
			};

		// We are going to pass this effect to the size effect:
		options.effect = "size";
		options.queue = false;
		options.complete = done;

		// Set default origin and restore for show/hide
		if ( mode !== "effect" ) {
			options.origin = origin || ["middle","center"];
			options.restore = true;
		}

		options.from = o.from || ( mode === "show" ? {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		} : original );
		options.to = {
			height: original.height * factor.y,
			width: original.width * factor.x,
			outerHeight: original.outerHeight * factor.y,
			outerWidth: original.outerWidth * factor.x
		};

		// Fade option to support puff
		if ( options.fade ) {
			if ( mode === "show" ) {
				options.from.opacity = 0;
				options.to.opacity = 1;
			}
			if ( mode === "hide" ) {
				options.from.opacity = 1;
				options.to.opacity = 0;
			}
		}

		// Animate
		el.effect( options );

	};

	$.effects.effect.size = function( o, done ) {

		// Create element
		var original, baseline, factor,
			el = $( this ),
			props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

			// Always restore
			props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

			// Copy for children
			props2 = [ "width", "height", "overflow" ],
			cProps = [ "fontSize" ],
			vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
			hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

			// Set options
			mode = $.effects.setMode( el, o.mode || "effect" ),
			restore = o.restore || mode !== "effect",
			scale = o.scale || "both",
			origin = o.origin || [ "middle", "center" ],
			position = el.css( "position" ),
			props = restore ? props0 : props1,
			zero = {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};

		if ( mode === "show" ) {
			el.show();
		}
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		};

		if ( o.mode === "toggle" && mode === "show" ) {
			el.from = o.to || zero;
			el.to = o.from || original;
		} else {
			el.from = o.from || ( mode === "show" ? zero : original );
			el.to = o.to || ( mode === "hide" ? zero : original );
		}

		// Set scaling factor
		factor = {
			from: {
				y: el.from.height / original.height,
				x: el.from.width / original.width
			},
			to: {
				y: el.to.height / original.height,
				x: el.to.width / original.width
			}
		};

		// Scale the css box
		if ( scale === "box" || scale === "both" ) {

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( vProps );
				el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				props = props.concat( hProps );
				el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
				el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
			}
		}

		// Scale the content
		if ( scale === "content" || scale === "both" ) {

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( cProps ).concat( props2 );
				el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
			}
		}

		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
		el.css( "overflow", "hidden" ).css( el.from );

		// Adjust
		if (origin) { // Calculate baseline shifts
			baseline = $.effects.getBaseline( origin, original );
			el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
			el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
			el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
			el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
		}
		el.css( el.from ); // set top & left

		// Animate
		if ( scale === "content" || scale === "both" ) { // Scale the children

			// Add margins/font-size
			vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
			hProps = hProps.concat([ "marginLeft", "marginRight" ]);
			props2 = props0.concat(vProps).concat(hProps);

			el.find( "*[width]" ).each( function(){
				var child = $( this ),
					c_original = {
						height: child.height(),
						width: child.width(),
						outerHeight: child.outerHeight(),
						outerWidth: child.outerWidth()
					};
				if (restore) {
					$.effects.save(child, props2);
				}

				child.from = {
					height: c_original.height * factor.from.y,
					width: c_original.width * factor.from.x,
					outerHeight: c_original.outerHeight * factor.from.y,
					outerWidth: c_original.outerWidth * factor.from.x
				};
				child.to = {
					height: c_original.height * factor.to.y,
					width: c_original.width * factor.to.x,
					outerHeight: c_original.height * factor.to.y,
					outerWidth: c_original.width * factor.to.x
				};

				// Vertical props scaling
				if ( factor.from.y !== factor.to.y ) {
					child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
					child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
				}

				// Horizontal props scaling
				if ( factor.from.x !== factor.to.x ) {
					child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
					child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
				}

				// Animate children
				child.css( child.from );
				child.animate( child.to, o.duration, o.easing, function() {

					// Restore children
					if ( restore ) {
						$.effects.restore( child, props2 );
					}
				});
			});
		}

		// Animate
		el.animate( el.to, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( el.to.opacity === 0 ) {
					el.css( "opacity", el.from.opacity );
				}
				if( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				if ( !restore ) {

					// we need to calculate our new positioning based on the scaling
					if ( position === "static" ) {
						el.css({
							position: "relative",
							top: el.to.top,
							left: el.to.left
						});
					} else {
						$.each([ "top", "left" ], function( idx, pos ) {
							el.css( pos, function( _, str ) {
								var val = parseInt( str, 10 ),
									toRef = idx ? el.to.left : el.to.top;

								// if original was "auto", recalculate the new value from wrapper
								if ( str === "auto" ) {
									return toRef + "px";
								}

								return val + toRef + "px";
							});
						});
					}
				}

				$.effects.removeWrapper( el );
				done();
			}
		});

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.shake = function( o, done ) {

		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "effect" ),
			direction = o.direction || "left",
			distance = o.distance || 20,
			times = o.times || 3,
			anims = times * 2 + 1,
			speed = Math.round(o.duration/anims),
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			animation = {},
			animation1 = {},
			animation2 = {},
			i,

			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;

		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );

		// Animation
		animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
		animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
		animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

		// Animate
		el.animate( animation, speed, o.easing );

		// Shakes
		for ( i = 1; i < times; i++ ) {
			el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
		}
		el
			.animate( animation1, speed, o.easing )
			.animate( animation, speed / 2, o.easing )
			.queue(function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});

		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();

	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.slide = function( o, done ) {

		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
			mode = $.effects.setMode( el, o.mode || "show" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			distance,
			animation = {};

		// Adjust
		$.effects.save( el, props );
		el.show();
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

		$.effects.createWrapper( el ).css({
			overflow: "hidden"
		});

		if ( show ) {
			el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
		}

		// Animation
		animation[ ref ] = ( show ?
			( positiveMotion ? "+=" : "-=") :
			( positiveMotion ? "-=" : "+=")) +
			distance;

		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};

	})(jQuery);
	(function( $, undefined ) {

	$.effects.effect.transfer = function( o, done ) {
		var elem = $( this ),
			target = $( o.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $("body"),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop ,
				left: endPosition.left - fixLeft ,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( document.body )
				.addClass( o.className )
				.css({
					top: startPosition.top - fixTop ,
					left: startPosition.left - fixLeft ,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				})
				.animate( animation, o.duration, o.easing, function() {
					transfer.remove();
					done();
				});
	};

	})(jQuery);
	(function( $, undefined ) {

	$.widget( "ui.menu", {
		version: "1.10.4",
		defaultElement: "<ul>",
		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-carat-1-e"
			},
			menus: "ul",
			position: {
				my: "left top",
				at: "right top"
			},
			role: "menu",

			// callbacks
			blur: null,
			focus: null,
			select: null
		},

		_create: function() {
			this.activeMenu = this.element;
			// flag used to prevent firing of the click handler
			// as the event bubbles up through nested menus
			this.mouseHandled = false;
			this.element
				.uniqueId()
				.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
				.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
				.attr({
					role: this.options.role,
					tabIndex: 0
				})
				// need to catch all clicks on disabled menu
				// not possible through _on
				.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
					if ( this.options.disabled ) {
						event.preventDefault();
					}
				}, this ));

			if ( this.options.disabled ) {
				this.element
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			}

			this._on({
				// Prevent focus from sticking to links inside menu after clicking
				// them (focus should always stay on UL during navigation).
				"mousedown .ui-menu-item > a": function( event ) {
					event.preventDefault();
				},
				"click .ui-state-disabled > a": function( event ) {
					event.preventDefault();
				},
				"click .ui-menu-item:has(a)": function( event ) {
					var target = $( event.target ).closest( ".ui-menu-item" );
					if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
						this.select( event );

						// Only set the mouseHandled flag if the event will bubble, see #9469.
						if ( !event.isPropagationStopped() ) {
							this.mouseHandled = true;
						}

						// Open submenu on click
						if ( target.has( ".ui-menu" ).length ) {
							this.expand( event );
						} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

							// Redirect focus to the menu
							this.element.trigger( "focus", [ true ] );

							// If the active item is on the top level, let it stay active.
							// Otherwise, blur the active item since it is no longer visible.
							if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
								clearTimeout( this.timer );
							}
						}
					}
				},
				"mouseenter .ui-menu-item": function( event ) {
					var target = $( event.currentTarget );
					// Remove ui-state-active class from siblings of the newly focused menu item
					// to avoid a jump caused by adjacent elements both having a class with a border
					target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
					this.focus( event, target );
				},
				mouseleave: "collapseAll",
				"mouseleave .ui-menu": "collapseAll",
				focus: function( event, keepActiveItem ) {
					// If there's already an active item, keep it active
					// If not, activate the first item
					var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

					if ( !keepActiveItem ) {
						this.focus( event, item );
					}
				},
				blur: function( event ) {
					this._delay(function() {
						if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
							this.collapseAll( event );
						}
					});
				},
				keydown: "_keydown"
			});

			this.refresh();

			// Clicks outside of a menu collapse any open menus
			this._on( this.document, {
				click: function( event ) {
					if ( !$( event.target ).closest( ".ui-menu" ).length ) {
						this.collapseAll( event );
					}

					// Reset the mouseHandled flag
					this.mouseHandled = false;
				}
			});
		},

		_destroy: function() {
			// Destroy (sub)menus
			this.element
				.removeAttr( "aria-activedescendant" )
				.find( ".ui-menu" ).addBack()
					.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
					.removeAttr( "role" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-disabled" )
					.removeUniqueId()
					.show();

			// Destroy menu items
			this.element.find( ".ui-menu-item" )
				.removeClass( "ui-menu-item" )
				.removeAttr( "role" )
				.removeAttr( "aria-disabled" )
				.children( "a" )
					.removeUniqueId()
					.removeClass( "ui-corner-all ui-state-hover" )
					.removeAttr( "tabIndex" )
					.removeAttr( "role" )
					.removeAttr( "aria-haspopup" )
					.children().each( function() {
						var elem = $( this );
						if ( elem.data( "ui-menu-submenu-carat" ) ) {
							elem.remove();
						}
					});

			// Destroy menu dividers
			this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
		},

		_keydown: function( event ) {
			var match, prev, character, skip, regex,
				preventDefault = true;

			function escape( value ) {
				return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
			}

			switch ( event.keyCode ) {
			case $.ui.keyCode.PAGE_UP:
				this.previousPage( event );
				break;
			case $.ui.keyCode.PAGE_DOWN:
				this.nextPage( event );
				break;
			case $.ui.keyCode.HOME:
				this._move( "first", "first", event );
				break;
			case $.ui.keyCode.END:
				this._move( "last", "last", event );
				break;
			case $.ui.keyCode.UP:
				this.previous( event );
				break;
			case $.ui.keyCode.DOWN:
				this.next( event );
				break;
			case $.ui.keyCode.LEFT:
				this.collapse( event );
				break;
			case $.ui.keyCode.RIGHT:
				if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
					this.expand( event );
				}
				break;
			case $.ui.keyCode.ENTER:
			case $.ui.keyCode.SPACE:
				this._activate( event );
				break;
			case $.ui.keyCode.ESCAPE:
				this.collapse( event );
				break;
			default:
				preventDefault = false;
				prev = this.previousFilter || "";
				character = String.fromCharCode( event.keyCode );
				skip = false;

				clearTimeout( this.filterTimer );

				if ( character === prev ) {
					skip = true;
				} else {
					character = prev + character;
				}

				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
				match = skip && match.index( this.active.next() ) !== -1 ?
					this.active.nextAll( ".ui-menu-item" ) :
					match;

				// If no matches on the current filter, reset to the last character pressed
				// to move down the menu to the first item that starts with that character
				if ( !match.length ) {
					character = String.fromCharCode( event.keyCode );
					regex = new RegExp( "^" + escape( character ), "i" );
					match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
						return regex.test( $( this ).children( "a" ).text() );
					});
				}

				if ( match.length ) {
					this.focus( event, match );
					if ( match.length > 1 ) {
						this.previousFilter = character;
						this.filterTimer = this._delay(function() {
							delete this.previousFilter;
						}, 1000 );
					} else {
						delete this.previousFilter;
					}
				} else {
					delete this.previousFilter;
				}
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		},

		_activate: function( event ) {
			if ( !this.active.is( ".ui-state-disabled" ) ) {
				if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
					this.expand( event );
				} else {
					this.select( event );
				}
			}
		},

		refresh: function() {
			var menus,
				icon = this.options.icons.submenu,
				submenus = this.element.find( this.options.menus );

			this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

			// Initialize nested menus
			submenus.filter( ":not(.ui-menu)" )
				.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
				.hide()
				.attr({
					role: this.options.role,
					"aria-hidden": "true",
					"aria-expanded": "false"
				})
				.each(function() {
					var menu = $( this ),
						item = menu.prev( "a" ),
						submenuCarat = $( "<span>" )
							.addClass( "ui-menu-icon ui-icon " + icon )
							.data( "ui-menu-submenu-carat", true );

					item
						.attr( "aria-haspopup", "true" )
						.prepend( submenuCarat );
					menu.attr( "aria-labelledby", item.attr( "id" ) );
				});

			menus = submenus.add( this.element );

			// Don't refresh list items that are already adapted
			menus.children( ":not(.ui-menu-item):has(a)" )
				.addClass( "ui-menu-item" )
				.attr( "role", "presentation" )
				.children( "a" )
					.uniqueId()
					.addClass( "ui-corner-all" )
					.attr({
						tabIndex: -1,
						role: this._itemRole()
					});

			// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
			menus.children( ":not(.ui-menu-item)" ).each(function() {
				var item = $( this );
				// hyphen, em dash, en dash
				if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
					item.addClass( "ui-widget-content ui-menu-divider" );
				}
			});

			// Add aria-disabled attribute to any disabled menu item
			menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

			// If the active item has been removed, blur the menu
			if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				this.blur();
			}
		},

		_itemRole: function() {
			return {
				menu: "menuitem",
				listbox: "option"
			}[ this.options.role ];
		},

		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				this.element.find( ".ui-menu-icon" )
					.removeClass( this.options.icons.submenu )
					.addClass( value.submenu );
			}
			this._super( key, value );
		},

		focus: function( event, item ) {
			var nested, focused;
			this.blur( event, event && event.type === "focus" );

			this._scrollIntoView( item );

			this.active = item.first();
			focused = this.active.children( "a" ).addClass( "ui-state-focus" );
			// Only update aria-activedescendant if there's a role
			// otherwise we assume focus is managed elsewhere
			if ( this.options.role ) {
				this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
			}

			// Highlight active parent menu item, if any
			this.active
				.parent()
				.closest( ".ui-menu-item" )
				.children( "a:first" )
				.addClass( "ui-state-active" );

			if ( event && event.type === "keydown" ) {
				this._close();
			} else {
				this.timer = this._delay(function() {
					this._close();
				}, this.delay );
			}

			nested = item.children( ".ui-menu" );
			if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
				this._startOpening(nested);
			}
			this.activeMenu = item.parent();

			this._trigger( "focus", event, { item: item } );
		},

		_scrollIntoView: function( item ) {
			var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
			if ( this._hasScroll() ) {
				borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
				paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
				offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
				scroll = this.activeMenu.scrollTop();
				elementHeight = this.activeMenu.height();
				itemHeight = item.height();

				if ( offset < 0 ) {
					this.activeMenu.scrollTop( scroll + offset );
				} else if ( offset + itemHeight > elementHeight ) {
					this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
				}
			}
		},

		blur: function( event, fromFocus ) {
			if ( !fromFocus ) {
				clearTimeout( this.timer );
			}

			if ( !this.active ) {
				return;
			}

			this.active.children( "a" ).removeClass( "ui-state-focus" );
			this.active = null;

			this._trigger( "blur", event, { item: this.active } );
		},

		_startOpening: function( submenu ) {
			clearTimeout( this.timer );

			// Don't open if already open fixes a Firefox bug that caused a .5 pixel
			// shift in the submenu position when mousing over the carat icon
			if ( submenu.attr( "aria-hidden" ) !== "true" ) {
				return;
			}

			this.timer = this._delay(function() {
				this._close();
				this._open( submenu );
			}, this.delay );
		},

		_open: function( submenu ) {
			var position = $.extend({
				of: this.active
			}, this.options.position );

			clearTimeout( this.timer );
			this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
				.hide()
				.attr( "aria-hidden", "true" );

			submenu
				.show()
				.removeAttr( "aria-hidden" )
				.attr( "aria-expanded", "true" )
				.position( position );
		},

		collapseAll: function( event, all ) {
			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				// If we were passed an event, look for the submenu that contains the event
				var currentMenu = all ? this.element :
					$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

				// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
				if ( !currentMenu.length ) {
					currentMenu = this.element;
				}

				this._close( currentMenu );

				this.blur( event );
				this.activeMenu = currentMenu;
			}, this.delay );
		},

		// With no arguments, closes the currently active menu - if nothing is active
		// it closes all menus.  If passed an argument, it will search for menus BELOW
		_close: function( startMenu ) {
			if ( !startMenu ) {
				startMenu = this.active ? this.active.parent() : this.element;
			}

			startMenu
				.find( ".ui-menu" )
					.hide()
					.attr( "aria-hidden", "true" )
					.attr( "aria-expanded", "false" )
				.end()
				.find( "a.ui-state-active" )
					.removeClass( "ui-state-active" );
		},

		collapse: function( event ) {
			var newItem = this.active &&
				this.active.parent().closest( ".ui-menu-item", this.element );
			if ( newItem && newItem.length ) {
				this._close();
				this.focus( event, newItem );
			}
		},

		expand: function( event ) {
			var newItem = this.active &&
				this.active
					.children( ".ui-menu " )
					.children( ".ui-menu-item" )
					.first();

			if ( newItem && newItem.length ) {
				this._open( newItem.parent() );

				// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
				this._delay(function() {
					this.focus( event, newItem );
				});
			}
		},

		next: function( event ) {
			this._move( "next", "first", event );
		},

		previous: function( event ) {
			this._move( "prev", "last", event );
		},

		isFirstItem: function() {
			return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
		},

		isLastItem: function() {
			return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
		},

		_move: function( direction, filter, event ) {
			var next;
			if ( this.active ) {
				if ( direction === "first" || direction === "last" ) {
					next = this.active
						[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
						.eq( -1 );
				} else {
					next = this.active
						[ direction + "All" ]( ".ui-menu-item" )
						.eq( 0 );
				}
			}
			if ( !next || !next.length || !this.active ) {
				next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
			}

			this.focus( event, next );
		},

		nextPage: function( event ) {
			var item, base, height;

			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isLastItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.nextAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base - height < 0;
				});

				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.children( ".ui-menu-item" )
					[ !this.active ? "first" : "last" ]() );
			}
		},

		previousPage: function( event ) {
			var item, base, height;
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isFirstItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.prevAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base + height > 0;
				});

				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
			}
		},

		_hasScroll: function() {
			return this.element.outerHeight() < this.element.prop( "scrollHeight" );
		},

		select: function( event ) {
			// TODO: It should never be possible to not have an active item at this
			// point, but the tests don't trigger mouseenter before click.
			this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
			var ui = { item: this.active };
			if ( !this.active.has( ".ui-menu" ).length ) {
				this.collapseAll( event, true );
			}
			this._trigger( "select", event, ui );
		}
	});

	}( jQuery ));
	(function( $, undefined ) {

	$.widget( "ui.progressbar", {
		version: "1.10.4",
		options: {
			max: 100,
			value: 0,

			change: null,
			complete: null
		},

		min: 0,

		_create: function() {
			// Constrain initial value
			this.oldValue = this.options.value = this._constrainedValue();

			this.element
				.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.attr({
					// Only set static values, aria-valuenow and aria-valuemax are
					// set inside _refreshValue()
					role: "progressbar",
					"aria-valuemin": this.min
				});

			this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
				.appendTo( this.element );

			this._refreshValue();
		},

		_destroy: function() {
			this.element
				.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );

			this.valueDiv.remove();
		},

		value: function( newValue ) {
			if ( newValue === undefined ) {
				return this.options.value;
			}

			this.options.value = this._constrainedValue( newValue );
			this._refreshValue();
		},

		_constrainedValue: function( newValue ) {
			if ( newValue === undefined ) {
				newValue = this.options.value;
			}

			this.indeterminate = newValue === false;

			// sanitize value
			if ( typeof newValue !== "number" ) {
				newValue = 0;
			}

			return this.indeterminate ? false :
				Math.min( this.options.max, Math.max( this.min, newValue ) );
		},

		_setOptions: function( options ) {
			// Ensure "value" option is set after other values (like max)
			var value = options.value;
			delete options.value;

			this._super( options );

			this.options.value = this._constrainedValue( value );
			this._refreshValue();
		},

		_setOption: function( key, value ) {
			if ( key === "max" ) {
				// Don't allow a max less than min
				value = Math.max( this.min, value );
			}

			this._super( key, value );
		},

		_percentage: function() {
			return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
		},

		_refreshValue: function() {
			var value = this.options.value,
				percentage = this._percentage();

			this.valueDiv
				.toggle( this.indeterminate || value > this.min )
				.toggleClass( "ui-corner-right", value === this.options.max )
				.width( percentage.toFixed(0) + "%" );

			this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

			if ( this.indeterminate ) {
				this.element.removeAttr( "aria-valuenow" );
				if ( !this.overlayDiv ) {
					this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
				}
			} else {
				this.element.attr({
					"aria-valuemax": this.options.max,
					"aria-valuenow": value
				});
				if ( this.overlayDiv ) {
					this.overlayDiv.remove();
					this.overlayDiv = null;
				}
			}

			if ( this.oldValue !== value ) {
				this.oldValue = value;
				this._trigger( "change" );
			}
			if ( value === this.options.max ) {
				this._trigger( "complete" );
			}
		}
	});

	})( jQuery );
	(function( $, undefined ) {

	function num(v) {
		return parseInt(v, 10) || 0;
	}

	function isNumber(value) {
		return !isNaN(parseInt(value, 10));
	}

	$.widget("ui.resizable", $.ui.mouse, {
		version: "1.10.4",
		widgetEventPrefix: "resize",
		options: {
			alsoResize: false,
			animate: false,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: false,
			autoHide: false,
			containment: false,
			ghost: false,
			grid: false,
			handles: "e,s,se",
			helper: false,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			// See #7960
			zIndex: 90,

			// callbacks
			resize: null,
			start: null,
			stop: null
		},
		_create: function() {

			var n, i, handle, axis, hname,
				that = this,
				o = this.options;
			this.element.addClass("ui-resizable");

			$.extend(this, {
				_aspectRatio: !!(o.aspectRatio),
				aspectRatio: o.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
			});

			//Wrap the element if it cannot hold child nodes
			if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

				//Create a wrapper element and set the wrapper to the new current internal element
				this.element.wrap(
					$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
						position: this.element.css("position"),
						width: this.element.outerWidth(),
						height: this.element.outerHeight(),
						top: this.element.css("top"),
						left: this.element.css("left")
					})
				);

				//Overwrite the original this.element
				this.element = this.element.parent().data(
					"ui-resizable", this.element.data("ui-resizable")
				);

				this.elementIsWrapper = true;

				//Move margins to the wrapper
				this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
				this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

				//Prevent Safari textarea resize
				this.originalResizeStyle = this.originalElement.css("resize");
				this.originalElement.css("resize", "none");

				//Push the actual element to our proportionallyResize internal array
				this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

				// avoid IE jump (hard set the margin)
				this.originalElement.css({ margin: this.originalElement.css("margin") });

				// fix handlers offset
				this._proportionallyResize();

			}

			this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
			if(this.handles.constructor === String) {

				if ( this.handles === "all") {
					this.handles = "n,e,s,w,se,sw,ne,nw";
				}

				n = this.handles.split(",");
				this.handles = {};

				for(i = 0; i < n.length; i++) {

					handle = $.trim(n[i]);
					hname = "ui-resizable-"+handle;
					axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

					// Apply zIndex to all handles - see #7960
					axis.css({ zIndex: o.zIndex });

					//TODO : What's going on here?
					if ("se" === handle) {
						axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
					}

					//Insert into internal handles object and append to element
					this.handles[handle] = ".ui-resizable-"+handle;
					this.element.append(axis);
				}

			}

			this._renderAxis = function(target) {

				var i, axis, padPos, padWrapper;

				target = target || this.element;

				for(i in this.handles) {

					if(this.handles[i].constructor === String) {
						this.handles[i] = $(this.handles[i], this.element).show();
					}

					//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
					if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

						axis = $(this.handles[i], this.element);

						//Checking the correct pad and border
						padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

						//The padding type i have to apply...
						padPos = [ "padding",
							/ne|nw|n/.test(i) ? "Top" :
							/se|sw|s/.test(i) ? "Bottom" :
							/^e$/.test(i) ? "Right" : "Left" ].join("");

						target.css(padPos, padWrapper);

						this._proportionallyResize();

					}

					//TODO: What's that good for? There's not anything to be executed left
					if(!$(this.handles[i]).length) {
						continue;
					}
				}
			};

			//TODO: make renderAxis a prototype function
			this._renderAxis(this.element);

			this._handles = $(".ui-resizable-handle", this.element)
				.disableSelection();

			//Matching axis name
			this._handles.mouseover(function() {
				if (!that.resizing) {
					if (this.className) {
						axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
					}
					//Axis, default = se
					that.axis = axis && axis[1] ? axis[1] : "se";
				}
			});

			//If we want to auto hide the elements
			if (o.autoHide) {
				this._handles.hide();
				$(this.element)
					.addClass("ui-resizable-autohide")
					.mouseenter(function() {
						if (o.disabled) {
							return;
						}
						$(this).removeClass("ui-resizable-autohide");
						that._handles.show();
					})
					.mouseleave(function(){
						if (o.disabled) {
							return;
						}
						if (!that.resizing) {
							$(this).addClass("ui-resizable-autohide");
							that._handles.hide();
						}
					});
			}

			//Initialize the mouse interaction
			this._mouseInit();

		},

		_destroy: function() {

			this._mouseDestroy();

			var wrapper,
				_destroy = function(exp) {
					$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
						.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
				};

			//TODO: Unwrap at same DOM position
			if (this.elementIsWrapper) {
				_destroy(this.element);
				wrapper = this.element;
				this.originalElement.css({
					position: wrapper.css("position"),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css("top"),
					left: wrapper.css("left")
				}).insertAfter( wrapper );
				wrapper.remove();
			}

			this.originalElement.css("resize", this.originalResizeStyle);
			_destroy(this.originalElement);

			return this;
		},

		_mouseCapture: function(event) {
			var i, handle,
				capture = false;

			for (i in this.handles) {
				handle = $(this.handles[i])[0];
				if (handle === event.target || $.contains(handle, event.target)) {
					capture = true;
				}
			}

			return !this.options.disabled && capture;
		},

		_mouseStart: function(event) {

			var curleft, curtop, cursor,
				o = this.options,
				iniPos = this.element.position(),
				el = this.element;

			this.resizing = true;

			// bugfix for http://dev.jquery.com/ticket/1749
			if ( (/absolute/).test( el.css("position") ) ) {
				el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
			} else if (el.is(".ui-draggable")) {
				el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
			}

			this._renderProxy();

			curleft = num(this.helper.css("left"));
			curtop = num(this.helper.css("top"));

			if (o.containment) {
				curleft += $(o.containment).scrollLeft() || 0;
				curtop += $(o.containment).scrollTop() || 0;
			}

			//Store needed variables
			this.offset = this.helper.offset();
			this.position = { left: curleft, top: curtop };
			this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
			this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
			this.originalPosition = { left: curleft, top: curtop };
			this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
			this.originalMousePosition = { left: event.pageX, top: event.pageY };

			//Aspect Ratio
			this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

			cursor = $(".ui-resizable-" + this.axis).css("cursor");
			$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

			el.addClass("ui-resizable-resizing");
			this._propagate("start", event);
			return true;
		},

		_mouseDrag: function(event) {

			//Increase performance, avoid regex
			var data,
				el = this.helper, props = {},
				smp = this.originalMousePosition,
				a = this.axis,
				prevTop = this.position.top,
				prevLeft = this.position.left,
				prevWidth = this.size.width,
				prevHeight = this.size.height,
				dx = (event.pageX-smp.left)||0,
				dy = (event.pageY-smp.top)||0,
				trigger = this._change[a];

			if (!trigger) {
				return false;
			}

			// Calculate the attrs that will be change
			data = trigger.apply(this, [event, dx, dy]);

			// Put this in the mouseDrag handler since the user can start pressing shift while resizing
			this._updateVirtualBoundaries(event.shiftKey);
			if (this._aspectRatio || event.shiftKey) {
				data = this._updateRatio(data, event);
			}

			data = this._respectSize(data, event);

			this._updateCache(data);

			// plugins callbacks need to be called first
			this._propagate("resize", event);

			if (this.position.top !== prevTop) {
				props.top = this.position.top + "px";
			}
			if (this.position.left !== prevLeft) {
				props.left = this.position.left + "px";
			}
			if (this.size.width !== prevWidth) {
				props.width = this.size.width + "px";
			}
			if (this.size.height !== prevHeight) {
				props.height = this.size.height + "px";
			}
			el.css(props);

			if (!this._helper && this._proportionallyResizeElements.length) {
				this._proportionallyResize();
			}

			// Call the user callback if the element was resized
			if ( ! $.isEmptyObject(props) ) {
				this._trigger("resize", event, this.ui());
			}

			return false;
		},

		_mouseStop: function(event) {

			this.resizing = false;
			var pr, ista, soffseth, soffsetw, s, left, top,
				o = this.options, that = this;

			if(this._helper) {

				pr = this._proportionallyResizeElements;
				ista = pr.length && (/textarea/i).test(pr[0].nodeName);
				soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
				soffsetw = ista ? 0 : that.sizeDiff.width;

				s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
				left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
				top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

				if (!o.animate) {
					this.element.css($.extend(s, { top: top, left: left }));
				}

				that.helper.height(that.size.height);
				that.helper.width(that.size.width);

				if (this._helper && !o.animate) {
					this._proportionallyResize();
				}
			}

			$("body").css("cursor", "auto");

			this.element.removeClass("ui-resizable-resizing");

			this._propagate("stop", event);

			if (this._helper) {
				this.helper.remove();
			}

			return false;

		},

		_updateVirtualBoundaries: function(forceAspectRatio) {
			var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
				o = this.options;

			b = {
				minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
				maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
				minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
				maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
			};

			if(this._aspectRatio || forceAspectRatio) {
				// We want to create an enclosing box whose aspect ration is the requested one
				// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
				pMinWidth = b.minHeight * this.aspectRatio;
				pMinHeight = b.minWidth / this.aspectRatio;
				pMaxWidth = b.maxHeight * this.aspectRatio;
				pMaxHeight = b.maxWidth / this.aspectRatio;

				if(pMinWidth > b.minWidth) {
					b.minWidth = pMinWidth;
				}
				if(pMinHeight > b.minHeight) {
					b.minHeight = pMinHeight;
				}
				if(pMaxWidth < b.maxWidth) {
					b.maxWidth = pMaxWidth;
				}
				if(pMaxHeight < b.maxHeight) {
					b.maxHeight = pMaxHeight;
				}
			}
			this._vBoundaries = b;
		},

		_updateCache: function(data) {
			this.offset = this.helper.offset();
			if (isNumber(data.left)) {
				this.position.left = data.left;
			}
			if (isNumber(data.top)) {
				this.position.top = data.top;
			}
			if (isNumber(data.height)) {
				this.size.height = data.height;
			}
			if (isNumber(data.width)) {
				this.size.width = data.width;
			}
		},

		_updateRatio: function( data ) {

			var cpos = this.position,
				csize = this.size,
				a = this.axis;

			if (isNumber(data.height)) {
				data.width = (data.height * this.aspectRatio);
			} else if (isNumber(data.width)) {
				data.height = (data.width / this.aspectRatio);
			}

			if (a === "sw") {
				data.left = cpos.left + (csize.width - data.width);
				data.top = null;
			}
			if (a === "nw") {
				data.top = cpos.top + (csize.height - data.height);
				data.left = cpos.left + (csize.width - data.width);
			}

			return data;
		},

		_respectSize: function( data ) {

			var o = this._vBoundaries,
				a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
				isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
				dw = this.originalPosition.left + this.originalSize.width,
				dh = this.position.top + this.size.height,
				cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
			if (isminw) {
				data.width = o.minWidth;
			}
			if (isminh) {
				data.height = o.minHeight;
			}
			if (ismaxw) {
				data.width = o.maxWidth;
			}
			if (ismaxh) {
				data.height = o.maxHeight;
			}

			if (isminw && cw) {
				data.left = dw - o.minWidth;
			}
			if (ismaxw && cw) {
				data.left = dw - o.maxWidth;
			}
			if (isminh && ch) {
				data.top = dh - o.minHeight;
			}
			if (ismaxh && ch) {
				data.top = dh - o.maxHeight;
			}

			// fixing jump error on top/left - bug #2330
			if (!data.width && !data.height && !data.left && data.top) {
				data.top = null;
			} else if (!data.width && !data.height && !data.top && data.left) {
				data.left = null;
			}

			return data;
		},

		_proportionallyResize: function() {

			if (!this._proportionallyResizeElements.length) {
				return;
			}

			var i, j, borders, paddings, prel,
				element = this.helper || this.element;

			for ( i=0; i < this._proportionallyResizeElements.length; i++) {

				prel = this._proportionallyResizeElements[i];

				if (!this.borderDif) {
					this.borderDif = [];
					borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
					paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

					for ( j = 0; j < borders.length; j++ ) {
						this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
					}
				}

				prel.css({
					height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
					width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
				});

			}

		},

		_renderProxy: function() {

			var el = this.element, o = this.options;
			this.elementOffset = el.offset();

			if(this._helper) {

				this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

				this.helper.addClass(this._helper).css({
					width: this.element.outerWidth() - 1,
					height: this.element.outerHeight() - 1,
					position: "absolute",
					left: this.elementOffset.left +"px",
					top: this.elementOffset.top +"px",
					zIndex: ++o.zIndex //TODO: Don't modify option
				});

				this.helper
					.appendTo("body")
					.disableSelection();

			} else {
				this.helper = this.element;
			}

		},

		_change: {
			e: function(event, dx) {
				return { width: this.originalSize.width + dx };
			},
			w: function(event, dx) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { left: sp.left + dx, width: cs.width - dx };
			},
			n: function(event, dx, dy) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { top: sp.top + dy, height: cs.height - dy };
			},
			s: function(event, dx, dy) {
				return { height: this.originalSize.height + dy };
			},
			se: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			sw: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			},
			ne: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			nw: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			}
		},

		_propagate: function(n, event) {
			$.ui.plugin.call(this, n, [event, this.ui()]);
			(n !== "resize" && this._trigger(n, event, this.ui()));
		},

		plugins: {},

		ui: function() {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			};
		}

	});

	/*
	 * Resizable Extensions
	 */

	$.ui.plugin.add("resizable", "animate", {

		stop: function( event ) {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				pr = that._proportionallyResizeElements,
				ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width,
				style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
				left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			that.element.animate(
				$.extend(style, top && left ? { top: top, left: left } : {}), {
					duration: o.animateDuration,
					easing: o.animateEasing,
					step: function() {

						var data = {
							width: parseInt(that.element.css("width"), 10),
							height: parseInt(that.element.css("height"), 10),
							top: parseInt(that.element.css("top"), 10),
							left: parseInt(that.element.css("left"), 10)
						};

						if (pr && pr.length) {
							$(pr[0]).css({ width: data.width, height: data.height });
						}

						// propagating resize, and updating values for each animation step
						that._updateCache(data);
						that._propagate("resize", event);

					}
				}
			);
		}

	});

	$.ui.plugin.add("resizable", "containment", {

		start: function() {
			var element, p, co, ch, cw, width, height,
				that = $(this).data("ui-resizable"),
				o = that.options,
				el = that.element,
				oc = o.containment,
				ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

			if (!ce) {
				return;
			}

			that.containerElement = $(ce);

			if (/document/.test(oc) || oc === document) {
				that.containerOffset = { left: 0, top: 0 };
				that.containerPosition = { left: 0, top: 0 };

				that.parentData = {
					element: $(document), left: 0, top: 0,
					width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
				};
			}

			// i'm a node, so compute top, left, right, bottom
			else {
				element = $(ce);
				p = [];
				$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

				that.containerOffset = element.offset();
				that.containerPosition = element.position();
				that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

				co = that.containerOffset;
				ch = that.containerSize.height;
				cw = that.containerSize.width;
				width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
				height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

				that.parentData = {
					element: ce, left: co.left, top: co.top, width: width, height: height
				};
			}
		},

		resize: function( event ) {
			var woset, hoset, isParent, isOffsetRelative,
				that = $(this).data("ui-resizable"),
				o = that.options,
				co = that.containerOffset, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey,
				cop = { top:0, left:0 }, ce = that.containerElement;

			if (ce[0] !== document && (/static/).test(ce.css("position"))) {
				cop = co;
			}

			if (cp.left < (that._helper ? co.left : 0)) {
				that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
				if (pRatio) {
					that.size.height = that.size.width / that.aspectRatio;
				}
				that.position.left = o.helper ? co.left : 0;
			}

			if (cp.top < (that._helper ? co.top : 0)) {
				that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
				if (pRatio) {
					that.size.width = that.size.height * that.aspectRatio;
				}
				that.position.top = that._helper ? co.top : 0;
			}

			that.offset.left = that.parentData.left+that.position.left;
			that.offset.top = that.parentData.top+that.position.top;

			woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
			hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

			isParent = that.containerElement.get(0) === that.element.parent().get(0);
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

			if ( isParent && isOffsetRelative ) {
				woset -= Math.abs( that.parentData.left );
			}

			if (woset + that.size.width >= that.parentData.width) {
				that.size.width = that.parentData.width - woset;
				if (pRatio) {
					that.size.height = that.size.width / that.aspectRatio;
				}
			}

			if (hoset + that.size.height >= that.parentData.height) {
				that.size.height = that.parentData.height - hoset;
				if (pRatio) {
					that.size.width = that.size.height * that.aspectRatio;
				}
			}
		},

		stop: function(){
			var that = $(this).data("ui-resizable"),
				o = that.options,
				co = that.containerOffset,
				cop = that.containerPosition,
				ce = that.containerElement,
				helper = $(that.helper),
				ho = helper.offset(),
				w = helper.outerWidth() - that.sizeDiff.width,
				h = helper.outerHeight() - that.sizeDiff.height;

			if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
				$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
			}

			if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
				$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
			}

		}
	});

	$.ui.plugin.add("resizable", "alsoResize", {

		start: function () {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				_store = function (exp) {
					$(exp).each(function() {
						var el = $(this);
						el.data("ui-resizable-alsoresize", {
							width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
							left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
						});
					});
				};

			if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
				if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
				else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
			}else{
				_store(o.alsoResize);
			}
		},

		resize: function (event, ui) {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				os = that.originalSize,
				op = that.originalPosition,
				delta = {
					height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
					top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
				},

				_alsoResize = function (exp, c) {
					$(exp).each(function() {
						var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
							css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

						$.each(css, function (i, prop) {
							var sum = (start[prop]||0) + (delta[prop]||0);
							if (sum && sum >= 0) {
								style[prop] = sum || null;
							}
						});

						el.css(style);
					});
				};

			if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
			}else{
				_alsoResize(o.alsoResize);
			}
		},

		stop: function () {
			$(this).removeData("resizable-alsoresize");
		}
	});

	$.ui.plugin.add("resizable", "ghost", {

		start: function() {

			var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

			that.ghost = that.originalElement.clone();
			that.ghost
				.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
				.addClass("ui-resizable-ghost")
				.addClass(typeof o.ghost === "string" ? o.ghost : "");

			that.ghost.appendTo(that.helper);

		},

		resize: function(){
			var that = $(this).data("ui-resizable");
			if (that.ghost) {
				that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
			}
		},

		stop: function() {
			var that = $(this).data("ui-resizable");
			if (that.ghost && that.helper) {
				that.helper.get(0).removeChild(that.ghost.get(0));
			}
		}

	});

	$.ui.plugin.add("resizable", "grid", {

		resize: function() {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				cs = that.size,
				os = that.originalSize,
				op = that.originalPosition,
				a = that.axis,
				grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
				gridX = (grid[0]||1),
				gridY = (grid[1]||1),
				ox = Math.round((cs.width - os.width) / gridX) * gridX,
				oy = Math.round((cs.height - os.height) / gridY) * gridY,
				newWidth = os.width + ox,
				newHeight = os.height + oy,
				isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
				isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
				isMinWidth = o.minWidth && (o.minWidth > newWidth),
				isMinHeight = o.minHeight && (o.minHeight > newHeight);

			o.grid = grid;

			if (isMinWidth) {
				newWidth = newWidth + gridX;
			}
			if (isMinHeight) {
				newHeight = newHeight + gridY;
			}
			if (isMaxWidth) {
				newWidth = newWidth - gridX;
			}
			if (isMaxHeight) {
				newHeight = newHeight - gridY;
			}

			if (/^(se|s|e)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
			} else if (/^(ne)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else if (/^(sw)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.left = op.left - ox;
			} else {
				if ( newHeight - gridY > 0 ) {
					that.size.height = newHeight;
					that.position.top = op.top - oy;
				} else {
					that.size.height = gridY;
					that.position.top = op.top + os.height - gridY;
				}
				if ( newWidth - gridX > 0 ) {
					that.size.width = newWidth;
					that.position.left = op.left - ox;
				} else {
					that.size.width = gridX;
					that.position.left = op.left + os.width - gridX;
				}
			}
		}

	});

	})(jQuery);
	(function( $, undefined ) {

	$.widget("ui.selectable", $.ui.mouse, {
		version: "1.10.4",
		options: {
			appendTo: "body",
			autoRefresh: true,
			distance: 0,
			filter: "*",
			tolerance: "touch",

			// callbacks
			selected: null,
			selecting: null,
			start: null,
			stop: null,
			unselected: null,
			unselecting: null
		},
		_create: function() {
			var selectees,
				that = this;

			this.element.addClass("ui-selectable");

			this.dragged = false;

			// cache selectee children based on filter
			this.refresh = function() {
				selectees = $(that.options.filter, that.element[0]);
				selectees.addClass("ui-selectee");
				selectees.each(function() {
					var $this = $(this),
						pos = $this.offset();
					$.data(this, "selectable-item", {
						element: this,
						$element: $this,
						left: pos.left,
						top: pos.top,
						right: pos.left + $this.outerWidth(),
						bottom: pos.top + $this.outerHeight(),
						startselected: false,
						selected: $this.hasClass("ui-selected"),
						selecting: $this.hasClass("ui-selecting"),
						unselecting: $this.hasClass("ui-unselecting")
					});
				});
			};
			this.refresh();

			this.selectees = selectees.addClass("ui-selectee");

			this._mouseInit();

			this.helper = $("<div class='ui-selectable-helper'></div>");
		},

		_destroy: function() {
			this.selectees
				.removeClass("ui-selectee")
				.removeData("selectable-item");
			this.element
				.removeClass("ui-selectable ui-selectable-disabled");
			this._mouseDestroy();
		},

		_mouseStart: function(event) {
			var that = this,
				options = this.options;

			this.opos = [event.pageX, event.pageY];

			if (this.options.disabled) {
				return;
			}

			this.selectees = $(options.filter, this.element[0]);

			this._trigger("start", event);

			$(options.appendTo).append(this.helper);
			// position helper (lasso)
			this.helper.css({
				"left": event.pageX,
				"top": event.pageY,
				"width": 0,
				"height": 0
			});

			if (options.autoRefresh) {
				this.refresh();
			}

			this.selectees.filter(".ui-selected").each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.startselected = true;
				if (!event.metaKey && !event.ctrlKey) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
					selectee.$element.addClass("ui-unselecting");
					selectee.unselecting = true;
					// selectable UNSELECTING callback
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
			});

			$(event.target).parents().addBack().each(function() {
				var doSelect,
					selectee = $.data(this, "selectable-item");
				if (selectee) {
					doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
					selectee.$element
						.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
						.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
					selectee.unselecting = !doSelect;
					selectee.selecting = doSelect;
					selectee.selected = doSelect;
					// selectable (UN)SELECTING callback
					if (doSelect) {
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					} else {
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
					return false;
				}
			});

		},

		_mouseDrag: function(event) {

			this.dragged = true;

			if (this.options.disabled) {
				return;
			}

			var tmp,
				that = this,
				options = this.options,
				x1 = this.opos[0],
				y1 = this.opos[1],
				x2 = event.pageX,
				y2 = event.pageY;

			if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
			if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
			this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

			this.selectees.each(function() {
				var selectee = $.data(this, "selectable-item"),
					hit = false;

				//prevent helper from being selected if appendTo: selectable
				if (!selectee || selectee.element === that.element[0]) {
					return;
				}

				if (options.tolerance === "touch") {
					hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
				} else if (options.tolerance === "fit") {
					hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
				}

				if (hit) {
					// SELECT
					if (selectee.selected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;
					}
					if (selectee.unselecting) {
						selectee.$element.removeClass("ui-unselecting");
						selectee.unselecting = false;
					}
					if (!selectee.selecting) {
						selectee.$element.addClass("ui-selecting");
						selectee.selecting = true;
						// selectable SELECTING callback
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					}
				} else {
					// UNSELECT
					if (selectee.selecting) {
						if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							selectee.$element.addClass("ui-selected");
							selectee.selected = true;
						} else {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							if (selectee.startselected) {
								selectee.$element.addClass("ui-unselecting");
								selectee.unselecting = true;
							}
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
					if (selectee.selected) {
						if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
							selectee.$element.removeClass("ui-selected");
							selectee.selected = false;

							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
				}
			});

			return false;
		},

		_mouseStop: function(event) {
			var that = this;

			this.dragged = false;

			$(".ui-unselecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-unselecting");
				selectee.unselecting = false;
				selectee.startselected = false;
				that._trigger("unselected", event, {
					unselected: selectee.element
				});
			});
			$(".ui-selecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
				selectee.selecting = false;
				selectee.selected = true;
				selectee.startselected = true;
				that._trigger("selected", event, {
					selected: selectee.element
				});
			});
			this._trigger("stop", event);

			this.helper.remove();

			return false;
		}

	});

	})(jQuery);
	(function( $, undefined ) {

	// number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	var numPages = 5;

	$.widget( "ui.slider", $.ui.mouse, {
		version: "1.10.4",
		widgetEventPrefix: "slide",

		options: {
			animate: false,
			distance: 0,
			max: 100,
			min: 0,
			orientation: "horizontal",
			range: false,
			step: 1,
			value: 0,
			values: null,

			// callbacks
			change: null,
			slide: null,
			start: null,
			stop: null
		},

		_create: function() {
			this._keySliding = false;
			this._mouseSliding = false;
			this._animateOff = true;
			this._handleIndex = null;
			this._detectOrientation();
			this._mouseInit();

			this.element
				.addClass( "ui-slider" +
					" ui-slider-" + this.orientation +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all");

			this._refresh();
			this._setOption( "disabled", this.options.disabled );

			this._animateOff = false;
		},

		_refresh: function() {
			this._createRange();
			this._createHandles();
			this._setupEvents();
			this._refreshValue();
		},

		_createHandles: function() {
			var i, handleCount,
				options = this.options,
				existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
				handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
				handles = [];

			handleCount = ( options.values && options.values.length ) || 1;

			if ( existingHandles.length > handleCount ) {
				existingHandles.slice( handleCount ).remove();
				existingHandles = existingHandles.slice( 0, handleCount );
			}

			for ( i = existingHandles.length; i < handleCount; i++ ) {
				handles.push( handle );
			}

			this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

			this.handle = this.handles.eq( 0 );

			this.handles.each(function( i ) {
				$( this ).data( "ui-slider-handle-index", i );
			});
		},

		_createRange: function() {
			var options = this.options,
				classes = "";

			if ( options.range ) {
				if ( options.range === true ) {
					if ( !options.values ) {
						options.values = [ this._valueMin(), this._valueMin() ];
					} else if ( options.values.length && options.values.length !== 2 ) {
						options.values = [ options.values[0], options.values[0] ];
					} else if ( $.isArray( options.values ) ) {
						options.values = options.values.slice(0);
					}
				}

				if ( !this.range || !this.range.length ) {
					this.range = $( "<div></div>" )
						.appendTo( this.element );

					classes = "ui-slider-range" +
					// note: this isn't the most fittingly semantic framework class for this element,
					// but worked best visually with a variety of themes
					" ui-widget-header ui-corner-all";
				} else {
					this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
						// Handle range switching from true to min/max
						.css({
							"left": "",
							"bottom": ""
						});
				}

				this.range.addClass( classes +
					( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
			} else {
				if ( this.range ) {
					this.range.remove();
				}
				this.range = null;
			}
		},

		_setupEvents: function() {
			var elements = this.handles.add( this.range ).filter( "a" );
			this._off( elements );
			this._on( elements, this._handleEvents );
			this._hoverable( elements );
			this._focusable( elements );
		},

		_destroy: function() {
			this.handles.remove();
			if ( this.range ) {
				this.range.remove();
			}

			this.element
				.removeClass( "ui-slider" +
					" ui-slider-horizontal" +
					" ui-slider-vertical" +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all" );

			this._mouseDestroy();
		},

		_mouseCapture: function( event ) {
			var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
				that = this,
				o = this.options;

			if ( o.disabled ) {
				return false;
			}

			this.elementSize = {
				width: this.element.outerWidth(),
				height: this.element.outerHeight()
			};
			this.elementOffset = this.element.offset();

			position = { x: event.pageX, y: event.pageY };
			normValue = this._normValueFromMouse( position );
			distance = this._valueMax() - this._valueMin() + 1;
			this.handles.each(function( i ) {
				var thisDistance = Math.abs( normValue - that.values(i) );
				if (( distance > thisDistance ) ||
					( distance === thisDistance &&
						(i === that._lastChangedValue || that.values(i) === o.min ))) {
					distance = thisDistance;
					closestHandle = $( this );
					index = i;
				}
			});

			allowed = this._start( event, index );
			if ( allowed === false ) {
				return false;
			}
			this._mouseSliding = true;

			this._handleIndex = index;

			closestHandle
				.addClass( "ui-state-active" )
				.focus();

			offset = closestHandle.offset();
			mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
			this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
				left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
				top: event.pageY - offset.top -
					( closestHandle.height() / 2 ) -
					( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
					( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
					( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
			};

			if ( !this.handles.hasClass( "ui-state-hover" ) ) {
				this._slide( event, index, normValue );
			}
			this._animateOff = true;
			return true;
		},

		_mouseStart: function() {
			return true;
		},

		_mouseDrag: function( event ) {
			var position = { x: event.pageX, y: event.pageY },
				normValue = this._normValueFromMouse( position );

			this._slide( event, this._handleIndex, normValue );

			return false;
		},

		_mouseStop: function( event ) {
			this.handles.removeClass( "ui-state-active" );
			this._mouseSliding = false;

			this._stop( event, this._handleIndex );
			this._change( event, this._handleIndex );

			this._handleIndex = null;
			this._clickOffset = null;
			this._animateOff = false;

			return false;
		},

		_detectOrientation: function() {
			this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
		},

		_normValueFromMouse: function( position ) {
			var pixelTotal,
				pixelMouse,
				percentMouse,
				valueTotal,
				valueMouse;

			if ( this.orientation === "horizontal" ) {
				pixelTotal = this.elementSize.width;
				pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
			} else {
				pixelTotal = this.elementSize.height;
				pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
			}

			percentMouse = ( pixelMouse / pixelTotal );
			if ( percentMouse > 1 ) {
				percentMouse = 1;
			}
			if ( percentMouse < 0 ) {
				percentMouse = 0;
			}
			if ( this.orientation === "vertical" ) {
				percentMouse = 1 - percentMouse;
			}

			valueTotal = this._valueMax() - this._valueMin();
			valueMouse = this._valueMin() + percentMouse * valueTotal;

			return this._trimAlignValue( valueMouse );
		},

		_start: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}
			return this._trigger( "start", event, uiHash );
		},

		_slide: function( event, index, newVal ) {
			var otherVal,
				newValues,
				allowed;

			if ( this.options.values && this.options.values.length ) {
				otherVal = this.values( index ? 0 : 1 );

				if ( ( this.options.values.length === 2 && this.options.range === true ) &&
						( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
					) {
					newVal = otherVal;
				}

				if ( newVal !== this.values( index ) ) {
					newValues = this.values();
					newValues[ index ] = newVal;
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal,
						values: newValues
					} );
					otherVal = this.values( index ? 0 : 1 );
					if ( allowed !== false ) {
						this.values( index, newVal );
					}
				}
			} else {
				if ( newVal !== this.value() ) {
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal
					} );
					if ( allowed !== false ) {
						this.value( newVal );
					}
				}
			}
		},

		_stop: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "stop", event, uiHash );
		},

		_change: function( event, index ) {
			if ( !this._keySliding && !this._mouseSliding ) {
				var uiHash = {
					handle: this.handles[ index ],
					value: this.value()
				};
				if ( this.options.values && this.options.values.length ) {
					uiHash.value = this.values( index );
					uiHash.values = this.values();
				}

				//store the last changed value index for reference when handles overlap
				this._lastChangedValue = index;

				this._trigger( "change", event, uiHash );
			}
		},

		value: function( newValue ) {
			if ( arguments.length ) {
				this.options.value = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, 0 );
				return;
			}

			return this._value();
		},

		values: function( index, newValue ) {
			var vals,
				newValues,
				i;

			if ( arguments.length > 1 ) {
				this.options.values[ index ] = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, index );
				return;
			}

			if ( arguments.length ) {
				if ( $.isArray( arguments[ 0 ] ) ) {
					vals = this.options.values;
					newValues = arguments[ 0 ];
					for ( i = 0; i < vals.length; i += 1 ) {
						vals[ i ] = this._trimAlignValue( newValues[ i ] );
						this._change( null, i );
					}
					this._refreshValue();
				} else {
					if ( this.options.values && this.options.values.length ) {
						return this._values( index );
					} else {
						return this.value();
					}
				}
			} else {
				return this._values();
			}
		},

		_setOption: function( key, value ) {
			var i,
				valsLength = 0;

			if ( key === "range" && this.options.range === true ) {
				if ( value === "min" ) {
					this.options.value = this._values( 0 );
					this.options.values = null;
				} else if ( value === "max" ) {
					this.options.value = this._values( this.options.values.length-1 );
					this.options.values = null;
				}
			}

			if ( $.isArray( this.options.values ) ) {
				valsLength = this.options.values.length;
			}

			$.Widget.prototype._setOption.apply( this, arguments );

			switch ( key ) {
				case "orientation":
					this._detectOrientation();
					this.element
						.removeClass( "ui-slider-horizontal ui-slider-vertical" )
						.addClass( "ui-slider-" + this.orientation );
					this._refreshValue();
					break;
				case "value":
					this._animateOff = true;
					this._refreshValue();
					this._change( null, 0 );
					this._animateOff = false;
					break;
				case "values":
					this._animateOff = true;
					this._refreshValue();
					for ( i = 0; i < valsLength; i += 1 ) {
						this._change( null, i );
					}
					this._animateOff = false;
					break;
				case "min":
				case "max":
					this._animateOff = true;
					this._refreshValue();
					this._animateOff = false;
					break;
				case "range":
					this._animateOff = true;
					this._refresh();
					this._animateOff = false;
					break;
			}
		},

		//internal value getter
		// _value() returns value trimmed by min and max, aligned by step
		_value: function() {
			var val = this.options.value;
			val = this._trimAlignValue( val );

			return val;
		},

		//internal values getter
		// _values() returns array of values trimmed by min and max, aligned by step
		// _values( index ) returns single value trimmed by min and max, aligned by step
		_values: function( index ) {
			var val,
				vals,
				i;

			if ( arguments.length ) {
				val = this.options.values[ index ];
				val = this._trimAlignValue( val );

				return val;
			} else if ( this.options.values && this.options.values.length ) {
				// .slice() creates a copy of the array
				// this copy gets trimmed by min and max and then returned
				vals = this.options.values.slice();
				for ( i = 0; i < vals.length; i+= 1) {
					vals[ i ] = this._trimAlignValue( vals[ i ] );
				}

				return vals;
			} else {
				return [];
			}
		},

		// returns the step-aligned value that val is closest to, between (inclusive) min and max
		_trimAlignValue: function( val ) {
			if ( val <= this._valueMin() ) {
				return this._valueMin();
			}
			if ( val >= this._valueMax() ) {
				return this._valueMax();
			}
			var step = ( this.options.step > 0 ) ? this.options.step : 1,
				valModStep = (val - this._valueMin()) % step,
				alignValue = val - valModStep;

			if ( Math.abs(valModStep) * 2 >= step ) {
				alignValue += ( valModStep > 0 ) ? step : ( -step );
			}

			// Since JavaScript has problems with large floats, round
			// the final value to 5 digits after the decimal point (see #4124)
			return parseFloat( alignValue.toFixed(5) );
		},

		_valueMin: function() {
			return this.options.min;
		},

		_valueMax: function() {
			return this.options.max;
		},

		_refreshValue: function() {
			var lastValPercent, valPercent, value, valueMin, valueMax,
				oRange = this.options.range,
				o = this.options,
				that = this,
				animate = ( !this._animateOff ) ? o.animate : false,
				_set = {};

			if ( this.options.values && this.options.values.length ) {
				this.handles.each(function( i ) {
					valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
					_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
					$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
					if ( that.options.range === true ) {
						if ( that.orientation === "horizontal" ) {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						} else {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						}
					}
					lastValPercent = valPercent;
				});
			} else {
				value = this.value();
				valueMin = this._valueMin();
				valueMax = this._valueMax();
				valPercent = ( valueMax !== valueMin ) ?
						( value - valueMin ) / ( valueMax - valueMin ) * 100 :
						0;
				_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

				if ( oRange === "min" && this.orientation === "horizontal" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "horizontal" ) {
					this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
				if ( oRange === "min" && this.orientation === "vertical" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "vertical" ) {
					this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
			}
		},

		_handleEvents: {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			click: function( event ) {
				event.preventDefault();
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		}

	});

	}(jQuery));
	(function( $, undefined ) {

	function isOverAxis( x, reference, size ) {
		return ( x > reference ) && ( x < ( reference + size ) );
	}

	function isFloating(item) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	}

	$.widget("ui.sortable", $.ui.mouse, {
		version: "1.10.4",
		widgetEventPrefix: "sort",
		ready: false,
		options: {
			appendTo: "parent",
			axis: false,
			connectWith: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			dropOnEmpty: true,
			forcePlaceholderSize: false,
			forceHelperSize: false,
			grid: false,
			handle: false,
			helper: "original",
			items: "> *",
			opacity: false,
			placeholder: false,
			revert: false,
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1000,

			// callbacks
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},
		_create: function() {

			var o = this.options;
			this.containerCache = {};
			this.element.addClass("ui-sortable");

			//Get the items
			this.refresh();

			//Let's determine if the items are being displayed horizontally
			this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;

			//Let's determine the parent's offset
			this.offset = this.element.offset();

			//Initialize mouse events for interaction
			this._mouseInit();

			//We're ready to go
			this.ready = true;

		},

		_destroy: function() {
			this.element
				.removeClass("ui-sortable ui-sortable-disabled");
			this._mouseDestroy();

			for ( var i = this.items.length - 1; i >= 0; i-- ) {
				this.items[i].item.removeData(this.widgetName + "-item");
			}

			return this;
		},

		_setOption: function(key, value){
			if ( key === "disabled" ) {
				this.options[ key ] = value;

				this.widget().toggleClass( "ui-sortable-disabled", !!value );
			} else {
				// Don't call widget base _setOption for disable as it adds ui-state-disabled class
				$.Widget.prototype._setOption.apply(this, arguments);
			}
		},

		_mouseCapture: function(event, overrideHandle) {
			var currentItem = null,
				validHandle = false,
				that = this;

			if (this.reverting) {
				return false;
			}

			if(this.options.disabled || this.options.type === "static") {
				return false;
			}

			//We have to refresh the items data once first
			this._refreshItems(event);

			//Find out if the clicked node (or one of its parents) is a actual item in this.items
			$(event.target).parents().each(function() {
				if($.data(this, that.widgetName + "-item") === that) {
					currentItem = $(this);
					return false;
				}
			});
			if($.data(event.target, that.widgetName + "-item") === that) {
				currentItem = $(event.target);
			}

			if(!currentItem) {
				return false;
			}
			if(this.options.handle && !overrideHandle) {
				$(this.options.handle, currentItem).find("*").addBack().each(function() {
					if(this === event.target) {
						validHandle = true;
					}
				});
				if(!validHandle) {
					return false;
				}
			}

			this.currentItem = currentItem;
			this._removeCurrentsFromItems();
			return true;

		},

		_mouseStart: function(event, overrideHandle, noActivation) {

			var i, body,
				o = this.options;

			this.currentContainer = this;

			//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
			this.refreshPositions();

			//Create and append the visible helper
			this.helper = this._createHelper(event);

			//Cache the helper size
			this._cacheHelperProportions();

			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */

			//Cache the margins of the original element
			this._cacheMargins();

			//Get the next scrolling parent
			this.scrollParent = this.helper.scrollParent();

			//The element's absolute position on the page minus margins
			this.offset = this.currentItem.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};

			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});

			// Only after we got the offset, we can change the helper's position to absolute
			// TODO: Still need to figure out a way to make relative sorting possible
			this.helper.css("position", "absolute");
			this.cssPosition = this.helper.css("position");

			//Generate the original position
			this.originalPosition = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;

			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

			//Cache the former DOM position
			this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

			//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
			if(this.helper[0] !== this.currentItem[0]) {
				this.currentItem.hide();
			}

			//Create the placeholder
			this._createPlaceholder();

			//Set a containment if given in the options
			if(o.containment) {
				this._setContainment();
			}

			if( o.cursor && o.cursor !== "auto" ) { // cursor option
				body = this.document.find( "body" );

				// support: IE
				this.storedCursor = body.css( "cursor" );
				body.css( "cursor", o.cursor );

				this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
			}

			if(o.opacity) { // opacity option
				if (this.helper.css("opacity")) {
					this._storedOpacity = this.helper.css("opacity");
				}
				this.helper.css("opacity", o.opacity);
			}

			if(o.zIndex) { // zIndex option
				if (this.helper.css("zIndex")) {
					this._storedZIndex = this.helper.css("zIndex");
				}
				this.helper.css("zIndex", o.zIndex);
			}

			//Prepare scrolling
			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
				this.overflowOffset = this.scrollParent.offset();
			}

			//Call callbacks
			this._trigger("start", event, this._uiHash());

			//Recache the helper size
			if(!this._preserveHelperProportions) {
				this._cacheHelperProportions();
			}


			//Post "activate" events to possible containers
			if( !noActivation ) {
				for ( i = this.containers.length - 1; i >= 0; i-- ) {
					this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
				}
			}

			//Prepare possible droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}

			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}

			this.dragging = true;

			this.helper.addClass("ui-sortable-helper");
			this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
			return true;

		},

		_mouseDrag: function(event) {
			var i, item, itemElement, intersection,
				o = this.options,
				scrolled = false;

			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");

			if (!this.lastPositionAbs) {
				this.lastPositionAbs = this.positionAbs;
			}

			//Do scrolling
			if(this.options.scroll) {
				if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					}

					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
					}

				} else {

					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}

					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}

				}

				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
			}

			//Regenerate the absolute position used for position checks
			this.positionAbs = this._convertPositionTo("absolute");

			//Set the helper position
			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}

			//Rearrange
			for (i = this.items.length - 1; i >= 0; i--) {

				//Cache variables and intersection, continue if no intersection
				item = this.items[i];
				itemElement = item.item[0];
				intersection = this._intersectsWithPointer(item);
				if (!intersection) {
					continue;
				}

				// Only put the placeholder inside the current Container, skip all
				// items from other containers. This works because when moving
				// an item from one container to another the
				// currentContainer is switched before the placeholder is moved.
				//
				// Without this, moving items in "sub-sortables" can cause
				// the placeholder to jitter beetween the outer and inner container.
				if (item.instance !== this.currentContainer) {
					continue;
				}

				// cannot intersect with itself
				// no useless actions that have been done before
				// no action if the item moved is the parent of the item checked
				if (itemElement !== this.currentItem[0] &&
					this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
					!$.contains(this.placeholder[0], itemElement) &&
					(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
				) {

					this.direction = intersection === 1 ? "down" : "up";

					if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
						this._rearrange(event, item);
					} else {
						break;
					}

					this._trigger("change", event, this._uiHash());
					break;
				}
			}

			//Post events to containers
			this._contactContainers(event);

			//Interconnect with droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}

			//Call callbacks
			this._trigger("sort", event, this._uiHash());

			this.lastPositionAbs = this.positionAbs;
			return false;

		},

		_mouseStop: function(event, noPropagation) {

			if(!event) {
				return;
			}

			//If we are using droppables, inform the manager about the drop
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				$.ui.ddmanager.drop(this, event);
			}

			if(this.options.revert) {
				var that = this,
					cur = this.placeholder.offset(),
					axis = this.options.axis,
					animation = {};

				if ( !axis || axis === "x" ) {
					animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
				}
				if ( !axis || axis === "y" ) {
					animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
				}
				this.reverting = true;
				$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
					that._clear(event);
				});
			} else {
				this._clear(event, noPropagation);
			}

			return false;

		},

		cancel: function() {

			if(this.dragging) {

				this._mouseUp({ target: null });

				if(this.options.helper === "original") {
					this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
				} else {
					this.currentItem.show();
				}

				//Post deactivating events to containers
				for (var i = this.containers.length - 1; i >= 0; i--){
					this.containers[i]._trigger("deactivate", null, this._uiHash(this));
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", null, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}

			}

			if (this.placeholder) {
				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
				if(this.placeholder[0].parentNode) {
					this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
				}
				if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
					this.helper.remove();
				}

				$.extend(this, {
					helper: null,
					dragging: false,
					reverting: false,
					_noFinalSort: null
				});

				if(this.domPosition.prev) {
					$(this.domPosition.prev).after(this.currentItem);
				} else {
					$(this.domPosition.parent).prepend(this.currentItem);
				}
			}

			return this;

		},

		serialize: function(o) {

			var items = this._getItemsAsjQuery(o && o.connected),
				str = [];
			o = o || {};

			$(items).each(function() {
				var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
				if (res) {
					str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
				}
			});

			if(!str.length && o.key) {
				str.push(o.key + "=");
			}

			return str.join("&");

		},

		toArray: function(o) {

			var items = this._getItemsAsjQuery(o && o.connected),
				ret = [];

			o = o || {};

			items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
			return ret;

		},

		/* Be careful with the following core functions */
		_intersectsWith: function(item) {

			var x1 = this.positionAbs.left,
				x2 = x1 + this.helperProportions.width,
				y1 = this.positionAbs.top,
				y2 = y1 + this.helperProportions.height,
				l = item.left,
				r = l + item.width,
				t = item.top,
				b = t + item.height,
				dyClick = this.offset.click.top,
				dxClick = this.offset.click.left,
				isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
				isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
				isOverElement = isOverElementHeight && isOverElementWidth;

			if ( this.options.tolerance === "pointer" ||
				this.options.forcePointerForContainers ||
				(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
			) {
				return isOverElement;
			} else {

				return (l < x1 + (this.helperProportions.width / 2) && // Right Half
					x2 - (this.helperProportions.width / 2) < r && // Left Half
					t < y1 + (this.helperProportions.height / 2) && // Bottom Half
					y2 - (this.helperProportions.height / 2) < b ); // Top Half

			}
		},

		_intersectsWithPointer: function(item) {

			var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
				isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
				isOverElement = isOverElementHeight && isOverElementWidth,
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();

			if (!isOverElement) {
				return false;
			}

			return this.floating ?
				( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
				: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

		},

		_intersectsWithSides: function(item) {

			var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
				isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();

			if (this.floating && horizontalDirection) {
				return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
			} else {
				return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
			}

		},

		_getDragVerticalDirection: function() {
			var delta = this.positionAbs.top - this.lastPositionAbs.top;
			return delta !== 0 && (delta > 0 ? "down" : "up");
		},

		_getDragHorizontalDirection: function() {
			var delta = this.positionAbs.left - this.lastPositionAbs.left;
			return delta !== 0 && (delta > 0 ? "right" : "left");
		},

		refresh: function(event) {
			this._refreshItems(event);
			this.refreshPositions();
			return this;
		},

		_connectWith: function() {
			var options = this.options;
			return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
		},

		_getItemsAsjQuery: function(connected) {

			var i, j, cur, inst,
				items = [],
				queries = [],
				connectWith = this._connectWith();

			if(connectWith && connected) {
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i]);
					for ( j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
						}
					}
				}
			}

			queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

			function addItems() {
				items.push( this );
			}
			for (i = queries.length - 1; i >= 0; i--){
				queries[i][0].each( addItems );
			}

			return $(items);

		},

		_removeCurrentsFromItems: function() {

			var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

			this.items = $.grep(this.items, function (item) {
				for (var j=0; j < list.length; j++) {
					if(list[j] === item.item[0]) {
						return false;
					}
				}
				return true;
			});

		},

		_refreshItems: function(event) {

			this.items = [];
			this.containers = [this];

			var i, j, cur, inst, targetData, _queries, item, queriesLength,
				items = this.items,
				queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
				connectWith = this._connectWith();

			if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i]);
					for (j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
							this.containers.push(inst);
						}
					}
				}
			}

			for (i = queries.length - 1; i >= 0; i--) {
				targetData = queries[i][1];
				_queries = queries[i][0];

				for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
					item = $(_queries[j]);

					item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

					items.push({
						item: item,
						instance: targetData,
						width: 0, height: 0,
						left: 0, top: 0
					});
				}
			}

		},

		refreshPositions: function(fast) {

			//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
			if(this.offsetParent && this.helper) {
				this.offset.parent = this._getParentOffset();
			}

			var i, item, t, p;

			for (i = this.items.length - 1; i >= 0; i--){
				item = this.items[i];

				//We ignore calculating positions of all connected containers when we're not over them
				if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
					continue;
				}

				t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

				if (!fast) {
					item.width = t.outerWidth();
					item.height = t.outerHeight();
				}

				p = t.offset();
				item.left = p.left;
				item.top = p.top;
			}

			if(this.options.custom && this.options.custom.refreshContainers) {
				this.options.custom.refreshContainers.call(this);
			} else {
				for (i = this.containers.length - 1; i >= 0; i--){
					p = this.containers[i].element.offset();
					this.containers[i].containerCache.left = p.left;
					this.containers[i].containerCache.top = p.top;
					this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
					this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
				}
			}

			return this;
		},

		_createPlaceholder: function(that) {
			that = that || this;
			var className,
				o = that.options;

			if(!o.placeholder || o.placeholder.constructor === String) {
				className = o.placeholder;
				o.placeholder = {
					element: function() {

						var nodeName = that.currentItem[0].nodeName.toLowerCase(),
							element = $( "<" + nodeName + ">", that.document[0] )
								.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
								.removeClass("ui-sortable-helper");

						if ( nodeName === "tr" ) {
							that.currentItem.children().each(function() {
								$( "<td>&#160;</td>", that.document[0] )
									.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
									.appendTo( element );
							});
						} else if ( nodeName === "img" ) {
							element.attr( "src", that.currentItem.attr( "src" ) );
						}

						if ( !className ) {
							element.css( "visibility", "hidden" );
						}

						return element;
					},
					update: function(container, p) {

						// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
						// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
						if(className && !o.forcePlaceholderSize) {
							return;
						}

						//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
						if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
						if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
					}
				};
			}

			//Create the placeholder
			that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

			//Append it after the actual current item
			that.currentItem.after(that.placeholder);

			//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
			o.placeholder.update(that, that.placeholder);

		},

		_contactContainers: function(event) {
			var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
				innermostContainer = null,
				innermostIndex = null;

			// get innermost container that intersects with item
			for (i = this.containers.length - 1; i >= 0; i--) {

				// never consider a container that's located within the item itself
				if($.contains(this.currentItem[0], this.containers[i].element[0])) {
					continue;
				}

				if(this._intersectsWith(this.containers[i].containerCache)) {

					// if we've already found a container and it's more "inner" than this, then continue
					if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
						continue;
					}

					innermostContainer = this.containers[i];
					innermostIndex = i;

				} else {
					// container doesn't intersect. trigger "out" event if necessary
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", event, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}

			}

			// if no intersecting containers found, return
			if(!innermostContainer) {
				return;
			}

			// move the item into the container if it's not there already
			if(this.containers.length === 1) {
				if (!this.containers[innermostIndex].containerCache.over) {
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			} else {

				//When entering a new container, we will find the item with the least distance and append our item near it
				dist = 10000;
				itemWithLeastDistance = null;
				floating = innermostContainer.floating || isFloating(this.currentItem);
				posProperty = floating ? "left" : "top";
				sizeProperty = floating ? "width" : "height";
				base = this.positionAbs[posProperty] + this.offset.click[posProperty];
				for (j = this.items.length - 1; j >= 0; j--) {
					if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
						continue;
					}
					if(this.items[j].item[0] === this.currentItem[0]) {
						continue;
					}
					if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
						continue;
					}
					cur = this.items[j].item.offset()[posProperty];
					nearBottom = false;
					if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
						nearBottom = true;
						cur += this.items[j][sizeProperty];
					}

					if(Math.abs(cur - base) < dist) {
						dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
						this.direction = nearBottom ? "up": "down";
					}
				}

				//Check if dropOnEmpty is enabled
				if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
					return;
				}

				if(this.currentContainer === this.containers[innermostIndex]) {
					return;
				}

				itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
				this._trigger("change", event, this._uiHash());
				this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
				this.currentContainer = this.containers[innermostIndex];

				//Update the placeholder
				this.options.placeholder.update(this.currentContainer, this.placeholder);

				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}


		},

		_createHelper: function(event) {

			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

			//Add the helper to the DOM if that didn't happen already
			if(!helper.parents("body").length) {
				$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
			}

			if(helper[0] === this.currentItem[0]) {
				this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
			}

			if(!helper[0].style.width || o.forceHelperSize) {
				helper.width(this.currentItem.width());
			}
			if(!helper[0].style.height || o.forceHelperSize) {
				helper.height(this.currentItem.height());
			}

			return helper;

		},

		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},

		_getParentOffset: function() {


			//Get the offsetParent and cache its position
			this.offsetParent = this.helper.offsetParent();
			var po = this.offsetParent.offset();

			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}

			// This needs to be actually done for all browsers, since pageX/pageY includes this information
			// with an ugly IE fix
			if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}

			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};

		},

		_getRelativeOffset: function() {

			if(this.cssPosition === "relative") {
				var p = this.currentItem.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}

		},

		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
				top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
			};
		},

		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},

		_setContainment: function() {

			var ce, co, over,
				o = this.options;
			if(o.containment === "parent") {
				o.containment = this.helper[0].parentNode;
			}
			if(o.containment === "document" || o.containment === "window") {
				this.containment = [
					0 - this.offset.relative.left - this.offset.parent.left,
					0 - this.offset.relative.top - this.offset.parent.top,
					$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
					($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
				];
			}

			if(!(/^(document|window|parent)$/).test(o.containment)) {
				ce = $(o.containment)[0];
				co = $(o.containment).offset();
				over = ($(ce).css("overflow") !== "hidden");

				this.containment = [
					co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
					co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
					co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
					co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
				];
			}

		},

		_convertPositionTo: function(d, pos) {

			if(!pos) {
				pos = this.position;
			}
			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
				)
			};

		},

		_generatePosition: function(event) {

			var top, left,
				o = this.options,
				pageX = event.pageX,
				pageY = event.pageY,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

			// This is another very weird special case that only happens for relative elements:
			// 1. If the css position is relative
			// 2. and the scroll parent is the document or similar to the offset parent
			// we have to refresh the relative offset during the scroll so there are no jumps
			if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
				this.offset.relative = this._getRelativeOffset();
			}

			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */

			if(this.originalPosition) { //If we are not dragging yet, we won't check for options

				if(this.containment) {
					if(event.pageX - this.offset.click.left < this.containment[0]) {
						pageX = this.containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < this.containment[1]) {
						pageY = this.containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > this.containment[2]) {
						pageX = this.containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > this.containment[3]) {
						pageY = this.containment[3] + this.offset.click.top;
					}
				}

				if(o.grid) {
					top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
					pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

					left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
					pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}

			}

			return {
				top: (
					pageY -																// The absolute mouse position
					this.offset.click.top -													// Click offset (relative to the element)
					this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
				),
				left: (
					pageX -																// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
				)
			};

		},

		_rearrange: function(event, i, a, hardRefresh) {

			a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

			//Various things done here to improve the performance:
			// 1. we create a setTimeout, that calls refreshPositions
			// 2. on the instance, we have a counter variable, that get's higher after every append
			// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
			// 4. this lets only the last addition to the timeout stack through
			this.counter = this.counter ? ++this.counter : 1;
			var counter = this.counter;

			this._delay(function() {
				if(counter === this.counter) {
					this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
				}
			});

		},

		_clear: function(event, noPropagation) {

			this.reverting = false;
			// We delay all events that have to be triggered to after the point where the placeholder has been removed and
			// everything else normalized again
			var i,
				delayedTriggers = [];

			// We first have to update the dom position of the actual currentItem
			// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
			if(!this._noFinalSort && this.currentItem.parent().length) {
				this.placeholder.before(this.currentItem);
			}
			this._noFinalSort = null;

			if(this.helper[0] === this.currentItem[0]) {
				for(i in this._storedCSS) {
					if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
						this._storedCSS[i] = "";
					}
				}
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			if(this.fromOutside && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
			}
			if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
			}

			// Check if the items Container has Changed and trigger appropriate
			// events.
			if (this !== this.currentContainer) {
				if(!noPropagation) {
					delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
				}
			}


			//Post events to containers
			function delayEvent( type, instance, container ) {
				return function( event ) {
					container._trigger( type, event, instance._uiHash( instance ) );
				};
			}
			for (i = this.containers.length - 1; i >= 0; i--){
				if (!noPropagation) {
					delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
				}
				if(this.containers[i].containerCache.over) {
					delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
					this.containers[i].containerCache.over = 0;
				}
			}

			//Do what was originally in plugins
			if ( this.storedCursor ) {
				this.document.find( "body" ).css( "cursor", this.storedCursor );
				this.storedStylesheet.remove();
			}
			if(this._storedOpacity) {
				this.helper.css("opacity", this._storedOpacity);
			}
			if(this._storedZIndex) {
				this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
			}

			this.dragging = false;
			if(this.cancelHelperRemoval) {
				if(!noPropagation) {
					this._trigger("beforeStop", event, this._uiHash());
					for (i=0; i < delayedTriggers.length; i++) {
						delayedTriggers[i].call(this, event);
					} //Trigger all delayed events
					this._trigger("stop", event, this._uiHash());
				}

				this.fromOutside = false;
				return false;
			}

			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
			}

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

			if(this.helper[0] !== this.currentItem[0]) {
				this.helper.remove();
			}
			this.helper = null;

			if(!noPropagation) {
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return true;

		},

		_trigger: function() {
			if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
				this.cancel();
			}
		},

		_uiHash: function(_inst) {
			var inst = _inst || this;
			return {
				helper: inst.helper,
				placeholder: inst.placeholder || $([]),
				position: inst.position,
				originalPosition: inst.originalPosition,
				offset: inst.positionAbs,
				item: inst.currentItem,
				sender: _inst ? _inst.element : null
			};
		}

	});

	})(jQuery);
	(function( $ ) {

	function modifier( fn ) {
		return function() {
			var previous = this.element.val();
			fn.apply( this, arguments );
			this._refresh();
			if ( previous !== this.element.val() ) {
				this._trigger( "change" );
			}
		};
	}

	$.widget( "ui.spinner", {
		version: "1.10.4",
		defaultElement: "<input>",
		widgetEventPrefix: "spin",
		options: {
			culture: null,
			icons: {
				down: "ui-icon-triangle-1-s",
				up: "ui-icon-triangle-1-n"
			},
			incremental: true,
			max: null,
			min: null,
			numberFormat: null,
			page: 10,
			step: 1,

			change: null,
			spin: null,
			start: null,
			stop: null
		},

		_create: function() {
			// handle string values that need to be parsed
			this._setOption( "max", this.options.max );
			this._setOption( "min", this.options.min );
			this._setOption( "step", this.options.step );

			// Only format if there is a value, prevents the field from being marked
			// as invalid in Firefox, see #9573.
			if ( this.value() !== "" ) {
				// Format the value, but don't constrain.
				this._value( this.element.val(), true );
			}

			this._draw();
			this._on( this._events );
			this._refresh();

			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},

		_getCreateOptions: function() {
			var options = {},
				element = this.element;

			$.each( [ "min", "max", "step" ], function( i, option ) {
				var value = element.attr( option );
				if ( value !== undefined && value.length ) {
					options[ option ] = value;
				}
			});

			return options;
		},

		_events: {
			keydown: function( event ) {
				if ( this._start( event ) && this._keydown( event ) ) {
					event.preventDefault();
				}
			},
			keyup: "_stop",
			focus: function() {
				this.previous = this.element.val();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				this._stop();
				this._refresh();
				if ( this.previous !== this.element.val() ) {
					this._trigger( "change", event );
				}
			},
			mousewheel: function( event, delta ) {
				if ( !delta ) {
					return;
				}
				if ( !this.spinning && !this._start( event ) ) {
					return false;
				}

				this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
				clearTimeout( this.mousewheelTimer );
				this.mousewheelTimer = this._delay(function() {
					if ( this.spinning ) {
						this._stop( event );
					}
				}, 100 );
				event.preventDefault();
			},
			"mousedown .ui-spinner-button": function( event ) {
				var previous;

				// We never want the buttons to have focus; whenever the user is
				// interacting with the spinner, the focus should be on the input.
				// If the input is focused then this.previous is properly set from
				// when the input first received focus. If the input is not focused
				// then we need to set this.previous based on the value before spinning.
				previous = this.element[0] === this.document[0].activeElement ?
					this.previous : this.element.val();
				function checkFocus() {
					var isActive = this.element[0] === this.document[0].activeElement;
					if ( !isActive ) {
						this.element.focus();
						this.previous = previous;
						// support: IE
						// IE sets focus asynchronously, so we need to check if focus
						// moved off of the input because the user clicked on the button.
						this._delay(function() {
							this.previous = previous;
						});
					}
				}

				// ensure focus is on (or stays on) the text field
				event.preventDefault();
				checkFocus.call( this );

				// support: IE
				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				// and check (again) if focus moved off of the input.
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
					checkFocus.call( this );
				});

				if ( this._start( event ) === false ) {
					return;
				}

				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			"mouseup .ui-spinner-button": "_stop",
			"mouseenter .ui-spinner-button": function( event ) {
				// button will add ui-state-active if mouse was down while mouseleave and kept down
				if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
					return;
				}

				if ( this._start( event ) === false ) {
					return false;
				}
				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			// TODO: do we really want to consider this a stop?
			// shouldn't we just stop the repeater and wait until mouseup before
			// we trigger the stop event?
			"mouseleave .ui-spinner-button": "_stop"
		},

		_draw: function() {
			var uiSpinner = this.uiSpinner = this.element
				.addClass( "ui-spinner-input" )
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()
					// add buttons
					.append( this._buttonHtml() );

			this.element.attr( "role", "spinbutton" );

			// button bindings
			this.buttons = uiSpinner.find( ".ui-spinner-button" )
				.attr( "tabIndex", -1 )
				.button()
				.removeClass( "ui-corner-all" );

			// IE 6 doesn't understand height: 50% for the buttons
			// unless the wrapper has an explicit height
			if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
					uiSpinner.height() > 0 ) {
				uiSpinner.height( uiSpinner.height() );
			}

			// disable spinner if element was already disabled
			if ( this.options.disabled ) {
				this.disable();
			}
		},

		_keydown: function( event ) {
			var options = this.options,
				keyCode = $.ui.keyCode;

			switch ( event.keyCode ) {
			case keyCode.UP:
				this._repeat( null, 1, event );
				return true;
			case keyCode.DOWN:
				this._repeat( null, -1, event );
				return true;
			case keyCode.PAGE_UP:
				this._repeat( null, options.page, event );
				return true;
			case keyCode.PAGE_DOWN:
				this._repeat( null, -options.page, event );
				return true;
			}

			return false;
		},

		_uiSpinnerHtml: function() {
			return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
		},

		_buttonHtml: function() {
			return "" +
				"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
					"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
				"</a>" +
				"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
					"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
				"</a>";
		},

		_start: function( event ) {
			if ( !this.spinning && this._trigger( "start", event ) === false ) {
				return false;
			}

			if ( !this.counter ) {
				this.counter = 1;
			}
			this.spinning = true;
			return true;
		},

		_repeat: function( i, steps, event ) {
			i = i || 500;

			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				this._repeat( 40, steps, event );
			}, i );

			this._spin( steps * this.options.step, event );
		},

		_spin: function( step, event ) {
			var value = this.value() || 0;

			if ( !this.counter ) {
				this.counter = 1;
			}

			value = this._adjustValue( value + step * this._increment( this.counter ) );

			if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
				this._value( value );
				this.counter++;
			}
		},

		_increment: function( i ) {
			var incremental = this.options.incremental;

			if ( incremental ) {
				return $.isFunction( incremental ) ?
					incremental( i ) :
					Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
			}

			return 1;
		},

		_precision: function() {
			var precision = this._precisionOf( this.options.step );
			if ( this.options.min !== null ) {
				precision = Math.max( precision, this._precisionOf( this.options.min ) );
			}
			return precision;
		},

		_precisionOf: function( num ) {
			var str = num.toString(),
				decimal = str.indexOf( "." );
			return decimal === -1 ? 0 : str.length - decimal - 1;
		},

		_adjustValue: function( value ) {
			var base, aboveMin,
				options = this.options;

			// make sure we're at a valid step
			// - find out where we are relative to the base (min or 0)
			base = options.min !== null ? options.min : 0;
			aboveMin = value - base;
			// - round to the nearest step
			aboveMin = Math.round(aboveMin / options.step) * options.step;
			// - rounding is based on 0, so adjust back to our base
			value = base + aboveMin;

			// fix precision from bad JS floating point math
			value = parseFloat( value.toFixed( this._precision() ) );

			// clamp the value
			if ( options.max !== null && value > options.max) {
				return options.max;
			}
			if ( options.min !== null && value < options.min ) {
				return options.min;
			}

			return value;
		},

		_stop: function( event ) {
			if ( !this.spinning ) {
				return;
			}

			clearTimeout( this.timer );
			clearTimeout( this.mousewheelTimer );
			this.counter = 0;
			this.spinning = false;
			this._trigger( "stop", event );
		},

		_setOption: function( key, value ) {
			if ( key === "culture" || key === "numberFormat" ) {
				var prevValue = this._parse( this.element.val() );
				this.options[ key ] = value;
				this.element.val( this._format( prevValue ) );
				return;
			}

			if ( key === "max" || key === "min" || key === "step" ) {
				if ( typeof value === "string" ) {
					value = this._parse( value );
				}
			}
			if ( key === "icons" ) {
				this.buttons.first().find( ".ui-icon" )
					.removeClass( this.options.icons.up )
					.addClass( value.up );
				this.buttons.last().find( ".ui-icon" )
					.removeClass( this.options.icons.down )
					.addClass( value.down );
			}

			this._super( key, value );

			if ( key === "disabled" ) {
				if ( value ) {
					this.element.prop( "disabled", true );
					this.buttons.button( "disable" );
				} else {
					this.element.prop( "disabled", false );
					this.buttons.button( "enable" );
				}
			}
		},

		_setOptions: modifier(function( options ) {
			this._super( options );
			this._value( this.element.val() );
		}),

		_parse: function( val ) {
			if ( typeof val === "string" && val !== "" ) {
				val = window.Globalize && this.options.numberFormat ?
					Globalize.parseFloat( val, 10, this.options.culture ) : +val;
			}
			return val === "" || isNaN( val ) ? null : val;
		},

		_format: function( value ) {
			if ( value === "" ) {
				return "";
			}
			return window.Globalize && this.options.numberFormat ?
				Globalize.format( value, this.options.numberFormat, this.options.culture ) :
				value;
		},

		_refresh: function() {
			this.element.attr({
				"aria-valuemin": this.options.min,
				"aria-valuemax": this.options.max,
				// TODO: what should we do with values that can't be parsed?
				"aria-valuenow": this._parse( this.element.val() )
			});
		},

		// update the value without triggering change
		_value: function( value, allowAny ) {
			var parsed;
			if ( value !== "" ) {
				parsed = this._parse( value );
				if ( parsed !== null ) {
					if ( !allowAny ) {
						parsed = this._adjustValue( parsed );
					}
					value = this._format( parsed );
				}
			}
			this.element.val( value );
			this._refresh();
		},

		_destroy: function() {
			this.element
				.removeClass( "ui-spinner-input" )
				.prop( "disabled", false )
				.removeAttr( "autocomplete" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );
			this.uiSpinner.replaceWith( this.element );
		},

		stepUp: modifier(function( steps ) {
			this._stepUp( steps );
		}),
		_stepUp: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * this.options.step );
				this._stop();
			}
		},

		stepDown: modifier(function( steps ) {
			this._stepDown( steps );
		}),
		_stepDown: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * -this.options.step );
				this._stop();
			}
		},

		pageUp: modifier(function( pages ) {
			this._stepUp( (pages || 1) * this.options.page );
		}),

		pageDown: modifier(function( pages ) {
			this._stepDown( (pages || 1) * this.options.page );
		}),

		value: function( newVal ) {
			if ( !arguments.length ) {
				return this._parse( this.element.val() );
			}
			modifier( this._value ).call( this, newVal );
		},

		widget: function() {
			return this.uiSpinner;
		}
	});

	}( jQuery ) );
	(function( $, undefined ) {

	var tabId = 0,
		rhash = /#.*$/;

	function getNextTabId() {
		return ++tabId;
	}

	function isLocal( anchor ) {
		// support: IE7
		// IE7 doesn't normalize the href property when set via script (#9317)
		anchor = anchor.cloneNode( false );

		return anchor.hash.length > 1 &&
			decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
				decodeURIComponent( location.href.replace( rhash, "" ) );
	}

	$.widget( "ui.tabs", {
		version: "1.10.4",
		delay: 300,
		options: {
			active: null,
			collapsible: false,
			event: "click",
			heightStyle: "content",
			hide: null,
			show: null,

			// callbacks
			activate: null,
			beforeActivate: null,
			beforeLoad: null,
			load: null
		},

		_create: function() {
			var that = this,
				options = this.options;

			this.running = false;

			this.element
				.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
				.toggleClass( "ui-tabs-collapsible", options.collapsible )
				// Prevent users from focusing disabled tabs via click
				.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
					if ( $( this ).is( ".ui-state-disabled" ) ) {
						event.preventDefault();
					}
				})
				// support: IE <9
				// Preventing the default action in mousedown doesn't prevent IE
				// from focusing the element, so if the anchor gets focused, blur.
				// We don't have to worry about focusing the previously focused
				// element since clicking on a non-focusable element should focus
				// the body anyway.
				.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
					if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
						this.blur();
					}
				});

			this._processTabs();
			options.active = this._initialActive();

			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			if ( $.isArray( options.disabled ) ) {
				options.disabled = $.unique( options.disabled.concat(
					$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
						return that.tabs.index( li );
					})
				) ).sort();
			}

			// check for length avoids error when initializing empty list
			if ( this.options.active !== false && this.anchors.length ) {
				this.active = this._findActive( options.active );
			} else {
				this.active = $();
			}

			this._refresh();

			if ( this.active.length ) {
				this.load( options.active );
			}
		},

		_initialActive: function() {
			var active = this.options.active,
				collapsible = this.options.collapsible,
				locationHash = location.hash.substring( 1 );

			if ( active === null ) {
				// check the fragment identifier in the URL
				if ( locationHash ) {
					this.tabs.each(function( i, tab ) {
						if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
							active = i;
							return false;
						}
					});
				}

				// check for a tab marked active via a class
				if ( active === null ) {
					active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
				}

				// no active tab, set to false
				if ( active === null || active === -1 ) {
					active = this.tabs.length ? 0 : false;
				}
			}

			// handle numbers: negative, out of range
			if ( active !== false ) {
				active = this.tabs.index( this.tabs.eq( active ) );
				if ( active === -1 ) {
					active = collapsible ? false : 0;
				}
			}

			// don't allow collapsible: false and active: false
			if ( !collapsible && active === false && this.anchors.length ) {
				active = 0;
			}

			return active;
		},

		_getCreateEventData: function() {
			return {
				tab: this.active,
				panel: !this.active.length ? $() : this._getPanelForTab( this.active )
			};
		},

		_tabKeydown: function( event ) {
			var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
				selectedIndex = this.tabs.index( focusedTab ),
				goingForward = true;

			if ( this._handlePageNav( event ) ) {
				return;
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
					selectedIndex++;
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.LEFT:
					goingForward = false;
					selectedIndex--;
					break;
				case $.ui.keyCode.END:
					selectedIndex = this.anchors.length - 1;
					break;
				case $.ui.keyCode.HOME:
					selectedIndex = 0;
					break;
				case $.ui.keyCode.SPACE:
					// Activate only, no collapsing
					event.preventDefault();
					clearTimeout( this.activating );
					this._activate( selectedIndex );
					return;
				case $.ui.keyCode.ENTER:
					// Toggle (cancel delayed activation, allow collapsing)
					event.preventDefault();
					clearTimeout( this.activating );
					// Determine if we should collapse or activate
					this._activate( selectedIndex === this.options.active ? false : selectedIndex );
					return;
				default:
					return;
			}

			// Focus the appropriate tab, based on which key was pressed
			event.preventDefault();
			clearTimeout( this.activating );
			selectedIndex = this._focusNextTab( selectedIndex, goingForward );

			// Navigating with control key will prevent automatic activation
			if ( !event.ctrlKey ) {
				// Update aria-selected immediately so that AT think the tab is already selected.
				// Otherwise AT may confuse the user by stating that they need to activate the tab,
				// but the tab will already be activated by the time the announcement finishes.
				focusedTab.attr( "aria-selected", "false" );
				this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

				this.activating = this._delay(function() {
					this.option( "active", selectedIndex );
				}, this.delay );
			}
		},

		_panelKeydown: function( event ) {
			if ( this._handlePageNav( event ) ) {
				return;
			}

			// Ctrl+up moves focus to the current tab
			if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
				event.preventDefault();
				this.active.focus();
			}
		},

		// Alt+page up/down moves focus to the previous/next tab (and activates)
		_handlePageNav: function( event ) {
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
				this._activate( this._focusNextTab( this.options.active - 1, false ) );
				return true;
			}
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
				this._activate( this._focusNextTab( this.options.active + 1, true ) );
				return true;
			}
		},

		_findNextTab: function( index, goingForward ) {
			var lastTabIndex = this.tabs.length - 1;

			function constrain() {
				if ( index > lastTabIndex ) {
					index = 0;
				}
				if ( index < 0 ) {
					index = lastTabIndex;
				}
				return index;
			}

			while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
				index = goingForward ? index + 1 : index - 1;
			}

			return index;
		},

		_focusNextTab: function( index, goingForward ) {
			index = this._findNextTab( index, goingForward );
			this.tabs.eq( index ).focus();
			return index;
		},

		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}

			if ( key === "disabled" ) {
				// don't use the widget factory's disabled handling
				this._setupDisabled( value );
				return;
			}

			this._super( key, value);

			if ( key === "collapsible" ) {
				this.element.toggleClass( "ui-tabs-collapsible", value );
				// Setting collapsible: false while collapsed; open first panel
				if ( !value && this.options.active === false ) {
					this._activate( 0 );
				}
			}

			if ( key === "event" ) {
				this._setupEvents( value );
			}

			if ( key === "heightStyle" ) {
				this._setupHeightStyle( value );
			}
		},

		_tabId: function( tab ) {
			return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
		},

		_sanitizeSelector: function( hash ) {
			return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
		},

		refresh: function() {
			var options = this.options,
				lis = this.tablist.children( ":has(a[href])" );

			// get disabled tabs from class attribute from HTML
			// this will get converted to a boolean if needed in _refresh()
			options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
				return lis.index( tab );
			});

			this._processTabs();

			// was collapsed or no tabs
			if ( options.active === false || !this.anchors.length ) {
				options.active = false;
				this.active = $();
			// was active, but active tab is gone
			} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
				// all remaining tabs are disabled
				if ( this.tabs.length === options.disabled.length ) {
					options.active = false;
					this.active = $();
				// activate previous tab
				} else {
					this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
				}
			// was active, active tab still exists
			} else {
				// make sure active index is correct
				options.active = this.tabs.index( this.active );
			}

			this._refresh();
		},

		_refresh: function() {
			this._setupDisabled( this.options.disabled );
			this._setupEvents( this.options.event );
			this._setupHeightStyle( this.options.heightStyle );

			this.tabs.not( this.active ).attr({
				"aria-selected": "false",
				tabIndex: -1
			});
			this.panels.not( this._getPanelForTab( this.active ) )
				.hide()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				});

			// Make sure one tab is in the tab order
			if ( !this.active.length ) {
				this.tabs.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active
					.addClass( "ui-tabs-active ui-state-active" )
					.attr({
						"aria-selected": "true",
						tabIndex: 0
					});
				this._getPanelForTab( this.active )
					.show()
					.attr({
						"aria-expanded": "true",
						"aria-hidden": "false"
					});
			}
		},

		_processTabs: function() {
			var that = this;

			this.tablist = this._getList()
				.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.attr( "role", "tablist" );

			this.tabs = this.tablist.find( "> li:has(a[href])" )
				.addClass( "ui-state-default ui-corner-top" )
				.attr({
					role: "tab",
					tabIndex: -1
				});

			this.anchors = this.tabs.map(function() {
					return $( "a", this )[ 0 ];
				})
				.addClass( "ui-tabs-anchor" )
				.attr({
					role: "presentation",
					tabIndex: -1
				});

			this.panels = $();

			this.anchors.each(function( i, anchor ) {
				var selector, panel, panelId,
					anchorId = $( anchor ).uniqueId().attr( "id" ),
					tab = $( anchor ).closest( "li" ),
					originalAriaControls = tab.attr( "aria-controls" );

				// inline tab
				if ( isLocal( anchor ) ) {
					selector = anchor.hash;
					panel = that.element.find( that._sanitizeSelector( selector ) );
				// remote tab
				} else {
					panelId = that._tabId( tab );
					selector = "#" + panelId;
					panel = that.element.find( selector );
					if ( !panel.length ) {
						panel = that._createPanel( panelId );
						panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
					}
					panel.attr( "aria-live", "polite" );
				}

				if ( panel.length) {
					that.panels = that.panels.add( panel );
				}
				if ( originalAriaControls ) {
					tab.data( "ui-tabs-aria-controls", originalAriaControls );
				}
				tab.attr({
					"aria-controls": selector.substring( 1 ),
					"aria-labelledby": anchorId
				});
				panel.attr( "aria-labelledby", anchorId );
			});

			this.panels
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.attr( "role", "tabpanel" );
		},

		// allow overriding how to find the list for rare usage scenarios (#7715)
		_getList: function() {
			return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
		},

		_createPanel: function( id ) {
			return $( "<div>" )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		},

		_setupDisabled: function( disabled ) {
			if ( $.isArray( disabled ) ) {
				if ( !disabled.length ) {
					disabled = false;
				} else if ( disabled.length === this.anchors.length ) {
					disabled = true;
				}
			}

			// disable tabs
			for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
				if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
					$( li )
						.addClass( "ui-state-disabled" )
						.attr( "aria-disabled", "true" );
				} else {
					$( li )
						.removeClass( "ui-state-disabled" )
						.removeAttr( "aria-disabled" );
				}
			}

			this.options.disabled = disabled;
		},

		_setupEvents: function( event ) {
			var events = {
				click: function( event ) {
					event.preventDefault();
				}
			};
			if ( event ) {
				$.each( event.split(" "), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}

			this._off( this.anchors.add( this.tabs ).add( this.panels ) );
			this._on( this.anchors, events );
			this._on( this.tabs, { keydown: "_tabKeydown" } );
			this._on( this.panels, { keydown: "_panelKeydown" } );

			this._focusable( this.tabs );
			this._hoverable( this.tabs );
		},

		_setupHeightStyle: function( heightStyle ) {
			var maxHeight,
				parent = this.element.parent();

			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				maxHeight -= this.element.outerHeight() - this.element.height();

				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );

					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});

				this.element.children().not( this.panels ).each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});

				this.panels.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.panels.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				}).height( maxHeight );
			}
		},

		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				anchor = $( event.currentTarget ),
				tab = anchor.closest( "li" ),
				clickedIsActive = tab[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : this._getPanelForTab( tab ),
				toHide = !active.length ? $() : this._getPanelForTab( active ),
				eventData = {
					oldTab: active,
					oldPanel: toHide,
					newTab: collapsing ? $() : tab,
					newPanel: toShow
				};

			event.preventDefault();

			if ( tab.hasClass( "ui-state-disabled" ) ||
					// tab is already loading
					tab.hasClass( "ui-tabs-loading" ) ||
					// can't switch durning an animation
					this.running ||
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}

			options.active = collapsing ? false : this.tabs.index( tab );

			this.active = clickedIsActive ? $() : tab;
			if ( this.xhr ) {
				this.xhr.abort();
			}

			if ( !toHide.length && !toShow.length ) {
				$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
			}

			if ( toShow.length ) {
				this.load( this.tabs.index( tab ), event );
			}
			this._toggle( event, eventData );
		},

		// handles show/hide for selecting tabs
		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel;

			this.running = true;

			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}

			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

				if ( toShow.length && that.options.show ) {
					that._show( toShow, that.options.show, complete );
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length && this.options.hide ) {
				this._hide( toHide, this.options.hide, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}

			toHide.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});
			eventData.oldTab.attr( "aria-selected", "false" );
			// If we're switching tabs, remove the old tab from the tab order.
			// If we're opening from collapsed state, remove the previous tab from the tab order.
			// If we're collapsing, then keep the collapsing tab in the tab order.
			if ( toShow.length && toHide.length ) {
				eventData.oldTab.attr( "tabIndex", -1 );
			} else if ( toShow.length ) {
				this.tabs.filter(function() {
					return $( this ).attr( "tabIndex" ) === 0;
				})
				.attr( "tabIndex", -1 );
			}

			toShow.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			});
			eventData.newTab.attr({
				"aria-selected": "true",
				tabIndex: 0
			});
		},

		_activate: function( index ) {
			var anchor,
				active = this._findActive( index );

			// trying to activate the already active panel
			if ( active[ 0 ] === this.active[ 0 ] ) {
				return;
			}

			// trying to collapse, simulate a click on the current active header
			if ( !active.length ) {
				active = this.active;
			}

			anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
			this._eventHandler({
				target: anchor,
				currentTarget: anchor,
				preventDefault: $.noop
			});
		},

		_findActive: function( index ) {
			return index === false ? $() : this.tabs.eq( index );
		},

		_getIndex: function( index ) {
			// meta-function to give users option to provide a href string instead of a numerical index.
			if ( typeof index === "string" ) {
				index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
			}

			return index;
		},

		_destroy: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}

			this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

			this.tablist
				.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.removeAttr( "role" );

			this.anchors
				.removeClass( "ui-tabs-anchor" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeUniqueId();

			this.tabs.add( this.panels ).each(function() {
				if ( $.data( this, "ui-tabs-destroy" ) ) {
					$( this ).remove();
				} else {
					$( this )
						.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
							"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
						.removeAttr( "tabIndex" )
						.removeAttr( "aria-live" )
						.removeAttr( "aria-busy" )
						.removeAttr( "aria-selected" )
						.removeAttr( "aria-labelledby" )
						.removeAttr( "aria-hidden" )
						.removeAttr( "aria-expanded" )
						.removeAttr( "role" );
				}
			});

			this.tabs.each(function() {
				var li = $( this ),
					prev = li.data( "ui-tabs-aria-controls" );
				if ( prev ) {
					li
						.attr( "aria-controls", prev )
						.removeData( "ui-tabs-aria-controls" );
				} else {
					li.removeAttr( "aria-controls" );
				}
			});

			this.panels.show();

			if ( this.options.heightStyle !== "content" ) {
				this.panels.css( "height", "" );
			}
		},

		enable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === false ) {
				return;
			}

			if ( index === undefined ) {
				disabled = false;
			} else {
				index = this._getIndex( index );
				if ( $.isArray( disabled ) ) {
					disabled = $.map( disabled, function( num ) {
						return num !== index ? num : null;
					});
				} else {
					disabled = $.map( this.tabs, function( li, num ) {
						return num !== index ? num : null;
					});
				}
			}
			this._setupDisabled( disabled );
		},

		disable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === true ) {
				return;
			}

			if ( index === undefined ) {
				disabled = true;
			} else {
				index = this._getIndex( index );
				if ( $.inArray( index, disabled ) !== -1 ) {
					return;
				}
				if ( $.isArray( disabled ) ) {
					disabled = $.merge( [ index ], disabled ).sort();
				} else {
					disabled = [ index ];
				}
			}
			this._setupDisabled( disabled );
		},

		load: function( index, event ) {
			index = this._getIndex( index );
			var that = this,
				tab = this.tabs.eq( index ),
				anchor = tab.find( ".ui-tabs-anchor" ),
				panel = this._getPanelForTab( tab ),
				eventData = {
					tab: tab,
					panel: panel
				};

			// not remote
			if ( isLocal( anchor[ 0 ] ) ) {
				return;
			}

			this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

			// support: jQuery <1.8
			// jQuery <1.8 returns false if the request is canceled in beforeSend,
			// but as of 1.8, $.ajax() always returns a jqXHR object.
			if ( this.xhr && this.xhr.statusText !== "canceled" ) {
				tab.addClass( "ui-tabs-loading" );
				panel.attr( "aria-busy", "true" );

				this.xhr
					.success(function( response ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							panel.html( response );
							that._trigger( "load", event, eventData );
						}, 1 );
					})
					.complete(function( jqXHR, status ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							if ( status === "abort" ) {
								that.panels.stop( false, true );
							}

							tab.removeClass( "ui-tabs-loading" );
							panel.removeAttr( "aria-busy" );

							if ( jqXHR === that.xhr ) {
								delete that.xhr;
							}
						}, 1 );
					});
			}
		},

		_ajaxSettings: function( anchor, event, eventData ) {
			var that = this;
			return {
				url: anchor.attr( "href" ),
				beforeSend: function( jqXHR, settings ) {
					return that._trigger( "beforeLoad", event,
						$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
				}
			};
		},

		_getPanelForTab: function( tab ) {
			var id = $( tab ).attr( "aria-controls" );
			return this.element.find( this._sanitizeSelector( "#" + id ) );
		}
	});

	})( jQuery );
	(function( $ ) {

	var increments = 0;

	function addDescribedBy( elem, id ) {
		var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	}

	function removeDescribedBy( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
			index = $.inArray( id, describedby );
		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	}

	$.widget( "ui.tooltip", {
		version: "1.10.4",
		options: {
			content: function() {
				// support: IE<9, Opera in jQuery <1.7
				// .text() can't accept undefined, so coerce to a string
				var title = $( this ).attr( "title" ) || "";
				// Escape title, since we're going from an attribute to raw HTML
				return $( "<a>" ).text( title ).html();
			},
			hide: true,
			// Disabled elements have inconsistent behavior across browsers (#8661)
			items: "[title]:not([disabled])",
			position: {
				my: "left top+15",
				at: "left bottom",
				collision: "flipfit flip"
			},
			show: true,
			tooltipClass: null,
			track: false,

			// callbacks
			close: null,
			open: null
		},

		_create: function() {
			this._on({
				mouseover: "open",
				focusin: "open"
			});

			// IDs of generated tooltips, needed for destroy
			this.tooltips = {};
			// IDs of parent tooltips where we removed the title attribute
			this.parents = {};

			if ( this.options.disabled ) {
				this._disable();
			}
		},

		_setOption: function( key, value ) {
			var that = this;

			if ( key === "disabled" ) {
				this[ value ? "_disable" : "_enable" ]();
				this.options[ key ] = value;
				// disable element style changes
				return;
			}

			this._super( key, value );

			if ( key === "content" ) {
				$.each( this.tooltips, function( id, element ) {
					that._updateContent( element );
				});
			}
		},

		_disable: function() {
			var that = this;

			// close open tooltips
			$.each( this.tooltips, function( id, element ) {
				var event = $.Event( "blur" );
				event.target = event.currentTarget = element[0];
				that.close( event, true );
			});

			// remove title attributes to prevent native tooltips
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.is( "[title]" ) ) {
					element
						.data( "ui-tooltip-title", element.attr( "title" ) )
						.attr( "title", "" );
				}
			});
		},

		_enable: function() {
			// restore title attributes
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
			});
		},

		open: function( event ) {
			var that = this,
				target = $( event ? event.target : this.element )
					// we need closest here due to mouseover bubbling,
					// but always pointing at the same event target
					.closest( this.options.items );

			// No element to show a tooltip for or the tooltip is already open
			if ( !target.length || target.data( "ui-tooltip-id" ) ) {
				return;
			}

			if ( target.attr( "title" ) ) {
				target.data( "ui-tooltip-title", target.attr( "title" ) );
			}

			target.data( "ui-tooltip-open", true );

			// kill parent tooltips, custom or native, for hover
			if ( event && event.type === "mouseover" ) {
				target.parents().each(function() {
					var parent = $( this ),
						blurEvent;
					if ( parent.data( "ui-tooltip-open" ) ) {
						blurEvent = $.Event( "blur" );
						blurEvent.target = blurEvent.currentTarget = this;
						that.close( blurEvent, true );
					}
					if ( parent.attr( "title" ) ) {
						parent.uniqueId();
						that.parents[ this.id ] = {
							element: this,
							title: parent.attr( "title" )
						};
						parent.attr( "title", "" );
					}
				});
			}

			this._updateContent( target, event );
		},

		_updateContent: function( target, event ) {
			var content,
				contentOption = this.options.content,
				that = this,
				eventType = event ? event.type : null;

			if ( typeof contentOption === "string" ) {
				return this._open( event, target, contentOption );
			}

			content = contentOption.call( target[0], function( response ) {
				// ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}
				// IE may instantly serve a cached response for ajax requests
				// delay this call to _open so the other call to _open runs first
				that._delay(function() {
					// jQuery creates a special event for focusin when it doesn't
					// exist natively. To improve performance, the native event
					// object is reused and the type is changed. Therefore, we can't
					// rely on the type being correct after the event finished
					// bubbling, so we set it back to the previous value. (#8740)
					if ( event ) {
						event.type = eventType;
					}
					this._open( event, target, response );
				});
			});
			if ( content ) {
				this._open( event, target, content );
			}
		},

		_open: function( event, target, content ) {
			var tooltip, events, delayedShow,
				positionOption = $.extend( {}, this.options.position );

			if ( !content ) {
				return;
			}

			// Content can be updated multiple times. If the tooltip already
			// exists, then just update the content and bail.
			tooltip = this._find( target );
			if ( tooltip.length ) {
				tooltip.find( ".ui-tooltip-content" ).html( content );
				return;
			}

			// if we have a title, clear it to prevent the native tooltip
			// we have to check first to avoid defining a title if none exists
			// (we don't want to cause an element to start matching [title])
			//
			// We use removeAttr only for key events, to allow IE to export the correct
			// accessible attributes. For mouse events, set to empty string to avoid
			// native tooltip showing up (happens only when removing inside mouseover).
			if ( target.is( "[title]" ) ) {
				if ( event && event.type === "mouseover" ) {
					target.attr( "title", "" );
				} else {
					target.removeAttr( "title" );
				}
			}

			tooltip = this._tooltip( target );
			addDescribedBy( target, tooltip.attr( "id" ) );
			tooltip.find( ".ui-tooltip-content" ).html( content );

			function position( event ) {
				positionOption.of = event;
				if ( tooltip.is( ":hidden" ) ) {
					return;
				}
				tooltip.position( positionOption );
			}
			if ( this.options.track && event && /^mouse/.test( event.type ) ) {
				this._on( this.document, {
					mousemove: position
				});
				// trigger once to override element-relative positioning
				position( event );
			} else {
				tooltip.position( $.extend({
					of: target
				}, this.options.position ) );
			}

			tooltip.hide();

			this._show( tooltip, this.options.show );
			// Handle tracking tooltips that are shown with a delay (#8644). As soon
			// as the tooltip is visible, position the tooltip using the most recent
			// event.
			if ( this.options.show && this.options.show.delay ) {
				delayedShow = this.delayedShow = setInterval(function() {
					if ( tooltip.is( ":visible" ) ) {
						position( positionOption.of );
						clearInterval( delayedShow );
					}
				}, $.fx.interval );
			}

			this._trigger( "open", event, { tooltip: tooltip } );

			events = {
				keyup: function( event ) {
					if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
						var fakeEvent = $.Event(event);
						fakeEvent.currentTarget = target[0];
						this.close( fakeEvent, true );
					}
				},
				remove: function() {
					this._removeTooltip( tooltip );
				}
			};
			if ( !event || event.type === "mouseover" ) {
				events.mouseleave = "close";
			}
			if ( !event || event.type === "focusin" ) {
				events.focusout = "close";
			}
			this._on( true, target, events );
		},

		close: function( event ) {
			var that = this,
				target = $( event ? event.currentTarget : this.element ),
				tooltip = this._find( target );

			// disabling closes the tooltip, so we need to track when we're closing
			// to avoid an infinite loop in case the tooltip becomes disabled on close
			if ( this.closing ) {
				return;
			}

			// Clear the interval for delayed tracking tooltips
			clearInterval( this.delayedShow );

			// only set title if we had one before (see comment in _open())
			if ( target.data( "ui-tooltip-title" ) ) {
				target.attr( "title", target.data( "ui-tooltip-title" ) );
			}

			removeDescribedBy( target );

			tooltip.stop( true );
			this._hide( tooltip, this.options.hide, function() {
				that._removeTooltip( $( this ) );
			});

			target.removeData( "ui-tooltip-open" );
			this._off( target, "mouseleave focusout keyup" );
			// Remove 'remove' binding only on delegated targets
			if ( target[0] !== this.element[0] ) {
				this._off( target, "remove" );
			}
			this._off( this.document, "mousemove" );

			if ( event && event.type === "mouseleave" ) {
				$.each( this.parents, function( id, parent ) {
					$( parent.element ).attr( "title", parent.title );
					delete that.parents[ id ];
				});
			}

			this.closing = true;
			this._trigger( "close", event, { tooltip: tooltip } );
			this.closing = false;
		},

		_tooltip: function( element ) {
			var id = "ui-tooltip-" + increments++,
				tooltip = $( "<div>" )
					.attr({
						id: id,
						role: "tooltip"
					})
					.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
						( this.options.tooltipClass || "" ) );
			$( "<div>" )
				.addClass( "ui-tooltip-content" )
				.appendTo( tooltip );
			tooltip.appendTo( this.document[0].body );
			this.tooltips[ id ] = element;
			return tooltip;
		},

		_find: function( target ) {
			var id = target.data( "ui-tooltip-id" );
			return id ? $( "#" + id ) : $();
		},

		_removeTooltip: function( tooltip ) {
			tooltip.remove();
			delete this.tooltips[ tooltip.attr( "id" ) ];
		},

		_destroy: function() {
			var that = this;

			// close open tooltips
			$.each( this.tooltips, function( id, element ) {
				// Delegate to close method to handle common cleanup
				var event = $.Event( "blur" );
				event.target = event.currentTarget = element[0];
				that.close( event, true );

				// Remove immediately; destroying an open tooltip doesn't use the
				// hide animation
				$( "#" + id ).remove();

				// Restore the title
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
					element.removeData( "ui-tooltip-title" );
				}
			});
		}
	});

	}( jQuery ) );


	/* jQuery-Impromptu - v5.1.1
	 * http://trentrichardson.com/Impromptu
	 * Copyright (c) 2013 Trent Richardson; Licensed MIT 
	 */

	(function($) {

		/**
		* setDefaults - Sets the default options
		* @param message String/Object - String of html or Object of states
		* @param options Object - Options to set the prompt
		* @return jQuery - container with overlay and prompt 
		*/
		$.prompt = function(message, options) {
			// only for backwards compat, to be removed in future version
			if(options !== undefined && options.classes !== undefined && typeof options.classes === 'string'){
				options = { box: options.classes };
			}

			$.prompt.options = $.extend({},$.prompt.defaults,options);
			$.prompt.currentPrefix = $.prompt.options.prefix;

			// Be sure any previous timeouts are destroyed
			if($.prompt.timeout){
				clearTimeout($.prompt.timeout);
			}
			$.prompt.timeout = false;

			var opts = $.prompt.options,
				$body = $(document.body),
				$window = $(window);

			//build the box and fade
			var msgbox = '<div class="'+ $.prompt.options.prefix +'box '+ opts.classes.box +'">';
			if(opts.useiframe && ($('object, applet').length > 0)) {
				msgbox += '<iframe src="javascript:false;" style="display:block;position:absolute;z-index:-1;" class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></iframe>';
			} else {
				msgbox +='<div class="'+ opts.prefix +'fade '+ opts.classes.fade +'"></div>';
			}
			msgbox += '<div class="'+ opts.prefix +' '+ opts.classes.prompt +'">'+
						'<form action="javascript:false;" onsubmit="return false;" class="'+ opts.prefix +'form">'+
							'<div class="'+ opts.prefix +'close '+ opts.classes.close +'">'+ opts.closeText +'</div>'+
							'<div class="'+ opts.prefix +'states"></div>'+
						'</form>'+
					'</div>'+
				'</div>';

			$.prompt.jqib = $(msgbox).appendTo($body);
			$.prompt.jqi = $.prompt.jqib.children('.'+ opts.prefix);//.data('jqi',opts);
			$.prompt.jqif = $.prompt.jqib.children('.'+ opts.prefix +'fade');

			//if a string was passed, convert to a single state
			if(message.constructor === String){
				message = {
					state0: {
						title: opts.title,
						html: message,
						buttons: opts.buttons,
						position: opts.position,
						focus: opts.focus,
						submit: opts.submit
					}
				};
			}

			//build the states
			$.prompt.options.states = {};
			var k,v;
			for(k in message){
				v = $.extend({},$.prompt.defaults.state,{name:k},message[k]);
				$.prompt.addState(v.name, v);

				if($.prompt.currentStateName === ''){
					$.prompt.currentStateName = v.name;
				}
			}

			// Go ahead and transition to the first state. It won't be visible just yet though until we show the prompt
			var $firstState = $.prompt.jqi.find('.'+ opts.prefix +'states .'+ opts.prefix +'state').eq(0);
			$.prompt.goToState($firstState.data('jqi-name'));

			//Events
			$.prompt.jqi.on('click', '.'+ opts.prefix +'buttons button', function(e){
				var $t = $(this),
					$state = $t.parents('.'+ opts.prefix +'state'),
					stateobj = $.prompt.options.states[$state.data('jqi-name')],
					msg = $state.children('.'+ opts.prefix +'message'),
					clicked = stateobj.buttons[$t.text()] || stateobj.buttons[$t.html()],
					forminputs = {};

				// if for some reason we couldn't get the value
				if(clicked === undefined){
					for(var i in stateobj.buttons){
						if(stateobj.buttons[i].title === $t.text() || stateobj.buttons[i].title === $t.html()){
							clicked = stateobj.buttons[i].value;
						}
					}
				}

				//collect all form element values from all states.
				$.each($.prompt.jqi.children('form').serializeArray(),function(i,obj){
					if (forminputs[obj.name] === undefined) {
						forminputs[obj.name] = obj.value;
					} else if (typeof forminputs[obj.name] === Array || typeof forminputs[obj.name] === 'object') {
						forminputs[obj.name].push(obj.value);
					} else {
						forminputs[obj.name] = [forminputs[obj.name],obj.value];	
					} 
				});

				// trigger an event
				var promptsubmite = new $.Event('impromptu:submit');
				promptsubmite.stateName = stateobj.name;
				promptsubmite.state = $state;
				$state.trigger(promptsubmite, [clicked, msg, forminputs]);

				if(!promptsubmite.isDefaultPrevented()){
					$.prompt.close(true, clicked,msg,forminputs);
				}
			});

			// if the fade is clicked blink the prompt
			var fadeClicked = function(){
				if(opts.persistent){
					var offset = (opts.top.toString().indexOf('%') >= 0? ($window.height()*(parseInt(opts.top,10)/100)) : parseInt(opts.top,10)),
						top = parseInt($.prompt.jqi.css('top').replace('px',''),10) - offset;

					//$window.scrollTop(top);
					$('html,body').animate({ scrollTop: top }, 'fast', function(){
						var i = 0;
						$.prompt.jqib.addClass(opts.prefix +'warning');
						var intervalid = setInterval(function(){
							$.prompt.jqib.toggleClass(opts.prefix +'warning');
							if(i++ > 1){
								clearInterval(intervalid);
								$.prompt.jqib.removeClass(opts.prefix +'warning');
							}
						}, 100);
					});
				}
				else {
					$.prompt.close(true);
				}
			};

			// listen for esc or tab keys
			var keyPressEventHandler = function(e){
				var key = (window.event) ? event.keyCode : e.keyCode;

				//escape key closes
				if(key===27) {
					fadeClicked();	
				}

				//constrain tabs, tabs should iterate through the state and not leave
				if (key === 9){
					var $inputels = $('input,select,textarea,button',$.prompt.getCurrentState());
					var fwd = !e.shiftKey && e.target === $inputels[$inputels.length-1];
					var back = e.shiftKey && e.target === $inputels[0];
					if (fwd || back) {
						setTimeout(function(){ 
							if (!$inputels){
								return;
							}
							var el = $inputels[back===true ? $inputels.length-1 : 0];

							if (el){
								el.focus();
							}
						},10);
						return false;
					}
				}
			};

			$.prompt.position();
			$.prompt.style();

			$.prompt.jqif.click(fadeClicked);
			$window.resize({animate:false}, $.prompt.position);
			$.prompt.jqi.find('.'+ opts.prefix +'close').click($.prompt.close);
			$.prompt.jqib.on("keydown",keyPressEventHandler)
						.on('impromptu:loaded', opts.loaded)
						.on('impromptu:close', opts.close)
						.on('impromptu:statechanging', opts.statechanging)
						.on('impromptu:statechanged', opts.statechanged);

			// Show it
			$.prompt.jqif[opts.show](opts.overlayspeed);
			$.prompt.jqi[opts.show](opts.promptspeed, function(){
				$.prompt.jqib.trigger('impromptu:loaded');
			});

			// Timeout
			if(opts.timeout > 0){
				$.prompt.timeout = setTimeout(function(){ $.prompt.close(true); },opts.timeout);
			}

			return $.prompt.jqib;
		};

		$.prompt.defaults = {
			prefix:'jqi',
			classes: {
				box: '',
				fade: '',
				prompt: '',
				close: '',
				title: '',
				message: '',
				buttons: '',
				button: '',
				defaultButton: ''
			},
			title: '',
			closeText: '&times;',
			buttons: {
				Ok: true
			},
			loaded: function(e){},
			submit: function(e,v,m,f){},
			close: function(e,v,m,f){},
			statechanging: function(e, from, to){},
			statechanged: function(e, to){},
			opacity: 0.6,
			zIndex: 999,
			overlayspeed: 'slow',
			promptspeed: 'fast',
			show: 'fadeIn',
			focus: 0,
			defaultButton: 0,
			useiframe: false,
			top: '15%',
			position: { 
				container: null, 
				x: null, 
				y: null,
				arrow: null,
				width: null
			},
			persistent: true,
			timeout: 0,
			states: {},
			state: {
				name: null,
				title: '',
				html: '',
				buttons: {
					Ok: true
				},
				focus: 0,
				defaultButton: 0,
				position: { 
					container: null, 
					x: null, 
					y: null,
					arrow: null,
					width: null
				},
				submit: function(e,v,m,f){
					return true;
				}
			}
		};

		/**
		* currentPrefix String - At any time this show be the prefix 
		* of the current prompt ex: "jqi"
		*/
		$.prompt.currentPrefix = $.prompt.defaults.prefix;

		/**
		* currentStateName String - At any time this is the current state
		* of the current prompt ex: "state0"
		*/
		$.prompt.currentStateName = "";

		/**
		* setDefaults - Sets the default options
		* @param o Object - Options to set as defaults
		* @return void
		*/
		$.prompt.setDefaults = function(o) {
			$.prompt.defaults = $.extend({}, $.prompt.defaults, o);
		};

		/**
		* setStateDefaults - Sets the default options for a state
		* @param o Object - Options to set as defaults
		* @return void
		*/
		$.prompt.setStateDefaults = function(o) {
			$.prompt.defaults.state = $.extend({}, $.prompt.defaults.state, o);
		};

		/**
		* position - Repositions the prompt (Used internally)
		* @return void
		*/
		$.prompt.position = function(e){
			var restoreFx = $.fx.off,
				$state = $.prompt.getCurrentState(),
				stateObj = $.prompt.options.states[$state.data('jqi-name')],
				pos = stateObj? stateObj.position : undefined,
				$window = $(window),
				bodyHeight = document.body.scrollHeight, //$(document.body).outerHeight(true),
				windowHeight = $(window).height(),
				documentHeight = $(document).height(),
				height = bodyHeight > windowHeight ? bodyHeight : windowHeight,
				top = parseInt($window.scrollTop(),10) + ($.prompt.options.top.toString().indexOf('%') >= 0? 
						(windowHeight*(parseInt($.prompt.options.top,10)/100)) : parseInt($.prompt.options.top,10));

			// when resizing the window turn off animation
			if(e !== undefined && e.data.animate === false){
				$.fx.off = true;
			}

			$.prompt.jqib.css({
				position: "absolute",
				height: height,
				width: "100%",
				top: 0,
				left: 0,
				right: 0,
				bottom: 0
			});
			$.prompt.jqif.css({
				position: "fixed",
				height: height,
				width: "100%",
				top: 0,
				left: 0,
				right: 0,
				bottom: 0
			});

			// tour positioning
			if(pos && pos.container){
				var offset = $(pos.container).offset();

				if($.isPlainObject(offset) && offset.top !== undefined){
					$.prompt.jqi.css({
						position: "absolute"
					});
					$.prompt.jqi.animate({
						top: offset.top + pos.y,
						left: offset.left + pos.x,
						marginLeft: 0,
						width: (pos.width !== undefined)? pos.width : null
					});
					top = (offset.top + pos.y) - ($.prompt.options.top.toString().indexOf('%') >= 0? (windowHeight*(parseInt($.prompt.options.top,10)/100)) : parseInt($.prompt.options.top,10));
					$('html,body').animate({ scrollTop: top }, 'slow', 'swing', function(){});
				}
			}
			// custom state width animation
			else if(pos && pos.width){
				$.prompt.jqi.css({
						position: "absolute",
						left: '50%'
					});
				$.prompt.jqi.animate({
						top: pos.y || top,
						left: pos.x || '50%',
						marginLeft: ((pos.width/2)*-1),
						width: pos.width
					});
			}
			// standard prompt positioning
			else{
				$.prompt.jqi.css({
					position: "absolute",
					top: top,
					left: '50%',//$window.width()/2,
					marginLeft: (($.prompt.jqi.outerWidth(false)/2)*-1)
				});
			}

			// restore fx settings
			if(e !== undefined && e.data.animate === false){
				$.fx.off = restoreFx;
			}
		};

		/**
		* style - Restyles the prompt (Used internally)
		* @return void
		*/
		$.prompt.style = function(){
			$.prompt.jqif.css({
				zIndex: $.prompt.options.zIndex,
				display: "none",
				opacity: $.prompt.options.opacity
			});
			$.prompt.jqi.css({
				zIndex: $.prompt.options.zIndex+1,
				display: "none"
			});
			$.prompt.jqib.css({
				zIndex: $.prompt.options.zIndex
			});
		};

		/**
		* get - Get the prompt
		* @return jQuery - the prompt
		*/
		$.prompt.get = function(state) {
			return $('.'+ $.prompt.currentPrefix);
		};

		/**
		* addState - Injects a state into the prompt
		* @param statename String - Name of the state
		* @param stateobj Object - options for the state
		* @param afterState String - selector of the state to insert after
		* @return jQuery - the newly created state
		*/
		$.prompt.addState = function(statename, stateobj, afterState) {
			var state = "",
				$state = null,
				arrow = "",
				title = "",
				opts = $.prompt.options,
				$jqistates = $('.'+ $.prompt.currentPrefix +'states'),
				defbtn,k,v,i=0;

			stateobj = $.extend({},$.prompt.defaults.state, {name:statename}, stateobj);

			if(stateobj.position.arrow !== null){
				arrow = '<div class="'+ opts.prefix + 'arrow '+ opts.prefix + 'arrow'+ stateobj.position.arrow +'"></div>';
			}
			if(stateobj.title && stateobj.title !== ''){
				title = '<div class="lead '+ opts.prefix + 'title '+ opts.classes.title +'">'+  stateobj.title +'</div>';
			}
			state += '<div id="'+ opts.prefix +'state_'+ statename +'" class="'+ opts.prefix + 'state" data-jqi-name="'+ statename +'" style="display:none;">'+ 
						arrow + title +
						'<div class="'+ opts.prefix +'message '+ opts.classes.message +'">' + stateobj.html +'</div>'+
						'<div class="'+ opts.prefix +'buttons '+ opts.classes.buttons +'"'+ ($.isEmptyObject(stateobj.buttons)? 'style="display:none;"':'') +'>';

			for(k in stateobj.buttons){
				v = stateobj.buttons[k],
				defbtn = stateobj.focus === i || (isNaN(stateobj.focus) && stateobj.defaultButton === i) ? ($.prompt.currentPrefix + 'defaultbutton ' + opts.classes.defaultButton) : '';

				if(typeof v === 'object'){
					state += '<button class="'+ opts.classes.button +' '+ defbtn;

					if(typeof v.classes !== "undefined"){
						state += ' '+ ($.isArray(v.classes)? v.classes.join(' ') : v.classes) + ' ';
					}

					state += '" name="' + opts.prefix + '_' + statename + '_button' + v.title.replace(/[^a-z0-9]+/gi,'') + '" id="' + opts.prefix + '_' + statename + '_button' + v.title.replace(/[^a-z0-9]+/gi,'') + '" value="' + v.value + '">' + v.title + '</button>';

				} else {
					state += '<button class="'+ opts.classes.button +' '+ defbtn +'" name="' + opts.prefix + '_' + statename + '_button' + k + '" id="' + opts.prefix +  '_' + statename + '_button' + k + '" value="' + v + '">' + k + '</button>';

				}
				i++;
			}
			state += '</div></div>';

			$state = $(state);

			$state.on('impromptu:submit', stateobj.submit);

			if(afterState !== undefined){
				$jqistates.find('#'+ $.prompt.currentPrefix +'state_'+ afterState).after($state);
			}
			else{
				$jqistates.append($state);
			}

			$.prompt.options.states[statename] = stateobj;

			return $state;
		};

		/**
		* removeState - Removes a state from the promt
		* @param state String - Name of the state
		* @return Boolean - returns true on success, false on failure
		*/
		$.prompt.removeState = function(state) {
			var $state = $.prompt.getState(state),
				rm = function(){ $state.remove(); };

			if($state.length === 0){
				return false;
			}

			// transition away from it before deleting
			if($state.is(':visible')){
				if($state.next().length > 0){
					$.prompt.nextState(rm);
				}
				else{
					$.prompt.prevState(rm);
				}
			}
			else{
				$state.slideUp('slow', rm);
			}

			return true;
		};

		/**
		* getState - Get the state by its name
		* @param state String - Name of the state
		* @return jQuery - the state
		*/
		$.prompt.getState = function(state) {
			return $('#'+ $.prompt.currentPrefix +'state_'+ state);
		};
		$.prompt.getStateContent = function(state) {
			return $.prompt.getState(state);
		};

		/**
		* getCurrentState - Get the current visible state
		* @return jQuery - the current visible state
		*/
		$.prompt.getCurrentState = function() {
			return $.prompt.getState($.prompt.getCurrentStateName());
		};

		/**
		* getCurrentStateName - Get the name of the current visible state
		* @return String - the current visible state's name
		*/
		$.prompt.getCurrentStateName = function() {
			return $.prompt.currentStateName;
		};

		/**
		* goToState - Goto the specified state
		* @param state String - name of the state to transition to
		* @param subState Boolean - true to be a sub state within the currently open state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/	
		$.prompt.goToState = function(state, subState, callback) {
			var $jqi = $.prompt.get(),
				jqiopts = $.prompt.options,
				$state = $.prompt.getState(state),
				stateobj = jqiopts.states[$state.data('jqi-name')],
				promptstatechanginge = new $.Event('impromptu:statechanging');

			// subState can be ommitted
			if(typeof subState === 'function'){
				callback = subState;
				subState = false;
			}

			$.prompt.jqib.trigger(promptstatechanginge, [$.prompt.getCurrentStateName(), state]);

			if(!promptstatechanginge.isDefaultPrevented() && $state.length > 0){
				$.prompt.jqi.find('.'+ $.prompt.currentPrefix +'parentstate').removeClass($.prompt.currentPrefix +'parentstate');

				if(subState){ // hide any open substates
					// get rid of any substates
					$.prompt.jqi.find('.'+ $.prompt.currentPrefix +'substate').not($state)
						.slideUp(jqiopts.promptspeed)
						.removeClass('.'+ $.prompt.currentPrefix +'substate')
						.find('.'+ $.prompt.currentPrefix +'arrow').hide();

					// add parent state class so it can be visible, but blocked
					$.prompt.jqi.find('.'+ $.prompt.currentPrefix +'state:visible').addClass($.prompt.currentPrefix +'parentstate');

					// add substate class so we know it will be smaller
					$state.addClass($.prompt.currentPrefix +'substate');
				}
				else{ // hide any open states
					$.prompt.jqi.find('.'+ $.prompt.currentPrefix +'state').not($state)
						.slideUp(jqiopts.promptspeed)
						.find('.'+ $.prompt.currentPrefix +'arrow').hide();
				}
				$.prompt.currentStateName = stateobj.name;

				$state.slideDown(jqiopts.promptspeed,function(){
					var $t = $(this);

					// if focus is a selector, find it, else its button index
					if(typeof(stateobj.focus) === 'string'){
						$t.find(stateobj.focus).eq(0).focus();
					}
					else{
						$t.find('.'+ $.prompt.currentPrefix +'defaultbutton').focus();
					}

					$t.find('.'+ $.prompt.currentPrefix +'arrow').show(jqiopts.promptspeed);

					if (typeof callback === 'function'){
						$.prompt.jqib.on('impromptu:statechanged', callback);
					}
					$.prompt.jqib.trigger('impromptu:statechanged', [state]);
					if (typeof callback === 'function'){
						$.prompt.jqib.off('impromptu:statechanged', callback);
					}
				});
				if(!subState){
					$.prompt.position();
				}
			}
			return $state;
		};

		/**
		* nextState - Transition to the next state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/	
		$.prompt.nextState = function(callback) {
			var $next = $('#'+ $.prompt.currentPrefix +'state_'+ $.prompt.getCurrentStateName()).next();
			return $.prompt.goToState( $next.attr('id').replace($.prompt.currentPrefix +'state_',''), callback );
		};

		/**
		* prevState - Transition to the previous state
		* @param callback Function - called when the transition is complete
		* @return jQuery - the newly active state
		*/	
		$.prompt.prevState = function(callback) {
			var $prev = $('#'+ $.prompt.currentPrefix +'state_'+ $.prompt.getCurrentStateName()).prev();
			$.prompt.goToState( $prev.attr('id').replace($.prompt.currentPrefix +'state_',''), callback );
		};

		/**
		* close - Closes the prompt
		* @param callback Function - called when the transition is complete
		* @param clicked String - value of the button clicked (only used internally)
		* @param msg jQuery - The state message body (only used internally)
		* @param forvals Object - key/value pairs of all form field names and values (only used internally)
		* @return jQuery - the newly active state
		*/	
		$.prompt.close = function(callCallback, clicked, msg, formvals){
			if($.prompt.timeout){
				clearTimeout($.prompt.timeout);
				$.prompt.timeout = false;
			}

			$.prompt.jqib.fadeOut('fast',function(){

				if(callCallback) {
					$.prompt.jqib.trigger('impromptu:close', [clicked,msg,formvals]);
				}
				$.prompt.jqib.remove();

				$(window).off('resize',$.prompt.position);
			});
		};

		/**
		* Enable using $('.selector').prompt({});
		* This will grab the html within the prompt as the prompt message
		*/
		$.fn.prompt = function(options){
			if(options === undefined){
				options = {};
			}
			if(options.withDataAndEvents === undefined){
				options.withDataAndEvents = false;
			}

			$.prompt($(this).clone(options.withDataAndEvents).html(),options);
		};

	})(jQuery);


	/**
	 * Strophe
	 */

	var Base64 = (function() {
	    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	    var obj = {
		encode: function(input) {
		    var output = "";
		    var chr1, chr2, chr3;
		    var enc1, enc2, enc3, enc4;
		    var i = 0;
		    do {
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);
			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;
			if (isNaN(chr2)) {
			    enc3 = enc4 = 64
			} else {
			    if (isNaN(chr3)) {
				enc4 = 64
			    }
			}
			output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4)
		    } while (i < input.length);
		    return output
		},
		decode: function(input) {
		    var output = "";
		    var chr1, chr2, chr3;
		    var enc1, enc2, enc3, enc4;
		    var i = 0;
		    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		    do {
			enc1 = keyStr.indexOf(input.charAt(i++));
			enc2 = keyStr.indexOf(input.charAt(i++));
			enc3 = keyStr.indexOf(input.charAt(i++));
			enc4 = keyStr.indexOf(input.charAt(i++));
			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;
			output = output + String.fromCharCode(chr1);
			if (enc3 != 64) {
			    output = output + String.fromCharCode(chr2)
			}
			if (enc4 != 64) {
			    output = output + String.fromCharCode(chr3)
			}
		    } while (i < input.length);
		    return output
		}
	    };
	    return obj
	})();

	function b64_sha1(s) {
	    return binb2b64(core_sha1(str2binb(s), s.length * 8))
	}

	function str_sha1(s) {
	    return binb2str(core_sha1(str2binb(s), s.length * 8))
	}

	function b64_hmac_sha1(key, data) {
	    return binb2b64(core_hmac_sha1(key, data))
	}

	function str_hmac_sha1(key, data) {
	    return binb2str(core_hmac_sha1(key, data))
	}

	function core_sha1(x, len) {
	    x[len >> 5] |= 128 << (24 - len % 32);
	    x[((len + 64 >> 9) << 4) + 15] = len;
	    var w = new Array(80);
	    var a = 1732584193;
	    var b = -271733879;
	    var c = -1732584194;
	    var d = 271733878;
	    var e = -1009589776;
	    var i, j, t, olda, oldb, oldc, oldd, olde;
	    for (i = 0; i < x.length; i += 16) {
		olda = a;
		oldb = b;
		oldc = c;
		oldd = d;
		olde = e;
		for (j = 0; j < 80; j++) {
		    if (j < 16) {
			w[j] = x[i + j]
		    } else {
			w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1)
		    }
		    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
		    e = d;
		    d = c;
		    c = rol(b, 30);
		    b = a;
		    a = t
		}
		a = safe_add(a, olda);
		b = safe_add(b, oldb);
		c = safe_add(c, oldc);
		d = safe_add(d, oldd);
		e = safe_add(e, olde)
	    }
	    return [a, b, c, d, e]
	}

	function sha1_ft(t, b, c, d) {
	    if (t < 20) {
		return (b & c) | ((~b) & d)
	    }
	    if (t < 40) {
		return b ^ c ^ d
	    }
	    if (t < 60) {
		return (b & c) | (b & d) | (c & d)
	    }
	    return b ^ c ^ d
	}

	function sha1_kt(t) {
	    return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514
	}

	function core_hmac_sha1(key, data) {
	    var bkey = str2binb(key);
	    if (bkey.length > 16) {
		bkey = core_sha1(bkey, key.length * 8)
	    }
	    var ipad = new Array(16),
		opad = new Array(16);
	    for (var i = 0; i < 16; i++) {
		ipad[i] = bkey[i] ^ 909522486;
		opad[i] = bkey[i] ^ 1549556828
	    }
	    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
	    return core_sha1(opad.concat(hash), 512 + 160)
	}

	function safe_add(x, y) {
	    var lsw = (x & 65535) + (y & 65535);
	    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	    return (msw << 16) | (lsw & 65535)
	}

	function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt))
	}

	function str2binb(str) {
	    var bin = [];
	    var mask = 255;
	    for (var i = 0; i < str.length * 8; i += 8) {
		bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << (24 - i % 32)
	    }
	    return bin
	}

	function binb2str(bin) {
	    var str = "";
	    var mask = 255;
	    for (var i = 0; i < bin.length * 32; i += 8) {
		str += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & mask)
	    }
	    return str
	}

	function binb2b64(binarray) {
	    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	    var str = "";
	    var triplet, j;
	    for (var i = 0; i < binarray.length * 4; i += 3) {
		triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 255) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 255) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 255);
		for (j = 0; j < 4; j++) {
		    if (i * 8 + j * 6 > binarray.length * 32) {
			str += "="
		    } else {
			str += tab.charAt((triplet >> 6 * (3 - j)) & 63)
		    }
		}
	    }
	    return str
	}
	var MD5 = (function() {
	    var safe_add = function(x, y) {
		var lsw = (x & 65535) + (y & 65535);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 65535)
	    };
	    var bit_rol = function(num, cnt) {
		return (num << cnt) | (num >>> (32 - cnt))
	    };
	    var str2binl = function(str) {
		var bin = [];
		for (var i = 0; i < str.length * 8; i += 8) {
		    bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << (i % 32)
		}
		return bin
	    };
	    var binl2str = function(bin) {
		var str = "";
		for (var i = 0; i < bin.length * 32; i += 8) {
		    str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & 255)
		}
		return str
	    };
	    var binl2hex = function(binarray) {
		var hex_tab = "0123456789abcdef";
		var str = "";
		for (var i = 0; i < binarray.length * 4; i++) {
		    str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 15) + hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 15)
		}
		return str
	    };
	    var md5_cmn = function(q, a, b, x, s, t) {
		return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
	    };
	    var md5_ff = function(a, b, c, d, x, s, t) {
		return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
	    };
	    var md5_gg = function(a, b, c, d, x, s, t) {
		return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
	    };
	    var md5_hh = function(a, b, c, d, x, s, t) {
		return md5_cmn(b ^ c ^ d, a, b, x, s, t)
	    };
	    var md5_ii = function(a, b, c, d, x, s, t) {
		return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
	    };
	    var core_md5 = function(x, len) {
		x[len >> 5] |= 128 << ((len) % 32);
		x[(((len + 64) >>> 9) << 4) + 14] = len;
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var olda, oldb, oldc, oldd;
		for (var i = 0; i < x.length; i += 16) {
		    olda = a;
		    oldb = b;
		    oldc = c;
		    oldd = d;
		    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
		    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
		    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
		    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
		    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
		    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
		    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
		    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
		    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
		    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
		    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
		    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
		    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
		    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
		    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
		    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
		    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
		    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
		    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
		    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
		    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
		    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
		    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
		    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
		    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
		    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
		    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
		    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
		    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
		    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
		    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
		    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
		    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
		    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
		    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
		    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
		    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
		    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
		    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
		    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
		    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
		    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
		    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
		    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
		    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
		    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
		    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
		    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
		    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
		    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
		    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
		    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
		    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
		    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
		    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
		    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
		    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
		    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
		    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
		    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
		    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
		    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
		    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
		    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
		    a = safe_add(a, olda);
		    b = safe_add(b, oldb);
		    c = safe_add(c, oldc);
		    d = safe_add(d, oldd)
		}
		return [a, b, c, d]
	    };
	    var obj = {
		hexdigest: function(s) {
		    return binl2hex(core_md5(str2binl(s), s.length * 8))
		},
		hash: function(s) {
		    return binl2str(core_md5(str2binl(s), s.length * 8))
		}
	    };
	    return obj
	})();
	if (!Function.prototype.bind) {
	    Function.prototype.bind = function(obj) {
		var func = this;
		var _slice = Array.prototype.slice;
		var _concat = Array.prototype.concat;
		var _args = _slice.call(arguments, 1);
		return function() {
		    return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)))
		}
	    }
	}
	if (!Array.prototype.indexOf) {
	    Array.prototype.indexOf = function(elt) {
		var len = this.length;
		var from = Number(arguments[1]) || 0;
		from = (from < 0) ? Math.ceil(from) : Math.floor(from);
		if (from < 0) {
		    from += len
		}
		for (; from < len; from++) {
		    if (from in this && this[from] === elt) {
			return from
		    }
		}
		return -1
	    }
	}(function(callback) {
	    var Strophe;

	    function $build(name, attrs) {
		return new Strophe.Builder(name, attrs)
	    }

	    function $msg(attrs) {
		return new Strophe.Builder("message", attrs)
	    }

	    function $iq(attrs) {
		return new Strophe.Builder("iq", attrs)
	    }

	    function $pres(attrs) {
		return new Strophe.Builder("presence", attrs)
	    }
	    Strophe = {
		VERSION: "1.1.3",
		NS: {
		    HTTPBIND: "http://jabber.org/protocol/httpbind",
		    BOSH: "urn:xmpp:xbosh",
		    CLIENT: "jabber:client",
		    AUTH: "jabber:iq:auth",
		    ROSTER: "jabber:iq:roster",
		    PROFILE: "jabber:iq:profile",
		    DISCO_INFO: "http://jabber.org/protocol/disco#info",
		    DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
		    MUC: "http://jabber.org/protocol/muc",
		    SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
		    STREAM: "http://etherx.jabber.org/streams",
		    BIND: "urn:ietf:params:xml:ns:xmpp-bind",
		    SESSION: "urn:ietf:params:xml:ns:xmpp-session",
		    VERSION: "jabber:iq:version",
		    STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
		    XHTML_IM: "http://jabber.org/protocol/xhtml-im",
		    XHTML: "http://www.w3.org/1999/xhtml"
		},
		XHTML: {
		    tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
		    attributes: {
			a: ["href"],
			blockquote: ["style"],
			br: [],
			cite: ["style"],
			em: [],
			img: ["src", "alt", "style", "height", "width"],
			li: ["style"],
			ol: ["style"],
			p: ["style"],
			span: ["style"],
			strong: [],
			ul: ["style"],
			body: []
		    },
		    css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
		    validTag: function(tag) {
			for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
			    if (tag == Strophe.XHTML.tags[i]) {
				return true
			    }
			}
			return false
		    },
		    validAttribute: function(tag, attribute) {
			if (typeof Strophe.XHTML.attributes[tag] !== "undefined" && Strophe.XHTML.attributes[tag].length > 0) {
			    for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
				if (attribute == Strophe.XHTML.attributes[tag][i]) {
				    return true
				}
			    }
			}
			return false
		    },
		    validCSS: function(style) {
			for (var i = 0; i < Strophe.XHTML.css.length; i++) {
			    if (style == Strophe.XHTML.css[i]) {
				return true
			    }
			}
			return false
		    }
		},
		Status: {
		    ERROR: 0,
		    CONNECTING: 1,
		    CONNFAIL: 2,
		    AUTHENTICATING: 3,
		    AUTHFAIL: 4,
		    CONNECTED: 5,
		    DISCONNECTED: 6,
		    DISCONNECTING: 7,
		    ATTACHED: 8
		},
		LogLevel: {
		    DEBUG: 0,
		    INFO: 1,
		    WARN: 2,
		    ERROR: 3,
		    FATAL: 4
		},
		ElementType: {
		    NORMAL: 1,
		    TEXT: 3,
		    CDATA: 4,
		    FRAGMENT: 11
		},
		TIMEOUT: 1.1,
		SECONDARY_TIMEOUT: 0.1,
		addNamespace: function(name, value) {
		    Strophe.NS[name] = value
		},
		forEachChild: function(elem, elemName, func) {
		    var i, childNode;
		    for (i = 0; i < elem.childNodes.length; i++) {
			childNode = elem.childNodes[i];
			if (childNode.nodeType == Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
			    func(childNode)
			}
		    }
		},
		isTagEqual: function(el, name) {
		    return el.tagName.toLowerCase() == name.toLowerCase()
		},
		_xmlGenerator: null,
		_makeGenerator: function() {
		    var doc;
		    if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
			doc = this._getIEXmlDom();
			doc.appendChild(doc.createElement("strophe"))
		    } else {
			doc = document.implementation.createDocument("jabber:client", "strophe", null)
		    }
		    return doc
		},
		xmlGenerator: function() {
		    if (!Strophe._xmlGenerator) {
			Strophe._xmlGenerator = Strophe._makeGenerator()
		    }
		    return Strophe._xmlGenerator
		},
		_getIEXmlDom: function() {
		    var doc = null;
		    var docStrings = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
		    for (var d = 0; d < docStrings.length; d++) {
			if (doc === null) {
			    try {
				doc = new ActiveXObject(docStrings[d])
			    } catch (e) {
				doc = null
			    }
			} else {
			    break
			}
		    }
		    return doc
		},
		xmlElement: function(name) {
		    if (!name) {
			return null
		    }
		    var node = Strophe.xmlGenerator().createElement(name);
		    var a, i, k;
		    for (a = 1; a < arguments.length; a++) {
			if (!arguments[a]) {
			    continue
			}
			if (typeof(arguments[a]) == "string" || typeof(arguments[a]) == "number") {
			    node.appendChild(Strophe.xmlTextNode(arguments[a]))
			} else {
			    if (typeof(arguments[a]) == "object" && typeof(arguments[a].sort) == "function") {
				for (i = 0; i < arguments[a].length; i++) {
				    if (typeof(arguments[a][i]) == "object" && typeof(arguments[a][i].sort) == "function") {
					node.setAttribute(arguments[a][i][0], arguments[a][i][1])
				    }
				}
			    } else {
				if (typeof(arguments[a]) == "object") {
				    for (k in arguments[a]) {
					if (arguments[a].hasOwnProperty(k)) {
					    node.setAttribute(k, arguments[a][k])
					}
				    }
				}
			    }
			}
		    }
		    return node
		},
		xmlescape: function(text) {
		    text = text.replace(/\&/g, "&amp;");
		    text = text.replace(/</g, "&lt;");
		    text = text.replace(/>/g, "&gt;");
		    text = text.replace(/'/g, "&apos;");
		    text = text.replace(/"/g, "&quot;");
		    return text
		},
		xmlTextNode: function(text) {
		    return Strophe.xmlGenerator().createTextNode(text)
		},
		xmlHtmlNode: function(html) {
		    var node;
		    if (window.DOMParser) {
			var parser = new DOMParser();
			node = parser.parseFromString(html, "text/xml")
		    } else {
			node = new ActiveXObject("Microsoft.XMLDOM");
			node.async = "false";
			node.loadXML(html)
		    }
		    return node
		},
		getText: function(elem) {
		    if (!elem) {
			return null
		    }
		    var str = "";
		    if (elem.childNodes.length === 0 && elem.nodeType == Strophe.ElementType.TEXT) {
			str += elem.nodeValue
		    }
		    for (var i = 0; i < elem.childNodes.length; i++) {
			if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
			    str += elem.childNodes[i].nodeValue
			}
		    }
		    return Strophe.xmlescape(str)
		},
		copyElement: function(elem) {
		    var i, el;
		    if (elem.nodeType == Strophe.ElementType.NORMAL) {
			el = Strophe.xmlElement(elem.tagName);
			for (i = 0; i < elem.attributes.length; i++) {
			    el.setAttribute(elem.attributes[i].nodeName.toLowerCase(), elem.attributes[i].value)
			}
			for (i = 0; i < elem.childNodes.length; i++) {
			    el.appendChild(Strophe.copyElement(elem.childNodes[i]))
			}
		    } else {
			if (elem.nodeType == Strophe.ElementType.TEXT) {
			    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue)
			}
		    }
		    return el
		},
		createHtml: function(elem) {
		    var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
		    if (elem.nodeType == Strophe.ElementType.NORMAL) {
			tag = elem.nodeName.toLowerCase();
			if (Strophe.XHTML.validTag(tag)) {
			    try {
				el = Strophe.xmlElement(tag);
				for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
				    attribute = Strophe.XHTML.attributes[tag][i];
				    value = elem.getAttribute(attribute);
				    if (typeof value == "undefined" || value === null || value === "" || value === false || value === 0) {
					continue
				    }
				    if (attribute == "style" && typeof value == "object") {
					if (typeof value.cssText != "undefined") {
					    value = value.cssText
					}
				    }
				    if (attribute == "style") {
					css = [];
					cssAttrs = value.split(";");
					for (j = 0; j < cssAttrs.length; j++) {
					    attr = cssAttrs[j].split(":");
					    cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
					    if (Strophe.XHTML.validCSS(cssName)) {
						cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
						css.push(cssName + ": " + cssValue)
					    }
					}
					if (css.length > 0) {
					    value = css.join("; ");
					    el.setAttribute(attribute, value)
					}
				    } else {
					el.setAttribute(attribute, value)
				    }
				}
				for (i = 0; i < elem.childNodes.length; i++) {
				    el.appendChild(Strophe.createHtml(elem.childNodes[i]))
				}
			    } catch (e) {
				el = Strophe.xmlTextNode("")
			    }
			} else {
			    el = Strophe.xmlGenerator().createDocumentFragment();
			    for (i = 0; i < elem.childNodes.length; i++) {
				el.appendChild(Strophe.createHtml(elem.childNodes[i]))
			    }
			}
		    } else {
			if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
			    el = Strophe.xmlGenerator().createDocumentFragment();
			    for (i = 0; i < elem.childNodes.length; i++) {
				el.appendChild(Strophe.createHtml(elem.childNodes[i]))
			    }
			} else {
			    if (elem.nodeType == Strophe.ElementType.TEXT) {
				el = Strophe.xmlTextNode(elem.nodeValue)
			    }
			}
		    }
		    return el
		},
		escapeNode: function(node) {
		    return node.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
		},
		unescapeNode: function(node) {
		    return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
		},
		getNodeFromJid: function(jid) {
		    if (jid.indexOf("@") < 0) {
			return null
		    }
		    return jid.split("@")[0]
		},
		getDomainFromJid: function(jid) {
		    var bare = Strophe.getBareJidFromJid(jid);
		    if (bare.indexOf("@") < 0) {
			return bare
		    } else {
			var parts = bare.split("@");
			parts.splice(0, 1);
			return parts.join("@")
		    }
		},
		getResourceFromJid: function(jid) {
		    var s = jid.split("/");
		    if (s.length < 2) {
			return null
		    }
		    s.splice(0, 1);
		    return s.join("/")
		},
		getBareJidFromJid: function(jid) {
		    return jid ? jid.split("/")[0] : null
		},
		log: function(level, msg) {
		    return
		},
		debug: function(msg) {
		    this.log(this.LogLevel.DEBUG, msg)
		},
		info: function(msg) {
		    this.log(this.LogLevel.INFO, msg)
		},
		warn: function(msg) {
		    this.log(this.LogLevel.WARN, msg)
		},
		error: function(msg) {
		    this.log(this.LogLevel.ERROR, msg)
		},
		fatal: function(msg) {
		    this.log(this.LogLevel.FATAL, msg)
		},
		serialize: function(elem) {
		    var result;
		    if (!elem) {
			return null
		    }
		    if (typeof(elem.tree) === "function") {
			elem = elem.tree()
		    }
		    var nodeName = elem.nodeName;
		    var i, child;
		    if (elem.getAttribute("_realname")) {
			nodeName = elem.getAttribute("_realname")
		    }
		    result = "<" + nodeName;
		    for (i = 0; i < elem.attributes.length; i++) {
			if (elem.attributes[i].nodeName != "_realname") {
			    result += " " + elem.attributes[i].nodeName.toLowerCase() + "='" + elem.attributes[i].value.replace(/&/g, "&amp;").replace(/\'/g, "&apos;").replace(/>/g, "&gt;").replace(/</g, "&lt;") + "'"
			}
		    }
		    if (elem.childNodes.length > 0) {
			result += ">";
			for (i = 0; i < elem.childNodes.length; i++) {
			    child = elem.childNodes[i];
			    switch (child.nodeType) {
				case Strophe.ElementType.NORMAL:
				    result += Strophe.serialize(child);
				    break;
				case Strophe.ElementType.TEXT:
				    result += Strophe.xmlescape(child.nodeValue);
				    break;
				case Strophe.ElementType.CDATA:
				    result += "<![CDATA[" + child.nodeValue + "]]>"
			    }
			}
			result += "</" + nodeName + ">"
		    } else {
			result += "/>"
		    }
		    return result
		},
		_requestId: 0,
		_connectionPlugins: {},
		addConnectionPlugin: function(name, ptype) {
		    Strophe._connectionPlugins[name] = ptype
		}
	    };
	    Strophe.Builder = function(name, attrs) {
		if (name == "presence" || name == "message" || name == "iq") {
		    if (attrs && !attrs.xmlns) {
			attrs.xmlns = Strophe.NS.CLIENT
		    } else {
			if (!attrs) {
			    attrs = {
				xmlns: Strophe.NS.CLIENT
			    }
			}
		    }
		}
		this.nodeTree = Strophe.xmlElement(name, attrs);
		this.node = this.nodeTree
	    };
	    Strophe.Builder.prototype = {
		tree: function() {
		    return this.nodeTree
		},
		toString: function() {
		    return Strophe.serialize(this.nodeTree)
		},
		up: function() {
		    this.node = this.node.parentNode;
		    return this
		},
		attrs: function(moreattrs) {
		    for (var k in moreattrs) {
			if (moreattrs.hasOwnProperty(k)) {
			    this.node.setAttribute(k, moreattrs[k])
			}
		    }
		    return this
		},
		c: function(name, attrs, text) {
		    var child = Strophe.xmlElement(name, attrs, text);
		    this.node.appendChild(child);
		    if (!text) {
			this.node = child
		    }
		    return this
		},
		cnode: function(elem) {
		    var impNode;
		    var xmlGen = Strophe.xmlGenerator();
		    try {
			impNode = (xmlGen.importNode !== undefined)
		    } catch (e) {
			impNode = false
		    }
		    var newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);
		    this.node.appendChild(newElem);
		    this.node = newElem;
		    return this
		},
		t: function(text) {
		    var child = Strophe.xmlTextNode(text);
		    this.node.appendChild(child);
		    return this
		},
		h: function(html) {
		    var fragment = document.createElement("body");
		    fragment.innerHTML = html;
		    var xhtml = Strophe.createHtml(fragment);
		    while (xhtml.childNodes.length > 0) {
			this.node.appendChild(xhtml.childNodes[0])
		    }
		    return this
		}
	    };
	    Strophe.Handler = function(handler, ns, name, type, id, from, options) {
		this.handler = handler;
		this.ns = ns;
		this.name = name;
		this.type = type;
		this.id = id;
		this.options = options || {
		    matchBare: false
		};
		if (!this.options.matchBare) {
		    this.options.matchBare = false
		}
		if (this.options.matchBare) {
		    this.from = from ? Strophe.getBareJidFromJid(from) : null
		} else {
		    this.from = from
		}
		this.user = true
	    };
	    Strophe.Handler.prototype = {
		isMatch: function(elem) {
		    var nsMatch;
		    var from = null;
		    if (this.options.matchBare) {
			from = Strophe.getBareJidFromJid(elem.getAttribute("from"))
		    } else {
			from = elem.getAttribute("from")
		    }
		    nsMatch = false;
		    if (!this.ns) {
			nsMatch = true
		    } else {
			var that = this;
			Strophe.forEachChild(elem, null, function(elem) {
			    if (elem.getAttribute("xmlns") == that.ns) {
				nsMatch = true
			    }
			});
			nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns
		    }
		    if (nsMatch && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || elem.getAttribute("type") == this.type) && (!this.id || elem.getAttribute("id") == this.id) && (!this.from || from == this.from)) {
			return true
		    }
		    return false
		},
		run: function(elem) {
		    var result = null;
		    try {
			result = this.handler(elem)
		    } catch (e) {
			if (e.sourceURL) {
			    Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message)
			} else {
			    if (e.fileName) {
				if (typeof(console) != "undefined") {
				    console.trace();
				    console.error(this.handler, " - error - ", e, e.message)
				}
				Strophe.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message)
			    } else {
				Strophe.fatal("error: " + e.message + "\n" + e.stack)
			    }
			}
			throw e
		    }
		    return result
		},
		toString: function() {
		    return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
		}
	    };
	    Strophe.TimedHandler = function(period, handler) {
		this.period = period;
		this.handler = handler;
		this.lastCalled = new Date().getTime();
		this.user = true
	    };
	    Strophe.TimedHandler.prototype = {
		run: function() {
		    this.lastCalled = new Date().getTime();
		    return this.handler()
		},
		reset: function() {
		    this.lastCalled = new Date().getTime()
		},
		toString: function() {
		    return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
		}
	    };
	    Strophe.Connection = function(service, options) {
		this.service = service;
		this.options = options || {};
		var proto = this.options.protocol || "";
		if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
		    this._proto = new Strophe.Websocket(this)
		} else {
		    this._proto = new Strophe.Bosh(this)
		}
		this.jid = "";
		this.domain = null;
		this.features = null;
		this._sasl_data = {};
		this.do_session = false;
		this.do_bind = false;
		this.timedHandlers = [];
		this.handlers = [];
		this.removeTimeds = [];
		this.removeHandlers = [];
		this.addTimeds = [];
		this.addHandlers = [];
		this._authentication = {};
		this._idleTimeout = null;
		this._disconnectTimeout = null;
		this.do_authentication = true;
		this.authenticated = false;
		this.disconnecting = false;
		this.connected = false;
		this.errors = 0;
		this.paused = false;
		this._data = [];
		this._uniqueId = 0;
		this._sasl_success_handler = null;
		this._sasl_failure_handler = null;
		this._sasl_challenge_handler = null;
		this.maxRetries = 5;
		this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
		for (var k in Strophe._connectionPlugins) {
		    if (Strophe._connectionPlugins.hasOwnProperty(k)) {
			var ptype = Strophe._connectionPlugins[k];
			var F = function() {};
			F.prototype = ptype;
			this[k] = new F();
			this[k].init(this)
		    }
		}
	    };
	    Strophe.Connection.prototype = {
		reset: function() {
		    this._proto._reset();
		    this.do_session = false;
		    this.do_bind = false;
		    this.timedHandlers = [];
		    this.handlers = [];
		    this.removeTimeds = [];
		    this.removeHandlers = [];
		    this.addTimeds = [];
		    this.addHandlers = [];
		    this._authentication = {};
		    this.authenticated = false;
		    this.disconnecting = false;
		    this.connected = false;
		    this.errors = 0;
		    this._requests = [];
		    this._uniqueId = 0
		},
		pause: function() {
		    this.paused = true
		},
		resume: function() {
		    this.paused = false
		},
		getUniqueId: function(suffix) {
		    if (typeof(suffix) == "string" || typeof(suffix) == "number") {
			return ++this._uniqueId + ":" + suffix
		    } else {
			return ++this._uniqueId + ""
		    }
		},
		connect: function(jid, pass, callback, wait, hold, route) {
		    this.jid = jid;
		    this.authzid = Strophe.getBareJidFromJid(this.jid);
		    this.authcid = Strophe.getNodeFromJid(this.jid);
		    this.pass = pass;
		    this.servtype = "xmpp";
		    this.connect_callback = callback;
		    this.disconnecting = false;
		    this.connected = false;
		    this.authenticated = false;
		    this.errors = 0;
		    this.domain = Strophe.getDomainFromJid(this.jid);
		    this._changeConnectStatus(Strophe.Status.CONNECTING, null);
		    this._proto._connect(wait, hold, route)
		},
		attach: function(jid, sid, rid, callback, wait, hold, wind) {
		    this._proto._attach(jid, sid, rid, callback, wait, hold, wind)
		},
		xmlInput: function(elem) {
		    return
		},
		xmlOutput: function(elem) {
		    return
		},
		rawInput: function(data) {
		    return
		},
		rawOutput: function(data) {
		    return
		},
		send: function(elem) {
		    if (elem === null) {
			return
		    }
		    if (typeof(elem.sort) === "function") {
			for (var i = 0; i < elem.length; i++) {
			    this._queueData(elem[i])
			}
		    } else {
			if (typeof(elem.tree) === "function") {
			    this._queueData(elem.tree())
			} else {
			    this._queueData(elem)
			}
		    }
		    this._proto._send()
		},
		flush: function() {
		    clearTimeout(this._idleTimeout);
		    this._onIdle()
		},
		sendIQ: function(elem, callback, errback, timeout) {
		    var timeoutHandler = null;
		    var that = this;
		    if (typeof(elem.tree) === "function") {
			elem = elem.tree()
		    }
		    var id = elem.getAttribute("id");
		    if (!id) {
			id = this.getUniqueId("sendIQ");
			elem.setAttribute("id", id)
		    }
		    var handler = this.addHandler(function(stanza) {
			if (timeoutHandler) {
			    that.deleteTimedHandler(timeoutHandler)
			}
			var iqtype = stanza.getAttribute("type");
			if (iqtype == "result") {
			    if (callback) {
				callback(stanza)
			    }
			} else {
			    if (iqtype == "error") {
				if (errback) {
				    errback(stanza)
				}
			    } else {
				throw {
				    name: "StropheError",
				    message: "Got bad IQ type of " + iqtype
				}
			    }
			}
		    }, null, "iq", null, id);
		    if (timeout) {
			timeoutHandler = this.addTimedHandler(timeout, function() {
			    that.deleteHandler(handler);
			    if (errback) {
				errback(null)
			    }
			    return false
			})
		    }
		    this.send(elem);
		    return id
		},
		_queueData: function(element) {
		    if (element === null || !element.tagName || !element.childNodes) {
			throw {
			    name: "StropheError",
			    message: "Cannot queue non-DOMElement."
			}
		    }
		    this._data.push(element)
		},
		_sendRestart: function() {
		    this._data.push("restart");
		    this._proto._sendRestart();
		    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100)
		},
		addTimedHandler: function(period, handler) {
		    var thand = new Strophe.TimedHandler(period, handler);
		    this.addTimeds.push(thand);
		    return thand
		},
		deleteTimedHandler: function(handRef) {
		    this.removeTimeds.push(handRef)
		},
		addHandler: function(handler, ns, name, type, id, from, options) {
		    var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
		    this.addHandlers.push(hand);
		    return hand
		},
		deleteHandler: function(handRef) {
		    this.removeHandlers.push(handRef)
		},
		disconnect: function(reason) {
		    this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
		    Strophe.info("Disconnect was called because: " + reason);
		    if (this.connected) {
			var pres = false;
			this.disconnecting = true;
			if (this.authenticated) {
			    pres = $pres({
				xmlns: Strophe.NS.CLIENT,
				type: "unavailable"
			    })
			}
			this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));
			this._proto._disconnect(pres)
		    }
		},
		_changeConnectStatus: function(status, condition) {
		    for (var k in Strophe._connectionPlugins) {
			if (Strophe._connectionPlugins.hasOwnProperty(k)) {
			    var plugin = this[k];
			    if (plugin.statusChanged) {
				try {
				    plugin.statusChanged(status, condition)
				} catch (err) {
				    Strophe.error("" + k + " plugin caused an exception changing status: " + err)
				}
			    }
			}
		    }
		    if (this.connect_callback) {
			try {
			    this.connect_callback(status, condition)
			} catch (e) {
			    Strophe.error("User connection callback caused an exception: " + e)
			}
		    }
		},
		_doDisconnect: function() {
		    if (this._disconnectTimeout !== null) {
			this.deleteTimedHandler(this._disconnectTimeout);
			this._disconnectTimeout = null
		    }
		    Strophe.info("_doDisconnect was called");
		    this._proto._doDisconnect();
		    this.authenticated = false;
		    this.disconnecting = false;
		    this.handlers = [];
		    this.timedHandlers = [];
		    this.removeTimeds = [];
		    this.removeHandlers = [];
		    this.addTimeds = [];
		    this.addHandlers = [];
		    this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
		    this.connected = false
		},
		_dataRecv: function(req, raw) {
		    Strophe.info("_dataRecv called");
		    var elem = this._proto._reqToData(req);
		    if (elem === null) {
			return
		    }
		    if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
			if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
			    this.xmlInput(elem.childNodes[0])
			} else {
			    this.xmlInput(elem)
			}
		    }
		    if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
			if (raw) {
			    this.rawInput(raw)
			} else {
			    this.rawInput(Strophe.serialize(elem))
			}
		    }
		    var i, hand;
		    while (this.removeHandlers.length > 0) {
			hand = this.removeHandlers.pop();
			i = this.handlers.indexOf(hand);
			if (i >= 0) {
			    this.handlers.splice(i, 1)
			}
		    }
		    while (this.addHandlers.length > 0) {
			this.handlers.push(this.addHandlers.pop())
		    }
		    if (this.disconnecting && this._proto._emptyQueue()) {
			this._doDisconnect();
			return
		    }
		    var typ = elem.getAttribute("type");
		    var cond, conflict;
		    if (typ !== null && typ == "terminate") {
			if (this.disconnecting) {
			    return
			}
			cond = elem.getAttribute("condition");
			conflict = elem.getElementsByTagName("conflict");
			if (cond !== null) {
			    if (cond == "remote-stream-error" && conflict.length > 0) {
				cond = "conflict"
			    }
			    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
			} else {
			    this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
			}
			this.disconnect("unknown stream-error");
			return
		    }
		    var that = this;
		    Strophe.forEachChild(elem, null, function(child) {
			var i, newList;
			newList = that.handlers;
			that.handlers = [];
			for (i = 0; i < newList.length; i++) {
			    var hand = newList[i];
			    try {
				if (hand.isMatch(child) && (that.authenticated || !hand.user)) {
				    if (hand.run(child)) {
					that.handlers.push(hand)
				    }
				} else {
				    that.handlers.push(hand)
				}
			    } catch (e) {
				Strophe.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
			    }
			}
		    })
		},
		mechanisms: {},
		_connect_cb: function(req, _callback, raw) {
		    Strophe.info("_connect_cb was called");
		    this.connected = true;
		    var bodyWrap = this._proto._reqToData(req);
		    if (!bodyWrap) {
			return
		    }
		    if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
			if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
			    this.xmlInput(bodyWrap.childNodes[0])
			} else {
			    this.xmlInput(bodyWrap)
			}
		    }
		    if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
			if (raw) {
			    this.rawInput(raw)
			} else {
			    this.rawInput(Strophe.serialize(bodyWrap))
			}
		    }
		    var conncheck = this._proto._connect_cb(bodyWrap);
		    if (conncheck === Strophe.Status.CONNFAIL) {
			return
		    }
		    this._authentication.sasl_scram_sha1 = false;
		    this._authentication.sasl_plain = false;
		    this._authentication.sasl_digest_md5 = false;
		    this._authentication.sasl_anonymous = false;
		    this._authentication.legacy_auth = false;
		    var hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0;
		    if (!hasFeatures) {
			hasFeatures = bodyWrap.getElementsByTagName("features").length > 0
		    }
		    var mechanisms = bodyWrap.getElementsByTagName("mechanism");
		    var matched = [];
		    var i, mech, found_authentication = false;
		    if (!hasFeatures) {
			this._proto._no_auth_received(_callback);
			return
		    }
		    if (mechanisms.length > 0) {
			for (i = 0; i < mechanisms.length; i++) {
			    mech = Strophe.getText(mechanisms[i]);
			    if (this.mechanisms[mech]) {
				matched.push(this.mechanisms[mech])
			    }
			}
		    }
		    this._authentication.legacy_auth = bodyWrap.getElementsByTagName("auth").length > 0;
		    found_authentication = this._authentication.legacy_auth || matched.length > 0;
		    if (!found_authentication) {
			this._proto._no_auth_received(_callback);
			return
		    }
		    if (this.do_authentication !== false) {
			this.authenticate(matched)
		    }
		},
		authenticate: function(matched) {
		    var i;
		    for (i = 0; i < matched.length - 1; ++i) {
			var higher = i;
			for (var j = i + 1; j < matched.length; ++j) {
			    if (matched[j].prototype.priority > matched[higher].prototype.priority) {
				higher = j
			    }
			}
			if (higher != i) {
			    var swap = matched[i];
			    matched[i] = matched[higher];
			    matched[higher] = swap
			}
		    }
		    var mechanism_found = false;
		    for (i = 0; i < matched.length; ++i) {
			if (!matched[i].test(this)) {
			    continue
			}
			this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
			this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
			this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null);
			this._sasl_mechanism = new matched[i]();
			this._sasl_mechanism.onStart(this);
			var request_auth_exchange = $build("auth", {
			    xmlns: Strophe.NS.SASL,
			    mechanism: this._sasl_mechanism.name
			});
			if (this._sasl_mechanism.isClientFirst) {
			    var response = this._sasl_mechanism.onChallenge(this, null);
			    request_auth_exchange.t(Base64.encode(response))
			}
			this.send(request_auth_exchange.tree());
			mechanism_found = true;
			break
		    }
		    if (!mechanism_found) {
			if (Strophe.getNodeFromJid(this.jid) === null) {
			    this._changeConnectStatus(Strophe.Status.CONNFAIL, "x-strophe-bad-non-anon-jid");
			    this.disconnect("x-strophe-bad-non-anon-jid")
			} else {
			    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
			    this._addSysHandler(this._auth1_cb.bind(this), null, null, null, "_auth_1");
			    this.send($iq({
				type: "get",
				to: this.domain,
				id: "_auth_1"
			    }).c("query", {
				xmlns: Strophe.NS.AUTH
			    }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree())
			}
		    }
		},
		_sasl_challenge_cb: function(elem) {
		    var challenge = Base64.decode(Strophe.getText(elem));
		    var response = this._sasl_mechanism.onChallenge(this, challenge);
		    var stanza = $build("response", {
			xmlns: Strophe.NS.SASL
		    });
		    if (response !== "") {
			stanza.t(Base64.encode(response))
		    }
		    this.send(stanza.tree());
		    return true
		},
		_auth1_cb: function(elem) {
		    var iq = $iq({
			type: "set",
			id: "_auth_2"
		    }).c("query", {
			xmlns: Strophe.NS.AUTH
		    }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
		    if (!Strophe.getResourceFromJid(this.jid)) {
			this.jid = Strophe.getBareJidFromJid(this.jid) + "/strophe"
		    }
		    iq.up().c("resource", {}).t(Strophe.getResourceFromJid(this.jid));
		    this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
		    this.send(iq.tree());
		    return false
		},
		_sasl_success_cb: function(elem) {
		    if (this._sasl_data["server-signature"]) {
			var serverSignature;
			var success = Base64.decode(Strophe.getText(elem));
			var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
			var matches = success.match(attribMatch);
			if (matches[1] == "v") {
			    serverSignature = matches[2]
			}
			if (serverSignature != this._sasl_data["server-signature"]) {
			    this.deleteHandler(this._sasl_failure_handler);
			    this._sasl_failure_handler = null;
			    if (this._sasl_challenge_handler) {
				this.deleteHandler(this._sasl_challenge_handler);
				this._sasl_challenge_handler = null
			    }
			    this._sasl_data = {};
			    return this._sasl_failure_cb(null)
			}
		    }
		    Strophe.info("SASL authentication succeeded.");
		    if (this._sasl_mechanism) {
			this._sasl_mechanism.onSuccess()
		    }
		    this.deleteHandler(this._sasl_failure_handler);
		    this._sasl_failure_handler = null;
		    if (this._sasl_challenge_handler) {
			this.deleteHandler(this._sasl_challenge_handler);
			this._sasl_challenge_handler = null
		    }
		    this._addSysHandler(this._sasl_auth1_cb.bind(this), null, "stream:features", null, null);
		    this._sendRestart();
		    return false
		},
		_sasl_auth1_cb: function(elem) {
		    this.features = elem;
		    var i, child;
		    for (i = 0; i < elem.childNodes.length; i++) {
			child = elem.childNodes[i];
			if (child.nodeName == "bind") {
			    this.do_bind = true
			}
			if (child.nodeName == "session") {
			    this.do_session = true
			}
		    }
		    if (!this.do_bind) {
			this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
			return false
		    } else {
			this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, "_bind_auth_2");
			var resource = Strophe.getResourceFromJid(this.jid);
			if (resource) {
			    this.send($iq({
				type: "set",
				id: "_bind_auth_2"
			    }).c("bind", {
				xmlns: Strophe.NS.BIND
			    }).c("resource", {}).t(resource).tree())
			} else {
			    this.send($iq({
				type: "set",
				id: "_bind_auth_2"
			    }).c("bind", {
				xmlns: Strophe.NS.BIND
			    }).tree())
			}
		    }
		    return false
		},
		_sasl_bind_cb: function(elem) {
		    if (elem.getAttribute("type") == "error") {
			Strophe.info("SASL binding failed.");
			var conflict = elem.getElementsByTagName("conflict"),
			    condition;
			if (conflict.length > 0) {
			    condition = "conflict"
			}
			this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
			return false
		    }
		    var bind = elem.getElementsByTagName("bind");
		    var jidNode;
		    if (bind.length > 0) {
			jidNode = bind[0].getElementsByTagName("jid");
			if (jidNode.length > 0) {
			    this.jid = Strophe.getText(jidNode[0]);
			    if (this.do_session) {
				this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, "_session_auth_2");
				this.send($iq({
				    type: "set",
				    id: "_session_auth_2"
				}).c("session", {
				    xmlns: Strophe.NS.SESSION
				}).tree())
			    } else {
				this.authenticated = true;
				this._changeConnectStatus(Strophe.Status.CONNECTED, null)
			    }
			}
		    } else {
			Strophe.info("SASL binding failed.");
			this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
			return false
		    }
		},
		_sasl_session_cb: function(elem) {
		    if (elem.getAttribute("type") == "result") {
			this.authenticated = true;
			this._changeConnectStatus(Strophe.Status.CONNECTED, null)
		    } else {
			if (elem.getAttribute("type") == "error") {
			    Strophe.info("Session creation failed.");
			    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
			    return false
			}
		    }
		    return false
		},
		_sasl_failure_cb: function(elem) {
		    if (this._sasl_success_handler) {
			this.deleteHandler(this._sasl_success_handler);
			this._sasl_success_handler = null
		    }
		    if (this._sasl_challenge_handler) {
			this.deleteHandler(this._sasl_challenge_handler);
			this._sasl_challenge_handler = null
		    }
		    if (this._sasl_mechanism) {
			this._sasl_mechanism.onFailure()
		    }
		    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
		    return false
		},
		_auth2_cb: function(elem) {
		    if (elem.getAttribute("type") == "result") {
			this.authenticated = true;
			this._changeConnectStatus(Strophe.Status.CONNECTED, null)
		    } else {
			if (elem.getAttribute("type") == "error") {
			    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
			    this.disconnect("authentication failed")
			}
		    }
		    return false
		},
		_addSysTimedHandler: function(period, handler) {
		    var thand = new Strophe.TimedHandler(period, handler);
		    thand.user = false;
		    this.addTimeds.push(thand);
		    return thand
		},
		_addSysHandler: function(handler, ns, name, type, id) {
		    var hand = new Strophe.Handler(handler, ns, name, type, id);
		    hand.user = false;
		    this.addHandlers.push(hand);
		    return hand
		},
		_onDisconnectTimeout: function() {
		    Strophe.info("_onDisconnectTimeout was called");
		    this._proto._onDisconnectTimeout();
		    this._doDisconnect();
		    return false
		},
		_onIdle: function() {
		    var i, thand, since, newList;
		    while (this.addTimeds.length > 0) {
			this.timedHandlers.push(this.addTimeds.pop())
		    }
		    while (this.removeTimeds.length > 0) {
			thand = this.removeTimeds.pop();
			i = this.timedHandlers.indexOf(thand);
			if (i >= 0) {
			    this.timedHandlers.splice(i, 1)
			}
		    }
		    var now = new Date().getTime();
		    newList = [];
		    for (i = 0; i < this.timedHandlers.length; i++) {
			thand = this.timedHandlers[i];
			if (this.authenticated || !thand.user) {
			    since = thand.lastCalled + thand.period;
			    if (since - now <= 0) {
				if (thand.run()) {
				    newList.push(thand)
				}
			    } else {
				newList.push(thand)
			    }
			}
		    }
		    this.timedHandlers = newList;
		    clearTimeout(this._idleTimeout);
		    this._proto._onIdle();
		    if (this.connected) {
			this._idleTimeout = setTimeout(this._onIdle.bind(this), 100)
		    }
		}
	    };
	    if (callback) {
		callback(Strophe, $build, $msg, $iq, $pres)
	    }
	    Strophe.SASLMechanism = function(name, isClientFirst, priority) {
		this.name = name;
		this.isClientFirst = isClientFirst;
		this.priority = priority
	    };
	    Strophe.SASLMechanism.prototype = {
		test: function(connection) {
		    return true
		},
		onStart: function(connection) {
		    this._connection = connection
		},
		onChallenge: function(connection, challenge) {
		    throw new Error("You should implement challenge handling!")
		},
		onFailure: function() {
		    this._connection = null
		},
		onSuccess: function() {
		    this._connection = null
		}
	    };
	    Strophe.SASLAnonymous = function() {};
	    Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);
	    Strophe.SASLAnonymous.test = function(connection) {
		return connection.authcid === null
	    };
	    Strophe.Connection.prototype.mechanisms[Strophe.SASLAnonymous.prototype.name] = Strophe.SASLAnonymous;
	    Strophe.SASLPlain = function() {};
	    Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);
	    Strophe.SASLPlain.test = function(connection) {
		return connection.authcid !== null
	    };
	    Strophe.SASLPlain.prototype.onChallenge = function(connection) {
		var auth_str = connection.authzid;
		auth_str = auth_str + "\u0000";
		auth_str = auth_str + connection.authcid;
		auth_str = auth_str + "\u0000";
		auth_str = auth_str + connection.pass;
		return auth_str
	    };
	    Strophe.Connection.prototype.mechanisms[Strophe.SASLPlain.prototype.name] = Strophe.SASLPlain;
	    Strophe.SASLSHA1 = function() {};
	    Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);
	    Strophe.SASLSHA1.test = function(connection) {
		return connection.authcid !== null
	    };
	    Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
		var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
		var auth_str = "n=" + connection.authcid;
		auth_str += ",r=";
		auth_str += cnonce;
		connection._sasl_data.cnonce = cnonce;
		connection._sasl_data["client-first-message-bare"] = auth_str;
		auth_str = "n,," + auth_str;
		this.onChallenge = function(connection, challenge) {
		    var nonce, salt, iter, Hi, U, U_old, i, k;
		    var clientKey, serverKey, clientSignature;
		    var responseText = "c=biws,";
		    var authMessage = connection._sasl_data["client-first-message-bare"] + "," + challenge + ",";
		    var cnonce = connection._sasl_data.cnonce;
		    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
		    while (challenge.match(attribMatch)) {
			var matches = challenge.match(attribMatch);
			challenge = challenge.replace(matches[0], "");
			switch (matches[1]) {
			    case "r":
				nonce = matches[2];
				break;
			    case "s":
				salt = matches[2];
				break;
			    case "i":
				iter = matches[2];
				break
			}
		    }
		    if (nonce.substr(0, cnonce.length) !== cnonce) {
			connection._sasl_data = {};
			return connection._sasl_failure_cb()
		    }
		    responseText += "r=" + nonce;
		    authMessage += responseText;
		    salt = Base64.decode(salt);
		    salt += "\x00\x00\x00\x01";
		    Hi = U_old = core_hmac_sha1(connection.pass, salt);
		    for (i = 1; i < iter; i++) {
			U = core_hmac_sha1(connection.pass, binb2str(U_old));
			for (k = 0; k < 5; k++) {
			    Hi[k] ^= U[k]
			}
			U_old = U
		    }
		    Hi = binb2str(Hi);
		    clientKey = core_hmac_sha1(Hi, "Client Key");
		    serverKey = str_hmac_sha1(Hi, "Server Key");
		    clientSignature = core_hmac_sha1(str_sha1(binb2str(clientKey)), authMessage);
		    connection._sasl_data["server-signature"] = b64_hmac_sha1(serverKey, authMessage);
		    for (k = 0; k < 5; k++) {
			clientKey[k] ^= clientSignature[k]
		    }
		    responseText += ",p=" + Base64.encode(binb2str(clientKey));
		    return responseText
		}.bind(this);
		return auth_str
	    };
	    Strophe.Connection.prototype.mechanisms[Strophe.SASLSHA1.prototype.name] = Strophe.SASLSHA1;
	    Strophe.SASLMD5 = function() {};
	    Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);
	    Strophe.SASLMD5.test = function(connection) {
		return connection.authcid !== null
	    };
	    Strophe.SASLMD5.prototype._quote = function(str) {
		return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
	    };
	    Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
		var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
		var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
		var realm = "";
		var host = null;
		var nonce = "";
		var qop = "";
		var matches;
		while (challenge.match(attribMatch)) {
		    matches = challenge.match(attribMatch);
		    challenge = challenge.replace(matches[0], "");
		    matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
		    switch (matches[1]) {
			case "realm":
			    realm = matches[2];
			    break;
			case "nonce":
			    nonce = matches[2];
			    break;
			case "qop":
			    qop = matches[2];
			    break;
			case "host":
			    host = matches[2];
			    break
		    }
		}
		var digest_uri = connection.servtype + "/" + connection.domain;
		if (host !== null) {
		    digest_uri = digest_uri + "/" + host
		}
		var A1 = MD5.hash(connection.authcid + ":" + realm + ":" + this._connection.pass) + ":" + nonce + ":" + cnonce;
		var A2 = "AUTHENTICATE:" + digest_uri;
		var responseText = "";
		responseText += "charset=utf-8,";
		responseText += "username=" + this._quote(connection.authcid) + ",";
		responseText += "realm=" + this._quote(realm) + ",";
		responseText += "nonce=" + this._quote(nonce) + ",";
		responseText += "nc=00000001,";
		responseText += "cnonce=" + this._quote(cnonce) + ",";
		responseText += "digest-uri=" + this._quote(digest_uri) + ",";
		responseText += "response=" + MD5.hexdigest(MD5.hexdigest(A1) + ":" + nonce + ":00000001:" + cnonce + ":auth:" + MD5.hexdigest(A2)) + ",";
		responseText += "qop=auth";
		this.onChallenge = function() {
		    return ""
		}.bind(this);
		return responseText
	    };
	    Strophe.Connection.prototype.mechanisms[Strophe.SASLMD5.prototype.name] = Strophe.SASLMD5
	})(function() {
	    window.Strophe = arguments[0];
	    window.$build = arguments[1];
	    window.$msg = arguments[2];
	    window.$iq = arguments[3];
	    window.$pres = arguments[4]
	});
	Strophe.Request = function(elem, func, rid, sends) {
	    this.id = ++Strophe._requestId;
	    this.xmlData = elem;
	    this.data = Strophe.serialize(elem);
	    this.origFunc = func;
	    this.func = func;
	    this.rid = rid;
	    this.date = NaN;
	    this.sends = sends || 0;
	    this.abort = false;
	    this.dead = null;
	    this.age = function() {
		if (!this.date) {
		    return 0
		}
		var now = new Date();
		return (now - this.date) / 1000
	    };
	    this.timeDead = function() {
		if (!this.dead) {
		    return 0
		}
		var now = new Date();
		return (now - this.dead) / 1000
	    };
	    this.xhr = this._newXHR()
	};
	Strophe.Request.prototype = {
	    getResponse: function() {
		var node = null;
		if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
		    node = this.xhr.responseXML.documentElement;
		    if (node.tagName == "parsererror") {
			Strophe.error("invalid response received");
			Strophe.error("responseText: " + this.xhr.responseText);
			Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML));
			throw "parsererror"
		    }
		} else {
		    if (this.xhr.responseText) {
			Strophe.error("invalid response received");
			Strophe.error("responseText: " + this.xhr.responseText);
			Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML))
		    }
		}
		return node
	    },
	    _newXHR: function() {
		var xhr = null;
		if (window.XMLHttpRequest) {
		    xhr = new XMLHttpRequest();
		    if (xhr.overrideMimeType) {
			xhr.overrideMimeType("text/xml")
		    }
		} else {
		    if (window.ActiveXObject) {
			xhr = new ActiveXObject("Microsoft.XMLHTTP")
		    }
		}
		xhr.onreadystatechange = this.func.bind(null, this);
		return xhr
	    }
	};
	Strophe.Bosh = function(connection) {
	    this._conn = connection;
	    this.rid = Math.floor(Math.random() * 4294967295);
	    this.sid = null;
	    this.hold = 1;
	    this.wait = 60;
	    this.window = 5;
	    this._requests = []
	};
	Strophe.Bosh.prototype = {
	    strip: null,
	    _buildBody: function() {
		var bodyWrap = $build("body", {
		    rid: this.rid++,
		    xmlns: Strophe.NS.HTTPBIND
		});
		if (this.sid !== null) {
		    bodyWrap.attrs({
			sid: this.sid
		    })
		}
		return bodyWrap
	    },
	    _reset: function() {
		this.rid = Math.floor(Math.random() * 4294967295);
		this.sid = null
	    },
	    _connect: function(wait, hold, route) {
		this.wait = wait || this.wait;
		this.hold = hold || this.hold;
		var body = this._buildBody().attrs({
		    to: this._conn.domain,
		    "xml:lang": "en",
		    wait: this.wait,
		    hold: this.hold,
		    content: "text/xml; charset=utf-8",
		    ver: "1.6",
		    "xmpp:version": "1.0",
		    "xmlns:xmpp": Strophe.NS.BOSH
		});
		if (route) {
		    body.attrs({
			route: route
		    })
		}
		var _connect_cb = this._conn._connect_cb;
		this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute("rid")));
		this._throttledRequestHandler()
	    },
	    _attach: function(jid, sid, rid, callback, wait, hold, wind) {
		this._conn.jid = jid;
		this.sid = sid;
		this.rid = rid;
		this._conn.connect_callback = callback;
		this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);
		this._conn.authenticated = true;
		this._conn.connected = true;
		this.wait = wait || this.wait;
		this.hold = hold || this.hold;
		this.window = wind || this.window;
		this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null)
	    },
	    _connect_cb: function(bodyWrap) {
		var typ = bodyWrap.getAttribute("type");
		var cond, conflict;
		if (typ !== null && typ == "terminate") {
		    Strophe.error("BOSH-Connection failed: " + cond);
		    cond = bodyWrap.getAttribute("condition");
		    conflict = bodyWrap.getElementsByTagName("conflict");
		    if (cond !== null) {
			if (cond == "remote-stream-error" && conflict.length > 0) {
			    cond = "conflict"
			}
			this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
		    } else {
			this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
		    }
		    this._conn._doDisconnect();
		    return Strophe.Status.CONNFAIL
		}
		if (!this.sid) {
		    this.sid = bodyWrap.getAttribute("sid")
		}
		var wind = bodyWrap.getAttribute("requests");
		if (wind) {
		    this.window = parseInt(wind, 10)
		}
		var hold = bodyWrap.getAttribute("hold");
		if (hold) {
		    this.hold = parseInt(hold, 10)
		}
		var wait = bodyWrap.getAttribute("wait");
		if (wait) {
		    this.wait = parseInt(wait, 10)
		}
	    },
	    _disconnect: function(pres) {
		this._sendTerminate(pres)
	    },
	    _doDisconnect: function() {
		this.sid = null;
		this.rid = Math.floor(Math.random() * 4294967295)
	    },
	    _emptyQueue: function() {
		return this._requests.length === 0
	    },
	    _hitError: function(reqStatus) {
		this.errors++;
		Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
		if (this.errors > 4) {
		    this._onDisconnectTimeout()
		}
	    },
	    _no_auth_received: function(_callback) {
		if (_callback) {
		    _callback = _callback.bind(this._conn)
		} else {
		    _callback = this._conn._connect_cb.bind(this._conn)
		}
		var body = this._buildBody();
		this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _callback.bind(this._conn)), body.tree().getAttribute("rid")));
		this._throttledRequestHandler()
	    },
	    _onDisconnectTimeout: function() {
		var req;
		while (this._requests.length > 0) {
		    req = this._requests.pop();
		    req.abort = true;
		    req.xhr.abort();
		    req.xhr.onreadystatechange = function() {}
		}
	    },
	    _onIdle: function() {
		var data = this._conn._data;
		if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
		    Strophe.info("no requests during idle cycle, sending blank request");
		    data.push(null)
		}
		if (this._requests.length < 2 && data.length > 0 && !this._conn.paused) {
		    var body = this._buildBody();
		    for (var i = 0; i < data.length; i++) {
			if (data[i] !== null) {
			    if (data[i] === "restart") {
				body.attrs({
				    to: this._conn.domain,
				    "xml:lang": "en",
				    "xmpp:restart": "true",
				    "xmlns:xmpp": Strophe.NS.BOSH
				})
			    } else {
				body.cnode(data[i]).up()
			    }
			}
		    }
		    delete this._conn._data;
		    this._conn._data = [];
		    this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid")));
		    this._processRequest(this._requests.length - 1)
		}
		if (this._requests.length > 0) {
		    var time_elapsed = this._requests[0].age();
		    if (this._requests[0].dead !== null) {
			if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
			    this._throttledRequestHandler()
			}
		    }
		    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
			Strophe.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) + " seconds since last activity");
			this._throttledRequestHandler()
		    }
		}
	    },
	    _onRequestStateChange: function(func, req) {
		Strophe.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
		if (req.abort) {
		    req.abort = false;
		    return
		}
		var reqStatus;
		if (req.xhr.readyState == 4) {
		    reqStatus = 0;
		    try {
			reqStatus = req.xhr.status
		    } catch (e) {}
		    if (typeof(reqStatus) == "undefined") {
			reqStatus = 0
		    }
		    if (this.disconnecting) {
			if (reqStatus >= 400) {
			    this._hitError(reqStatus);
			    return
			}
		    }
		    var reqIs0 = (this._requests[0] == req);
		    var reqIs1 = (this._requests[1] == req);
		    if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
			this._removeRequest(req);
			Strophe.debug("request id " + req.id + " should now be removed")
		    }
		    if (reqStatus == 200) {
			if (reqIs1 || (reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
			    this._restartRequest(0)
			}
			Strophe.debug("request id " + req.id + "." + req.sends + " got 200");
			func(req);
			this.errors = 0
		    } else {
			Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
			if (reqStatus === 0 || (reqStatus >= 400 && reqStatus < 600) || reqStatus >= 12000) {
			    this._hitError(reqStatus);
			    if (reqStatus >= 400 && reqStatus < 500) {
				this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
				this._conn._doDisconnect()
			    }
			}
		    }
		    if (!((reqStatus > 0 && reqStatus < 500) || req.sends > 5)) {
			this._throttledRequestHandler()
		    }
		}
	    },
	    _processRequest: function(i) {
		var self = this;
		var req = this._requests[i];
		var reqStatus = -1;
		try {
		    if (req.xhr.readyState == 4) {
			reqStatus = req.xhr.status
		    }
		} catch (e) {
		    Strophe.error("caught an error in _requests[" + i + "], reqStatus: " + reqStatus)
		}
		if (typeof(reqStatus) == "undefined") {
		    reqStatus = -1
		}
		if (req.sends > this.maxRetries) {
		    this._onDisconnectTimeout();
		    return
		}
		var time_elapsed = req.age();
		var primaryTimeout = (!isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
		var secondaryTimeout = (req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
		var requestCompletedWithServerError = (req.xhr.readyState == 4 && (reqStatus < 1 || reqStatus >= 500));
		if (primaryTimeout || secondaryTimeout || requestCompletedWithServerError) {
		    if (secondaryTimeout) {
			Strophe.error("Request " + this._requests[i].id + " timed out (secondary), restarting")
		    }
		    req.abort = true;
		    req.xhr.abort();
		    req.xhr.onreadystatechange = function() {};
		    this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);
		    req = this._requests[i]
		}
		if (req.xhr.readyState === 0) {
		    Strophe.debug("request id " + req.id + "." + req.sends + " posting");
		    try {
			req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true)
		    } catch (e2) {
			Strophe.error("XHR open failed.");
			if (!this._conn.connected) {
			    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "bad-service")
			}
			this._conn.disconnect();
			return
		    }
		    var sendFunc = function() {
			req.date = new Date();
			if (self._conn.options.customHeaders) {
			    var headers = self._conn.options.customHeaders;
			    for (var header in headers) {
				if (headers.hasOwnProperty(header)) {
				    req.xhr.setRequestHeader(header, headers[header])
				}
			    }
			}
			req.xhr.send(req.data)
		    };
		    if (req.sends > 1) {
			var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;
			setTimeout(sendFunc, backoff)
		    } else {
			sendFunc()
		    }
		    req.sends++;
		    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
			if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
			    this._conn.xmlOutput(req.xmlData.childNodes[0])
			} else {
			    this._conn.xmlOutput(req.xmlData)
			}
		    }
		    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
			this._conn.rawOutput(req.data)
		    }
		} else {
		    Strophe.debug("_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState)
		}
	    },
	    _removeRequest: function(req) {
		Strophe.debug("removing request");
		var i;
		for (i = this._requests.length - 1; i >= 0; i--) {
		    if (req == this._requests[i]) {
			this._requests.splice(i, 1)
		    }
		}
		req.xhr.onreadystatechange = function() {};
		this._throttledRequestHandler()
	    },
	    _restartRequest: function(i) {
		var req = this._requests[i];
		if (req.dead === null) {
		    req.dead = new Date()
		}
		this._processRequest(i)
	    },
	    _reqToData: function(req) {
		try {
		    return req.getResponse()
		} catch (e) {
		    if (e != "parsererror") {
			throw e
		    }
		    this._conn.disconnect("strophe-parsererror")
		}
	    },
	    _sendTerminate: function(pres) {
		Strophe.info("_sendTerminate was called");
		var body = this._buildBody().attrs({
		    type: "terminate"
		});
		if (pres) {
		    body.cnode(pres.tree())
		}
		var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid"));
		this._requests.push(req);
		this._throttledRequestHandler()
	    },
	    _send: function() {
		clearTimeout(this._conn._idleTimeout);
		this._throttledRequestHandler();
		this._conn._idleTimeout = setTimeout(this._conn._onIdle.bind(this._conn), 100)
	    },
	    _sendRestart: function() {
		this._throttledRequestHandler();
		clearTimeout(this._conn._idleTimeout)
	    },
	    _throttledRequestHandler: function() {
		if (!this._requests) {
		    Strophe.debug("_throttledRequestHandler called with undefined requests")
		} else {
		    Strophe.debug("_throttledRequestHandler called with " + this._requests.length + " requests")
		}
		if (!this._requests || this._requests.length === 0) {
		    return
		}
		if (this._requests.length > 0) {
		    this._processRequest(0)
		}
		if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
		    this._processRequest(1)
		}
	    }
	};
	Strophe.Websocket = function(connection) {
	    this._conn = connection;
	    this.strip = "stream:stream";
	    var service = connection.service;
	    if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
		var new_service = "";
		if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
		    new_service += "ws"
		} else {
		    new_service += "wss"
		}
		new_service += "://" + window.location.host;
		if (service.indexOf("/") !== 0) {
		    new_service += window.location.pathname + service
		} else {
		    new_service += service
		}
		connection.service = new_service
	    }
	};
	Strophe.Websocket.prototype = {
	    _buildStream: function() {
		return $build("stream:stream", {
		    to: this._conn.domain,
		    xmlns: Strophe.NS.CLIENT,
		    "xmlns:stream": Strophe.NS.STREAM,
		    version: "1.0"
		})
	    },
	    _check_streamerror: function(bodyWrap, connectstatus) {
		var errors = bodyWrap.getElementsByTagName("stream:error");
		if (errors.length === 0) {
		    return false
		}
		var error = errors[0];
		var condition = "";
		var text = "";
		var ns = "urn:ietf:params:xml:ns:xmpp-streams";
		for (var i = 0; i < error.childNodes.length; i++) {
		    var e = error.childNodes[i];
		    if (e.getAttribute("xmlns") !== ns) {
			break
		    }
		    if (e.nodeName === "text") {
			text = e.textContent
		    } else {
			condition = e.nodeName
		    }
		}
		var errorString = "WebSocket stream error: ";
		if (condition) {
		    errorString += condition
		} else {
		    errorString += "unknown"
		}
		if (text) {
		    errorString += " - " + condition
		}
		Strophe.error(errorString);
		this._conn._changeConnectStatus(connectstatus, condition);
		this._conn._doDisconnect();
		return true
	    },
	    _reset: function() {
		return
	    },
	    _connect: function() {
		this._closeSocket();
		this.socket = new WebSocket(this._conn.service, "xmpp");
		this.socket.onopen = this._onOpen.bind(this);
		this.socket.onerror = this._onError.bind(this);
		this.socket.onclose = this._onClose.bind(this);
		this.socket.onmessage = this._connect_cb_wrapper.bind(this)
	    },
	    _connect_cb: function(bodyWrap) {
		var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
		if (error) {
		    return Strophe.Status.CONNFAIL
		}
	    },
	    _handleStreamStart: function(message) {
		var error = false;
		var ns = message.getAttribute("xmlns");
		if (typeof ns !== "string") {
		    error = "Missing xmlns in stream:stream"
		} else {
		    if (ns !== Strophe.NS.CLIENT) {
			error = "Wrong xmlns in stream:stream: " + ns
		    }
		}
		var ns_stream = message.namespaceURI;
		if (typeof ns_stream !== "string") {
		    error = "Missing xmlns:stream in stream:stream"
		} else {
		    if (ns_stream !== Strophe.NS.STREAM) {
			error = "Wrong xmlns:stream in stream:stream: " + ns_stream
		    }
		}
		var ver = message.getAttribute("version");
		if (typeof ver !== "string") {
		    error = "Missing version in stream:stream"
		} else {
		    if (ver !== "1.0") {
			error = "Wrong version in stream:stream: " + ver
		    }
		}
		if (error) {
		    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
		    this._conn._doDisconnect();
		    return false
		}
		return true
	    },
	    _connect_cb_wrapper: function(message) {
		if (message.data.indexOf("<stream:stream ") === 0 || message.data.indexOf("<?xml") === 0) {
		    var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
		    if (data === "") {
			return
		    }
		    data = message.data.replace(/<stream:stream (.*[^\/])>/, "<stream:stream $1/>");
		    var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
		    this._conn.xmlInput(streamStart);
		    this._conn.rawInput(message.data);
		    if (this._handleStreamStart(streamStart)) {
			this._connect_cb(streamStart);
			this.streamStart = message.data.replace(/^<stream:(.*)\/>$/, "<stream:$1>")
		    }
		} else {
		    if (message.data === "</stream:stream>") {
			this._conn.rawInput(message.data);
			this._conn.xmlInput(document.createElement("stream:stream"));
			this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
			this._conn._doDisconnect();
			return
		    } else {
			var string = this._streamWrap(message.data);
			var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
			this.socket.onmessage = this._onMessage.bind(this);
			this._conn._connect_cb(elem, null, message.data)
		    }
		}
	    },
	    _disconnect: function(pres) {
		if (this.socket.readyState !== WebSocket.CLOSED) {
		    if (pres) {
			this._conn.send(pres)
		    }
		    var close = "</stream:stream>";
		    this._conn.xmlOutput(document.createElement("stream:stream"));
		    this._conn.rawOutput(close);
		    try {
			this.socket.send(close)
		    } catch (e) {
			Strophe.info("Couldn't send closing stream tag.")
		    }
		}
		this._conn._doDisconnect()
	    },
	    _doDisconnect: function() {
		Strophe.info("WebSockets _doDisconnect was called");
		this._closeSocket()
	    },
	    _streamWrap: function(stanza) {
		return this.streamStart + stanza + "</stream:stream>"
	    },
	    _closeSocket: function() {
		if (this.socket) {
		    try {
			this.socket.close()
		    } catch (e) {}
		}
		this.socket = null
	    },
	    _emptyQueue: function() {
		return true
	    },
	    _onClose: function() {
		if (this._conn.connected && !this._conn.disconnecting) {
		    Strophe.error("Websocket closed unexcectedly");
		    this._conn._doDisconnect()
		} else {
		    Strophe.info("Websocket closed")
		}
	    },
	    _no_auth_received: function(_callback) {
		Strophe.error("Server did not send any auth methods");
		this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
		if (_callback) {
		    _callback = _callback.bind(this._conn);
		    _callback()
		}
		this._conn._doDisconnect()
	    },
	    _onDisconnectTimeout: function() {},
	    _onError: function(error) {
		Strophe.error("Websocket error " + error);
		this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established was disconnected.");
		this._disconnect()
	    },
	    _onIdle: function() {
		var data = this._conn._data;
		if (data.length > 0 && !this._conn.paused) {
		    for (var i = 0; i < data.length; i++) {
			if (data[i] !== null) {
			    var stanza, rawStanza;
			    if (data[i] === "restart") {
				stanza = this._buildStream();
				rawStanza = this._removeClosingTag(stanza);
				stanza = stanza.tree()
			    } else {
				stanza = data[i];
				rawStanza = Strophe.serialize(stanza)
			    }
			    this._conn.xmlOutput(stanza);
			    this._conn.rawOutput(rawStanza);
			    this.socket.send(rawStanza)
			}
		    }
		    this._conn._data = []
		}
	    },
	    _onMessage: function(message) {
		var elem, data;
		if (message.data === "</stream:stream>") {
		    var close = "</stream:stream>";
		    this._conn.rawInput(close);
		    this._conn.xmlInput(document.createElement("stream:stream"));
		    if (!this._conn.disconnecting) {
			this._conn._doDisconnect()
		    }
		    return
		} else {
		    if (message.data.search("<stream:stream ") === 0) {
			data = message.data.replace(/<stream:stream (.*[^\/])>/, "<stream:stream $1/>");
			elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
			if (!this._handleStreamStart(elem)) {
			    return
			}
		    } else {
			data = this._streamWrap(message.data);
			elem = new DOMParser().parseFromString(data, "text/xml").documentElement
		    }
		}
		if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
		    return
		}
		if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") {
		    this._conn.xmlInput(elem);
		    this._conn.rawInput(Strophe.serialize(elem));
		    return
		}
		this._conn._dataRecv(elem, message.data)
	    },
	    _onOpen: function() {
		Strophe.info("Websocket open");
		var start = this._buildStream();
		this._conn.xmlOutput(start.tree());
		var startString = this._removeClosingTag(start);
		this._conn.rawOutput(startString);
		this.socket.send(startString)
	    },
	    _removeClosingTag: function(elem) {
		var string = Strophe.serialize(elem);
		string = string.replace(/<(stream:stream .*[^\/])\/>$/, "<$1>");
		return string
	    },
	    _reqToData: function(stanza) {
		return stanza
	    },
	    _send: function() {
		this._conn.flush()
	    },
	    _sendRestart: function() {
		clearTimeout(this._conn._idleTimeout);
		this._conn._onIdle.bind(this._conn)()
	    }
	};


	/**
	 * Base class for ColibriFocus and JingleSession.
	 * @param connection Strophe connection object
	 * @param sid my session identifier(resource)
	 * @constructor
	 */

	function SessionBase(connection, sid) {
	    this.connection = connection;
	    this.sid = sid;

	    /**
	     * The indicator which determines whether the (local) video has been muted
	     * in response to a user command in contrast to an automatic decision made
	     * by the application logic.
	     */
	    this.videoMuteByUser = false;
	}


	SessionBase.prototype.modifySources = function (successCallback) {
	    var self = this;
	    if(this.peerconnection)
		this.peerconnection.modifySources(function(){
		    $(document).trigger('setLocalDescription.jingle', [self.sid]);
		    if(successCallback) {
			successCallback();
		    }
		});
	};

	SessionBase.prototype.addSource = function (elem, fromJid) {

	    var self = this;
	    // FIXME: dirty waiting
	    if (!this.peerconnection.localDescription)
	    {
		console.warn("addSource - localDescription not ready yet")
		setTimeout(function()
		    {
			self.addSource(elem, fromJid);
		    },
		    200
		);
		return;
	    }

	    this.peerconnection.addSource(elem);

	    this.modifySources();
	};

	SessionBase.prototype.removeSource = function (elem, fromJid) {

	    var self = this;
	    // FIXME: dirty waiting
	    if (!this.peerconnection.localDescription)
	    {
		console.warn("removeSource - localDescription not ready yet")
		setTimeout(function()
		    {
			self.removeSource(elem, fromJid);
		    },
		    200
		);
		return;
	    }

	    this.peerconnection.removeSource(elem);

	    this.modifySources();
	};

	/**
	 * Switches video streams.
	 * @param new_stream new stream that will be used as video of this session.
	 * @param oldStream old video stream of this session.
	 * @param success_callback callback executed after successful stream switch.
	 */
	SessionBase.prototype.switchStreams = function (new_stream, oldStream, success_callback) {

	    var self = this;

	    // Stop the stream to trigger onended event for old stream
	    
	    oldStream.getAudioTracks().forEach(function (track) {
		track.stop();
	    });
	
	    oldStream.getVideoTracks().forEach(function (track) {
		track.stop();
	    });	    

	    // Remember SDP to figure out added/removed SSRCs
	    var oldSdp = null;
	    if(self.peerconnection) {
		if(self.peerconnection.localDescription) {
		    oldSdp = new SDP(self.peerconnection.localDescription.sdp);
		}
		self.peerconnection.removeStream(oldStream, true);
		self.peerconnection.addStream(new_stream);
	    }

	    self.connection.jingle.localVideo = new_stream;

	    self.connection.jingle.localStreams = [];

	    //in firefox we have only one stream object
	    if(self.connection.jingle.localAudio != self.connection.jingle.localVideo)
		self.connection.jingle.localStreams.push(self.connection.jingle.localAudio);
	    self.connection.jingle.localStreams.push(self.connection.jingle.localVideo);

	    // Conference is not active
	    if(!oldSdp || !self.peerconnection) {
		success_callback();
		return;
	    }

	    self.peerconnection.switchstreams = true;
	    self.modifySources(function() {
		//console.log('modify sources done');

		success_callback();

		var newSdp = new SDP(self.peerconnection.localDescription.sdp);
		//console.log("SDPs", oldSdp, newSdp);
		self.notifyMySSRCUpdate(oldSdp, newSdp);
	    });
	};

	/**
	 * Figures out added/removed ssrcs and send update IQs.
	 * @param old_sdp SDP object for old description.
	 * @param new_sdp SDP object for new description.
	 */
	SessionBase.prototype.notifyMySSRCUpdate = function (old_sdp, new_sdp) {

	    var old_media = old_sdp.getMediaSsrcMap();
	    var new_media = new_sdp.getMediaSsrcMap();
	    //console.log("old/new medias: ", old_media, new_media);

	    var toAdd = old_sdp.getNewMedia(new_sdp);
	    var toRemove = new_sdp.getNewMedia(old_sdp);
	    //console.log("to add", toAdd);
	    //console.log("to remove", toRemove);
	    if(Object.keys(toRemove).length > 0){
		this.sendSSRCUpdate(toRemove, null, false);
	    }
	    if(Object.keys(toAdd).length > 0){
		this.sendSSRCUpdate(toAdd, null, true);
	    }
	};

	/**
	 * Empty method that does nothing by default. It should send SSRC update IQs to session participants.
	 * @param sdpMediaSsrcs array of
	 * @param fromJid
	 * @param isAdd
	 */
	SessionBase.prototype.sendSSRCUpdate = function(sdpMediaSsrcs, fromJid, isAdd) {
	    //FIXME: put default implementation here(maybe from JingleSession?)
	}

	/**
	 * Sends SSRC update IQ.
	 * @param sdpMediaSsrcs SSRCs map obtained from SDP.getNewMedia. Cntains SSRCs to add/remove.
	 * @param sid session identifier that will be put into the IQ.
	 * @param initiator initiator identifier.
	 * @param toJid destination Jid
	 * @param isAdd indicates if this is remove or add operation.
	 */
	SessionBase.prototype.sendSSRCUpdateIq = function(sdpMediaSsrcs, sid, initiator, toJid, isAdd) {

	    var self = this;
	    var modify = $iq({to: toJid, type: 'set'})
		.c('jingle', {
		    xmlns: 'urn:xmpp:jingle:1',
		    action: isAdd ? 'source-add' : 'source-remove',
		    initiator: initiator,
		    sid: sid
		}
	    );
	    // FIXME: only announce video ssrcs since we mix audio and dont need
	    //      the audio ssrcs therefore
	    var modified = false;
	    Object.keys(sdpMediaSsrcs).forEach(function(channelNum){
		modified = true;
		var channel = sdpMediaSsrcs[channelNum];
		modify.c('content', {name: channel.mediaType});

		modify.c('description', {xmlns:'urn:xmpp:jingle:apps:rtp:1', media: channel.mediaType});
		// FIXME: not completly sure this operates on blocks and / or handles different ssrcs correctly
		// generate sources from lines
		Object.keys(channel.ssrcs).forEach(function(ssrcNum) {
		    var mediaSsrc = channel.ssrcs[ssrcNum];
		    modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
		    modify.attrs({ssrc: mediaSsrc.ssrc});
		    // iterate over ssrc lines
		    mediaSsrc.lines.forEach(function (line) {
			var idx = line.indexOf(' ');
			var kv = line.substr(idx + 1);
			modify.c('parameter');
			if (kv.indexOf(':') == -1) {
			    modify.attrs({ name: kv });
			} else {
			    modify.attrs({ name: kv.split(':', 2)[0] });
			    modify.attrs({ value: kv.split(':', 2)[1] });
			}
			modify.up(); // end of parameter
		    });
		    modify.up(); // end of source
		});

		// generate source groups from lines
		channel.ssrcGroups.forEach(function(ssrcGroup) {
		    if (ssrcGroup.ssrcs.length != 0) {

			modify.c('ssrc-group', {
			    semantics: ssrcGroup.semantics,
			    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'
			});

			ssrcGroup.ssrcs.forEach(function (ssrc) {
			    modify.c('source', { ssrc: ssrc })
				.up(); // end of source
			});
			modify.up(); // end of ssrc-group
		    }
		});

		modify.up(); // end of description
		modify.up(); // end of content
	    });
	    if (modified) {
		self.connection.sendIQ(modify,
		    function (res) {
			//console.info('got modify result', res);
		    },
		    function (err) {
			console.error('got modify error', err);
		    }
		);
	    } else {
		//console.log('modification not necessary');
	    }
	};

	/**
	 * Determines whether the (local) video is mute i.e. all video tracks are
	 * disabled.
	 *
	 * @return <tt>true</tt> if the (local) video is mute i.e. all video tracks are
	 * disabled; otherwise, <tt>false</tt>
	 */
	SessionBase.prototype.isVideoMute = function () {
	    var tracks = connection.jingle.localVideo.getVideoTracks();
	    var mute = true;

	    for (var i = 0; i < tracks.length; ++i) {
		if (tracks[i].enabled) {
		    mute = false;
		    break;
		}
	    }
	    return mute;
	};

	/**
	 * Mutes/unmutes the (local) video i.e. enables/disables all video tracks.
	 *
	 * @param mute <tt>true</tt> to mute the (local) video i.e. to disable all video
	 * tracks; otherwise, <tt>false</tt>
	 * @param callback a function to be invoked with <tt>mute</tt> after all video
	 * tracks have been enabled/disabled. The function may, optionally, return
	 * another function which is to be invoked after the whole mute/unmute operation
	 * has completed successfully.
	 * @param options an object which specifies optional arguments such as the
	 * <tt>boolean</tt> key <tt>byUser</tt> with default value <tt>true</tt> which
	 * specifies whether the method was initiated in response to a user command (in
	 * contrast to an automatic decision made by the application logic)
	 */
	SessionBase.prototype.setVideoMute = function (mute, callback, options) {
	    var byUser;

	    if (options) {
		byUser = options.byUser;
		if (typeof byUser === 'undefined') {
		    byUser = true;
		} 
	    } else {
		byUser = true;
	    }
	    // The user's command to mute the (local) video takes precedence over any
	    // automatic decision made by the application logic.
	    if (byUser) {
		this.videoMuteByUser = mute;
	    } else if (this.videoMuteByUser) {
		return;
	    }
	    if (mute == this.isVideoMute())
	    {
		// Even if no change occurs, the specified callback is to be executed.
		// The specified callback may, optionally, return a successCallback
		// which is to be executed as well.
		var successCallback = callback(mute);

		if (successCallback) {
		    successCallback();
		}
	    } else {
		var tracks = connection.jingle.localVideo.getVideoTracks();

		for (var i = 0; i < tracks.length; ++i) {
		    tracks[i].enabled = !mute;
		}

		if (this.peerconnection) {
		    this.peerconnection.hardMuteVideo(mute);
		}

		this.modifySources(callback(mute));
	    }
	};

	// SDP-based mute by going recvonly/sendrecv
	// FIXME: should probably black out the screen as well
	SessionBase.prototype.toggleVideoMute = function (callback) {
	    setVideoMute(isVideoMute(), callback);
	};


	/**
	 * Strophe.JingleSession
	 */


	JingleSession.prototype = Object.create(SessionBase.prototype);
	function JingleSession(me, sid, connection) {

	    SessionBase.call(this, connection, sid);

	    this.me = me;
	    this.initiator = null;
	    this.responder = null;
	    this.isInitiator = null;
	    this.peerjid = null;
	    this.state = null;
	    this.localSDP = null;
	    this.remoteSDP = null;
	    this.localStreams = [];
	    this.relayedStreams = [];
	    this.remoteStreams = [];
	    this.startTime = null;
	    this.stopTime = null;
	    this.media_constraints = null;
	    this.pc_constraints = null;
	    this.ice_config = {};
	    this.drip_container = [];

	    this.usetrickle = true;
	    this.usepranswer = false; // early transport warmup -- mind you, this might fail. depends on webrtc issue 1718
	    this.usedrip = false; // dripping is sending trickle candidates not one-by-one

	    this.hadstuncandidate = false;
	    this.hadturncandidate = false;
	    this.lasticecandidate = false;

	    this.relayHost = null;
	    this.relayLocalPort = null;
	    this.relayRemotePort = null; 
    
	    this.statsinterval = null;

	    this.reason = null;

	    this.wait = true;
	    this.localStreamsSSRC = null;
	}

	JingleSession.prototype.initiate = function (peerjid, isInitiator) {
	    var self = this;
	    if (this.state !== null) {
		console.error('attempt to initiate on session ' + this.sid +
		    'in state ' + this.state);
		return;
	    }
	    this.isInitiator = isInitiator;
	    this.state = 'pending';
	    this.initiator = isInitiator ? this.me : peerjid;
	    this.responder = !isInitiator ? this.me : peerjid;
	    this.peerjid = peerjid;
	    this.hadstuncandidate = false;
	    this.hadturncandidate = false;
	    this.lasticecandidate = false;
	    this.relayHost = null;
	    this.relayLocalPort = null;
	    this.relayRemotePort = null; 
	    
	    this.peerconnection
		= new TraceablePeerConnection(
		    this.connection.jingle.ice_config,
		    this.connection.jingle.pc_constraints );

	    this.peerconnection.onicecandidate = function (event) {
		self.sendIceCandidate(event.candidate);
	    };
	    this.peerconnection.onaddstream = function (event) {
		self.remoteStreams.push(event.stream);
		//console.log("REMOTE STREAM ADDED: " + event.stream + " - " + event.stream.id);
		$(document).trigger('remotestreamadded.jingle', [event, self.sid]);
	    };
	    this.peerconnection.onremovestream = function (event) {
		// Remove the stream from remoteStreams
		var streamIdx = self.remoteStreams.indexOf(event.stream);
		if(streamIdx !== -1){
		    self.remoteStreams.splice(streamIdx, 1);
		}
		// FIXME: remotestreamremoved.jingle not defined anywhere(unused)
		$(document).trigger('remotestreamremoved.jingle', [event, self.sid]);
	    };
	    this.peerconnection.onsignalingstatechange = function (event) {
		if (!(self && self.peerconnection)) return;
	    };
	    this.peerconnection.oniceconnectionstatechange = function (event) {
		if (!(self && self.peerconnection)) return;
		switch (self.peerconnection.iceConnectionState) {
		    case 'connected':
			this.startTime = new Date();
			break;
		    case 'disconnected':
			this.stopTime = new Date();
			break;
		}
		$(document).trigger('iceconnectionstatechange.jingle', [self.sid, self]);
	    };
	    // add any local and relayed stream
	    this.localStreams.forEach(function(stream) {
		self.peerconnection.addStream(stream);
	    });
	    this.relayedStreams.forEach(function(stream) {
		self.peerconnection.addStream(stream);
	    });
	};

	JingleSession.prototype.accept = function () {
	    var self = this;
	    this.state = 'active';

	    var pranswer = this.peerconnection.localDescription;
	    if (!pranswer || pranswer.type != 'pranswer') {
		return;
	    }
	    //console.log('going from pranswer to answer');
	    if (this.usetrickle) {
		// remove candidates already sent from session-accept
		var lines = SDPUtil.find_lines(pranswer.sdp, 'a=candidate:');
		for (var i = 0; i < lines.length; i++) {
		    pranswer.sdp = pranswer.sdp.replace(lines[i] + '\r\n', '');
		}
	    }
	    while (SDPUtil.find_line(pranswer.sdp, 'a=inactive')) {
		// FIXME: change any inactive to sendrecv or whatever they were originally
		pranswer.sdp = pranswer.sdp.replace('a=inactive', 'a=sendrecv');
	    }
	    pranswer = simulcast.reverseTransformLocalDescription(pranswer);
	    var prsdp = new SDP(pranswer.sdp);
	    var accept = $iq({to: this.peerjid,
		type: 'set'})
		.c('jingle', {xmlns: 'urn:xmpp:jingle:1',
		    action: 'session-accept',
		    initiator: this.initiator,
		    responder: this.responder,
		    sid: this.sid });
	    prsdp.toJingle(accept, this.initiator == this.me ? 'initiator' : 'responder', this.localStreamsSSRC);
	    var sdp = this.peerconnection.localDescription.sdp;
	    while (SDPUtil.find_line(sdp, 'a=inactive')) {
		// FIXME: change any inactive to sendrecv or whatever they were originally
		sdp = sdp.replace('a=inactive', 'a=sendrecv');
	    }
	    this.peerconnection.setLocalDescription(new RTCSessionDescription({type: 'answer', sdp: this.setBandwidth(sdp)}), // BAO
		function () {
		    //console.log('setLocalDescription success');
		    $(document).trigger('setLocalDescription.jingle', [self.sid]);

		    this.connection.sendIQ(accept,
			function () {
			    var ack = {};
			    ack.source = 'answer';
			    $(document).trigger('ack.jingle', [self.sid, ack]);
			},
			function (stanza) {
			    var error = ($(stanza).find('error').length) ? {
				code: $(stanza).find('error').attr('code'),
				reason: $(stanza).find('error :first')[0].tagName
			    }:{};
			    error.source = 'answer';
			    $(document).trigger('error.jingle', [self.sid, error]);
			});
		},
		function (e) {
		    console.error('setLocalDescription failed', e);
		}
	    );
	};

	/**
	 * Implements SessionBase.sendSSRCUpdate.
	 */
	JingleSession.prototype.sendSSRCUpdate = function(sdpMediaSsrcs, fromJid, isadd) {

	    var self = this;
	    //console.log('tell', self.peerjid, 'about ' + (isadd ? 'new' : 'removed') + ' ssrcs from' + self.me);

	    //  BAO This code is now redundant
	    //
	    //if (!(this.peerconnection.signalingState == 'stable' && this.peerconnection.iceConnectionState == 'connected')){
	    //    console.log("Too early to send updates");
	    //    return;
	    //}
	    
	    this.sendSSRCUpdateIq(sdpMediaSsrcs, self.sid, self.initiator, self.peerjid, isadd);
	};

	JingleSession.prototype.terminate = function (reason) {
	    this.state = 'ended';
	    this.reason = reason;
	    this.peerconnection.close();
	    if (this.statsinterval !== null) {
		window.clearInterval(this.statsinterval);
		this.statsinterval = null;
	    }
	};

	JingleSession.prototype.active = function () {
	    return this.state == 'active';
	};

	JingleSession.prototype.sendIceCandidate = function (candidate) {
	    var self = this;
	    if (candidate && !this.lasticecandidate) {
		var ice = SDPUtil.iceparams(this.localSDP.media[candidate.sdpMLineIndex], this.localSDP.session);
		var jcand = SDPUtil.candidateToJingle(candidate.candidate);
		if (!(ice && jcand)) {
		    console.error('failed to get ice && jcand');
		    return;
		}
		ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';

		if (jcand.type === 'srflx') {
		    this.hadstuncandidate = true;
		} else if (jcand.type === 'relay') {
		    this.hadturncandidate = true;
		}

		if (this.usetrickle) {
		    if (this.usedrip) {
			if (this.drip_container.length === 0) {
			    // start 20ms callout
			    window.setTimeout(function () {
				if (self.drip_container.length === 0) return;
				self.sendIceCandidates(self.drip_container);
				self.drip_container = [];
			    }, 20);

			}
			this.drip_container.push(candidate);
			return;
		    } else {
			self.sendIceCandidate([candidate]);
		    }
		}
	    } else {
		//console.log('sendIceCandidate: last candidate.');
		if (!this.usetrickle) {
		    //console.log('should send full offer now...');
		    var init = $iq({to: this.peerjid,
			type: 'set'})
			.c('jingle', {xmlns: 'urn:xmpp:jingle:1',
			    action: this.peerconnection.localDescription.type == 'offer' ? 'session-initiate' : 'session-accept',
			    initiator: this.initiator,
			    sid: this.sid});
		    this.localSDP = new SDP(this.peerconnection.localDescription.sdp);
		    var self = this;
		    var sendJingle = function (ssrc) {
			if(!ssrc)
			    ssrc = {};
			self.localSDP.toJingle(init, self.initiator == self.me ? 'initiator' : 'responder', ssrc);
			self.connection.sendIQ(init,
			    function () {
				//console.log('session initiate ack');
				var ack = {};
				ack.source = 'offer';
				$(document).trigger('ack.jingle', [self.sid, ack]);
			    },
			    function (stanza) {
				self.state = 'error';
				self.peerconnection.close();
				var error = ($(stanza).find('error').length) ? {
				    code: $(stanza).find('error').attr('code'),
				    reason: $(stanza).find('error :first')[0].tagName,
				}:{};
				error.source = 'offer';
				$(document).trigger('error.jingle', [self.sid, error]);
			    });
		    }

		    RTC.getLocalSSRC(this, function (ssrcs) {
			if(ssrcs)
			{
			    sendJingle(ssrcs);
			    $(document).trigger("setLocalDescription.jingle", [self.sid]);
			}
			else
			{
			    sendJingle();
			}
		    });

		}
		this.lasticecandidate = true;
		//console.log('Have we encountered any srflx candidates? ' + this.hadstuncandidate);
		//console.log('Have we encountered any relay candidates? ' + this.hadturncandidate);

		if (!(this.hadstuncandidate || this.hadturncandidate) && this.peerconnection.signalingState != 'closed') {
		    $(document).trigger('nostuncandidates.jingle', [this.sid]);
		}
	    }
	};

	JingleSession.prototype.sendIceCandidates = function (candidates) {
	    //console.log('sendIceCandidates', candidates);
	    var self = this;
	    var relayDone = false;
	    var cand = $iq({to: this.peerjid, type: 'set'})
		.c('jingle', {xmlns: 'urn:xmpp:jingle:1',
		    action: 'transport-info',
		    initiator: this.initiator,
		    sid: this.sid});
	    for (var mid = 0; mid < this.localSDP.media.length; mid++) {
		var cands = candidates.filter(function (el) { return el.sdpMLineIndex == mid; });
		var mline = SDPUtil.parse_mline(this.localSDP.media[mid].split('\r\n')[0]);
		if (cands.length > 0) {
		    var ice = SDPUtil.iceparams(this.localSDP.media[mid], this.localSDP.session);
		    ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
		    cand.c('content', {creator: this.initiator == this.me ? 'initiator' : 'responder',
			name: (cands[0].sdpMid? cands[0].sdpMid : mline.media)
		    }).c('transport', ice);
		    for (var i = 0; i < cands.length; i++) {
			cand.c('candidate', SDPUtil.candidateToJingle(cands[i].candidate)).up();
		    }
		    
		    if (!self.relayDone )
		    {
			    console.log('sendIceCandidates: send jingle nodes request');            
			    var iqRelay = $iq({type: "get", to: "relay." + self.connection.domain}).c('channel', {xmlns: "http://jabber.org/protocol/jinglenodes#channel", protocol: 'udp'});

			    self.connection.sendIQ(iqRelay, function(response)
			    {
				if ($(response).attr('type') == "result")
				{
					console.log('sendIceCandidates: jingle nodes response', response);  
					self.hadturncandidate = true;

					$(response).find('channel').each(function() 
					{
						self.relayHost = $(this).attr('host');
						self.relayLocalPort = $(this).attr('localport');
						self.relayRemotePort = $(this).attr('remoteport');

						var relayCandidate = "a=candidate:3707591233 1 udp 2113937151 " + self.relayHost + " " + self.relayRemotePort + " typ relay generation 0 ";

						console.log("add JingleNodes candidate: " + self.relayHost + " " + self.relayLocalPort + " " + self.relayRemotePort); 
						cand.c('candidate', SDPUtil.candidateToJingle(relayCandidate)).up();
					});

				}		
			    }, function(err) {console.error("jingle nodes request error", err)});
			    
			    relayDone = true;
		    }	    	    
		    // add fingerprint
		    if (SDPUtil.find_line(this.localSDP.media[mid], 'a=fingerprint:', this.localSDP.session)) {
			var tmp = SDPUtil.parse_fingerprint(SDPUtil.find_line(this.localSDP.media[mid], 'a=fingerprint:', this.localSDP.session));
			tmp.required = true;
			cand.c(
			    'fingerprint',
			    {xmlns: 'urn:xmpp:jingle:apps:dtls:0'})
			    .t(tmp.fingerprint);
			delete tmp.fingerprint;
			cand.attrs(tmp);
			cand.up();
		    }
		    cand.up(); // transport
		    cand.up(); // content
		}
		
		self.relayDone = relayDone;
	    }
	    // might merge last-candidate notification into this, but it is called alot later. See webrtc issue #2340
	    //console.log('was this the last candidate', this.lasticecandidate);
	    this.connection.sendIQ(cand,
		function () {
		    var ack = {};
		    ack.source = 'transportinfo';
		    $(document).trigger('ack.jingle', [this.sid, ack]);
		},
		function (stanza) {
		    var error = ($(stanza).find('error').length) ? {
			code: $(stanza).find('error').attr('code'),
			reason: $(stanza).find('error :first')[0].tagName,
		    }:{};
		    error.source = 'transportinfo';
		    $(document).trigger('error.jingle', [this.sid, error]);
		});
	};


	JingleSession.prototype.sendOffer = function () {
	    //console.log('sendOffer...');
	    var self = this;
	    this.peerconnection.createOffer(function (sdp) {
		    self.createdOffer(sdp);
		},
		function (e) {
		    console.error('createOffer failed', e);
		},
		this.media_constraints
	    );
	};

	JingleSession.prototype.createdOffer = function (sdp) {
	    //console.log('createdOffer', sdp);
	    var self = this;
	    this.localSDP = new SDP(sdp.sdp);
	    //this.localSDP.mangle();
	    var sendJingle = function () {
		var init = $iq({to: this.peerjid,
		    type: 'set'})
		    .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
			action: 'session-initiate',
			initiator: this.initiator,
			sid: this.sid});
		this.localSDP.toJingle(init, this.initiator == this.me ? 'initiator' : 'responder', this.localStreamsSSRC);
		this.connection.sendIQ(init,
		    function () {
			var ack = {};
			ack.source = 'offer';
			$(document).trigger('ack.jingle', [self.sid, ack]);
		    },
		    function (stanza) {
			self.state = 'error';
			self.peerconnection.close();
			var error = ($(stanza).find('error').length) ? {
			    code: $(stanza).find('error').attr('code'),
			    reason: $(stanza).find('error :first')[0].tagName,
			}:{};
			error.source = 'offer';
			$(document).trigger('error.jingle', [self.sid, error]);
		    });
	    }
	    sdp.sdp = this.setBandwidth(this.localSDP.raw); // BAO

	    this.peerconnection.setLocalDescription(sdp,
		function () {
		    if(this.usetrickle)
		    {
			RTC.getLocalSSRC(function(ssrc)
			{
			    sendJingle(ssrc);
			    $(document).trigger('setLocalDescription.jingle', [self.sid]);
			});
		    }
		    else
			$(document).trigger('setLocalDescription.jingle', [self.sid]);
		    //console.log('setLocalDescription success');
		},
		function (e) {
		    console.error('setLocalDescription failed', e);
		}
	    );
	    var cands = SDPUtil.find_lines(this.localSDP.raw, 'a=candidate:');
	    for (var i = 0; i < cands.length; i++) {
		var cand = SDPUtil.parse_icecandidate(cands[i]);
		if (cand.type == 'srflx') {
		    this.hadstuncandidate = true;
		} else if (cand.type == 'relay') {
		    this.hadturncandidate = true;
		}
	    }
	};

	JingleSession.prototype.setRemoteDescription = function (elem, desctype) {
	    //console.log('setting remote description... ', desctype);
	    this.remoteSDP = new SDP('');
	    this.remoteSDP.fromJingle(elem);
	    if (this.peerconnection.remoteDescription !== null) {
		//console.log('setRemoteDescription when remote description is not null, should be pranswer', this.peerconnection.remoteDescription);
		if (this.peerconnection.remoteDescription.type == 'pranswer') {
		    var pranswer = new SDP(this.peerconnection.remoteDescription.sdp);
		    for (var i = 0; i < pranswer.media.length; i++) {
			// make sure we have ice ufrag and pwd
			if (!SDPUtil.find_line(this.remoteSDP.media[i], 'a=ice-ufrag:', this.remoteSDP.session)) {
			    if (SDPUtil.find_line(pranswer.media[i], 'a=ice-ufrag:', pranswer.session)) {
				this.remoteSDP.media[i] += SDPUtil.find_line(pranswer.media[i], 'a=ice-ufrag:', pranswer.session) + '\r\n';
			    } else {
				console.warn('no ice ufrag?');
			    }
			    if (SDPUtil.find_line(pranswer.media[i], 'a=ice-pwd:', pranswer.session)) {
				this.remoteSDP.media[i] += SDPUtil.find_line(pranswer.media[i], 'a=ice-pwd:', pranswer.session) + '\r\n';
			    } else {
				console.warn('no ice pwd?');
			    }
			}
			// copy over candidates
			var lines = SDPUtil.find_lines(pranswer.media[i], 'a=candidate:');
			for (var j = 0; j < lines.length; j++) {
			    this.remoteSDP.media[i] += lines[j] + '\r\n';
			}
		    }
		    this.remoteSDP.raw = this.remoteSDP.session + this.remoteSDP.media.join('');
		}
	    }
	    
	    if (this.relayHost != null && this.relayLocalPort != null)
	    {
		var candidate = new RTCIceCandidate({sdpMLineIndex: "0", candidate: "a=candidate:3707591233 1 udp 2113937151 " + this.relayHost + " " + this.relayLocalPort + " typ relay generation 0 "});
		this.peerconnection.addIceCandidate(candidate);  
		this.hadturncandidate = true;
	    }
	    
	    var remotedesc = new RTCSessionDescription({type: desctype, sdp: this.remoteSDP.raw});

	    this.peerconnection.setRemoteDescription(remotedesc,
		function () {
		    //console.log('setRemoteDescription success');
		},
		function (e) {
		    console.error('setRemoteDescription error', e);
		    $(document).trigger('fatalError.jingle', [self, e]);
		}
	    );
	};

	JingleSession.prototype.addIceCandidate = function (elem) {
	    var self = this;
	    if (this.peerconnection.signalingState == 'closed') {
		return;
	    }
	    if (!this.peerconnection.remoteDescription && this.peerconnection.signalingState == 'have-local-offer') {
		//console.log('trickle ice candidate arriving before session accept...');
		// create a PRANSWER for setRemoteDescription
		if (!this.remoteSDP) {
		    var cobbled = 'v=0\r\n' +
			'o=- ' + '1923518516' + ' 2 IN IP4 0.0.0.0\r\n' +// FIXME
			's=-\r\n' +
			't=0 0\r\n';
		    // first, take some things from the local description
		    for (var i = 0; i < this.localSDP.media.length; i++) {
			cobbled += SDPUtil.find_line(this.localSDP.media[i], 'm=') + '\r\n';
			cobbled += SDPUtil.find_lines(this.localSDP.media[i], 'a=rtpmap:').join('\r\n') + '\r\n';
			if (SDPUtil.find_line(this.localSDP.media[i], 'a=mid:')) {
			    cobbled += SDPUtil.find_line(this.localSDP.media[i], 'a=mid:') + '\r\n';
			}
			cobbled += 'a=inactive\r\n';
		    }
		    this.remoteSDP = new SDP(cobbled);
		}
		// then add things like ice and dtls from remote candidate
		elem.each(function () {
		    for (var i = 0; i < self.remoteSDP.media.length; i++) {
			if (SDPUtil.find_line(self.remoteSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
			    self.remoteSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
			    if (!SDPUtil.find_line(self.remoteSDP.media[i], 'a=ice-ufrag:')) {
				var tmp = $(this).find('transport');
				self.remoteSDP.media[i] += 'a=ice-ufrag:' + tmp.attr('ufrag') + '\r\n';
				self.remoteSDP.media[i] += 'a=ice-pwd:' + tmp.attr('pwd') + '\r\n';
				tmp = $(this).find('transport>fingerprint');
				if (tmp.length) {
				    self.remoteSDP.media[i] += 'a=fingerprint:' + tmp.attr('hash') + ' ' + tmp.text() + '\r\n';
				} else {
				    //console.log('no dtls fingerprint (webrtc issue #1718?)');
				    self.remoteSDP.media[i] += 'a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:BAADBAADBAADBAADBAADBAADBAADBAADBAADBAAD\r\n';
				}
				break;
			    }
			}
		    }
		});
		this.remoteSDP.raw = this.remoteSDP.session + this.remoteSDP.media.join('');

		// we need a complete SDP with ice-ufrag/ice-pwd in all parts
		// this makes the assumption that the PRANSWER is constructed such that the ice-ufrag is in all mediaparts
		// but it could be in the session part as well. since the code above constructs this sdp this can't happen however
		var iscomplete = this.remoteSDP.media.filter(function (mediapart) {
		    return SDPUtil.find_line(mediapart, 'a=ice-ufrag:');
		}).length == this.remoteSDP.media.length;

		if (iscomplete) {
		    //console.log('setting pranswer');
		    try {
			this.peerconnection.setRemoteDescription(new RTCSessionDescription({type: 'pranswer', sdp: this.remoteSDP.raw }),
			    function() {
			    },
			    function(e) {
				//console.log('setRemoteDescription pranswer failed', e.toString());
			    });
		    } catch (e) {
			console.error('setting pranswer failed', e);
		    }
		} else {
		    //console.log('not yet setting pranswer');
		}
	    }
	    // operate on each content element
	    elem.each(function () {
		// would love to deactivate this, but firefox still requires it
		var idx = -1;
		var i;
		for (i = 0; i < self.remoteSDP.media.length; i++) {
		    if (SDPUtil.find_line(self.remoteSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
			self.remoteSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
			idx = i;
			break;
		    }
		}
		if (idx == -1) { // fall back to localdescription
		    for (i = 0; i < self.localSDP.media.length; i++) {
			if (SDPUtil.find_line(self.localSDP.media[i], 'a=mid:' + $(this).attr('name')) ||
			    self.localSDP.media[i].indexOf('m=' + $(this).attr('name')) === 0) {
			    idx = i;
			    break;
			}
		    }
		}
		var name = $(this).attr('name');
		// TODO: check ice-pwd and ice-ufrag?
		$(this).find('transport>candidate').each(function () {
		    var line, candidate;
		    line = SDPUtil.candidateFromJingle(this);
		    candidate = new RTCIceCandidate({sdpMLineIndex: idx,
			sdpMid: name,
			candidate: line});
		    try {
			self.peerconnection.addIceCandidate(candidate);
		    } catch (e) {
			console.error('addIceCandidate failed', e.toString(), line);
		    }
		});
	    });
	};

	JingleSession.prototype.sendAnswer = function (provisional) {
	    //console.log('createAnswer', provisional);
	    var self = this;
	    this.peerconnection.createAnswer(
		function (sdp) {
		    self.createdAnswer(sdp, provisional);
		},
		function (e) {
		    console.error('createAnswer failed', e);
		},
		this.media_constraints
	    );
	};

	JingleSession.prototype.createdAnswer = function (sdp, provisional) {
	    //console.log('createAnswer callback');
	    var self = this;
	    this.localSDP = new SDP(sdp.sdp);
	    //this.localSDP.mangle();
	    this.usepranswer = provisional === true;
	    if (this.usetrickle) {
		if (this.usepranswer) {
		    sdp.type = 'pranswer';
		    for (var i = 0; i < this.localSDP.media.length; i++) {
			this.localSDP.media[i] = this.localSDP.media[i].replace('a=sendrecv\r\n', 'a=inactive\r\n');
		    }
		    this.localSDP.raw = this.localSDP.session + '\r\n' + this.localSDP.media.join('');
		}
	    }
	    var self = this;
	    var sendJingle = function (ssrcs) {

			var accept = $iq({to: self.peerjid,
			    type: 'set'})
			    .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
				action: 'session-accept',
				initiator: self.initiator,
				responder: self.responder,
				sid: self.sid });
			var publicLocalDesc = simulcast.reverseTransformLocalDescription(sdp);
			var publicLocalSDP = new SDP(publicLocalDesc.sdp);
			publicLocalSDP.toJingle(accept, self.initiator == self.me ? 'initiator' : 'responder', ssrcs);
			self.connection.sendIQ(accept,
			    function () {
				var ack = {};
				ack.source = 'answer';
				$(document).trigger('ack.jingle', [self.sid, ack]);
			    },
			    function (stanza) {
				var error = ($(stanza).find('error').length) ? {
				    code: $(stanza).find('error').attr('code'),
				    reason: $(stanza).find('error :first')[0].tagName,
				}:{};
				error.source = 'answer';
				$(document).trigger('error.jingle', [self.sid, error]);
			    });
	    }
	    sdp.sdp = this.setBandwidth(this.localSDP.raw); //BAO
	    this.peerconnection.setLocalDescription(sdp,
		function () {

		    //console.log('setLocalDescription success');
		    if (self.usetrickle && !self.usepranswer) {
			RTC.getLocalSSRC(self, function (ssrc) {
			    sendJingle(ssrc);
			    $(document).trigger('setLocalDescription.jingle', [self.sid]);
			});
		    }
		    else
			$(document).trigger('setLocalDescription.jingle', [self.sid]);
		},
		function (e) {
		    console.error('setLocalDescription failed', e);
		}
	    );
	    var cands = SDPUtil.find_lines(this.localSDP.raw, 'a=candidate:');
	    for (var j = 0; j < cands.length; j++) {
		var cand = SDPUtil.parse_icecandidate(cands[j]);
		if (cand.type == 'srflx') {
		    this.hadstuncandidate = true;
		} else if (cand.type == 'relay') {
		    this.hadturncandidate = true;
		}
	    }
	};

	JingleSession.prototype.sendTerminate = function (reason, text) {
	    var self = this,
		term = $iq({to: this.peerjid,
		    type: 'set'})
		    .c('jingle', {xmlns: 'urn:xmpp:jingle:1',
			action: 'session-terminate',
			initiator: this.initiator,
			sid: this.sid})
		    .c('reason')
		    .c(reason || 'success');

	    if (text) {
		term.up().c('text').t(text);
	    }

	    this.connection.sendIQ(term,
		function () {
		    self.peerconnection.close();
		    self.peerconnection = null;
		    self.terminate();
		    var ack = {};
		    ack.source = 'terminate';
		    $(document).trigger('ack.jingle', [self.sid, ack]);
		},
		function (stanza) {
		    var error = ($(stanza).find('error').length) ? {
			code: $(stanza).find('error').attr('code'),
			reason: $(stanza).find('error :first')[0].tagName,
		    }:{};
		    $(document).trigger('ack.jingle', [self.sid, error]);
		});
	    if (this.statsinterval !== null) {
		window.clearInterval(this.statsinterval);
		this.statsinterval = null;
	    }
	};

	JingleSession.prototype.sendMute = function (muted, content) {
	    var info = $iq({to: this.peerjid,
		type: 'set'})
		.c('jingle', {xmlns: 'urn:xmpp:jingle:1',
		    action: 'session-info',
		    initiator: this.initiator,
		    sid: this.sid });
	    info.c(muted ? 'mute' : 'unmute', {xmlns: 'urn:xmpp:jingle:apps:rtp:info:1'});
	    info.attrs({'creator': this.me == this.initiator ? 'creator' : 'responder'});
	    if (content) {
		info.attrs({'name': content});
	    }
	    this.connection.send(info);
	};

	JingleSession.prototype.sendRinging = function () {
	    var info = $iq({to: this.peerjid,
		type: 'set'})
		.c('jingle', {xmlns: 'urn:xmpp:jingle:1',
		    action: 'session-info',
		    initiator: this.initiator,
		    sid: this.sid });
	    info.c('ringing', {xmlns: 'urn:xmpp:jingle:apps:rtp:info:1'});
	    this.connection.send(info);
	};

	JingleSession.prototype.getStats = function (interval) {
	    var self = this;
	    var recv = {audio: 0, video: 0};
	    var lost = {audio: 0, video: 0};
	    var lastrecv = {audio: 0, video: 0};
	    var lastlost = {audio: 0, video: 0};
	    var loss = {audio: 0, video: 0};
	    var delta = {audio: 0, video: 0};
	    this.statsinterval = window.setInterval(function () {
		if (self && self.peerconnection && self.peerconnection.getStats) {
		    self.peerconnection.getStats(function (stats) {
			var results = stats.result();
			// TODO: there are so much statistics you can get from this..
			for (var i = 0; i < results.length; ++i) {
			    if (results[i].type == 'ssrc') {
				var packetsrecv = results[i].stat('packetsReceived');
				var packetslost = results[i].stat('packetsLost');
				if (packetsrecv && packetslost) {
				    packetsrecv = parseInt(packetsrecv, 10);
				    packetslost = parseInt(packetslost, 10);

				    if (results[i].stat('googFrameRateReceived')) {
					lastlost.video = lost.video;
					lastrecv.video = recv.video;
					recv.video = packetsrecv;
					lost.video = packetslost;
				    } else {
					lastlost.audio = lost.audio;
					lastrecv.audio = recv.audio;
					recv.audio = packetsrecv;
					lost.audio = packetslost;
				    }
				}
			    }
			}
			delta.audio = recv.audio - lastrecv.audio;
			delta.video = recv.video - lastrecv.video;
			loss.audio = (delta.audio > 0) ? Math.ceil(100 * (lost.audio - lastlost.audio) / delta.audio) : 0;
			loss.video = (delta.video > 0) ? Math.ceil(100 * (lost.video - lastlost.video) / delta.video) : 0;
			$(document).trigger('packetloss.jingle', [self.sid, loss]);
		    });
		}
	    }, interval || 3000);
	    return this.statsinterval;
	};

	// BAO

	JingleSession.prototype.setBandwidth = function (sdp) 
	{
	    // remove existing bandwidth lines
	    //sdp = sdp.replace( /b=AS([^\r\n]+\r\n)/g , '');

	    // audio bandwidth 
	    sdp = sdp.replace( /a=mid:audio\r\n/g , 'a=mid:audio\r\nb=AS:' + config.audioBandwidth + '\r\n');

	    // video bandwidth
	    sdp = sdp.replace( /a=mid:video\r\n/g , 'a=mid:video\r\nb=AS:' + config.videoBandwidth + '\r\n');

	    return sdp;
	}


	/**
	 * Strophe.jingle.sdp.util
	 */

	/**
	 * Contains utility classes used in SDP class.
	 *
	 */

	/**
	 * Class holds a=ssrc lines and media type a=mid
	 * @param ssrc synchronization source identifier number(a=ssrc lines from SDP)
	 * @param type media type eg. "audio" or "video"(a=mid frm SDP)
	 * @constructor
	 */
	function ChannelSsrc(ssrc, type) {
	    this.ssrc = ssrc;
	    this.type = type;
	    this.lines = [];
	}

	/**
	 * Class holds a=ssrc-group: lines
	 * @param semantics
	 * @param ssrcs
	 * @constructor
	 */
	function ChannelSsrcGroup(semantics, ssrcs, line) {
	    this.semantics = semantics;
	    this.ssrcs = ssrcs;
	}

	/**
	 * Helper class represents media channel. Is a container for ChannelSsrc, holds channel idx and media type.
	 * @param channelNumber channel idx in SDP media array.
	 * @param mediaType media type(a=mid)
	 * @constructor
	 */
	function MediaChannel(channelNumber, mediaType) {
	    /**
	     * SDP channel number
	     * @type {*}
	     */
	    this.chNumber = channelNumber;
	    /**
	     * Channel media type(a=mid)
	     * @type {*}
	     */
	    this.mediaType = mediaType;
	    /**
	     * The maps of ssrc numbers to ChannelSsrc objects.
	     */
	    this.ssrcs = {};

	    /**
	     * The array of ChannelSsrcGroup objects.
	     * @type {Array}
	     */
	    this.ssrcGroups = [];
	}

	SDPUtil = {
	    iceparams: function (mediadesc, sessiondesc) {
		var data = null;
		if (SDPUtil.find_line(mediadesc, 'a=ice-ufrag:', sessiondesc) &&
		    SDPUtil.find_line(mediadesc, 'a=ice-pwd:', sessiondesc)) {
		    data = {
			ufrag: SDPUtil.parse_iceufrag(SDPUtil.find_line(mediadesc, 'a=ice-ufrag:', sessiondesc)),
			pwd: SDPUtil.parse_icepwd(SDPUtil.find_line(mediadesc, 'a=ice-pwd:', sessiondesc))
		    };
		}
		return data;
	    },
	    parse_iceufrag: function (line) {
		return line.substring(12);
	    },
	    build_iceufrag: function (frag) {
		return 'a=ice-ufrag:' + frag;
	    },
	    parse_icepwd: function (line) {
		return line.substring(10);
	    },
	    build_icepwd: function (pwd) {
		return 'a=ice-pwd:' + pwd;
	    },
	    parse_mid: function (line) {
		return line.substring(6);
	    },
	    parse_mline: function (line) {
		var parts = line.substring(2).split(' '),
		    data = {};
		data.media = parts.shift();
		data.port = parts.shift();
		data.proto = parts.shift();
		if (parts[parts.length - 1] === '') { // trailing whitespace
		    parts.pop();
		}
		data.fmt = parts;
		return data;
	    },
	    build_mline: function (mline) {
		return 'm=' + mline.media + ' ' + mline.port + ' ' + mline.proto + ' ' + mline.fmt.join(' ');
	    },
	    parse_rtpmap: function (line) {
		var parts = line.substring(9).split(' '),
		    data = {};
		data.id = parts.shift();
		parts = parts[0].split('/');
		data.name = parts.shift();
		data.clockrate = parts.shift();
		data.channels = parts.length ? parts.shift() : '1';
		return data;
	    },
	    /**
	     * Parses SDP line "a=sctpmap:..." and extracts SCTP port from it.
	     * @param line eg. "a=sctpmap:5000 webrtc-datachannel"
	     * @returns [SCTP port number, protocol, streams]
	     */
	    parse_sctpmap: function (line)
	    {
		var parts = line.substring(10).split(' ');
		var sctpPort = parts[0];
		var protocol = parts[1];
		// Stream count is optional
		var streamCount = parts.length > 2 ? parts[2] : null;
		return [sctpPort, protocol, streamCount];// SCTP port
	    },
	    build_rtpmap: function (el) {
		var line = 'a=rtpmap:' + el.getAttribute('id') + ' ' + el.getAttribute('name') + '/' + el.getAttribute('clockrate');
		if (el.getAttribute('channels') && el.getAttribute('channels') != '1') {
		    line += '/' + el.getAttribute('channels');
		}
		return line;
	    },
	    parse_crypto: function (line) {
		var parts = line.substring(9).split(' '),
		    data = {};
		data.tag = parts.shift();
		data['crypto-suite'] = parts.shift();
		data['key-params'] = parts.shift();
		if (parts.length) {
		    data['session-params'] = parts.join(' ');
		}
		return data;
	    },
	    parse_fingerprint: function (line) { // RFC 4572
		var parts = line.substring(14).split(' '),
		    data = {};
		data.hash = parts.shift();
		data.fingerprint = parts.shift();
		// TODO assert that fingerprint satisfies 2UHEX *(":" 2UHEX) ?
		return data;
	    },
	    parse_fmtp: function (line) {
		var parts = line.split(' '),
		    i, key, value,
		    data = [];
		parts.shift();
		parts = parts.join(' ').split(';');
		for (i = 0; i < parts.length; i++) {
		    key = parts[i].split('=')[0];
		    while (key.length && key[0] == ' ') {
			key = key.substring(1);
		    }
		    value = parts[i].split('=')[1];
		    if (key && value) {
			data.push({name: key, value: value});
		    } else if (key) {
			// rfc 4733 (DTMF) style stuff
			data.push({name: '', value: key});
		    }
		}
		return data;
	    },
	    parse_icecandidate: function (line) {
		var candidate = {},
		    elems = line.split(' ');
		candidate.foundation = elems[0].substring(12);
		candidate.component = elems[1];
		candidate.protocol = elems[2].toLowerCase();
		candidate.priority = elems[3];
		candidate.ip = elems[4];
		candidate.port = elems[5];
		// elems[6] => "typ"
		candidate.type = elems[7];
		candidate.generation = 0; // default value, may be overwritten below
		for (var i = 8; i < elems.length; i += 2) {
		    switch (elems[i]) {
			case 'raddr':
			    candidate['rel-addr'] = elems[i + 1];
			    break;
			case 'rport':
			    candidate['rel-port'] = elems[i + 1];
			    break;
			case 'generation':
			    candidate.generation = elems[i + 1];
			    break;
			case 'tcptype':
			    candidate.tcptype = elems[i + 1];
			    break;
			default: // TODO
			    //console.log('parse_icecandidate not translating "' + elems[i] + '" = "' + elems[i + 1] + '"');
		    }
		}
		candidate.network = '1';
		candidate.id = Math.random().toString(36).substr(2, 10); // not applicable to SDP -- FIXME: should be unique, not just random
		return candidate;
	    },
	    build_icecandidate: function (cand) {
		var line = ['a=candidate:' + cand.foundation, cand.component, cand.protocol, cand.priority, cand.ip, cand.port, 'typ', cand.type].join(' ');
		line += ' ';
		switch (cand.type) {
		    case 'srflx':
		    case 'prflx':
		    case 'relay':
			if (cand.hasOwnAttribute('rel-addr') && cand.hasOwnAttribute('rel-port')) {
			    line += 'raddr';
			    line += ' ';
			    line += cand['rel-addr'];
			    line += ' ';
			    line += 'rport';
			    line += ' ';
			    line += cand['rel-port'];
			    line += ' ';
			}
			break;
		}
		if (cand.hasOwnAttribute('tcptype')) {
		    line += 'tcptype';
		    line += ' ';
		    line += cand.tcptype;
		    line += ' ';
		}
		line += 'generation';
		line += ' ';
		line += cand.hasOwnAttribute('generation') ? cand.generation : '0';
		return line;
	    },
	    parse_ssrc: function (desc) {
		// proprietary mapping of a=ssrc lines
		// TODO: see "Jingle RTP Source Description" by Juberti and P. Thatcher on google docs
		// and parse according to that
		var lines = desc.split('\r\n'),
		    data = {};
		for (var i = 0; i < lines.length; i++) {
		    if (lines[i].substring(0, 7) == 'a=ssrc:') {
			var idx = lines[i].indexOf(' ');
			data[lines[i].substr(idx + 1).split(':', 2)[0]] = lines[i].substr(idx + 1).split(':', 2)[1];
		    }
		}
		return data;
	    },
	    parse_rtcpfb: function (line) {
		var parts = line.substr(10).split(' ');
		var data = {};
		data.pt = parts.shift();
		data.type = parts.shift();
		data.params = parts;
		return data;
	    },
	    parse_extmap: function (line) {
		var parts = line.substr(9).split(' ');
		var data = {};
		data.value = parts.shift();
		if (data.value.indexOf('/') != -1) {
		    data.direction = data.value.substr(data.value.indexOf('/') + 1);
		    data.value = data.value.substr(0, data.value.indexOf('/'));
		} else {
		    data.direction = 'both';
		}
		data.uri = parts.shift();
		data.params = parts;
		return data;
	    },
	    find_line: function (haystack, needle, sessionpart) {
	    	if (!haystack) return;
		var lines = haystack.split('\r\n');
		for (var i = 0; i < lines.length; i++) {
		    if (lines[i].substring(0, needle.length) == needle) {
			return lines[i];
		    }
		}
		if (!sessionpart) {
		    return false;
		}
		// search session part
		lines = sessionpart.split('\r\n');
		for (var j = 0; j < lines.length; j++) {
		    if (lines[j].substring(0, needle.length) == needle) {
			return lines[j];
		    }
		}
		return false;
	    },
	    find_lines: function (haystack, needle, sessionpart) {
		var lines = haystack.split('\r\n'),
		    needles = [];
		for (var i = 0; i < lines.length; i++) {
		    if (lines[i].substring(0, needle.length) == needle)
			needles.push(lines[i]);
		}
		if (needles.length || !sessionpart) {
		    return needles;
		}
		// search session part
		lines = sessionpart.split('\r\n');
		for (var j = 0; j < lines.length; j++) {
		    if (lines[j].substring(0, needle.length) == needle) {
			needles.push(lines[j]);
		    }
		}
		return needles;
	    },
	    candidateToJingle: function (line) {
		// a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host generation 0
		//      <candidate component=... foundation=... generation=... id=... ip=... network=... port=... priority=... protocol=... type=.../>
		if (line.indexOf('candidate:') === 0) {
		    line = 'a=' + line;
		} else if (line.substring(0, 12) != 'a=candidate:') {
		    //console.log('parseCandidate called with a line that is not a candidate line');
		    //console.log(line);
		    return null;
		}
		if (line.substring(line.length - 2) == '\r\n') // chomp it
		    line = line.substring(0, line.length - 2);
		var candidate = {},
		    elems = line.split(' '),
		    i;
		if (elems[6] != 'typ') {
		    //console.log('did not find typ in the right place');
		    //console.log(line);
		    return null;
		}
		candidate.foundation = elems[0].substring(12);
		candidate.component = elems[1];
		candidate.protocol = elems[2].toLowerCase();
		candidate.priority = elems[3];
		candidate.ip = elems[4];
		candidate.port = elems[5];
		// elems[6] => "typ"
		candidate.type = elems[7];

		candidate.generation = '0'; // default, may be overwritten below
		for (i = 8; i < elems.length; i += 2) {
		    switch (elems[i]) {
			case 'raddr':
			    candidate['rel-addr'] = elems[i + 1];
			    break;
			case 'rport':
			    candidate['rel-port'] = elems[i + 1];
			    break;
			case 'generation':
			    candidate.generation = elems[i + 1];
			    break;
			case 'tcptype':
			    candidate.tcptype = elems[i + 1];
			    break;
			default: // TODO
			    //console.log('not translating "' + elems[i] + '" = "' + elems[i + 1] + '"');
		    }
		}
		candidate.network = '1';
		candidate.id = Math.random().toString(36).substr(2, 10); // not applicable to SDP -- FIXME: should be unique, not just random
		return candidate;
	    },
	    candidateFromJingle: function (cand) {
		var line = 'a=candidate:';
		line += cand.getAttribute('foundation');
		line += ' ';
		line += cand.getAttribute('component');
		line += ' ';
		line += cand.getAttribute('protocol'); //.toUpperCase(); // chrome M23 doesn't like this
		line += ' ';
		line += cand.getAttribute('priority');
		line += ' ';
		line += cand.getAttribute('ip');
		line += ' ';
		line += cand.getAttribute('port');
		line += ' ';
		line += 'typ';
		line += ' ' + cand.getAttribute('type');
		line += ' ';
		switch (cand.getAttribute('type')) {
		    case 'srflx':
		    case 'prflx':
		    case 'relay':
			if (cand.getAttribute('rel-addr') && cand.getAttribute('rel-port')) {
			    line += 'raddr';
			    line += ' ';
			    line += cand.getAttribute('rel-addr');
			    line += ' ';
			    line += 'rport';
			    line += ' ';
			    line += cand.getAttribute('rel-port');
			    line += ' ';
			}
			break;
		}
		if (cand.getAttribute('protocol').toLowerCase() == 'tcp') {
		    line += 'tcptype';
		    line += ' ';
		    line += cand.getAttribute('tcptype');
		    line += ' ';
		}
		line += 'generation';
		line += ' ';
		line += cand.getAttribute('generation') || '0';
		return line + '\r\n';
	    }
	};



	/**
	 * Strophe.jingle.sdp
	 */

	function SDP(sdp) {
	    this.media = sdp.split('\r\nm=');
	    for (var i = 1; i < this.media.length; i++) {
		this.media[i] = 'm=' + this.media[i];
		if (i != this.media.length - 1) {
		    this.media[i] += '\r\n';
		}
	    }
	    this.session = this.media.shift() + '\r\n';
	    this.raw = this.session + this.media.join('');
	}
	/**
	 * Returns map of MediaChannel mapped per channel idx.
	 */
	SDP.prototype.getMediaSsrcMap = function() {
	    var self = this;
	    var media_ssrcs = {};
	    for (channelNum = 0; channelNum < self.media.length; channelNum++) {
		modified = true;
		tmp = SDPUtil.find_lines(self.media[channelNum], 'a=ssrc:');
		var type = SDPUtil.parse_mid(SDPUtil.find_line(self.media[channelNum], 'a=mid:'));
		var channel = new MediaChannel(channelNum, type);
		media_ssrcs[channelNum] = channel;
		tmp.forEach(function (line) {
		    var linessrc = line.substring(7).split(' ')[0];
		    // allocate new ChannelSsrc
		    if(!channel.ssrcs[linessrc]) {
			channel.ssrcs[linessrc] = new ChannelSsrc(linessrc, type);
		    }
		    channel.ssrcs[linessrc].lines.push(line);
		});
		tmp = SDPUtil.find_lines(self.media[channelNum], 'a=ssrc-group:');
		tmp.forEach(function(line){
		    var semantics = line.substr(0, idx).substr(13);
		    var ssrcs = line.substr(14 + semantics.length).split(' ');
		    if (ssrcs.length != 0) {
			var ssrcGroup = new ChannelSsrcGroup(semantics, ssrcs);
			channel.ssrcGroups.push(ssrcGroup);
		    }
		});
	    }
	    return media_ssrcs;
	};
	/**
	 * Returns <tt>true</tt> if this SDP contains given SSRC.
	 * @param ssrc the ssrc to check.
	 * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.
	 */
	SDP.prototype.containsSSRC = function(ssrc) {
	    var channels = this.getMediaSsrcMap();
	    var contains = false;
	    Object.keys(channels).forEach(function(chNumber){
		var channel = channels[chNumber];
		//console.log("Check", channel, ssrc);
		if(Object.keys(channel.ssrcs).indexOf(ssrc) != -1){
		    contains = true;
		}
	    });
	    return contains;
	};

	/**
	 * Returns map of MediaChannel that contains only media not contained in <tt>otherSdp</tt>. Mapped by channel idx.
	 * @param otherSdp the other SDP to check ssrc with.
	 */
	SDP.prototype.getNewMedia = function(otherSdp) {

	    // this could be useful in Array.prototype.
	    function arrayEquals(array) {
		// if the other array is a falsy value, return
		if (!array)
		    return false;

		// compare lengths - can save a lot of time
		if (this.length != array.length)
		    return false;

		for (var i = 0, l=this.length; i < l; i++) {
		    // Check if we have nested arrays
		    if (this[i] instanceof Array && array[i] instanceof Array) {
			// recurse into the nested arrays
			if (!this[i].equals(array[i]))
			    return false;
		    }
		    else if (this[i] != array[i]) {
			// Warning - two different object instances will never be equal: {x:20} != {x:20}
			return false;
		    }
		}
		return true;
	    }

	    var myMedia = this.getMediaSsrcMap();
	    var othersMedia = otherSdp.getMediaSsrcMap();
	    var newMedia = {};
	    Object.keys(othersMedia).forEach(function(channelNum) {
		var myChannel = myMedia[channelNum];
		var othersChannel = othersMedia[channelNum];
		if(!myChannel && othersChannel) {
		    // Add whole channel
		    newMedia[channelNum] = othersChannel;
		    return;
		}
		// Look for new ssrcs accross the channel
		Object.keys(othersChannel.ssrcs).forEach(function(ssrc) {
		    if(Object.keys(myChannel.ssrcs).indexOf(ssrc) === -1) {
			// Allocate channel if we've found ssrc that doesn't exist in our channel
			if(!newMedia[channelNum]){
			    newMedia[channelNum] = new MediaChannel(othersChannel.chNumber, othersChannel.mediaType);
			}
			newMedia[channelNum].ssrcs[ssrc] = othersChannel.ssrcs[ssrc];
		    }
		});

		// Look for new ssrc groups across the channels
		othersChannel.ssrcGroups.forEach(function(otherSsrcGroup){

		    // try to match the other ssrc-group with an ssrc-group of ours
		    var matched = false;
		    for (var i = 0; i < myChannel.ssrcGroups.length; i++) {
			var mySsrcGroup = myChannel.ssrcGroups[i];
			if (otherSsrcGroup.semantics == mySsrcGroup.semantics
			    && arrayEquals.apply(otherSsrcGroup.ssrcs, [mySsrcGroup.ssrcs])) {

			    matched = true;
			    break;
			}
		    }

		    if (!matched) {
			// Allocate channel if we've found an ssrc-group that doesn't
			// exist in our channel

			if(!newMedia[channelNum]){
			    newMedia[channelNum] = new MediaChannel(othersChannel.chNumber, othersChannel.mediaType);
			}
			newMedia[channelNum].ssrcGroups.push(otherSsrcGroup);
		    }
		});
	    });
	    return newMedia;
	};

	// remove iSAC and CN from SDP
	SDP.prototype.mangle = function () {
	    var i, j, mline, lines, rtpmap, newdesc;
	    for (i = 0; i < this.media.length; i++) {
		lines = this.media[i].split('\r\n');
		lines.pop(); // remove empty last element
		mline = SDPUtil.parse_mline(lines.shift());
		if (mline.media != 'audio')
		    continue;
		newdesc = '';
		mline.fmt.length = 0;
		for (j = 0; j < lines.length; j++) {
		    if (lines[j].substr(0, 9) == 'a=rtpmap:') {
			rtpmap = SDPUtil.parse_rtpmap(lines[j]);
			if (rtpmap.name == 'CN' || rtpmap.name == 'ISAC')
			    continue;
			mline.fmt.push(rtpmap.id);
			newdesc += lines[j] + '\r\n';
		    } else {
			newdesc += lines[j] + '\r\n';
		    }
		}
		this.media[i] = SDPUtil.build_mline(mline) + '\r\n';
		this.media[i] += newdesc;
	    }
	    this.raw = this.session + this.media.join('');
	};

	// remove lines matching prefix from session section
	SDP.prototype.removeSessionLines = function(prefix) {
	    var self = this;
	    var lines = SDPUtil.find_lines(this.session, prefix);
	    lines.forEach(function(line) {
		self.session = self.session.replace(line + '\r\n', '');
	    });
	    this.raw = this.session + this.media.join('');
	    return lines;
	}
	// remove lines matching prefix from a media section specified by mediaindex
	// TODO: non-numeric mediaindex could match mid
	SDP.prototype.removeMediaLines = function(mediaindex, prefix) {
	    var self = this;
	    var lines = SDPUtil.find_lines(this.media[mediaindex], prefix);
	    lines.forEach(function(line) {
		self.media[mediaindex] = self.media[mediaindex].replace(line + '\r\n', '');
	    });
	    this.raw = this.session + this.media.join('');
	    return lines;
	}

	// add content's to a jingle element
	SDP.prototype.toJingle = function (elem, thecreator, ssrcs) {
	//    //console.log("SSRC" + ssrcs["audio"] + " - " + ssrcs["video"]);
	    var i, j, k, mline, ssrc, rtpmap, tmp, line, lines;
	    var self = this;
	    // new bundle plan
	    if (SDPUtil.find_line(this.session, 'a=group:')) {
		lines = SDPUtil.find_lines(this.session, 'a=group:');
		for (i = 0; i < lines.length; i++) {
		    tmp = lines[i].split(' ');
		    var semantics = tmp.shift().substr(8);
		    elem.c('group', {xmlns: 'urn:xmpp:jingle:apps:grouping:0', semantics:semantics});
		    for (j = 0; j < tmp.length; j++) {
			elem.c('content', {name: tmp[j]}).up();
		    }
		    elem.up();
		}
	    }
	    for (i = 0; i < this.media.length; i++) {
		mline = SDPUtil.parse_mline(this.media[i].split('\r\n')[0]);
		if (!(mline.media === 'audio' ||
		      mline.media === 'video' ||
		      mline.media === 'application'))
		{
		    continue;
		}
		if (SDPUtil.find_line(this.media[i], 'a=ssrc:')) {
		    ssrc = SDPUtil.find_line(this.media[i], 'a=ssrc:').substring(7).split(' ')[0]; // take the first
		} else {
		    if(ssrcs && ssrcs[mline.media])
		    {
			ssrc = ssrcs[mline.media];
		    }
		    else
			ssrc = false;
		}

		elem.c('content', {creator: thecreator, name: mline.media});
		if (SDPUtil.find_line(this.media[i], 'a=mid:')) {
		    // prefer identifier from a=mid if present
		    var mid = SDPUtil.parse_mid(SDPUtil.find_line(this.media[i], 'a=mid:'));
		    elem.attrs({ name: mid });
		}

		if (SDPUtil.find_line(this.media[i], 'a=rtpmap:').length)
		{
		    elem.c('description',
			{xmlns: 'urn:xmpp:jingle:apps:rtp:1',
			    media: mline.media });
		    if (ssrc) {
			elem.attrs({ssrc: ssrc});
		    }
		    for (j = 0; j < mline.fmt.length; j++) {
			rtpmap = SDPUtil.find_line(this.media[i], 'a=rtpmap:' + mline.fmt[j]);
			elem.c('payload-type', SDPUtil.parse_rtpmap(rtpmap));
			// put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo value=bar/>
			if (SDPUtil.find_line(this.media[i], 'a=fmtp:' + mline.fmt[j])) {
			    tmp = SDPUtil.parse_fmtp(SDPUtil.find_line(this.media[i], 'a=fmtp:' + mline.fmt[j]));
			    for (k = 0; k < tmp.length; k++) {
				elem.c('parameter', tmp[k]).up();
			    }
			}
			this.RtcpFbToJingle(i, elem, mline.fmt[j]); // XEP-0293 -- map a=rtcp-fb

			elem.up();
		    }
		    if (SDPUtil.find_line(this.media[i], 'a=crypto:', this.session)) {
			elem.c('encryption', {required: 1});
			var crypto = SDPUtil.find_lines(this.media[i], 'a=crypto:', this.session);
			crypto.forEach(function(line) {
			    elem.c('crypto', SDPUtil.parse_crypto(line)).up();
			});
			elem.up(); // end of encryption
		    }

		    if (ssrc) {
			// new style mapping
			elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
			// FIXME: group by ssrc and support multiple different ssrcs
			var ssrclines = SDPUtil.find_lines(this.media[i], 'a=ssrc:');
			if(ssrclines.length > 0) {
			    ssrclines.forEach(function (line) {
				idx = line.indexOf(' ');
				var linessrc = line.substr(0, idx).substr(7);
				if (linessrc != ssrc) {
				    elem.up();
				    ssrc = linessrc;
				    elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
				}
				var kv = line.substr(idx + 1);
				elem.c('parameter');
				if (kv.indexOf(':') == -1) {
				    elem.attrs({ name: kv });
				} else {
				    elem.attrs({ name: kv.split(':', 2)[0] });
				    elem.attrs({ value: kv.split(':', 2)[1] });
				}
				elem.up();
			    });
			    elem.up();
			}
			else
			{
			    elem.up();
			    elem.c('source', { ssrc: ssrc, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
			    elem.c('parameter');
			    elem.attrs({name: "cname", value:Math.random().toString(36).substring(7)});
			    elem.up();
			    var msid = null;
			    if(mline.media == "audio")
			    {
				msid = connection.jingle.localAudio.getAudioTracks()[0].id;
			    }
			    else
			    {
				msid = connection.jingle.localVideo.getVideoTracks()[0].id;
			    }
			    if(msid != null)
			    {
				msid = msid.replace(/[\{,\}]/g,"");
				elem.c('parameter');
				elem.attrs({name: "msid", value:msid});
				elem.up();
				elem.c('parameter');
				elem.attrs({name: "mslabel", value:msid});
				elem.up();
				elem.c('parameter');
				elem.attrs({name: "label", value:msid});
				elem.up();
				elem.up();
			    }


			}

			// XEP-0339 handle ssrc-group attributes
			var ssrc_group_lines = SDPUtil.find_lines(this.media[i], 'a=ssrc-group:');
			ssrc_group_lines.forEach(function(line) {
			    idx = line.indexOf(' ');
			    var semantics = line.substr(0, idx).substr(13);
			    var ssrcs = line.substr(14 + semantics.length).split(' ');
			    if (ssrcs.length != 0) {
				elem.c('ssrc-group', { semantics: semantics, xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });
				ssrcs.forEach(function(ssrc) {
				    elem.c('source', { ssrc: ssrc })
					.up();
				});
				elem.up();
			    }
			});
		    }

		    if (SDPUtil.find_line(this.media[i], 'a=rtcp-mux')) {
			elem.c('rtcp-mux').up();
		    }

		    // XEP-0293 -- map a=rtcp-fb:*
		    this.RtcpFbToJingle(i, elem, '*');

		    // XEP-0294
		    if (SDPUtil.find_line(this.media[i], 'a=extmap:')) {
			lines = SDPUtil.find_lines(this.media[i], 'a=extmap:');
			for (j = 0; j < lines.length; j++) {
			    tmp = SDPUtil.parse_extmap(lines[j]);
			    elem.c('rtp-hdrext', { xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
				uri: tmp.uri,
				id: tmp.value });
			    if (tmp.hasOwnProperty('direction')) {
				switch (tmp.direction) {
				    case 'sendonly':
					elem.attrs({senders: 'responder'});
					break;
				    case 'recvonly':
					elem.attrs({senders: 'initiator'});
					break;
				    case 'sendrecv':
					elem.attrs({senders: 'both'});
					break;
				    case 'inactive':
					elem.attrs({senders: 'none'});
					break;
				}
			    }
			    // TODO: handle params
			    elem.up();
			}
		    }
		    elem.up(); // end of description
		}

		// map ice-ufrag/pwd, dtls fingerprint, candidates
		this.TransportToJingle(i, elem);

		if (SDPUtil.find_line(this.media[i], 'a=sendrecv', this.session)) {
		    elem.attrs({senders: 'both'});
		} else if (SDPUtil.find_line(this.media[i], 'a=sendonly', this.session)) {
		    elem.attrs({senders: 'initiator'});
		} else if (SDPUtil.find_line(this.media[i], 'a=recvonly', this.session)) {
		    elem.attrs({senders: 'responder'});
		} else if (SDPUtil.find_line(this.media[i], 'a=inactive', this.session)) {
		    elem.attrs({senders: 'none'});
		}
		if (mline.port == '0') {
		    // estos hack to reject an m-line
		    elem.attrs({senders: 'rejected'});
		}
		elem.up(); // end of content
	    }
	    elem.up();
	    return elem;
	};

	SDP.prototype.TransportToJingle = function (mediaindex, elem) {
	    var i = mediaindex;
	    var tmp;
	    var self = this;
	    elem.c('transport');

	    // XEP-0343 DTLS/SCTP
	    if (SDPUtil.find_line(this.media[mediaindex], 'a=sctpmap:').length)
	    {
		var sctpmap = SDPUtil.find_line(
		    this.media[i], 'a=sctpmap:', self.session);
		if (sctpmap)
		{
		    var sctpAttrs = SDPUtil.parse_sctpmap(sctpmap);
		    elem.c('sctpmap',
			{
			    xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',
			    number: sctpAttrs[0], /* SCTP port */
			    protocol: sctpAttrs[1], /* protocol */
			});
		    // Optional stream count attribute
		    if (sctpAttrs.length > 2)
			elem.attrs({ streams: sctpAttrs[2]});
		    elem.up();
		}
	    }
	    // XEP-0320
	    var fingerprints = SDPUtil.find_lines(this.media[mediaindex], 'a=fingerprint:', this.session);
	    fingerprints.forEach(function(line) {
		tmp = SDPUtil.parse_fingerprint(line);
		tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';
		elem.c('fingerprint').t(tmp.fingerprint);
		delete tmp.fingerprint;
		line = SDPUtil.find_line(self.media[mediaindex], 'a=setup:', self.session);
		if (line) {
		    tmp.setup = line.substr(8);
		}
		elem.attrs(tmp);
		elem.up(); // end of fingerprint
	    });
	    tmp = SDPUtil.iceparams(this.media[mediaindex], this.session);
	    if (tmp) {
		tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';
		elem.attrs(tmp);
		// XEP-0176
		if (SDPUtil.find_line(this.media[mediaindex], 'a=candidate:', this.session)) { // add any a=candidate lines
		    var lines = SDPUtil.find_lines(this.media[mediaindex], 'a=candidate:', this.session);
		    lines.forEach(function (line) {
			elem.c('candidate', SDPUtil.candidateToJingle(line)).up();
		    });
		}
	    }
	    elem.up(); // end of transport
	}

	SDP.prototype.RtcpFbToJingle = function (mediaindex, elem, payloadtype) { // XEP-0293
	    var lines = SDPUtil.find_lines(this.media[mediaindex], 'a=rtcp-fb:' + payloadtype);
	    lines.forEach(function (line) {
		var tmp = SDPUtil.parse_rtcpfb(line);
		if (tmp.type == 'trr-int') {
		    elem.c('rtcp-fb-trr-int', {xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0', value: tmp.params[0]});
		    elem.up();
		} else {
		    elem.c('rtcp-fb', {xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0', type: tmp.type});
		    if (tmp.params.length > 0) {
			elem.attrs({'subtype': tmp.params[0]});
		    }
		    elem.up();
		}
	    });
	};

	SDP.prototype.RtcpFbFromJingle = function (elem, payloadtype) { // XEP-0293
	    var media = '';
	    var tmp = elem.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
	    if (tmp.length) {
		media += 'a=rtcp-fb:' + '*' + ' ' + 'trr-int' + ' ';
		if (tmp.attr('value')) {
		    media += tmp.attr('value');
		} else {
		    media += '0';
		}
		media += '\r\n';
	    }
	    tmp = elem.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
	    tmp.each(function () {
		media += 'a=rtcp-fb:' + payloadtype + ' ' + $(this).attr('type');
		if ($(this).attr('subtype')) {
		    media += ' ' + $(this).attr('subtype');
		}
		media += '\r\n';
	    });
	    return media;
	};

	// construct an SDP from a jingle stanza
	SDP.prototype.fromJingle = function (jingle) {
	    var self = this;
	    this.raw = 'v=0\r\n' +
		'o=- ' + '1923518516' + ' 2 IN IP4 0.0.0.0\r\n' +// FIXME
		's=-\r\n' +
		't=0 0\r\n';
	    // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04#section-8
	    if ($(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]').length) {
		$(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]').each(function (idx, group) {
		    var contents = $(group).find('>content').map(function (idx, content) {
			return content.getAttribute('name');
		    }).get();
		    if (contents.length > 0) {
			self.raw += 'a=group:' + (group.getAttribute('semantics') || group.getAttribute('type')) + ' ' + contents.join(' ') + '\r\n';
		    }
		});
	    }

	    this.session = this.raw;
	    jingle.find('>content').each(function () {
		var m = self.jingle2media($(this));
		self.media.push(m);
	    });

	    // reconstruct msid-semantic -- apparently not necessary
	    /*
	     var msid = SDPUtil.parse_ssrc(this.raw);
	     if (msid.hasOwnProperty('mslabel')) {
	     this.session += "a=msid-semantic: WMS " + msid.mslabel + "\r\n";
	     }
	     */

	    this.raw = this.session + this.media.join('');
	};

	// translate a jingle content element into an an SDP media part
	SDP.prototype.jingle2media = function (content) {
	    var media = '',
		desc = content.find('description'),
		ssrc = desc.attr('ssrc'),
		self = this,
		tmp;
	    var sctp = content.find(
		'>transport>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]');

	    tmp = { media: desc.attr('media') };
	    tmp.port = '1';
	    if (content.attr('senders') == 'rejected') {
		// estos hack to reject an m-line.
		tmp.port = '0';
	    }
	    if (content.find('>transport>fingerprint').length || desc.find('encryption').length) {
		if (sctp.length)
		    tmp.proto = 'DTLS/SCTP';
		else
		    tmp.proto = 'RTP/SAVPF';
	    } else {
		tmp.proto = 'RTP/AVPF';
	    }
	    if (!sctp.length)
	    {
		tmp.fmt = desc.find('payload-type').map(
		    function () { return this.getAttribute('id'); }).get();
		media += SDPUtil.build_mline(tmp) + '\r\n';
	    }
	    else
	    {
		media += 'm=application 1 DTLS/SCTP ' + sctp.attr('number') + '\r\n';
		media += 'a=sctpmap:' + sctp.attr('number') +
		    ' ' + sctp.attr('protocol');

		var streamCount = sctp.attr('streams');
		if (streamCount)
		    media += ' ' + streamCount + '\r\n';
		else
		    media += '\r\n';
	    }

	    media += 'c=IN IP4 0.0.0.0\r\n';
	    if (!sctp.length)
		media += 'a=rtcp:1 IN IP4 0.0.0.0\r\n';
	    tmp = content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
	    if (tmp.length) {
		if (tmp.attr('ufrag')) {
		    media += SDPUtil.build_iceufrag(tmp.attr('ufrag')) + '\r\n';
		}
		if (tmp.attr('pwd')) {
		    media += SDPUtil.build_icepwd(tmp.attr('pwd')) + '\r\n';
		}
		tmp.find('>fingerprint').each(function () {
		    // FIXME: check namespace at some point
		    media += 'a=fingerprint:' + this.getAttribute('hash');
		    media += ' ' + $(this).text();
		    media += '\r\n';
		    if (this.getAttribute('setup')) {
			media += 'a=setup:' + this.getAttribute('setup') + '\r\n';
		    }
		});
	    }
	    switch (content.attr('senders')) {
		case 'initiator':
		    media += 'a=sendonly\r\n';
		    break;
		case 'responder':
		    media += 'a=recvonly\r\n';
		    break;
		case 'none':
		    media += 'a=inactive\r\n';
		    break;
		case 'both':
		    media += 'a=sendrecv\r\n';
		    break;
	    }
	    media += 'a=mid:' + content.attr('name') + '\r\n';

	    // <description><rtcp-mux/></description>
	    // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec though
	    // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html
	    if (desc.find('rtcp-mux').length) {
		media += 'a=rtcp-mux\r\n';
	    }

	    if (desc.find('encryption').length) {
		desc.find('encryption>crypto').each(function () {
		    media += 'a=crypto:' + this.getAttribute('tag');
		    media += ' ' + this.getAttribute('crypto-suite');
		    media += ' ' + this.getAttribute('key-params');
		    if (this.getAttribute('session-params')) {
			media += ' ' + this.getAttribute('session-params');
		    }
		    media += '\r\n';
		});
	    }
	    desc.find('payload-type').each(function () {
		media += SDPUtil.build_rtpmap(this) + '\r\n';
		if ($(this).find('>parameter').length) {
		    media += 'a=fmtp:' + this.getAttribute('id') + ' ';
		    media += $(this).find('parameter').map(function () { return (this.getAttribute('name') ? (this.getAttribute('name') + '=') : '') + this.getAttribute('value'); }).get().join('; ');
		    media += '\r\n';
		}
		// xep-0293
		media += self.RtcpFbFromJingle($(this), this.getAttribute('id'));
	    });

	    // xep-0293
	    media += self.RtcpFbFromJingle(desc, '*');

	    // xep-0294
	    tmp = desc.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]');
	    tmp.each(function () {
		media += 'a=extmap:' + this.getAttribute('id') + ' ' + this.getAttribute('uri') + '\r\n';
	    });

	    content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]>candidate').each(function () {
		media += SDPUtil.candidateFromJingle(this);
	    });

	    // XEP-0339 handle ssrc-group attributes
	    tmp = content.find('description>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
		var semantics = this.getAttribute('semantics');
		var ssrcs = $(this).find('>source').map(function() {
		    return this.getAttribute('ssrc');
		}).get();

		if (ssrcs.length != 0) {
		    media += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
		}
	    });

	    tmp = content.find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
	    tmp.each(function () {
		var ssrc = this.getAttribute('ssrc');
		$(this).find('>parameter').each(function () {
		    media += 'a=ssrc:' + ssrc + ' ' + this.getAttribute('name');
		    if (this.getAttribute('value') && this.getAttribute('value').length)
			media += ':' + this.getAttribute('value');
		    media += '\r\n';
		});
	    });

	    return media;
	};

	// http://xmpp.org/extensions/xep-0059.html

	(function (root, factory) {
	    if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define("strophe.rsm", [
		    "strophe"
		], function (Strophe) {
		    factory(
			Strophe.Strophe,
			Strophe.$build,
			Strophe.$iq ,
			Strophe.$msg,
			Strophe.$pres
		    );
		    return Strophe;
		});
	    } else {
		// Browser globals
		factory(
		    root.Strophe,
		    root.$build,
		    root.$iq ,
		    root.$msg,
		    root.$pres
		);
	    }
	}(this, function (Strophe, $build, $iq, $msg, $pres) {

	Strophe.addNamespace('RSM', 'http://jabber.org/protocol/rsm');

	Strophe.RSM = function(options) {
	  this.attribs = ['max', 'first', 'last', 'after', 'before', 'index', 'count'];

	  if (typeof options.xml != 'undefined') {
	    this.fromXMLElement(options.xml);
	  } else {
	    for (var ii = 0; ii < this.attribs.length; ii++) {
	      var attrib = this.attribs[ii];
	      this[attrib] = options[attrib];
	    }
	  }
	};

	Strophe.RSM.prototype = {
	  toXML: function() {
	    var xml = $build('set', {xmlns: Strophe.NS.RSM});
	    for (var ii = 0; ii < this.attribs.length; ii++) {
	      var attrib = this.attribs[ii];
	      if (typeof this[attrib] != 'undefined') {
		xml = xml.c(attrib).t(this[attrib].toString()).up();
	      }
	    }
	    return xml.tree();
	  },

	  next: function(max) {
	    var newSet = new Strophe.RSM({max: max, after: this.last});
	    return newSet;
	  },

	  previous: function(max) {
	    var newSet = new Strophe.RSM({max: max, before: this.first});
	    return newSet;
	  },

	  fromXMLElement: function(xmlElement) {
	    for (var ii = 0; ii < this.attribs.length; ii++) {
	      var attrib = this.attribs[ii];
	      var elem = xmlElement.getElementsByTagName(attrib)[0];
	      if (typeof elem != 'undefined' && elem !== null) {
		this[attrib] = Strophe.getText(elem);
		if (attrib == 'first') {
		  this.index = elem.getAttribute('index');
		}
	      }
	    }
	  }
	};
	}));
	

	Strophe.addConnectionPlugin('mam', {
	    _c: null,
	    _p: [ 'with', 'start', 'end' ],
	    init: function (conn) {
		this._c = conn;
		Strophe.addNamespace('MAM', 'urn:xmpp:mam:0');
		console.log("strophe plugin mam enabled");
	    },
	    query: function (jid, options) {
	    	console.log("mam query", jid, options);
	    	
		var _p = this._p;
		var attr = {
		    type:'set',
		    id:jid
		};
		var mamAttr = {xmlns: Strophe.NS.MAM};
		if (!!options['queryid']) {
		    mamAttr.queryid = options['queryid'];
		    delete options['queryid'];
		}
		var iq = $iq(attr).c('query', mamAttr).c('x',{xmlns:'jabber:x:data', type:'submit'});

		iq.c('field',{var:'FORM_TYPE', type:'hidden'}).c('value').t('urn:xmpp:mam:0').up().up();
		var i;
		for (i = 0; i < this._p.length; i++) {
		    var pn = _p[i];
		    var p = options[pn];
		    delete options[pn];
		    if (!!p) {
			iq.c('field',{var:pn}).c('value').t(p).up().up();
		    }
		}
		iq.up();

		var onMessage = options['onMessage'];
		delete options['onMessage'];
		
		var onComplete = options['onComplete'];		
		delete options['onComplete'];
		
		var onError = options['onError'];
		delete options['onError'];
		
		iq.cnode(new Strophe.RSM(options).toXML());

		this._c.addHandler(onMessage, Strophe.NS.MAM, 'message', null);
		return this._c.sendIQ(iq, onComplete, onError);
	    }
	});	
	
	 /**
	  * Roster Plugin
	  * Allow easily roster management
	  *
	  *  Features
	  *  * Get roster from server
	  *  * handle presence
	  *  * handle roster iq
	  *  * subscribe/unsubscribe
	  *  * authorize/unauthorize
	  *  * roster versioning (xep 237)
	  */
	  
	 Strophe.addConnectionPlugin('roster',
	 {
	     /** Function: init
	      * Plugin init
	      *
	      * Parameters:
	      *   (Strophe.Connection) conn - Strophe connection
	      */
	     init: function(conn)
	     {
		 this._connection = conn;
		 this._callbacks = [];
		 /** Property: items
		  * Roster items
		  * [
		  *    {
		  *        name         : "",
		  *        jid          : "",
		  *        subscription : "",
		  *        ask          : "",
		  *        groups       : ["", ""],
		  *        resources    : {
		  *            myresource : {
		  *                show   : "",
		  *                status : "",
		  *                priority : ""
		  *            }
		  *        }
		  *    }
		  * ]
		  */
		 this.items = [];
		       /** Property: ver
			* current roster revision
			* always null if server doesn't support xep 237
			*/
		 ver = null;
		 // Override the connect and attach methods to always add presence and roster handlers.
		 // They are removed when the connection disconnects, so must be added on connection.
		 var oldCallback, roster = this, _connect = conn.connect, _attach = conn.attach;
		 var newCallback = function(status)
		 {
		     if (status == Strophe.Status.ATTACHED || status == Strophe.Status.CONNECTED)
		     {
			 try
			 {
			     // Presence subscription
			     conn.addHandler(roster._onReceivePresence.bind(roster), null, 'presence', null, null, null);
			     conn.addHandler(roster._onReceiveIQ.bind(roster), Strophe.NS.ROSTER, 'iq', "set", null, null);
			 }
			 catch (e)
			 {
			     Strophe.error(e);
			 }
		     }
		     
		     if (oldCallback && status == Strophe.Status.CONNECTED)  oldCallback.apply(this, arguments);
		 };
		 conn.connect = function(jid, pass, callback, wait, hold)
		 {
		     if (!oldCallback) oldCallback = callback;
		     
		     if (typeof jid  == "undefined")
			 jid  = null;
		     if (typeof pass == "undefined")
			 pass = null;
		     callback = newCallback;
		     _connect.apply(conn, [jid, pass, callback, wait, hold]);
		 };
		 conn.attach = function(jid, sid, rid, callback, wait, hold, wind)
		 {
		     if (!oldCallback) oldCallback = callback;
		     
		     if (typeof jid == "undefined")
			 jid = null;
		     if (typeof sid == "undefined")
			 sid = null;
		     if (typeof rid == "undefined")
			 rid = null;
		     callback = newCallback;
		     _attach.apply(conn, [jid, sid, rid, callback, wait, hold, wind]);
		 };

		 Strophe.addNamespace('ROSTER_VER', 'urn:xmpp:features:rosterver');
		 Strophe.addNamespace('NICK', 'http://jabber.org/protocol/nick');

		 console.log("strophe plugin: roster enabled");        
	     },
	     /** Function: supportVersioning
	      * return true if roster versioning is enabled on server
	      */
	     supportVersioning: function()
	     {
		 return (this._connection.features && this._connection.features.getElementsByTagName('ver').length > 0);
	     },
	     /** Function: get
	      * Get Roster on server
	      *
	      * Parameters:
	      *   (Function) userCallback - callback on roster result
	      *   (String) ver - current rev of roster
	      *      (only used if roster versioning is enabled)
	      *   (Array) items - initial items of ver
	      *      (only used if roster versioning is enabled)
	      *     In browser context you can use sessionStorage
	      *     to store your roster in json (JSON.stringify())
	      */
	     get: function(userCallback, ver, items)
	     {
		 var attrs = {xmlns: Strophe.NS.ROSTER};
		 //this.items = [];
		 if (this.supportVersioning())
		 {
		     // empty rev because i want an rev attribute in the result
		     attrs.ver = ver || '';
		     this.items = items || [];
		 }
		 var iq = $iq({type: 'get',  'id' : this._connection.getUniqueId('roster')}).c('query', attrs);
		 return this._connection.sendIQ(iq,
					 this._onReceiveRosterSuccess.bind(this, userCallback),
					 this._onReceiveRosterError.bind(this, userCallback));
	     },
	     /** Function: registerCallback
	      * register callback on roster (presence and iq)
	      *
	      * Parameters:
	      *   (Function) call_back
	      */
	     registerCallback: function(call_back)
	     {
		 this._callbacks.push(call_back);
	     },
	     /** Function: findItem
	      * Find item by JID
	      *
	      * Parameters:
	      *     (String) jid
	      */
	     findItem : function(jid)
	     {
		if (this.items)
		{
			for (var i = 0; i < this.items.length; i++)
			{
			    if (this.items[i] && this.items[i].jid == jid)
			    {
				return this.items[i];
			    }
			}
		}
		 return false;
	     },
	     /** Function: removeItem
	      * Remove item by JID
	      *
	      * Parameters:
	      *     (String) jid
	      */
	     removeItem : function(jid)
	     {
		 for (var i = 0; i < this.items.length; i++)
		 {
		     if (this.items[i] && this.items[i].jid == jid)
		     {
			 this.items.splice(i, 1);
			 return true;
		     }
		 }
		 return false;
	     },
	     /** Function: subscribe
	      * Subscribe presence
	      *
	      * Parameters:
	      *     (String) jid
	      *     (String) message (optional)
	      *     (String) nick  (optional)
	      */
	     subscribe: function(jid, message, nick) {
		 var pres = $pres({to: jid, type: "subscribe"});
		 if (message && message !== "") {
		     pres.c("status").t(message).up();
		 }
		 if (nick && nick !== "") {
		     pres.c('nick', {'xmlns': Strophe.NS.NICK}).t(nick).up();
		 }
		 this._connection.send(pres);
	     },
	     /** Function: unsubscribe
	      * Unsubscribe presence
	      *
	      * Parameters:
	      *     (String) jid
	      *     (String) message
	      */
	     unsubscribe: function(jid, message)
	     {
		 var pres = $pres({to: jid, type: "unsubscribe"});
		 if (message && message !== "")
		     pres.c("status").t(message);
		 this._connection.send(pres);
	     },
	     /** Function: authorize
	      * Authorize presence subscription
	      *
	      * Parameters:
	      *     (String) jid
	      *     (String) message
	      */
	     authorize: function(jid, message)
	     {
		 var pres = $pres({to: jid, type: "subscribed"});
		 if (message && message !== "")
		     pres.c("status").t(message);
		 this._connection.send(pres);
	     },
	     /** Function: unauthorize
	      * Unauthorize presence subscription
	      *
	      * Parameters:
	      *     (String) jid
	      *     (String) message
	      */
	     unauthorize: function(jid, message)
	     {
		 var pres = $pres({to: jid, type: "unsubscribed"});
		 if (message && message !== "")
		     pres.c("status").t(message);
		 this._connection.send(pres);
	     },
	     /** Function: add
	      * Add roster item
	      *
	      * Parameters:
	      *   (String) jid - item jid
	      *   (String) name - name
	      *   (Array) groups
	      *   (Function) call_back
	      */
	     add: function(jid, name, groups, call_back)
	     {
		 var iq = $iq({type: 'set'}).c('query', {xmlns: Strophe.NS.ROSTER}).c('item', {jid: jid,
											       name: name});
		 for (var i = 0; i < groups.length; i++)
		 {
		     iq.c('group').t(groups[i]).up();
		 }
		 this._connection.sendIQ(iq, call_back, call_back);
	     },
	     /** Function: update
	      * Update roster item
	      *
	      * Parameters:
	      *   (String) jid - item jid
	      *   (String) name - name
	      *   (Array) groups
	      *   (Function) call_back
	      */
	     update: function(jid, name, groups, call_back)
	     {
		 var item = this.findItem(jid);
		 if (!item)
		 {
		     throw "item not found";
		 }
		 var newName = name || item.name;
		 var newGroups = groups || item.groups;
		 var iq = $iq({type: 'set'}).c('query', {xmlns: Strophe.NS.ROSTER}).c('item', {jid: item.jid,
											       name: newName});
		 for (var i = 0; i < newGroups.length; i++)
		 {
		     iq.c('group').t(newGroups[i]).up();
		 }
		 return this._connection.sendIQ(iq, call_back, call_back);
	     },
	     /** Function: remove
	      * Remove roster item
	      *
	      * Parameters:
	      *   (String) jid - item jid
	      *   (Function) call_back
	      */
	     remove: function(jid, call_back)
	     {
		 var item = this.findItem(jid);
		 if (!item)
		 {
		     throw "item not found";
		 }
		 var iq = $iq({type: 'set'}).c('query', {xmlns: Strophe.NS.ROSTER}).c('item', {jid: item.jid,
											       subscription: "remove"});
		 this._connection.sendIQ(iq, call_back, call_back);
	     },
	     /** PrivateFunction: _onReceiveRosterSuccess
	      *
	      */
	     _onReceiveRosterSuccess: function(userCallback, stanza)
	     {
		 this._updateItems(stanza);
		 if (userCallback) userCallback(this.items);
	     },
	     /** PrivateFunction: _onReceiveRosterError
	      *
	      */
	     _onReceiveRosterError: function(userCallback, stanza)
	     {
		 userCallback(this.items);
	     },
	     isSelf: function (jid) {
		return (Strophe.getBareJidFromJid(jid) === Strophe.getBareJidFromJid(this._connection.jid));
	     },    
	     /** PrivateFunction: _onReceivePresence
	      * Handle presence
	      */
	     _onReceivePresence : function(presence)
	     {
		 var jid = presence.getAttribute('from');
		 var from = Strophe.getBareJidFromJid(jid);
		 var xquery = presence.getElementsByTagName("x");

		if (this.isSelf(from)) 
		{
		    return true;

		};

		var ignore = false;

		 for (i = 0; i < presence.childNodes.length; i++) 
		 {
			var xmlns = presence.childNodes[i].getAttribute("xmlns");  

			if (xmlns && (xmlns.match(Strophe.NS.MUC) || xmlns.match("urn:xmpp:rayo")))
			{
				ignore = true;
			}		
		 }

		if (jid.substring(0, 5) == "rayo-") return true;			
		if (jid.substring(0, 5) == "Jitsi") return true;        

		if (ignore) return true;

		 var item = this.findItem(from);

		 if (!item)
		 {
		     item = {
			 name         : Strophe.getNodeFromJid(jid),
			 jid          : from,
			 subscription : "both",
			 ask          : null,
			 groups       : [],
			 resources    : {}
		     };
		     this.items.push(item);
		 }

		 var type = presence.getAttribute('type');

		 if (type == 'unavailable')
		 {
		     delete item.resources[Strophe.getResourceFromJid(jid)];
		 }
		 else if (!type)
		 {
		     // TODO: add timestamp
		     item.resources[Strophe.getResourceFromJid(jid)] = {
			 show     : (presence.getElementsByTagName('show').length !== 0) ? Strophe.getText(presence.getElementsByTagName('show')[0]) : "",
			 status   : (presence.getElementsByTagName('status').length !== 0) ? Strophe.getText(presence.getElementsByTagName('status')[0]) : "",
			 priority : (presence.getElementsByTagName('priority').length !== 0) ? Strophe.getText(presence.getElementsByTagName('priority')[0]) : ""
		     };
		 }
		 else
		 {
		     // Stanza is not a presence notification. (It's probably a subscription type stanza.)
		     return true;
		 }
		 //this._call_backs(this.items, item);
		 return true;
	     },
	     /** PrivateFunction: _call_backs
	      *
	      */
	     _call_backs : function(items, item)
	     {
		 for (var i = 0; i < this._callbacks.length; i++) // [].forEach my love ...
		 {
		     this._callbacks[i](items, item);
		 }
	     },
	     /** PrivateFunction: _onReceiveIQ
	      * Handle roster push.
	      */
	     _onReceiveIQ : function(iq)
	     {
		 var id = iq.getAttribute('id');
		 var from = iq.getAttribute('from');
		 // Receiving client MUST ignore stanza unless it has no from or from = user's JID.
		 if (from && from !== "" && from != this._connection.jid && from != Strophe.getBareJidFromJid(this._connection.jid))
		     return true;
		 var iqresult = $iq({type: 'result', id: id, from: this._connection.jid});
		 this._connection.send(iqresult);
		 this._updateItems(iq);
		 return true;
	     },
	     /** PrivateFunction: _updateItems
	      * Update items from iq
	      */
	     _updateItems : function(iq)
	     {  
		 var query = iq.getElementsByTagName('query');
		 if (query.length !== 0)
		 {
		     this.ver = query.item(0).getAttribute('ver');
		     var self = this;
		     Strophe.forEachChild(query.item(0), 'item',
			 function (item)
			 {
			     self._updateItem(item);
			 }
		    );
		 }
		 this._call_backs(this.items);
	     },
	     /** PrivateFunction: _updateItem
	      * Update internal representation of roster item
	      */
	     _updateItem : function(item)
	     {
		 var jid           = item.getAttribute("jid");
		 var name          = item.getAttribute("name");
		 var subscription  = item.getAttribute("subscription");
		 var ask           = item.getAttribute("ask");
		 var groups        = [];
		 Strophe.forEachChild(item, 'group',
		     function(group)
		     {
			 groups.push(Strophe.getText(group));
		     }
		 );

		 if (subscription == "remove")
		 {
		     this.removeItem(jid);
		     return;
		 }

		 item = this.findItem(jid);

		 if (!item)
		 {
		     this.items.push({
			 name         : name,
			 jid          : jid,
			 subscription : subscription,
			 ask          : ask,
			 groups       : groups,
			 resources    : {}
		     });
		 }
		 else
		 {
		     item.name = name;
		     item.subscription = subscription;
		     item.ask = ask;
		     item.groups = groups;
		 }
	     }
	});


	/**
	 * Strophe.jingle plugin
	 */


	Strophe.addConnectionPlugin('jingle', {
	    connection: null,
	    sessions: {},
	    jid2session: {},
	    ice_config: {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]},
	    pc_constraints: {},
	    media_constraints: {
		mandatory: {
		    'OfferToReceiveAudio': true,
		    'OfferToReceiveVideo': true
		}
		// MozDontOfferDataChannel: true when this is firefox
	    },
	    localAudio: null,
	    localVideo: null,

	    init: function (conn) {
		this.connection = conn;
		if (this.connection.disco) {
		    // http://xmpp.org/extensions/xep-0167.html#support
		    // http://xmpp.org/extensions/xep-0176.html#support
		    this.connection.disco.addFeature('urn:xmpp:jingle:1');
		    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:1');
		    this.connection.disco.addFeature('urn:xmpp:jingle:transports:ice-udp:1');
		    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:audio');
		    this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:video');


		    // this is dealt with by SDP O/A so we don't need to annouce this
		    //this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0'); // XEP-0293
		    //this.connection.disco.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0'); // XEP-0294
		    if (config.useRtcpMux) {
			this.connection.disco.addFeature('urn:ietf:rfc:5761'); // rtcp-mux
		    }
		    if (config.useBundle) {
			this.connection.disco.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle
		    }
		    //this.connection.disco.addFeature('urn:ietf:rfc:5576'); // a=ssrc
		}
		this.connection.addHandler(this.onJingle.bind(this), 'urn:xmpp:jingle:1', 'iq', 'set', null, null);
		
		console.log("strophe plugin jingle enabled");  		
	    },
	    onJingle: function (iq) {
		var sid = $(iq).find('jingle').attr('sid');
		var action = $(iq).find('jingle').attr('action');
		var fromJid = iq.getAttribute('from');
		// send ack first
		var ack = $iq({type: 'result',
		    to: fromJid,
		    id: iq.getAttribute('id')
		});
		//console.log('on jingle ' + action + ' from ' + fromJid, iq);
		var sess = this.sessions[sid];
		if ('session-initiate' != action) {
		    if (!sess) {
			ack.type = 'error';
			ack.c('error', {type: 'cancel'})
			    .c('item-not-found', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up()
			    .c('unknown-session', {xmlns: 'urn:xmpp:jingle:errors:1'});
			this.connection.send(ack);
			return true;
		    }
		    // compare from to sess.peerjid (bare jid comparison for later compat with message-mode)
		    // local jid is not checked
		    if (Strophe.getBareJidFromJid(fromJid) != Strophe.getBareJidFromJid(sess.peerjid)) {
			console.warn('jid mismatch for session id', sid, fromJid, sess.peerjid);
			ack.type = 'error';
			ack.c('error', {type: 'cancel'})
			    .c('item-not-found', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up()
			    .c('unknown-session', {xmlns: 'urn:xmpp:jingle:errors:1'});
			this.connection.send(ack);
			return true;
		    }
		} else if (sess !== undefined) {
		    // existing session with same session id
		    // this might be out-of-order if the sess.peerjid is the same as from
		    ack.type = 'error';
		    ack.c('error', {type: 'cancel'})
			.c('service-unavailable', {xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'}).up();
		    console.warn('duplicate session id', sid);
		    this.connection.send(ack);
		    return true;
		}
		// FIXME: check for a defined action
		this.connection.send(ack);
		// see http://xmpp.org/extensions/xep-0166.html#concepts-session
		switch (action) {
		    case 'session-initiate':
			sess = new JingleSession($(iq).attr('to'), $(iq).find('jingle').attr('sid'), this.connection);
			// configure session

			//in firefox we have only one stream object
			if (this.localAudio != this.localVideo) {
			    sess.localStreams.push(this.localAudio);
			}
			if (this.localVideo) {
			    sess.localStreams.push(this.localVideo);
			}
			sess.media_constraints = this.media_constraints;
			sess.pc_constraints = this.pc_constraints;
			sess.ice_config = config.iceServers ? config.iceServers : this.ice_config;

			sess.initiate(fromJid, false);
			// FIXME: setRemoteDescription should only be done when this call is to be accepted
			sess.setRemoteDescription($(iq).find('>jingle'), 'offer');

			this.sessions[sess.sid] = sess;
			this.jid2session[sess.peerjid] = sess;

			// the callback should either
			// .sendAnswer and .accept
			// or .sendTerminate -- not necessarily synchronus
			$(document).trigger('callincoming.jingle', [sess.sid]);
			break;
		    case 'session-accept':
			sess.setRemoteDescription($(iq).find('>jingle'), 'answer');
			sess.accept();
			$(document).trigger('callaccepted.jingle', [sess.sid]);
			break;
		    case 'session-terminate':
			// If this is not the focus sending the terminate, we have
			// nothing more to do here.
			if (Object.keys(this.sessions).length < 1
			    || !(this.sessions[Object.keys(this.sessions)[0]]
				instanceof JingleSession))
			{
			    break;
			}
			//console.log('terminating...', sess.sid);
			sess.terminate();
			this.terminate(sess.sid);
			if ($(iq).find('>jingle>reason').length) {
			    $(document).trigger('callterminated.jingle', [
				sess.sid,
				sess.peerjid,
				$(iq).find('>jingle>reason>:first')[0].tagName,
				$(iq).find('>jingle>reason>text').text()
			    ]);
			} else {
			    $(document).trigger('callterminated.jingle',
						[sess.sid, sess.peerjid]);
			}
			break;
		    case 'transport-info':
			sess.addIceCandidate($(iq).find('>jingle>content'));
			break;
		    case 'session-info':
			var affected;
			if ($(iq).find('>jingle>ringing[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
			    $(document).trigger('ringing.jingle', [sess.sid]);
			} else if ($(iq).find('>jingle>mute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
			    affected = $(iq).find('>jingle>mute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').attr('name');
			    $(document).trigger('mute.jingle', [sess.sid, affected]);
			} else if ($(iq).find('>jingle>unmute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').length) {
			    affected = $(iq).find('>jingle>unmute[xmlns="urn:xmpp:jingle:apps:rtp:info:1"]').attr('name');
			    $(document).trigger('unmute.jingle', [sess.sid, affected]);
			}
			break;
		    case 'addsource': // FIXME: proprietary, un-jingleish
		    case 'source-add': // FIXME: proprietary
			sess.addSource($(iq).find('>jingle>content'), fromJid);
			break;
		    case 'removesource': // FIXME: proprietary, un-jingleish
		    case 'source-remove': // FIXME: proprietary
			sess.removeSource($(iq).find('>jingle>content'), fromJid);
			break;
		    default:
			console.warn('jingle action not implemented', action);
			break;
		}
		return true;
	    },
	    initiate: function (peerjid, myjid) { // initiate a new jinglesession to peerjid
		var sess = new JingleSession(myjid || this.connection.jid,
		    Math.random().toString(36).substr(2, 12), // random string
		    this.connection);
		// configure session

		//in firefox we have only one stream
		if (this.localAudio != this.localVideo) {
		    sess.localStreams.push(this.localAudio);
		}
		if (this.localVideo) {
		    sess.localStreams.push(this.localVideo);
		}
		sess.media_constraints = this.media_constraints;
		sess.pc_constraints = this.pc_constraints;
		sess.ice_config = config.iceServers ? config.iceServers : this.ice_config;

		sess.initiate(peerjid, true);
		this.sessions[sess.sid] = sess;
		this.jid2session[sess.peerjid] = sess;
		sess.sendOffer();
		return sess;
	    },
	    terminate: function (sid, reason, text) { // terminate by sessionid (or all sessions)
		if (sid === null || sid === undefined) {
		    for (sid in this.sessions) {
			if (this.sessions[sid].state != 'ended') {
			    this.sessions[sid].sendTerminate(reason || (!this.sessions[sid].active()) ? 'cancel' : null, text);
			    this.sessions[sid].terminate();
			}
			delete this.jid2session[this.sessions[sid].peerjid];
			delete this.sessions[sid];
		    }
		} else if (this.sessions.hasOwnProperty(sid)) {
		    if (this.sessions[sid].state != 'ended') {
			this.sessions[sid].sendTerminate(reason || (!this.sessions[sid].active()) ? 'cancel' : null, text);
			this.sessions[sid].terminate();
		    }
		    delete this.jid2session[this.sessions[sid].peerjid];
		    delete this.sessions[sid];
		}
	    },
	    // Used to terminate a session when an unavailable presence is received.
	    terminateByJid: function (jid) {
		if (this.jid2session.hasOwnProperty(jid)) {
		    var sess = this.jid2session[jid];
		    if (sess) {
			sess.terminate();
			//console.log('peer went away silently', jid);
			delete this.sessions[sess.sid];
			delete this.jid2session[jid];
			$(document).trigger('callterminated.jingle',
					    [sess.sid, jid], 'gone');
		    }
		}
	    },
	    terminateRemoteByJid: function (jid, reason) {
		if (this.jid2session.hasOwnProperty(jid)) {
		    var sess = this.jid2session[jid];
		    if (sess) {
			sess.sendTerminate(reason || (!sess.active()) ? 'kick' : null);
			sess.terminate();
			//console.log('terminate peer with jid', sess.sid, jid);
			delete this.sessions[sess.sid];
			delete this.jid2session[jid];
			$(document).trigger('callterminated.jingle',
					    [sess.sid, jid, 'kicked']);
		    }
		}
	    },
	    getStunAndTurnCredentials: function () {
		// get stun and turn configuration from server via xep-0215
		// uses time-limited credentials as described in
		// http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00
		//
		// see https://code.google.com/p/prosody-modules/source/browse/mod_turncredentials/mod_turncredentials.lua
		// for a prosody module which implements this
		//
		// currently, this doesn't work with updateIce and therefore credentials with a long
		// validity have to be fetched before creating the peerconnection
		// TODO: implement refresh via updateIce as described in
		//      https://code.google.com/p/webrtc/issues/detail?id=1650
		var self = this;
		this.connection.sendIQ(
		    $iq({type: 'get', to: this.connection.domain})
			.c('services', {xmlns: 'urn:xmpp:extdisco:1'}).c('service', {host: 'turn.' + this.connection.domain}),
		    function (res) {
			var iceservers = [];
			$(res).find('>services>service').each(function (idx, el) {
			    el = $(el);
			    var dict = {};
			    var type = el.attr('type');
			    switch (type) {
				case 'stun':
				    dict.url = 'stun:' + el.attr('host');
				    if (el.attr('port')) {
					dict.url += ':' + el.attr('port');
				    }
				    iceservers.push(dict);
				    break;
				case 'turn':
				case 'turns':
				    dict.url = type + ':';
				    if (el.attr('username')) { // https://code.google.com/p/webrtc/issues/detail?id=1508
					if (navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10) < 28) {
					    dict.url += el.attr('username') + '@';
					} else {
					    dict.username = el.attr('username'); // only works in M28
					}
				    }
				    dict.url += el.attr('host');
				    if (el.attr('port') && el.attr('port') != '3478') {
					dict.url += ':' + el.attr('port');
				    }
				    if (el.attr('transport') && el.attr('transport') != 'udp') {
					dict.url += '?transport=' + el.attr('transport');
				    }
				    if (el.attr('password')) {
					dict.credential = el.attr('password');
				    }
				    iceservers.push(dict);
				    break;
			    }
			});
			self.ice_config.iceServers = iceservers;
		    },
		    function (err) {
			console.warn('getting turn credentials failed', err);
			console.warn('is mod_turncredentials or similar installed?');
		    }
		);
		// implement push?
	    }
	});


	/**
	 * Strophe.openfire connector
	 */

	var Openfire = {};


	/** Class: Openfire.Connection
	 *  WebSockets Connection Manager for Openfire
	 *
	 *  Thie class manages an WebSockets connection
	 *  to an Openfire XMPP server through the WebSockets plugin and dispatches events to the user callbacks as
	 *  data arrives.  It uses the server side Openfire authentication
	 *
	 *  After creating a Openfire object, the user will typically
	 *  call connect() with a user supplied callback to handle connection level
	 *  events like authentication failure, disconnection, or connection
	 *  complete.
	 *
	 *  To send data to the connection, use send(doc) or sendRaw(text)
	 *
	 *  Use xmlInput(doc) and RawInput(text) overrideable function to receive XML data coming into the
	 *  connection.
	 *
	 *  The user will also have several event handlers defined by using
	 *  addHandler() and addTimedHandler().  These will allow the user code to
	 *  respond to interesting stanzas or do something periodically with the
	 *  connection.  These handlers will be active once authentication is
	 *  finished.
	 *
	 *  Create and initialize a Openfire object.
	 *
	 *
	 *  Returns:
	 *    A new Openfire object.
	 */

	Openfire.Connection = function(url) 
	{
	    if (!window.WebSocket) 
	    {
		window.WebSocket=window.MozWebSocket;

		if (!window.WebSocket)
		{
			var msg = "WebSocket not supported by this browser";			
			alert(msg);
			throw Error(msg);
		}
	    }

	    this.host = url.indexOf("/") < 0 ? url : url.split("/")[2];   
	    this.protocol = url.indexOf("/") < 0 ? "wss:" : (url.split("/")[0] == "http:") ? "ws:" : "wss:";   
	    this.jid = "";
	    this.resource = "ofmeet" + Math.round(Math.random() * 10000);
	    this.streamId = null;

	    // handler lists

	    this.timedHandlers = [];
	    this.handlers = [];
	    this.removeTimeds = [];
	    this.removeHandlers = [];
	    this.addTimeds = [];
	    this.addHandlers = [];
	    this._idleTimeout = null;

	    this.authenticated = false;
	    this.disconnecting = false;
	    this.connected = false;

	    this.errors = 0;

	    this._uniqueId = Math.round(Math.random() * 10000);

	    // setup onIdle callback every 1/10th of a second
	    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

	    // initialize plugins

	    for (var k in Strophe._connectionPlugins) 
	    {   
		if (Strophe._connectionPlugins.hasOwnProperty(k)) {
		    var ptype = Strophe._connectionPlugins[k];
		    // jslint complaints about the below line, but this is fine
		    var F = function () {};
		    F.prototype = ptype;
		    this[k] = new F();
		    this[k].init(this);	    
		}
	    }	   
	}

	Openfire.Connection.prototype = {

	    /** Function: reset
	     *  Reset the connection.
	     *
	     *  This function should be called after a connection is disconnected
	     *  before that connection is reused.
	     */

	    reset: function ()
	    {
		this.streamId = null;

		this.timedHandlers = [];
		this.handlers = [];
		this.removeTimeds = [];
		this.removeHandlers = [];
		this.addTimeds = [];
		this.addHandlers = [];

		this.authenticated = false;
		this.disconnecting = false;
		this.connected = false;

		this.errors = 0;
	    },


	    /** Function: pause
	     *  UNUSED with websockets
	     */

	    pause: function ()
	    {
		return;
	    },

	    /** Function: resume
	     *  UNUSED with websockets
	     */

	    resume: function ()
	    {
		return;
	    },

	    /** Function: getUniqueId
	     *  Generate a unique ID for use in <iq/> elements.
	     *
	     *  All <iq/> stanzas are required to have unique id attributes.  This
	     *  function makes creating these easy.  Each connection instance has
	     *  a counter which starts from zero, and the value of this counter
	     *  plus a colon followed by the suffix becomes the unique id. If no
	     *  suffix is supplied, the counter is used as the unique id.
	     *
	     *  Suffixes are used to make debugging easier when reading the stream
	     *  data, and their use is recommended.  The counter resets to 0 for
	     *  every new connection for the same reason.  For connections to the
	     *  same server that authenticate the same way, all the ids should be
	     *  the same, which makes it easy to see changes.  This is useful for
	     *  automated testing as well.
	     *
	     *  Parameters:
	     *    (String) suffix - A optional suffix to append to the id.
	     *
	     *  Returns:
	     *    A unique string to be used for the id attribute.
	     */

	    getUniqueId: function (suffix)
	    {
		if (typeof(suffix) == "string" || typeof(suffix) == "number") {
		    return ++this._uniqueId + ":" + suffix;
		} else {
		    return ++this._uniqueId + "";
		}
	    },

	    /** Function: connect
	     *  Starts the connection process.
	     *
	     *
	     *  Parameters:
	     *    (String) username - The Openfire username.  
	     *    (String) pass - The user's password.
	     *    (String) resource - The user resource for this connection.     
	     *    (Function) callback The connect callback function.
	     */

	    connect: function (jid, pass, callback, wait, hold, route)
	    { 	
		this.resource = jid.indexOf("/") > -1 ? jid.split("/")[1] : this.resource;
		this.username = jid.indexOf("@") < 0 ? null : jid.split("@")[0];		
		this.jid = jid.indexOf("/") > -1 ? jid : jid + '/' + this.resource;        
		this.pass = pass == "" ? null : pass;        
		this.connect_callback = callback;  
		this.disconnecting = false;
		this.connected = false;
		this.authenticated = false;
		this.errors = 0;

		this._changeConnectStatus(Strophe.Status.CONNECTING, null);   
		this.url = this.protocol + "//" + this.host + "/ofmeetws/server?username=" + this.username + "&password=" + this.pass + "&resource=" + this.resource;
		this._ws = new WebSocket(this.url, "xmpp");  

		this._ws.onopen = this._onopen.bind(this);
		this._ws.onmessage = this._onmessage.bind(this);
		this._ws.onclose = this._onclose.bind(this);

		window.openfireWebSocket = this;

		this.jid = this.jid.indexOf("@") < 0 ? this.resource + "@" + this.jid  : this.jid;

		this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);

	    },


	    /** 
	     *
	     * Private Function: _onopen websocket event handler
	     *
	     */    

	    _onopen: function() 
	    {       
		this.connected = true;
		this.authenticated = true;
		this.resource = Strophe.getResourceFromJid(this.jid);
		this.domain = Strophe.getDomainFromJid(this.jid);

		try {

		   this._changeConnectStatus(Strophe.Status.CONNECTED, null);	

		} catch (e) {

		    throw Error("User connection callback caused an exception: " + e);
		} 

		this.interval = setInterval (function() {window.openfireWebSocket.sendRaw(" ")}, 10000 );	
	    },

	    /** Function: attach
	     *  UNUSED, use connect again
	     */

	    attach: function()
	    {
		return 
	    },

	    /** Function: xmlInput
	     *  User overrideable function that receives XML data coming into the
	     *  connection.
	     *
	     *  The default function does nothing.  User code can override this with
	     *  > Openfire.xmlInput = function (elem) {
	     *  >   (user code)
	     *  > };
	     *
	     *  Parameters:
	     *    (XMLElement) elem - The XML data received by the connection.
	     */

	    xmlInput: function (elem)
	    {
		return;
	    },

	    /** Function: xmlOutput
	     *  User overrideable function that receives XML data sent to the
	     *  connection.
	     *
	     *  The default function does nothing.  User code can override this with
	     *  > Openfire.xmlOutput = function (elem) {
	     *  >   (user code)
	     *  > };
	     *
	     *  Parameters:
	     *    (XMLElement) elem - The XMLdata sent by the connection.
	     */

	    xmlOutput: function (elem)
	    {
		return;
	    },

	    /** Function: rawInput
	     *  User overrideable function that receives raw data coming into the
	     *  connection.
	     *
	     *  The default function does nothing.  User code can override this with
	     *  > Openfire.rawInput = function (data) {
	     *  >   (user code)
	     *  > };
	     *
	     *  Parameters:
	     *    (String) data - The data received by the connection.
	     */

	    rawInput: function (data)
	    {
		return;
	    },

	    /** Function: rawOutput
	     *  User overrideable function that receives raw data sent to the
	     *  connection.
	     *
	     *  The default function does nothing.  User code can override this with
	     *  > Openfire.rawOutput = function (data) {
	     *  >   (user code)
	     *  > };
	     *
	     *  Parameters:
	     *    (String) data - The data sent by the connection.
	     */

	    rawOutput: function (data)
	    {
		return;
	    },




	    /** Function: sendRaw
	     *  Send a stanza in raw XML text.
	     *
	     *  This function is called to push data onto the send queue to
	     *  go out over the wire.  Whenever a request is sent to the BOSH
	     *  server, all pending data is sent and the queue is flushed.
	     *
	     *  Parameters:
	     *    xml - The stanza text XML to send.
	     */

	    sendRaw: function(xml) {

		if(!this.connected || this._ws == null) {
		    throw Error("Not connected, cannot send packets.");
		}

		if (xml != " ")
		{
			this.xmlOutput(this._textToXML(xml));
			this.rawOutput(xml);
		}

		this._ws.send(xml);
	    },


	    /** Function: send
	     *  Send a stanza.
	     *
	     *  This function is called to push data onto the send queue to
	     *  go out over the wire.  Whenever a request is sent to the BOSH
	     *  server, all pending data is sent and the queue is flushed.
	     *
	     *  Parameters:
	     *    (XMLElement |
	     *     [XMLElement] |
	     *     Strophe.Builder) elem - The stanza to send.
	     */

	    send: function(elem) 
	    {    
		if(!this.connected || this._ws == null) {
		    throw Error("Not connected, cannot send packets.");
		}

		var toSend = "";

		if (elem === null) { return ; }

		if (typeof(elem.sort) === "function") 
		{
		    for (var i = 0; i < elem.length; i++) 
		    {
			toSend += Strophe.serialize(elem[i]);
			this.xmlOutput(elem[i]);
		    }

		} else if (typeof(elem.tree) === "function") {

		    toSend = Strophe.serialize(elem.tree());
		    this.xmlOutput(elem.tree());

		} else {

		    toSend = Strophe.serialize(elem);
		    this.xmlOutput(elem);
		}

		this.rawOutput(toSend);
		this._ws.send(toSend);
	    },    

	    /** Function: flush
	     *  UNUSED
	     */

	    flush: function ()
	    {
		return
	    },


	    /** Function: sendIQ
	     *  Helper function to send IQ stanzas.
	     *
	     *  Parameters:
	     *    (XMLElement) elem - The stanza to send.
	     *    (Function) callback - The callback function for a successful request.
	     *    (Function) errback - The callback function for a failed or timed
	     *      out request.  On timeout, the stanza will be null.
	     *    (Integer) timeout - The time specified in milliseconds for a
	     *      timeout to occur.
	     *
	     *  Returns:
	     *    The id used to send the IQ.
	     */

	    sendIQ: function(elem, callback, errback, timeout) {
		var timeoutHandler = null;
		var that = this;

		if (typeof(elem.tree) === "function") {
		    elem = elem.tree();
		}
		var id = elem.getAttribute('id');

		// inject id if not found

		if (!id) {
		    id = this.getUniqueId("sendIQ");
		    elem.setAttribute("id", id);
		}

		var handler = this.addHandler(function (stanza) {
		    // remove timeout handler if there is one

		    if (timeoutHandler) {
			that.deleteTimedHandler(timeoutHandler);
		    }

		    var iqtype = stanza.getAttribute('type');

		    if (iqtype == 'result') 
		    {
			if (callback) {
			    callback(stanza);
			}

		    } else if (iqtype == 'get') {

		    } else if (iqtype == 'error') {
			if (errback) {
			    errback(stanza);
			}
		    } else {
			throw {
			    name: "StropheError",
			    message: "Got bad IQ type of " + iqtype
			};
		    }
		}, null, 'iq', null, id);

		// if timeout specified, setup timeout handler.

		if (timeout) 
		{
		    timeoutHandler = this.addTimedHandler(timeout, function () {
			// get rid of normal handler
			that.deleteHandler(handler);

			// call errback on timeout with null stanza
			if (errback) {
			    errback(null);
			}
			return false;
		    });
		}

		this.send(elem);

		return id;
	    },

	    /** Function: addTimedHandler
	     *  Add a timed handler to the connection.
	     *
	     *  This function adds a timed handler.  The provided handler will
	     *  be called every period milliseconds until it returns false,
	     *  the connection is terminated, or the handler is removed.  Handlers
	     *  that wish to continue being invoked should return true.
	     *
	     *  Because of method binding it is necessary to save the result of
	     *  this function if you wish to remove a handler with
	     *  deleteTimedHandler().
	     *
	     *  Note that user handlers are not active until authentication is
	     *  successful.
	     *
	     *  Parameters:
	     *    (Integer) period - The period of the handler.
	     *    (Function) handler - The callback function.
	     *
	     *  Returns:
	     *    A reference to the handler that can be used to remove it.
	     */

	    addTimedHandler: function (period, handler)
	    {
		var thand = new Strophe.TimedHandler(period, handler);
		this.addTimeds.push(thand);
		return thand;
	    },


	    /** Function: deleteTimedHandler
	     *  Delete a timed handler for a connection.
	     *
	     *  This function removes a timed handler from the connection.  The
	     *  handRef parameter is *not* the function passed to addTimedHandler(),
	     *  but is the reference returned from addTimedHandler().
	     *
	     *  Parameters:
	     *    (Strophe.TimedHandler) handRef - The handler reference.
	     */

	    deleteTimedHandler: function (handRef)
	    {
		// this must be done in the Idle loop so that we don't change
		// the handlers during iteration

		this.removeTimeds.push(handRef);
	    },

	    /** Function: addHandler
	     *  Add a stanza handler for the connection.
	     *
	     *  This function adds a stanza handler to the connection.  The
	     *  handler callback will be called for any stanza that matches
	     *  the parameters.  Note that if multiple parameters are supplied,
	     *  they must all match for the handler to be invoked.
	     *
	     *  The handler will receive the stanza that triggered it as its argument.
	     *  The handler should return true if it is to be invoked again;
	     *  returning false will remove the handler after it returns.
	     *
	     *  As a convenience, the ns parameters applies to the top level element
	     *  and also any of its immediate children.  This is primarily to make
	     *  matching /iq/query elements easy.
	     *
	     *  The options argument contains handler matching flags that affect how
	     *  matches are determined. Currently the only flag is matchBare (a
	     *  boolean). When matchBare is true, the from parameter and the from
	     *  attribute on the stanza will be matched as bare JIDs instead of
	     *  full JIDs. To use this, pass {matchBare: true} as the value of
	     *  options. The default value for matchBare is false. 
	     *
	     *  The return value should be saved if you wish to remove the handler
	     *  with deleteHandler().
	     *
	     *  Parameters:
	     *    (Function) handler - The user callback.
	     *    (String) ns - The namespace to match.
	     *    (String) name - The stanza name to match.
	     *    (String) type - The stanza type attribute to match.
	     *    (String) id - The stanza id attribute to match.
	     *    (String) from - The stanza from attribute to match.
	     *    (String) options - The handler options
	     *
	     *  Returns:
	     *    A reference to the handler that can be used to remove it.
	     */

	    addHandler: function (handler, ns, name, type, id, from, options)
	    {
		var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
		this.addHandlers.push(hand);
		return hand;
	    },

	    /** Function: deleteHandler
	     *  Delete a stanza handler for a connection.
	     *
	     *  This function removes a stanza handler from the connection.  The
	     *  handRef parameter is *not* the function passed to addHandler(),
	     *  but is the reference returned from addHandler().
	     *
	     *  Parameters:
	     *    (Strophe.Handler) handRef - The handler reference.
	     */

	    deleteHandler: function (handRef)
	    {
		// this must be done in the Idle loop so that we don't change
		// the handlers during iteration

		this.removeHandlers.push(handRef);
	    },

	    /** Function: disconnect
	     *  Start the graceful disconnection process.
	     *
	     *  This function starts the disconnection process.  This process starts
	     *  by sending unavailable presence and sending BOSH body of type
	     *  terminate.  A timeout handler makes sure that disconnection happens
	     *  even if the BOSH server does not respond.
	     *
	     *  The user supplied connection callback will be notified of the
	     *  progress as this process happens.
	     *
	     *  Parameters:
	     *    (String) reason - The reason the disconnect is occuring.
	     */    

	    disconnect: function(reason) {

		if(!this.connected || this._ws == null) {
		    return;
		}

		this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);  
		Strophe.info("Disconnect was called because: " + reason);

		this._ws.close();

	    },

	    /** PrivateFunction: _onDisconnectTimeout
	     *  _Private_ timeout handler for handling non-graceful disconnection.
	     *
	     *  If the graceful disconnect process does not complete within the
	     *  time allotted, this handler finishes the disconnect anyway.
	     *
	     *  Returns:
	     *    false to remove the handler.
	     */

	    _onDisconnectTimeout: function ()
	    {
		Strophe.info("_onDisconnectTimeout was called");

		this._doDisconnect();

		return false;
	    },

	    /** PrivateFunction: _doDisconnect
	     *  _Private_ function to disconnect.
	     *
	     *  This is the last piece of the disconnection logic.  This resets the
	     *  connection and alerts the user's connection callback.
	     */

	    _doDisconnect: function ()
	    {
		Strophe.info("_doDisconnect was called");
		this._onclose();
	    },

	    /** PrivateFunction: _changeConnectStatus
	     *  _Private_ helper function that makes sure plugins and the user's
	     *  callback are notified of connection status changes.
	     *
	     *  Parameters:
	     *    (Integer) status - the new connection status, one of the values
	     *      in Strophe.Status
	     *    (String) condition - the error condition or null
	     */

	    _changeConnectStatus: function (status, condition)
	    {
		// notify all plugins listening for status changes

		for (var k in Strophe._connectionPlugins) 
		{
		    if (Strophe._connectionPlugins.hasOwnProperty(k)) 
		    {
			var plugin = this[k];

			if (plugin.statusChanged) 
			{
			    try {
				plugin.statusChanged(status, condition);
			    } catch (err) {
				Strophe.error("" + k + " plugin caused an exception changing status: " + err);
			    }
			}
		    }
		}

		// notify the user's callback

		if (typeof this.connect_callback == 'function')
		{
		    try {
			this.connect_callback(status, condition);
		    } catch (e) {
			Strophe.error("User connection callback caused an exception: " + e);
		   }
		}
	    },



	    /** 
	     *
	     * Private Function: _onclose websocket event handler
	     *
	     */    

	    _onclose: function() 
	    {
		Strophe.info("websocket closed");
		//console.log('_onclose - disconnected');
		clearInterval(this.interval);

		this.authenticated = false;
		this.disconnecting = false;
		this.streamId = null;

		// tell the parent we disconnected

		this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
		this.connected = false;

		// delete handlers

		this.handlers = [];
		this.timedHandlers = [];
		this.removeTimeds = [];
		this.removeHandlers = [];
		this.addTimeds = [];
		this.addHandlers = [];

		if(this._ws.readyState != this._ws.CLOSED)
		{
		  this._ws.close();
		}
	    },

	    /** 
	     *
	     * Private Function: _onmessage websocket event handler
	     *
	     */    

	    _onmessage: function(packet) 
	    {
		var elem;

		try {
		    elem = this._textToXML(packet.data);

		} catch (e) {

		    if (e != "parsererror") { throw e; }
		    this.disconnect("strophe-parsererror");
		}

		if (elem === null) { return; }

		this.xmlInput(elem);
		this.rawInput(packet.data);

		// remove handlers scheduled for deletion

		var i, hand;

		while (this.removeHandlers.length > 0) 
		{
		    hand = this.removeHandlers.pop();
		    i = this.handlers.indexOf(hand);

		    if (i >= 0) {
			this.handlers.splice(i, 1);
		    }
		}

		// add handlers scheduled for addition

		while (this.addHandlers.length > 0) 
		{
		    this.handlers.push(this.addHandlers.pop());
		}  

		// send each incoming stanza through the handler chain

		var i, newList;
		newList = this.handlers;
		this.handlers = [];

		for (i = 0; i < newList.length; i++) 
		{          
		    var hand = newList[i];

		    if (hand.isMatch(elem) && (this.authenticated || !hand.user)) 
		    {
			if (hand.run(elem)) 
			{
			    this.handlers.push(hand);
			}

		    } else {
			this.handlers.push(hand);
		    }
		}        
	    },


	    /** 
	     *
	     * Private Function: _textToXML convert text to DOM Document object
	     *
	     */    

	    _textToXML: function (text) {

		var doc = null;

		if (window['DOMParser']) {
		    var parser = new DOMParser();
		    doc = parser.parseFromString(text, 'text/xml');

		} else if (window['ActiveXObject']) {
		    var doc = new ActiveXObject("MSXML2.DOMDocument");
		    doc.async = false;
		    doc.loadXML(text);

		} else {
		    throw Error('No DOMParser object found.');
		}

		return doc.firstChild;
	    },     

	    /** PrivateFunction: _onIdle
	     *  _Private_ handler to process events during idle cycle.
	     *
	     *  This handler is called every 100ms to fire timed handlers that
	     *  are ready and keep poll requests going.
	     */

	    _onIdle: function ()
	    {
		var i, thand, since, newList;

		// remove timed handlers that have been scheduled for deletion

		while (this.removeTimeds.length > 0) 
		{
		    thand = this.removeTimeds.pop();
		    i = this.timedHandlers.indexOf(thand);
		    if (i >= 0) {
			this.timedHandlers.splice(i, 1);
		    }
		}

		// add timed handlers scheduled for addition

		while (this.addTimeds.length > 0) 
		{
		    this.timedHandlers.push(this.addTimeds.pop());
		}

		// call ready timed handlers
		var now = new Date().getTime();
		newList = [];

		for (i = 0; i < this.timedHandlers.length; i++) 
		{
		    thand = this.timedHandlers[i];

		    if (this.authenticated || !thand.user) {
			since = thand.lastCalled + thand.period;

			if (since - now <= 0) {
			    if (thand.run()) {
				newList.push(thand);
			    }
			} else {
			    newList.push(thand);
			}
		    }
		}

		this.timedHandlers = newList;

		// reactivate the timer

		clearTimeout(this._idleTimeout);
		this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
	    }        
	}

	/**
	 * Strophe.connectionmanager plugin
	 */

	Strophe.addConnectionPlugin('connectionmanager', {
	    /*
	     This plugin implements a Connection Manager that monitors
	     the Strophe connection and keeps track of unsent stanzas.
	     */
	    conn: null,
	    firstTime: true,
	    conn_state: null,
	    element_queue: [],
	    enabled: true,  // enabled by default

	    _status_lookup: {},

	    _receiveTimer: null,
	    _reconnectInterval: null,

	    // default config
	    config: {
		// try to reconnet continously, even after a graceful disconnect
		// unless the disconnect reason is "logout"
		autoReconnect: true,

		// if true (default), will automatically empty queue on successfull reconnect
		// (+/- 20 stanzas per packet, 2 seconds apart)
		autoResend: true,

		receiveTimeout: 20, // in seconds
		pingTimeout: 10, // in seconds
		reconnectInterval: 10, // in seconds - interval at which to attempt reconnection
		onEnqueueElement: null,
		onDequeueElement: null,
		onReceiveTimeout: null,
		onPingTimeout: null,
		onPingOK: null
	    },

	    // API

	    configure: function(config){
		config = config || {};

		for(var c in config){
		    if(config.hasOwnProperty(c)){
			this.config[c] = config[c];
		    }
		}
	    },

	    sendQueuedElements: function(max){
		max = max || this.element_queue.length;

		this.conn.pause(); // facilitate bulk sending
		for(var i = 0; i < this.element_queue.length && i < max; i++){
		    this.conn.send(this.element_queue[i]);
		}
		this.conn.resume();
	    },

	    resendAll: function(sent_callback){
		var sendInt = setInterval(function(){
		    if(this.element_queue.length === 0){
			clearInterval(sendInt);

			if(sent_callback){ sent_callback(); }
			return;
		    }

		    this.sendQueuedElements(20);
		}.bind(this), 2000);
	    },

	    enable: function(){
		this.disable(); // prevent double-enabling

		var that = this;
		var conn = this.conn;

		// insert a tap into the builtin _queueData function
		var _queueData = conn._queueData;

		if (_queueData)
		{
			conn._queueData = function (element) {
			    if(that._enqueueElement(element)){
				_queueData.call(this, element);
			    } else {
				//console.log("NOT passing through queue call to Strophe Connection!");
			    }
			};
		}

		var _onRequestStateChange = conn._onRequestStateChange;

		if (_onRequestStateChange)
		{        
			conn._onRequestStateChange = function(func, req){
			    _onRequestStateChange.call(this, function(){
				that._requestReceived(req);
				func(req);
			    }, req);
			};
		}

		// build a reverse lookup of Strophe.Status states
		for(var s in Strophe.Status){
		    if(Strophe.Status.hasOwnProperty(s)){
			this._status_lookup[Strophe.Status[s]] = s;
		    }
		}

		this.enabled = true;
	    },

	    disable: function(){
		this.conn._queueData = Strophe.Connection.prototype._queueData;
		this.conn._onRequestStateChange = Strophe.Connection.prototype._onRequestStateChange;

		clearTimeout(this._receiveTimer);
		clearInterval(this._reconnectInterval);

		this.enabled = false;
	    },

	    reconnect: function(){
		//console.log("reconnect start");

		var xhr = new XMLHttpRequest();
		xhr.open("GET", of.server + "/ofmeet/config", true);

		xhr.onload = (function() {
			//console.log("reconnect onload");
		}).bind(this);

		xhr.send(null);      	

		this.conn.disconnect();
		this.conn._onDisconnectTimeout(); // clears requests
		this.conn.connect(this.conn.jid, this.conn.pass,
				  this.conn.connect_callback,
				  this.conn.wait, this.conn.hold);
	    },

	    //--------------------------

	    init: function(conn) {
		this.conn = conn;

		this.enable();
		console.log("strophe plugin: connectionmanager enabled");         
	    },

	    /** Called automatically by Strophe when the connection status changes */
	    statusChanged: function(status, condition){
		if(!this.enabled){
		    return;
		}

		this.conn_state = status;
		//console.log("Strophe connection status: " + this._status_lookup[status] || status, condition);

		// start timer when connected and reset it when not connected
		clearTimeout(this._receiveTimer);

		if(status == Strophe.Status.CONNECTED){
		    this.conn.send($pres()); 

		    if (!this.firstTime) setTimeout(function() { window.location.reload(true);}, 5000);

		    this.firstTime = false; 

		    this._restartReceiveTimer();
		    clearInterval(this._reconnectInterval);
	//             clearInterval(this.__countInterval);
	//             this.__countInterval = null;

		    if(this.config.autoResend){
			this.resendAll();
		    }
			    }
		else if(status == Strophe.Status.DISCONNECTING){

		}
		else if(status == Strophe.Status.DISCONNECTED){
		    this.conn.reconnecting = true;

		    if(condition == "logout"){
			// disable auto reconnect
			this.config.autoReconnect = false;
		    }

		    clearInterval(this._reconnectInterval);

		    if(this.config.autoReconnect){           
			this._reconnectInterval = setInterval(
			    function(){
				if(!this.conn.connected){
				    this.reconnect();
				}
			    }.bind(this),
			    this.config.reconnectInterval * 1000);

	//                 // start the counting interval (for testing purposes)
	//                 if(this.__countInterval == null){
	//                     var i = 0;
	//                     this.__countInterval = setInterval(function(){
	//                         this.conn.send($msg({to: "all@conference." + this.conn.domain,
	//                                              type: "groupchat"}).c("body").t(i++));
	//                     }.bind(this), 1000);
	//                 }
		    }
		}
	    },

	    _enqueueElement: function(el){
		 //console.log("req sent: " + el);

		if(!el){
		    return;
		}


		// only enqueue elements that are not used for authentication
		// or session establishment.
		// also don't buffer presence stanzas
		if( (!el.getAttribute("id") 
		    || (Strophe.isTagEqual(el, "iq") && el.getAttribute("id").indexOf("_auth_") != -1))
		    || el.getAttribute("xmlns") == "urn:ietf:params:xml:ns:xmpp-sasl"
		    || Strophe.isTagEqual(el, "presence")
		  ){
		    // this is an auth/session stanza
		    return true;
		}

		// only push non-empty requests
		if(this.element_queue.indexOf(el) == -1){
		    this.element_queue.push(el);

		    if(this.config.onEnqueueElement){
			this.config.onEnqueueElement(el);
		    }
		}

		 //console.log("sentQueue: " + this.element_queue.length + " " + this.element_queue);
		 //console.log("_requests: " + this.conn._requests.length + " " + this.conn._requests);

		// if strophe is in the AUTHENTICATING (auth/session establishment) stage,
		// don't allow "regular requests" to be pushed through
	//         if(this.conn_state == Strophe.Status.AUTHENTICATING ||
	//            this.conn_state == Strophe.Status.DISCONNECTED){
		if(this.conn_state != Strophe.Status.CONNECTED){
		    return false;
		}

		return true;
	    },

	    _requestReceived: function(req){
		 //console.log("req received: " + req);

		// only dequeue in connected state
		if(this.conn_state == Strophe.Status.CONNECTED){
		    // clear the queue
		    var els = req.xmlData.childNodes;
		    if(els && els.length > 0){
			for(var i = 0; i < this.element_queue.length; i++){
			    for(var j = 0; j < els.length; j++){
				//if(this.element_queue[i] == els[j]){
				if(this.element_queue[i] && els[j] && (
				    this.element_queue[i].getAttribute("id") 
					== els[j].getAttribute("id"))){  // use request id comparisons instead
				    //console.log("removing from sent queue:" + this.element_queue[i]);
				    this.element_queue.splice(i--, 1);

				    if(this.config.onDequeueElement){
					this.config.onDequeueElement(els[j]);
				    }
				}
			    }
			}
		    }

		     //console.log("sentQueue:" + this.element_queue.length + " " + this.element_queue);
		     //console.log("_requests:" + this.conn._requests.length + " " + this.conn._requests);
		}

		this._restartReceiveTimer();
	    },

	    _restartReceiveTimer: function(){
		clearTimeout(this._receiveTimer);
		this._receiveTimer = setTimeout(this._onReceiveTimeout.bind(this),
						this.config.receiveTimeout * 1000);
	    },

	    _onReceiveTimeout: function(){
		// receive timeout reached, do a ping
		Strophe.info("CM: receive timeout");

		if(this.config.onReceiveTimeout){
		    this.config.onReceiveTimeout();
		}

		this.conn.send($iq(
		    {
			id: "ping",
			type: "get",
			to: this.conn.domain
		    }).c("ping", {xmlns: 'urn:xmpp:ping'}));

		var pingTimeout = setTimeout(this._onPingTimeout.bind(this),
					     this.config.pingTimeout * 1000);

		this.conn.addHandler(function(resp){
		    clearTimeout(pingTimeout);

		    if(this.config.onPingOK){
			this.config.onPingOK();
		    }
		}.bind(this), null, null, null, "ping");
	    },

	    _onPingTimeout: function(){
		Strophe.warn("CM: ping timed out, disconnecting!");

		if(this.config.onPingTimeout){
		    this.config.onPingTimeout();
		}

		// disconnect connection
		this.conn.disconnect();
	    }

	}); 

	/**
	 * Strophe.disco plugin
	 */

	Strophe.addConnectionPlugin("disco",{_connection:null,_identities:[],_features:[],_items:[],init:function(conn){this._connection=conn;this._identities=[];this._features=[];this._items=[];conn.addHandler(this._onDiscoInfo.bind(this),Strophe.NS.DISCO_INFO,"iq","get",null,null);conn.addHandler(this._onDiscoItems.bind(this),Strophe.NS.DISCO_ITEMS,"iq","get",null,null)},addIdentity:function(category,type,name,lang){for(var i=0;i<this._identities.length;i++){if(this._identities[i].category==category&&this._identities[i].type==type&&this._identities[i].name==name&&this._identities[i].lang==lang){return false}}this._identities.push({category:category,type:type,name:name,lang:lang});return true},addFeature:function(var_name){for(var i=0;i<this._features.length;i++){if(this._features[i]==var_name){return false}}this._features.push(var_name);return true},removeFeature:function(var_name){for(var i=0;i<this._features.length;i++){if(this._features[i]===var_name){this._features.splice(i,1);return true}}return false},addItem:function(jid,name,node,call_back){if(node&&!call_back){return false}this._items.push({jid:jid,name:name,node:node,call_back:call_back});return true},info:function(jid,node,success,error,timeout){var attrs={xmlns:Strophe.NS.DISCO_INFO};if(node){attrs.node=node}var info=$iq({from:this._connection.jid,to:jid,type:"get"}).c("query",attrs);this._connection.sendIQ(info,success,error,timeout)},items:function(jid,node,success,error,timeout){var attrs={xmlns:Strophe.NS.DISCO_ITEMS};if(node){attrs.node=node}var items=$iq({from:this._connection.jid,to:jid,type:"get"}).c("query",attrs);this._connection.sendIQ(items,success,error,timeout)},_buildIQResult:function(stanza,query_attrs){var id=stanza.getAttribute("id");var from=stanza.getAttribute("from");var iqresult=$iq({type:"result",id:id});if(from!==null){iqresult.attrs({to:from})}return iqresult.c("query",query_attrs)},_onDiscoInfo:function(stanza){var node=stanza.getElementsByTagName("query")[0].getAttribute("node");var attrs={xmlns:Strophe.NS.DISCO_INFO};if(node){attrs.node=node}var iqresult=this._buildIQResult(stanza,attrs);for(var i=0;i<this._identities.length;i++){var attrs={category:this._identities[i].category,type:this._identities[i].type};if(this._identities[i].name){attrs.name=this._identities[i].name}if(this._identities[i].lang){attrs["xml:lang"]=this._identities[i].lang}iqresult.c("identity",attrs).up()}for(var i=0;i<this._features.length;i++){iqresult.c("feature",{"var":this._features[i]}).up()}this._connection.send(iqresult.tree());return true},_onDiscoItems:function(stanza){var query_attrs={xmlns:Strophe.NS.DISCO_ITEMS};var node=stanza.getElementsByTagName("query")[0].getAttribute("node");if(node){query_attrs.node=node;var items=[];for(var i=0;i<this._items.length;i++){if(this._items[i].node==node){items=this._items[i].call_back(stanza);break}}}else{var items=this._items}var iqresult=this._buildIQResult(stanza,query_attrs);for(var i=0;i<items.length;i++){var attrs={jid:items[i].jid};if(items[i].name){attrs.name=items[i].name}if(items[i].node){attrs.node=items[i].node}iqresult.c("item",attrs).up()}this._connection.send(iqresult.tree());return true}});

	/**
	 * Strophe.caps plugin
	 */

	Strophe.addConnectionPlugin("caps",{HASH:"sha-1",node:"http://strophe.im/strophejs/",_ver:"",_connection:null,_knownCapabilities:{},_jidVerIndex:{},init:function(conn){this._connection=conn;Strophe.addNamespace("CAPS","http://jabber.org/protocol/caps");if(!this._connection.disco){throw"Caps plugin requires the disco plugin to be installed."}this._connection.disco.addFeature(Strophe.NS.CAPS);this._connection.addHandler(this._delegateCapabilities.bind(this),Strophe.NS.CAPS)},generateCapsAttrs:function(){return{xmlns:Strophe.NS.CAPS,hash:this.HASH,node:this.node,ver:this.generateVer()}},generateVer:function(){if(this._ver!==""){return this._ver}var ver="",identities=this._connection.disco._identities.sort(this._sortIdentities),identitiesLen=identities.length,features=this._connection.disco._features.sort(),featuresLen=features.length;for(var i=0;i<identitiesLen;i++){var curIdent=identities[i];ver+=curIdent.category+"/"+curIdent.type+"/"+curIdent.lang+"/"+curIdent.name+"<"}for(var i=0;i<featuresLen;i++){ver+=features[i]+"<"}this._ver=b64_sha1(ver);return this._ver},getCapabilitiesByJid:function(jid){if(this._jidVerIndex[jid]){return this._knownCapabilities[this._jidVerIndex[jid]]}return null},_delegateCapabilities:function(stanza){var from=stanza.getAttribute("from"),c=stanza.querySelector("c"),ver=c.getAttribute("ver"),node=c.getAttribute("node");if(!this._knownCapabilities[ver]){return this._requestCapabilities(from,node,ver)}else{this._jidVerIndex[from]=ver}if(!this._jidVerIndex[from]||!this._jidVerIndex[from]!==ver){this._jidVerIndex[from]=ver}return true},_requestCapabilities:function(to,node,ver){if(to!==this._connection.jid){var id=this._connection.disco.info(to,node+"#"+ver);this._connection.addHandler(this._handleDiscoInfoReply.bind(this),Strophe.NS.DISCO_INFO,"iq","result",id,to)}return true},_handleDiscoInfoReply:function(stanza){var query=stanza.querySelector("query"),node=query.getAttribute("node").split("#"),ver=node[1],from=stanza.getAttribute("from");if(!this._knownCapabilities[ver]){var childNodes=query.childNodes,childNodesLen=childNodes.length;this._knownCapabilities[ver]=[];for(var i=0;i<childNodesLen;i++){var node=childNodes[i];this._knownCapabilities[ver].push({name:node.nodeName,attributes:node.attributes})}this._jidVerIndex[from]=ver}else{if(!this._jidVerIndex[from]||!this._jidVerIndex[from]!==ver){this._jidVerIndex[from]=ver}}return false},_sortIdentities:function(a,b){if(a.category>b.category){return 1}if(a.category<b.category){return -1}if(a.type>b.type){return 1}if(a.type<b.type){return -1}if(a.lang>b.lang){return 1}if(a.lang<b.lang){return -1}return 0}});

	/**
	 * TraceablePeerConnection
	 */

	function TraceablePeerConnection(ice_config, constraints) {
	    var self = this;
	    var RTCPeerconnection = navigator.mozGetUserMedia ? mozRTCPeerConnection : webkitRTCPeerConnection;
	    this.peerconnection = new RTCPeerconnection(ice_config, constraints);
	    this.updateLog = [];
	    this.stats = {};
	    this.statsinterval = null;
	    this.maxstats = 0; // limit to 300 values, i.e. 5 minutes; set to 0 to disable

	    /**
	     * Array of ssrcs that will be added on next modifySources call.
	     * @type {Array}
	     */
	    this.addssrc = [];
	    /**
	     * Array of ssrcs that will be added on next modifySources call.
	     * @type {Array}
	     */
	    this.removessrc = [];
	    /**
	     * Pending operation that will be done during modifySources call.
	     * Currently 'mute'/'unmute' operations are supported.
	     *
	     * @type {String}
	     */
	    this.pendingop = null;

	    /**
	     * Flag indicates that peer connection stream have changed and modifySources should proceed.
	     * @type {boolean}
	     */
	    this.switchstreams = false;

	    // override as desired
	    this.trace = function (what, info) {
		//console.warn('WTRACE', what, info);
		self.updateLog.push({
		    time: new Date(),
		    type: what,
		    value: info || ""
		});
	    };
	    this.onicecandidate = null;
	    this.peerconnection.onicecandidate = function (event) {
		self.trace('onicecandidate', JSON.stringify(event.candidate, null, ' '));
		if (self.onicecandidate !== null) {
		    self.onicecandidate(event);
		}
	    };
	    this.onaddstream = null;
	    this.peerconnection.onaddstream = function (event) {
		self.trace('onaddstream', event.stream.id);
		if (self.onaddstream !== null) {
		    self.onaddstream(event);
		}
	    };
	    this.onremovestream = null;
	    this.peerconnection.onremovestream = function (event) {
		self.trace('onremovestream', event.stream.id);
		if (self.onremovestream !== null) {
		    self.onremovestream(event);
		}
	    };
	    this.onsignalingstatechange = null;
	    this.peerconnection.onsignalingstatechange = function (event) {
		self.trace('onsignalingstatechange', self.signalingState);
		if (self.onsignalingstatechange !== null) {
		    self.onsignalingstatechange(event);
		}
	    };
	    this.oniceconnectionstatechange = null;
	    this.peerconnection.oniceconnectionstatechange = function (event) {
		self.trace('oniceconnectionstatechange', self.iceConnectionState);
		if (self.oniceconnectionstatechange !== null) {
		    self.oniceconnectionstatechange(event);
		}
	    };
	    this.onnegotiationneeded = null;
	    this.peerconnection.onnegotiationneeded = function (event) {
		self.trace('onnegotiationneeded');
		if (self.onnegotiationneeded !== null) {
		    self.onnegotiationneeded(event);
		}
	    };
	    self.ondatachannel = null;
	    this.peerconnection.ondatachannel = function (event) {
		self.trace('ondatachannel', event);
		if (self.ondatachannel !== null) {
		    self.ondatachannel(event);
		}
	    };
	    if (!navigator.mozGetUserMedia && this.maxstats) {
		this.statsinterval = window.setInterval(function() {
		    self.peerconnection.getStats(function(stats) {
			var results = stats.result();
			for (var i = 0; i < results.length; ++i) {
			    //console.log(results[i].type, results[i].id, results[i].names())
			    var now = new Date();
			    results[i].names().forEach(function (name) {
				var id = results[i].id + '-' + name;
				if (!self.stats[id]) {
				    self.stats[id] = {
					startTime: now,
					endTime: now,
					values: [],
					times: []
				    };
				}
				self.stats[id].values.push(results[i].stat(name));
				self.stats[id].times.push(now.getTime());
				if (self.stats[id].values.length > self.maxstats) {
				    self.stats[id].values.shift();
				    self.stats[id].times.shift();
				}
				self.stats[id].endTime = now;
			    });
			}
		    });

		}, 1000);
	    }
	};

	dumpSDP = function(description) {
	    return 'type: ' + description.type + '\r\n' + description.sdp;
	}

	if (TraceablePeerConnection.prototype.__defineGetter__ !== undefined) {
	    TraceablePeerConnection.prototype.__defineGetter__('signalingState', function() { return this.peerconnection.signalingState; });
	    TraceablePeerConnection.prototype.__defineGetter__('iceConnectionState', function() { return this.peerconnection.iceConnectionState; });
	    TraceablePeerConnection.prototype.__defineGetter__('localDescription', function() {
		var publicLocalDescription = simulcast.reverseTransformLocalDescription(this.peerconnection.localDescription);
		return publicLocalDescription;
	    });
	    TraceablePeerConnection.prototype.__defineGetter__('remoteDescription', function() {
		var publicRemoteDescription = simulcast.reverseTransformRemoteDescription(this.peerconnection.remoteDescription);
		return publicRemoteDescription;
	    });
	}

	TraceablePeerConnection.prototype.addStream = function (stream) {
	    this.trace('addStream', stream.id);
	    simulcast.resetSender();
	    try
	    {
		this.peerconnection.addStream(stream);
	    }
	    catch (e)
	    {
		console.error(e);
		return;
	    }
	};

	TraceablePeerConnection.prototype.removeStream = function (stream, stopStreams) {
	    this.trace('removeStream', stream.id);
	    simulcast.resetSender();
	    if(stopStreams) {
		stream.getAudioTracks().forEach(function (track) {
		    track.stop();
		});
		stream.getVideoTracks().forEach(function (track) {
		    track.stop();
		});
	    }
	    this.peerconnection.removeStream(stream);
	};

	TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
	    this.trace('createDataChannel', label, opts);
	    return this.peerconnection.createDataChannel(label, opts);
	};

	TraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {
	    var self = this;
	    description = simulcast.transformLocalDescription(description);
	    this.trace('setLocalDescription', dumpSDP(description));
	    this.peerconnection.setLocalDescription(description,
		function () {
		    self.trace('setLocalDescriptionOnSuccess');
		    successCallback();
		},
		function (err) {
		    self.trace('setLocalDescriptionOnFailure', err);
		    
		    if (err.indexOf("Called in wrong state") > -1)
		    {
			setTimeout(function()
			{
				self.setLocalDescription(description, successCallback, failureCallback);

			}, 1000);

		    } else failureCallback(err);		    
		}
	    );
	    /*
	     if (this.statsinterval === null && this.maxstats > 0) {
	     // start gathering stats
	     }
	     */
	};

	TraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {
	    var self = this;
	    description = simulcast.transformRemoteDescription(description);
	    this.trace('setRemoteDescription', dumpSDP(description));
	    this.peerconnection.setRemoteDescription(description,
		function () {
		    self.trace('setRemoteDescriptionOnSuccess');
		    successCallback();
		},
		function (err) {
		    self.trace('setRemoteDescriptionOnFailure', err);
		    failureCallback(err);
		}
	    );
	    /*
	     if (this.statsinterval === null && this.maxstats > 0) {
	     // start gathering stats
	     }
	     */
	};

	TraceablePeerConnection.prototype.hardMuteVideo = function (muted) {
	    this.pendingop = muted ? 'mute' : 'unmute';
	};

	TraceablePeerConnection.prototype.enqueueAddSsrc = function(channel, ssrcLines) {
	    if (!this.addssrc[channel]) {
		this.addssrc[channel] = '';
	    }
	    this.addssrc[channel] += ssrcLines;
	};

	TraceablePeerConnection.prototype.addSource = function (elem) {
	    //console.log('addssrc', new Date().getTime());
	    //console.log('ice', this.iceConnectionState);
	    var sdp = new SDP(this.remoteDescription.sdp);
	    var mySdp = new SDP(this.peerconnection.localDescription.sdp);

	    var self = this;
	    $(elem).each(function (idx, content) {
		var name = $(content).attr('name');
		var lines = '';
		tmp = $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
		    var semantics = this.getAttribute('semantics');
		    var ssrcs = $(this).find('>source').map(function () {
			return this.getAttribute('ssrc');
		    }).get();

		    if (ssrcs.length != 0) {
			lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
		    }
		});
		tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]'); // can handle both >source and >description>source
		tmp.each(function () {
		    var ssrc = $(this).attr('ssrc');
		    if(mySdp.containsSSRC(ssrc)){
			/**
			 * This happens when multiple participants change their streams at the same time and
			 * ColibriFocus.modifySources have to wait for stable state. In the meantime multiple
			 * addssrc are scheduled for update IQ. See
			 */
			console.warn("Got add stream request for my own ssrc: "+ssrc);
			return;
		    }
		    $(this).find('>parameter').each(function () {
			lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');
			if ($(this).attr('value') && $(this).attr('value').length)
			    lines += ':' + $(this).attr('value');
			lines += '\r\n';
		    });
		});
		sdp.media.forEach(function(media, idx) {
		    if (!SDPUtil.find_line(media, 'a=mid:' + name))
			return;
		    sdp.media[idx] += lines;
		    self.enqueueAddSsrc(idx, lines);
		});
		sdp.raw = sdp.session + sdp.media.join('');
	    });
	};

	TraceablePeerConnection.prototype.enqueueRemoveSsrc = function(channel, ssrcLines) {
	    if (!this.removessrc[channel]){
		this.removessrc[channel] = '';
	    }
	    this.removessrc[channel] += ssrcLines;
	};

	TraceablePeerConnection.prototype.removeSource = function (elem) {
	    //console.log('removessrc', new Date().getTime());
	    //console.log('ice', this.iceConnectionState);
	    var sdp = new SDP(this.remoteDescription.sdp);
	    var mySdp = new SDP(this.peerconnection.localDescription.sdp);

	    var self = this;
	    $(elem).each(function (idx, content) {
		var name = $(content).attr('name');
		var lines = '';
		tmp = $(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
		    var semantics = this.getAttribute('semantics');
		    var ssrcs = $(this).find('>source').map(function () {
			return this.getAttribute('ssrc');
		    }).get();

		    if (ssrcs.length != 0) {
			lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\r\n';
		    }
		});
		tmp = $(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]'); // can handle both >source and >description>source
		tmp.each(function () {
		    var ssrc = $(this).attr('ssrc');
		    // This should never happen, but can be useful for bug detection
		    if(mySdp.containsSSRC(ssrc)){
			console.error("Got remove stream request for my own ssrc: "+ssrc);
			return;
		    }
		    $(this).find('>parameter').each(function () {
			lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');
			if ($(this).attr('value') && $(this).attr('value').length)
			    lines += ':' + $(this).attr('value');
			lines += '\r\n';
		    });
		});
		sdp.media.forEach(function(media, idx) {
		    if (!SDPUtil.find_line(media, 'a=mid:' + name))
			return;
		    sdp.media[idx] += lines;
		    self.enqueueRemoveSsrc(idx, lines);
		});
		sdp.raw = sdp.session + sdp.media.join('');
	    });
	};

	TraceablePeerConnection.prototype.modifySources = function(successCallback) {
	    var self = this;
	    if (this.signalingState == 'closed') return;
	    if (!(this.addssrc.length || this.removessrc.length || this.pendingop !== null || this.switchstreams)){
		// There is nothing to do since scheduled job might have been executed by another succeeding call
		if(successCallback){
		    successCallback();
		}
		return;
	    }

	    // FIXME: this is a big hack
	    // https://code.google.com/p/webrtc/issues/detail?id=2688
	    // ^ has been fixed.

	    // Reset switch streams flag
	    this.switchstreams = false;

	    var sdp = new SDP(this.remoteDescription.sdp);

	    // add sources
	    this.addssrc.forEach(function(lines, idx) {
		sdp.media[idx] += lines;
	    });
	    this.addssrc = [];

	    // remove sources
	    this.removessrc.forEach(function(lines, idx) {
		lines = lines.split('\r\n');
		lines.pop(); // remove empty last element;
		lines.forEach(function(line) {
		    sdp.media[idx] = sdp.media[idx].replace(line + '\r\n', '');
		});
	    });
	    this.removessrc = [];

	    // FIXME:
	    // this was a hack for the situation when only one peer exists
	    // in the conference.
	    // check if still required and remove
	    if (sdp.media[0])
		sdp.media[0] = sdp.media[0].replace('a=recvonly', 'a=sendrecv');
	    if (sdp.media[1])
		sdp.media[1] = sdp.media[1].replace('a=recvonly', 'a=sendrecv');

	    sdp.raw = sdp.session + sdp.media.join('');
	    this.setRemoteDescription(new RTCSessionDescription({type: 'offer', sdp: sdp.raw}),
		function() {

		    if(self.signalingState == 'closed') {
			console.error("createAnswer attempt on closed state");
			return;
		    }

		    self.createAnswer(
			function(modifiedAnswer) {
			    // change video direction, see https://github.com/jitsi/jitmeet/issues/41
			    if (self.pendingop !== null) {
				var sdp = new SDP(modifiedAnswer.sdp);
				if (sdp.media.length > 1) {
				    switch(self.pendingop) {
					case 'mute':
					    sdp.media[1] = sdp.media[1].replace('a=sendrecv', 'a=recvonly');
					    break;
					case 'unmute':
					    sdp.media[1] = sdp.media[1].replace('a=recvonly', 'a=sendrecv');
					    break;
				    }
				    sdp.raw = sdp.session + sdp.media.join('');
				    modifiedAnswer.sdp = sdp.raw;
				}
				self.pendingop = null;
			    }

			    // FIXME: pushing down an answer while ice connection state
			    // is still checking is bad...
			    //console.log(self.peerconnection.iceConnectionState);

			    // trying to work around another chrome bug
			    //modifiedAnswer.sdp = modifiedAnswer.sdp.replace(/a=setup:active/g, 'a=setup:actpass');
			    self.setLocalDescription(modifiedAnswer,
				function() {
				    //console.log('modified setLocalDescription ok');
				    if(successCallback){
					successCallback();
				    }
				},
				function(error) {
				    console.error('modified setLocalDescription failed', error);
				}
			    );
			},
			function(error) {
			    console.error('modified answer failed', error);
			}
		    );
		},
		function(error) {
		    console.error('modify failed', error);
		}
	    );
	};

	TraceablePeerConnection.prototype.close = function () {
	    this.trace('stop');
	    if (this.statsinterval !== null) {
		window.clearInterval(this.statsinterval);
		this.statsinterval = null;
	    }
	    try {
	    	this.peerconnection.close();
	    	
	    } catch (e) {}
	};

	TraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {
	    var self = this;
	    this.trace('createOffer', JSON.stringify(constraints, null, ' '));
	    this.peerconnection.createOffer(
		function (offer) {
		    self.trace('createOfferOnSuccess', dumpSDP(offer));
		    successCallback(offer);
		},
		function(err) {
		    self.trace('createOfferOnFailure', err);
		    failureCallback(err);
		},
		constraints
	    );
	};

	TraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {
	    var self = this;
	    this.trace('createAnswer', JSON.stringify(constraints, null, ' '));
	    this.peerconnection.createAnswer(
		function (answer) {
		    answer = simulcast.transformAnswer(answer);
		    self.trace('createAnswerOnSuccess', dumpSDP(answer));
		    successCallback(answer);
		},
		function(err) {
		    self.trace('createAnswerOnFailure', err);
		    failureCallback(err);
		},
		constraints
	    );
	};

	TraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {
	    var self = this;
	    this.trace('addIceCandidate', JSON.stringify(candidate, null, ' '));
	    this.peerconnection.addIceCandidate(candidate);
	    /* maybe later
	     this.peerconnection.addIceCandidate(candidate,
	     function () {
	     self.trace('addIceCandidateOnSuccess');
	     successCallback();
	     },
	     function (err) {
	     self.trace('addIceCandidateOnFailure', err);
	     failureCallback(err);
	     }
	     );
	     */
	};

	TraceablePeerConnection.prototype.getStats = function(callback, errback) {
	    if (navigator.mozGetUserMedia) {
		// ignore for now...
		if(!errback)
		    errback = function () {

		    }
		this.peerconnection.getStats(null,callback,errback);
	    } else {
		this.peerconnection.getStats(callback);
	    }
	};

	// mozilla chrome compat layer -- very similar to adapter.js
	function setupRTC() {
	    var RTC = null;
	    if (navigator.mozGetUserMedia) {
		//console.log('This appears to be Firefox');
		var version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
		if (version >= 22) {
		    RTC = {
			peerconnection: mozRTCPeerConnection,
			browser: 'firefox',
			getUserMedia: navigator.mozGetUserMedia.bind(navigator),
			attachMediaStream: function (element, stream) {
			    element[0].mozSrcObject = stream;
			    element[0].play();
			},
			pc_constraints: {},
			getLocalSSRC: function (session, callback) {
			    // NOTE(gp) latest FF nightlies seem to provide the local
			    // SSRCs in their SDP so there's no longer necessary to
			    // take it from the peer connection stats.
			    /*session.peerconnection.getStats(function (s) {
				    var ssrcs = {};
				    s.forEach(function (item) {
					if (item.type == "outboundrtp" && !item.isRemote)
					{
					    ssrcs[item.id.split('_')[2]] = item.ssrc;
					}
				    });
				    session.localStreamsSSRC = {
					"audio": ssrcs.audio,//for stable 0
					"video": ssrcs.video// for stable 1
				    };
				    callback(session.localStreamsSSRC);
				},
				function () {
				    callback(null);
				});*/
			    callback(null);
			},
			getStreamID: function (stream) {
			    var tracks = stream.getVideoTracks();
			    if(!tracks || tracks.length == 0)
			    {
				tracks = stream.getAudioTracks();
			    }
			    return tracks[0].id.replace(/[\{,\}]/g,"");
			},
			getVideoSrc: function (element) {
			    return element.mozSrcObject;
			},
			setVideoSrc: function (element, src) {
			    element.mozSrcObject = src;
			}
		    };
		    if (!MediaStream.prototype.getVideoTracks)
			MediaStream.prototype.getVideoTracks = function () { return []; };
		    if (!MediaStream.prototype.getAudioTracks)
			MediaStream.prototype.getAudioTracks = function () { return []; };
		    RTCSessionDescription = mozRTCSessionDescription;
		    RTCIceCandidate = mozRTCIceCandidate;
		}
	    } else if (navigator.webkitGetUserMedia) {
		//console.log('This appears to be Chrome');
		RTC = {
		    peerconnection: webkitRTCPeerConnection,
		    browser: 'chrome',
		    getUserMedia: navigator.webkitGetUserMedia.bind(navigator),
		    attachMediaStream: function (element, stream) {
			element.attr('src', URL.createObjectURL(stream));
		    },
		    // DTLS should now be enabled by default but..
		    pc_constraints: {'optional': [{'DtlsSrtpKeyAgreement': 'true'}]},
		    getLocalSSRC: function (session, callback) {
			callback(null);
		    },
		    getStreamID: function (stream) {
			// streams from FF endpoints have the characters '{' and '}'
			// that make jQuery choke.
			return stream.id.replace(/[\{,\}]/g,"");
		    },
		    getVideoSrc: function (element) {
			return element.getAttribute("src");
		    },
		    setVideoSrc: function (element, src) {
			element.setAttribute("src", src);
		    }
		};
		if (navigator.userAgent.indexOf('Android') != -1) {
		    RTC.pc_constraints = {}; // disable DTLS on Android
		}
		if (!webkitMediaStream.prototype.getVideoTracks) {
		    webkitMediaStream.prototype.getVideoTracks = function () {
			return this.videoTracks;
		    };
		}
		if (!webkitMediaStream.prototype.getAudioTracks) {
		    webkitMediaStream.prototype.getAudioTracks = function () {
			return this.audioTracks;
		    };
		}
	    }
	    if (RTC === null) {
		try { console.log('Browser does not appear to be WebRTC-capable'); } catch (e) { }
	    }
	    return RTC;
	}

	function getUserMediaWithConstraints(um, success_callback, failure_callback, resolution, bandwidth, fps, desktopStream) {
	    var constraints = {audio: false, video: false};

	    if (um.indexOf('video') >= 0) {
		constraints.video = { mandatory: {}, optional: [] };// same behaviour as true
	    }
	    if (um.indexOf('audio') >= 0) {
		constraints.audio = { mandatory: {}, optional: []};// same behaviour as true
	    }
	    if (um.indexOf('screen') >= 0) {
		constraints.video = {
		    mandatory: {
			chromeMediaSource: "screen",
			googLeakyBucket: true,
			maxWidth: window.screen.width,
			maxHeight: window.screen.height,
			maxFrameRate: 3
		    },
		    optional: []
		};
	    }
	    if (um.indexOf('desktop') >= 0) {
		constraints.video = {
		    mandatory: {
			chromeMediaSource: "desktop",
			chromeMediaSourceId: desktopStream,
			googLeakyBucket: true,
			maxWidth: window.screen.width,
			maxHeight: window.screen.height,
			maxFrameRate: 3
		    },
		    optional: []
		}
	    }

	    if (constraints.audio) {
		// if it is good enough for hangouts...
		constraints.audio.optional.push(
		    {googEchoCancellation: true},
		    {googAutoGainControl: true},
		    {googNoiseSupression: true},
		    {googHighpassFilter: true},
		    {googNoisesuppression2: true},
		    {googEchoCancellation2: true},
		    {googAutoGainControl2: true}
		);
	    }
	    if (constraints.video) {
		constraints.video.optional.push(
		    {googNoiseReduction: false} // chrome 37 workaround for issue 3807, reenable in M38
		);
		if (um.indexOf('video') >= 0) {
		    constraints.video.optional.push(
			{googLeakyBucket: true}
		    );
		}
	    }

	    // Check if we are running on Android device
	    var isAndroid = navigator.userAgent.indexOf('Android') != -1;

	    if (resolution && !constraints.video || isAndroid) {
		constraints.video = { mandatory: {}, optional: [] };// same behaviour as true
	    }
	    // see https://code.google.com/p/chromium/issues/detail?id=143631#c9 for list of supported resolutions
	    switch (resolution) {
		// 16:9 first
		case '1080':
		case 'fullhd':
		    constraints.video.mandatory.minWidth = 1920;
		    constraints.video.mandatory.minHeight = 1080;
		    break;
		case '720':
		case 'hd':
		    constraints.video.mandatory.minWidth = 1280;
		    constraints.video.mandatory.minHeight = 720;
		    break;
		case '360':
		    constraints.video.mandatory.minWidth = 640;
		    constraints.video.mandatory.minHeight = 360;
		    break;
		case '180':
		    constraints.video.mandatory.minWidth = 320;
		    constraints.video.mandatory.minHeight = 180;
		    break;
		// 4:3
		case '960':
		    constraints.video.mandatory.minWidth = 960;
		    constraints.video.mandatory.minHeight = 720;
		    break;
		case '640':
		case 'vga':
		    constraints.video.mandatory.minWidth = 640;
		    constraints.video.mandatory.minHeight = 480;
		    break;
		case '320':
		    constraints.video.mandatory.minWidth = 320;
		    constraints.video.mandatory.minHeight = 240;
		    break;
		default:
		    if (isAndroid) {
			constraints.video.mandatory.minWidth = 320;
			constraints.video.mandatory.minHeight = 240;
			constraints.video.mandatory.maxFrameRate = 15;
		    }
		    break;
	    }
	    if (constraints.video)
	    {
		    if (constraints.video.mandatory.minWidth)
			constraints.video.mandatory.maxWidth = constraints.video.mandatory.minWidth;
		    if (constraints.video.mandatory.minHeight)
			constraints.video.mandatory.maxHeight = constraints.video.mandatory.minHeight;
	    }

	    if (bandwidth) { // doesn't work currently, see webrtc issue 1846
		if (!constraints.video) constraints.video = {mandatory: {}, optional: []};//same behaviour as true
		constraints.video.optional.push({bandwidth: bandwidth});
	    }
	    if (fps) { // for some cameras it might be necessary to request 30fps
		// so they choose 30fps mjpg over 10fps yuy2
		if (!constraints.video) constraints.video = {mandatory: {}, optional: []};// same behaviour as true;
		constraints.video.mandatory.minFrameRate = fps;
	    }

	    var isFF = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

	    try {
		if (config.enableSimulcast
		    && constraints.video
		    && constraints.video.chromeMediaSource !== 'screen'
		    && constraints.video.chromeMediaSource !== 'desktop'
		    && !isAndroid

		    // We currently do not support FF, as it doesn't have multistream support.
		    && !isFF) {
		    simulcast.getUserMedia(constraints, function (stream) {
			    //console.log('onUserMediaSuccess');
			    success_callback(stream);
			},
			function (error) {
			    console.warn('Failed to get access to local media. Error ', error);
			    if (failure_callback) {
				failure_callback(error);
			    }
			});
		} else {

		    RTC.getUserMedia(constraints,
			function (stream) {
			    //console.log('onUserMediaSuccess');
			    success_callback(stream);
			},
			function (error) {
			    console.warn('Failed to get access to local media. Error ', error);
			    if (failure_callback) {
				failure_callback(error);
			    }
			});

		}
	    } catch (e) {
		console.error('GUM failed: ', e);
		if(failure_callback) {
		    failure_callback(e);
		}
	    }
	}


	/**
	 * Strophe logger implementation. Logs from level WARN and above.
	 */

	Strophe.log = function (level, msg) {
	    switch(level) {
		case Strophe.LogLevel.WARN:
		    console.warn("Strophe: "+msg);
		    break;
		case Strophe.LogLevel.ERROR:
		case Strophe.LogLevel.FATAL:
		    console.error("Strophe: "+msg);
		    break;
	    }
	};

	Strophe.getStatusString = function(status)
	{
	    switch (status)
	    {
		case Strophe.Status.ERROR:
		    return "ERROR";
		case Strophe.Status.CONNECTING:
		    return "CONNECTING";
		case Strophe.Status.CONNFAIL:
		    return "CONNFAIL";
		case Strophe.Status.AUTHENTICATING:
		    return "AUTHENTICATING";
		case Strophe.Status.AUTHFAIL:
		    return "AUTHFAIL";
		case Strophe.Status.CONNECTED:
		    return "CONNECTED";
		case Strophe.Status.DISCONNECTED:
		    return "DISCONNECTED";
		case Strophe.Status.DISCONNECTING:
		    return "DISCONNECTING";
		case Strophe.Status.ATTACHED:
		    return "ATTACHED";
		default:
		    return "unknown";
	    }
	};

	/**
	 * The audio Levels plugin.
	 */
	var AudioLevels = (function(my) {
	    var audioLevelCanvasCache = {};

	    my.LOCAL_LEVEL = 'local';

	    /**
	     * Updates the audio level canvas for the given peerJid. If the canvas
	     * didn't exist we create it.
	     */
	    my.updateAudioLevelCanvas = function (peerJid) {
		var resourceJid = null;
		var videoSpanId = null;
		if (!peerJid)
		    videoSpanId = 'localVideoContainer';
		else {
		    resourceJid = Strophe.getResourceFromJid(peerJid);

		    videoSpanId = 'participant_' + resourceJid;
		}

		var videoSpan = document.getElementById(videoSpanId);

		if (!videoSpan) {
		    if (resourceJid)
			console.error("No video element for jid", resourceJid);
		    else
			console.error("No video element for local video.");

		    return;
		}

		var audioLevelCanvas = $('#' + videoSpanId + '>canvas');

		var videoSpaceWidth = $('#remoteVideos').width();
		var thumbnailSize = VideoLayout.calculateThumbnailSize(videoSpaceWidth);
		var thumbnailWidth = thumbnailSize[0];
		var thumbnailHeight = thumbnailSize[1];

		if (!audioLevelCanvas || audioLevelCanvas.length === 0) {

		    audioLevelCanvas = document.createElement('canvas');
		    audioLevelCanvas.className = "audiolevel";
		    audioLevelCanvas.style.bottom = "-" + interfaceConfig.CANVAS_EXTRA/2 + "px";
		    audioLevelCanvas.style.left = "-" + interfaceConfig.CANVAS_EXTRA/2 + "px";
		    resizeAudioLevelCanvas( audioLevelCanvas,
			    thumbnailWidth,
			    thumbnailHeight);

		    videoSpan.appendChild(audioLevelCanvas);
		} else {
		    audioLevelCanvas = audioLevelCanvas.get(0);

		    resizeAudioLevelCanvas( audioLevelCanvas,
			    thumbnailWidth,
			    thumbnailHeight);
		}
	    };

	    /**
	     * Updates the audio level UI for the given resourceJid.
	     *
	     * @param resourceJid the resource jid indicating the video element for
	     * which we draw the audio level
	     * @param audioLevel the newAudio level to render
	     */
	    my.updateAudioLevel = function (resourceJid, audioLevel) {
		drawAudioLevelCanvas(resourceJid, audioLevel);

		var videoSpanId = getVideoSpanId(resourceJid);

		var audioLevelCanvas = $('#' + videoSpanId + '>canvas').get(0);

		if (!audioLevelCanvas)
		    return;

		var drawContext = audioLevelCanvas.getContext('2d');

		var canvasCache = audioLevelCanvasCache[resourceJid];

		drawContext.clearRect (0, 0,
			audioLevelCanvas.width, audioLevelCanvas.height);
		drawContext.drawImage(canvasCache, 0, 0);

		if(resourceJid === AudioLevels.LOCAL_LEVEL) {
		    if(!connection.emuc.myroomjid) {
			return;
		    }
		    resourceJid = Strophe.getResourceFromJid(connection.emuc.myroomjid);
		}

		if(resourceJid  === VideoLayout.getLargeVideoState().userResourceJid) {
		    AudioLevels.updateActiveSpeakerAudioLevel(audioLevel);
		}
	    };

	    my.updateActiveSpeakerAudioLevel = function(audioLevel) {
		var drawContext = $('#activeSpeakerAudioLevel')[0].getContext('2d');
		var r = interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE / 2;
		var center = (interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE + r) / 2;

		// Save the previous state of the context.
		drawContext.save();

		drawContext.clearRect(0, 0, 300, 300);

		// Draw a circle.
		drawContext.arc(center, center, r, 0, 2 * Math.PI);

		// Add a shadow around the circle
		drawContext.shadowColor = interfaceConfig.SHADOW_COLOR;
		drawContext.shadowBlur = getShadowLevel(audioLevel);
		drawContext.shadowOffsetX = 0;
		drawContext.shadowOffsetY = 0;

		// Fill the shape.
		drawContext.fill();

		drawContext.save();

		drawContext.restore();


		drawContext.arc(center, center, r, 0, 2 * Math.PI);

		drawContext.clip();
		drawContext.clearRect(0, 0, 277, 200);

		// Restore the previous context state.
		drawContext.restore();
	    };

	    /**
	     * Resizes the given audio level canvas to match the given thumbnail size.
	     */
	    function resizeAudioLevelCanvas(audioLevelCanvas,
					    thumbnailWidth,
					    thumbnailHeight) {
		audioLevelCanvas.width = thumbnailWidth + interfaceConfig.CANVAS_EXTRA;
		audioLevelCanvas.height = thumbnailHeight + interfaceConfig.CANVAS_EXTRA;
	    }

	    /**
	     * Draws the audio level canvas into the cached canvas object.
	     *
	     * @param resourceJid the resource jid indicating the video element for
	     * which we draw the audio level
	     * @param audioLevel the newAudio level to render
	     */
	    function drawAudioLevelCanvas(resourceJid, audioLevel) {
		if (!audioLevelCanvasCache[resourceJid]) {

		    var videoSpanId = getVideoSpanId(resourceJid);

		    var audioLevelCanvasOrig = $('#' + videoSpanId + '>canvas').get(0);

		    /*
		     * FIXME Testing has shown that audioLevelCanvasOrig may not exist.
		     * In such a case, the method CanvasUtil.cloneCanvas may throw an
		     * error. Since audio levels are frequently updated, the errors have
		     * been observed to pile into the console, strain the CPU.
		     */
		    if (audioLevelCanvasOrig)
		    {
			audioLevelCanvasCache[resourceJid]
			    = CanvasUtil.cloneCanvas(audioLevelCanvasOrig);
		    }
		}

		var canvas = audioLevelCanvasCache[resourceJid];

		if (!canvas || $('#videospace').css("display") == "none")
		    return;

		var drawContext = canvas.getContext('2d');

		drawContext.clearRect(0, 0, canvas.width, canvas.height);

		var shadowLevel = getShadowLevel(audioLevel);

		if (shadowLevel > 0)
		    // drawContext, x, y, w, h, r, shadowColor, shadowLevel
		    CanvasUtil.drawRoundRectGlow(   drawContext,
			interfaceConfig.CANVAS_EXTRA/2, interfaceConfig.CANVAS_EXTRA/2,
			canvas.width - interfaceConfig.CANVAS_EXTRA,
			canvas.height - interfaceConfig.CANVAS_EXTRA,
			interfaceConfig.CANVAS_RADIUS,
			interfaceConfig.SHADOW_COLOR,
			shadowLevel);
	    }

	    /**
	     * Returns the shadow/glow level for the given audio level.
	     *
	     * @param audioLevel the audio level from which we determine the shadow
	     * level
	     */
	    function getShadowLevel (audioLevel) {
		var shadowLevel = 0;

		if (audioLevel <= 0.3) {
		    shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*(audioLevel/0.3));
		}
		else if (audioLevel <= 0.6) {
		    shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*((audioLevel - 0.3) / 0.3));
		}
		else {
		    shadowLevel = Math.round(interfaceConfig.CANVAS_EXTRA/2*((audioLevel - 0.6) / 0.4));
		}
		return shadowLevel;
	    }

	    /**
	     * Returns the video span id corresponding to the given resourceJid or local
	     * user.
	     */
	    function getVideoSpanId(resourceJid) {
		var videoSpanId = null;
		if (resourceJid === AudioLevels.LOCAL_LEVEL
			|| (connection.emuc.myroomjid && resourceJid
			    === Strophe.getResourceFromJid(connection.emuc.myroomjid)))
		    videoSpanId = 'localVideoContainer';
		else
		    videoSpanId = 'participant_' + resourceJid;

		return videoSpanId;
	    }

	    /**
	     * Indicates that the remote video has been resized.
	     */
	    $(document).bind('remotevideo.resized', function (event, width, height) {
		var resized = false;
		$('#remoteVideos>span>canvas').each(function() {
		    var canvas = $(this).get(0);
		    if (canvas.width !== width + interfaceConfig.CANVAS_EXTRA) {
			canvas.width = width + interfaceConfig.CANVAS_EXTRA;
			resized = true;
		    }

		    if (canvas.heigh !== height + interfaceConfig.CANVAS_EXTRA) {
			canvas.height = height + interfaceConfig.CANVAS_EXTRA;
			resized = true;
		    }
		});

		if (resized)
		    Object.keys(audioLevelCanvasCache).forEach(function (resourceJid) {
			audioLevelCanvasCache[resourceJid].width
			    = width + interfaceConfig.CANVAS_EXTRA;
			audioLevelCanvasCache[resourceJid].height
			    = height + interfaceConfig.CANVAS_EXTRA;
		    });
	    });

	    return my;

	})(AudioLevels || {});


	/**
	 * ConnectionQuality.
	 */

	var ConnectionQuality = (function () {

	    /**
	     * Constructs new ConnectionQuality object
	     * @constructor
	     */
	    function ConnectionQuality() {

	    }

	    /**
	     * local stats
	     * @type {{}}
	     */
	    var stats = {};

	    /**
	     * remote stats
	     * @type {{}}
	     */
	    var remoteStats = {};

	    /**
	     * Interval for sending statistics to other participants
	     * @type {null}
	     */
	    var sendIntervalId = null;

	    /**
	     * Updates the local statistics
	     * @param data new statistics
	     */
	    ConnectionQuality.updateLocalStats = function (data) {
		stats = data;
		VideoLayout.updateLocalConnectionStats(100 - stats.packetLoss.total,stats);
		if(sendIntervalId == null)
		{
		    startSendingStats();
		}
	    };

	    /**
	     * Start statistics sending.
	     */
	    function startSendingStats() {
		sendStats();
		sendIntervalId = setInterval(sendStats, 10000);
	    }

	    /**
	     * Sends statistics to other participants
	     */
	    function sendStats() {
		connection.emuc.addConnectionInfoToPresence(convertToMUCStats(stats));
		connection.emuc.sendPresence();
	    }

	    /**
	     * Converts statistics to format for sending through XMPP
	     * @param stats the statistics
	     * @returns {{bitrate_donwload: *, bitrate_uplpoad: *, packetLoss_total: *, packetLoss_download: *, packetLoss_upload: *}}
	     */
	    function convertToMUCStats(stats) {
		return {
		    "bitrate_download": stats.bitrate.download,
		    "bitrate_upload": stats.bitrate.upload,
		    "packetLoss_total": stats.packetLoss.total,
		    "packetLoss_download": stats.packetLoss.download,
		    "packetLoss_upload": stats.packetLoss.upload
		};
	    }

	    /**
	     * Converts statitistics to format used by VideoLayout
	     * @param stats
	     * @returns {{bitrate: {download: *, upload: *}, packetLoss: {total: *, download: *, upload: *}}}
	     */
	    function parseMUCStats(stats) {
		return {
		    bitrate: {
			download: stats.bitrate_download,
			upload: stats.bitrate_upload
		    },
		    packetLoss: {
			total: stats.packetLoss_total,
			download: stats.packetLoss_download,
			upload: stats.packetLoss_upload
		    }
		};
	    }

	    /**
	     * Updates remote statistics
	     * @param jid the jid associated with the statistics
	     * @param data the statistics
	     */
	    ConnectionQuality.updateRemoteStats = function (jid, data) {
		if(data == null || data.packetLoss_total == null)
		{
		    VideoLayout.updateConnectionStats(jid, null, null);
		    return;
		}
		remoteStats[jid] = parseMUCStats(data);

		VideoLayout.updateConnectionStats(jid, 100 - data.packetLoss_total,remoteStats[jid]);

	    };

	    /**
	     * Stops statistics sending.
	     */
	    ConnectionQuality.stopSendingStats = function () {
		clearInterval(sendIntervalId);
		sendIntervalId = null;
		//notify UI about stopping statistics gathering
		VideoLayout.onStatsStop();
	    };

	    /**
	     * Returns the local statistics.
	     */
	    ConnectionQuality.getStats = function () {
		return stats;
	    }

	    return ConnectionQuality;
	})();


	/**
	 * Avatar
	 */

	var Avatar = (function(my) {
	    var users = {};
	    var activeSpeakerJid;
	    /**
	     * Sets the user's avatar in the settings menu(if local user), contact list
	     * and thumbnail
	     * @param jid jid of the user
	     * @param id email or userId to be used as a hash
	     */
	    my.setUserAvatar = function(jid, id) {
		if(id) {
		    if(users[jid] === id) {
			return;
		    }
		    users[jid] = id;
		}
		var thumbUrl = getGravatarUrl(users[jid] || jid, 100, jid); // BAO
		var contactListUrl = getGravatarUrl(users[jid] || jid, null, jid);
		var resourceJid = Strophe.getResourceFromJid(jid);
		var thumbnail = $('#participant_' + resourceJid);
		var avatar = $('#avatar_' + resourceJid);

		// set the avatar in the thumbnail
		if(avatar && avatar.length > 0) {
		    avatar[0].src = thumbUrl;
		} else {
		    if (thumbnail && thumbnail.length > 0) {
			avatar = document.createElement('img');
			avatar.id = 'avatar_' + resourceJid;
			avatar.className = 'userAvatar';
			avatar.src = thumbUrl;
			thumbnail.append(avatar);
		    }
		}

		//if the user is the current active speaker - update the active speaker
		// avatar
		if(jid === activeSpeakerJid) {
		    Avatar.updateActiveSpeakerAvatarSrc(jid);
		}
	    };

	    /**
	     * Hides or shows the user's avatar
	     * @param jid jid of the user
	     * @param show whether we should show the avatar or not
	     * video because there is no dominant speaker and no focused speaker
	     */
	    my.showUserAvatar = function(jid, show) {
		if(users[jid]) {
		    var resourceJid = Strophe.getResourceFromJid(jid);
		    var video = $('#participant_' + resourceJid + '>video');
		    var avatar = $('#avatar_' + resourceJid);

		    if(jid === connection.emuc.myroomjid) {
			video = $('#localVideoWrapper>video');
		    }
		    if(show === undefined || show === null) {
			show = isUserMuted(jid);
		    }

		    //if the user is the currently focused, the dominant speaker or if
		    //there is no focused and no dominant speaker and the large video is
		    //currently shown
		    if (activeSpeakerJid === jid && VideoLayout.isLargeVideoOnTop()) {
			setVisibility($("#largeVideo"), !show);
			setVisibility($('#activeSpeaker'), show);
			setVisibility(avatar, false);
			setVisibility(video, false);
		    } else {
			if (video && video.length > 0) {
			    setVisibility(video, !show);
			    setVisibility(avatar, show);
			}
		    }
		}
	    };

	    /**
	     * Updates the src of the active speaker avatar
	     * @param jid of the current active speaker
	     */
	    my.updateActiveSpeakerAvatarSrc = function(jid) {
		if(!jid) {
		    jid = connection.emuc.findJidFromResource(
			    VideoLayout.getLargeVideoState().userResourceJid);
		}
		var avatar = $("#activeSpeakerAvatar")[0];
		var url = getGravatarUrl(users[jid],
		    interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE, jid); // BAO
		if(jid === activeSpeakerJid && avatar.src === url) {
		    return;
		}
		activeSpeakerJid = jid;
		var isMuted = isUserMuted(jid);
		if(jid && isMuted !== null) {
		    avatar.src = url;
		    setVisibility($("#largeVideo"), !isMuted);
		    Avatar.showUserAvatar(jid, isMuted);
		}
	    };

	    function setVisibility(selector, show) {
		if (selector && selector.length > 0) {
		    selector.css("visibility", show ? "visible" : "hidden");
		}
	    }

	    function isUserMuted(jid) {
		// XXX(gp) we may want to rename this method to something like
		// isUserStreaming, for example.
		if (jid && jid != connection.emuc.myroomjid) {
		    var resource = Strophe.getResourceFromJid(jid);
		    if (!VideoLayout.isInLastN(resource)) {
			return true;
		    }
		}

		if (!mediaStreams[jid] || !mediaStreams[jid][MediaStream.VIDEO_TYPE]) {
		    return null;
		}
		return mediaStreams[jid][MediaStream.VIDEO_TYPE].muted;
	    }

	    function getGravatarUrl(id, size, jid) {		// BAO

		if (connection.emuc.myroomjid == jid && config.userAvatar && config.userAvatar != "null")
		{
			return config.userAvatar;	// BAO openfire avatars

		} else if (connection.ofmuc.members[jid] && connection.ofmuc.members[jid].avatar) {

			return connection.ofmuc.members[jid].avatar;
		}

		if(id === connection.emuc.myroomjid || !id) {
		    id = SettingsMenu.getUID();
		}

		return 'https://www.gravatar.com/avatar/' +
		    MD5.hexdigest(id.trim().toLowerCase()) +
		    "?d=mm&size=" + (size || "30");
	    }

	    return my;
	}(Avatar || {}));

	/**
	 * Utility class for drawing canvas shapes.
	 */
	var CanvasUtil = (function(my) {

	    /**
	     * Draws a round rectangle with a glow. The glowWidth indicates the depth
	     * of the glow.
	     *
	     * @param drawContext the context of the canvas to draw to
	     * @param x the x coordinate of the round rectangle
	     * @param y the y coordinate of the round rectangle
	     * @param w the width of the round rectangle
	     * @param h the height of the round rectangle
	     * @param glowColor the color of the glow
	     * @param glowWidth the width of the glow
	     */
	    my.drawRoundRectGlow
		= function(drawContext, x, y, w, h, r, glowColor, glowWidth) {

		// Save the previous state of the context.
		drawContext.save();

		if (w < 2 * r) r = w / 2;
		if (h < 2 * r) r = h / 2;

		// Draw a round rectangle.
		drawContext.beginPath();
		drawContext.moveTo(x+r, y);
		drawContext.arcTo(x+w, y,   x+w, y+h, r);
		drawContext.arcTo(x+w, y+h, x,   y+h, r);
		drawContext.arcTo(x,   y+h, x,   y,   r);
		drawContext.arcTo(x,   y,   x+w, y,   r);
		drawContext.closePath();

		// Add a shadow around the rectangle
		drawContext.shadowColor = glowColor;
		drawContext.shadowBlur = glowWidth;
		drawContext.shadowOffsetX = 0;
		drawContext.shadowOffsetY = 0;

		// Fill the shape.
		drawContext.fill();

		drawContext.save();

		drawContext.restore();

	//      1) Uncomment this line to use Composite Operation, which is doing the
	//      same as the clip function below and is also antialiasing the round
	//      border, but is said to be less fast performance wise.

	//      drawContext.globalCompositeOperation='destination-out';

		drawContext.beginPath();
		drawContext.moveTo(x+r, y);
		drawContext.arcTo(x+w, y,   x+w, y+h, r);
		drawContext.arcTo(x+w, y+h, x,   y+h, r);
		drawContext.arcTo(x,   y+h, x,   y,   r);
		drawContext.arcTo(x,   y,   x+w, y,   r);
		drawContext.closePath();

	//      2) Uncomment this line to use Composite Operation, which is doing the
	//      same as the clip function below and is also antialiasing the round
	//      border, but is said to be less fast performance wise.

	//      drawContext.fill();

		// Comment these two lines if choosing to do the same with composite
		// operation above 1 and 2.
		drawContext.clip();
		drawContext.clearRect(0, 0, 277, 200);

		// Restore the previous context state.
		drawContext.restore();
	    };

	    /**
	     * Clones the given canvas.
	     *
	     * @return the new cloned canvas.
	     */
	    my.cloneCanvas = function (oldCanvas) {
		/*
		 * FIXME Testing has shown that oldCanvas may not exist. In such a case,
		 * the method CanvasUtil.cloneCanvas may throw an error. Since audio
		 * levels are frequently updated, the errors have been observed to pile
		 * into the console, strain the CPU.
		 */
		if (!oldCanvas)
		    return oldCanvas;

		//create a new canvas
		var newCanvas = document.createElement('canvas');
		var context = newCanvas.getContext('2d');

		//set dimensions
		newCanvas.width = oldCanvas.width;
		newCanvas.height = oldCanvas.height;

		//apply the old canvas to the new one
		context.drawImage(oldCanvas, 0, 0);

		//return the new canvas
		return newCanvas;
	    };

	    return my;
	})(CanvasUtil || {});

	/**
	 * Handles commands received via chat messages.
	 */
	var CommandsProcessor = (function()
	{
	    /**
	     * Constructs new CommandProccessor instance from a message.
	     * @param message the message
	     * @constructor
	     */
	    function CommandsPrototype(message)
	    {
		/**
		 * Extracts the command from the message.
		 * @param message the received message
		 * @returns {string} the command
		 */
		function getCommand(message)
		{
		    if(message)
		    {
			for(var command in commands)
			{
			    if(message.indexOf("/" + command) == 0)
				return command;
			}
		    }
		    return "";
		};

		var command = getCommand(message);

		/**
		 * Returns the name of the command.
		 * @returns {String} the command
		 */
		this.getCommand = function()
		{
		    return command;
		}


		var messageArgument = message.substr(command.length + 2);

		/**
		 * Returns the arguments of the command.
		 * @returns {string}
		 */
		this.getArgument = function()
		{
		    return messageArgument;
		}
	    }

	    /**
	     * Checks whether this instance is valid command or not.
	     * @returns {boolean}
	     */
	    CommandsPrototype.prototype.isCommand = function()
	    {
		if(this.getCommand())
		    return true;
		return false;
	    }

	    /**
	     * Processes the command.
	     */
	    CommandsPrototype.prototype.processCommand = function()
	    {
		if(!this.isCommand())
		    return;

		commands[this.getCommand()](this.getArgument());

	    }

	    /**
	     * Processes the data for topic command.
	     * @param commandArguments the arguments of the topic command.
	     */
	    var processTopic = function(commandArguments)
	    {
		var topic = Util.escapeHtml(commandArguments);
		connection.emuc.setSubject(topic);
	    }

	    /**
	     * List with supported commands. The keys are the names of the commands and
	     * the value is the function that processes the message.
	     * @type {{String: function}}
	     */
	    var commands = {
		"topic" : processTopic
	    };

	    return CommandsPrototype;
	})();


	/* global connection, Strophe, updateLargeVideo, focusedVideoSrc*/

	// cache datachannels to avoid garbage collection
	// https://code.google.com/p/chromium/issues/detail?id=405545
	var _dataChannels = [];

	/**
	 * Callback triggered by PeerConnection when new data channel is opened
	 * on the bridge.
	 * @param event the event info object.
	 */

	function onDataChannel(event)
	{
	    var dataChannel = event.channel;

	    dataChannel.onopen = function ()
	    {
		//console.info("Data channel opened by the Videobridge!", dataChannel);

		// Code sample for sending string and/or binary data
		// Sends String message to the bridge
		//dataChannel.send("Hello bridge!");
		// Sends 12 bytes binary message to the bridge
		//dataChannel.send(new ArrayBuffer(12));

		// when the data channel becomes available, tell the bridge about video
		// selections so that it can do adaptive simulcast,
		var userJid = VideoLayout.getLargeVideoState().userJid;
		// we want the notification to trigger even if userJid is undefined,
		// or null.
		onSelectedEndpointChanged(userJid);
	    };

	    dataChannel.onerror = function (error)
	    {
		console.error("Data Channel Error:", error, dataChannel);
	    };

	    dataChannel.onmessage = function (event)
	    {
		var data = event.data;
		// JSON
		var obj;

		try
		{
		    obj = JSON.parse(data);
		}
		catch (e)
		{
		    console.error(
			"Failed to parse data channel message as JSON: ",
			data,
			dataChannel);
		}
		if (('undefined' !== typeof(obj)) && (null !== obj))
		{
		    var colibriClass = obj.colibriClass;

		    if ("DominantSpeakerEndpointChangeEvent" === colibriClass)
		    {
			// Endpoint ID from the Videobridge.
			var dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;

			//console.info("Data channel new dominant speaker event: ",   dominantSpeakerEndpoint);
			$(document).trigger(
			    'dominantspeakerchanged',
			    [dominantSpeakerEndpoint]);
		    }
		    else if ("InLastNChangeEvent" === colibriClass)
		    {
			var oldValue = obj.oldValue;
			var newValue = obj.newValue;
			// Make sure that oldValue and newValue are of type boolean.
			var type;

			if ((type = typeof oldValue) !== 'boolean') {
			    if (type === 'string') {
				oldValue = (oldValue == "true");
			    } else {
				oldValue = new Boolean(oldValue).valueOf();
			    }
			}
			if ((type = typeof newValue) !== 'boolean') {
			    if (type === 'string') {
				newValue = (newValue == "true");
			    } else {
				newValue = new Boolean(newValue).valueOf();
			    }
			}
			$(document).trigger('inlastnchanged', [oldValue, newValue]);
		    }
		    else if ("LastNEndpointsChangeEvent" === colibriClass)
		    {
			// The new/latest list of last-n endpoint IDs.
			var lastNEndpoints = obj.lastNEndpoints;
			// The list of endpoint IDs which are entering the list of
			// last-n at this time i.e. were not in the old list of last-n
			// endpoint IDs.
			var endpointsEnteringLastN = obj.endpointsEnteringLastN;
			var stream = obj.stream;

			//console.log("Data channel new last-n event: ",  lastNEndpoints, endpointsEnteringLastN, obj);
			
			$(document).trigger(
			    'lastnchanged',
			    [lastNEndpoints, endpointsEnteringLastN, stream]);
		    }
		    else if ("SimulcastLayersChangedEvent" === colibriClass)
		    {
			$(document).trigger(
			    'simulcastlayerschanged',
			    [obj.endpointSimulcastLayers]);
		    }
		    else if ("SimulcastLayersChangingEvent" === colibriClass)
		    {
			$(document).trigger(
			    'simulcastlayerschanging',
			    [obj.endpointSimulcastLayers]);
		    }
		    else if ("StartSimulcastLayerEvent" === colibriClass)
		    {
			$(document).trigger('startsimulcastlayer', obj.simulcastLayer);
		    }
		    else if ("StopSimulcastLayerEvent" === colibriClass)
		    {
			$(document).trigger('stopsimulcastlayer', obj.simulcastLayer);
		    }
		    else
		    {
			console.debug("Data channel JSON-formatted message: ", obj);
		    }
		}
	    };

	    dataChannel.onclose = function ()
	    {
		//console.info("The Data Channel closed", dataChannel);
		var idx = _dataChannels.indexOf(dataChannel);
		if (idx > -1) 
		    _dataChannels = _dataChannels.splice(idx, 1);
	    };
	    _dataChannels.push(dataChannel);
	}

	/**
	 * Binds "ondatachannel" event listener to given PeerConnection instance.
	 * @param peerConnection WebRTC peer connection instance.
	 */
	function bindDataChannelListener(peerConnection)
	{
	    peerConnection.ondatachannel = onDataChannel;

	    // Sample code for opening new data channel from Jitsi Meet to the bridge.
	    // Although it's not a requirement to open separate channels from both bridge
	    // and peer as single channel can be used for sending and receiving data.
	    // So either channel opened by the bridge or the one opened here is enough
	    // for communication with the bridge.
	/*
	    var dataChannelOptions = { reliable: true };
	    var dataChannel
	       = peerConnection.createDataChannel("myChannel", dataChannelOptions);

	    // Can be used only when is in open state
	    dataChannel.onopen = function ()
	    {
		dataChannel.send("My channel !!!");
	    };
	    dataChannel.onmessage = function (event)
	    {
		var msgData = event.data;
		//console.info("Got My Data Channel Message:", msgData, dataChannel);
	    };
	*/
	}


	/* global Strophe */
	Strophe.addConnectionPlugin('logger', {
	    // logs raw stanzas and makes them available for download as JSON
	    connection: null,
	    log: [],
	    init: function (conn) {
		this.connection = conn;
		this.connection.rawInput = this.log_incoming.bind(this);
		this.connection.rawOutput = this.log_outgoing.bind(this);
		
		console.log("strophe plugin logger enabled");  		
	    },
	    log_incoming: function (stanza) {
		this.log.push([new Date().getTime(), 'incoming', stanza]);
	    },
	    log_outgoing: function (stanza) {
		this.log.push([new Date().getTime(), 'outgoing', stanza]);
	    },
	});


	/**
	 * JitsiPopover
	 */

	var JitsiPopover = (function () {
	    /**
	     * Constructs new JitsiPopover and attaches it to the element
	     * @param element jquery selector
	     * @param options the options for the popover.
	     * @constructor
	     */
	    function JitsiPopover(element, options)
	    {
		this.options = {
		    skin: "white",
		    content: ""
		};
		if(options)
		{
		    if(options.skin)
			this.options.skin = options.skin;

		    if(options.content)
			this.options.content = options.content;
		}

		this.elementIsHovered = false;
		this.popoverIsHovered = false;
		this.popoverShown = false;

		element.data("jitsi_popover", this);
		this.element = element;
		this.template = ' <div class="jitsipopover ' + this.options.skin +
		    '"><div class="arrow"></div><div class="jitsipopover-content"></div>' +
		    '<div class="jitsiPopupmenuPadding"></div></div>';
		var self = this;
		this.element.on("mouseenter", function () {
		    self.elementIsHovered = true;
		    self.show();
		}).on("mouseleave", function () {
		    self.elementIsHovered = false;
		    setTimeout(function () {
			self.hide();
		    }, 10);
		});
	    }

	    /**
	     * Shows the popover
	     */
	    JitsiPopover.prototype.show = function () {
		this.createPopover();
		this.popoverShown = true;

	    };

	    /**
	     * Hides the popover
	     */
	    JitsiPopover.prototype.hide = function () {
		if(!this.elementIsHovered && !this.popoverIsHovered && this.popoverShown)
		{
		    this.forceHide();
		}
	    };

	    /**
	     * Hides the popover
	     */
	    JitsiPopover.prototype.forceHide = function () {
		$(".jitsipopover").remove();
		this.popoverShown = false;
	    };

	    /**
	     * Creates the popover html
	     */
	    JitsiPopover.prototype.createPopover = function () {
		$("body").append(this.template);
		$(".jitsipopover > .jitsipopover-content").html(this.options.content);
		var self = this;
		$(".jitsipopover").on("mouseenter", function () {
		    self.popoverIsHovered = true;
		}).on("mouseleave", function () {
		    self.popoverIsHovered = false;
		    self.hide();
		});

		this.refreshPosition();
	    };

	    /**
	     * Refreshes the position of the popover
	     */
	    JitsiPopover.prototype.refreshPosition = function () {
		$(".jitsipopover").position({
		    my: "bottom",
		    at: "top",
		    collision: "fit",
		    of: this.element,
		    using: function (position, elements) {
			var calcLeft = elements.target.left - elements.element.left + elements.target.width/2;
			$(".jitsipopover").css({top: position.top, left: position.left, display: "table"});
			$(".jitsipopover > .arrow").css({left: calcLeft});
			$(".jitsipopover > .jitsiPopupmenuPadding").css({left: calcLeft - 50});
		    }
		});
	    };

	    /**
	     * Updates the content of popover.
	     * @param content new content
	     */
	    JitsiPopover.prototype.updateContent = function (content) {
		this.options.content = content;
		if(!this.popoverShown)
		    return;
		$(".jitsipopover").remove();
		this.createPopover();
	    };

	    return JitsiPopover;


	})();


	/**
	 * VideoLayout
	 */

	var VideoLayout = (function (my) {
	    var currentDominantSpeaker = null;
	    var lastNCount = -1;
	    var localLastNCount = -1;
	    var localLastNSet = [];
	    var lastNEndpointsCache = [];
	    var lastNPickupJid = null;
	    var largeVideoState = {
		updateInProgress: false,
		newSrc: ''
	    };

	    var defaultLocalDisplayName = "Me";

	    my.init = function()
	    {
	    	lastNCount = config.channelLastN;
	    	localLastNCount = config.chan	    
	    }
	    
	    my.connectionIndicators = {};

	    my.isInLastN = function(resource) {
		return lastNCount < 0 // lastN is disabled, return true
		    || (lastNCount > 0 && lastNEndpointsCache.length == 0) // lastNEndpoints cache not built yet, return true
		    || (lastNEndpointsCache && lastNEndpointsCache.indexOf(resource) !== -1);
	    };

	    my.changeLocalStream = function (stream) {
		connection.jingle.localAudio = stream;
		VideoLayout.changeLocalVideo(stream, true);
	    };

	    my.changeLocalAudio = function(stream) {
		connection.jingle.localAudio = stream;
		RTC.attachMediaStream($('#localAudio'), stream);
		document.getElementById('localAudio').autoplay = true;
		document.getElementById('localAudio').volume = 0;
		if (preMuted) {
		    setAudioMuted(true);
		    preMuted = false;
		}
	    };

	    my.changeLocalVideo = function(stream, flipX) {
		connection.jingle.localVideo = stream;

		var localVideo = document.createElement('video');
		localVideo.id = 'localVideo_' + RTC.getStreamID(stream);
		localVideo.autoplay = true;
		localVideo.volume = 0; // is it required if audio is separated ?
		localVideo.oncontextmenu = function () { return false; };

		var localVideoContainer = document.getElementById('localVideoWrapper');
		localVideoContainer.appendChild(localVideo);

		// Set default display name.
		setDisplayName('localVideoContainer');

		if(!VideoLayout.connectionIndicators["localVideoContainer"]) {
		    VideoLayout.connectionIndicators["localVideoContainer"]
			= new ConnectionIndicator($("#localVideoContainer")[0], null);
		}

		AudioLevels.updateAudioLevelCanvas();

		var localVideoSelector = $('#' + localVideo.id);
		// Add click handler to both video and video wrapper elements in case
		// there's no video.
		localVideoSelector.click(function (event) {
		    event.stopPropagation();
		    VideoLayout.handleVideoThumbClicked(
			RTC.getVideoSrc(localVideo),
			false,
			Strophe.getResourceFromJid(connection.emuc.myroomjid));
		});
		$('#localVideoContainer').click(function (event) {
		    event.stopPropagation();
		    VideoLayout.handleVideoThumbClicked(
			RTC.getVideoSrc(localVideo),
			false,
			Strophe.getResourceFromJid(connection.emuc.myroomjid));
		});

		// Add hover handler
		$('#localVideoContainer').hover(
		    function() {
			VideoLayout.showDisplayName('localVideoContainer', true);
		    },
		    function() {
			if (!VideoLayout.isLargeVideoVisible()
				|| RTC.getVideoSrc(localVideo) !== RTC.getVideoSrc($('#largeVideo')[0]))
			    VideoLayout.showDisplayName('localVideoContainer', false);
		    }
		);
		// Add stream ended handler
		stream.onended = function () {
		    localVideoContainer.removeChild(localVideo);
		    VideoLayout.updateRemovedVideo(RTC.getVideoSrc(localVideo));
		};
		// Flip video x axis if needed
		flipXLocalVideo = flipX;
		if (flipX) {
		    localVideoSelector.addClass("flipVideoX");
		}
		// Attach WebRTC stream
		var videoStream = simulcast.getLocalVideoStream();
		RTC.attachMediaStream(localVideoSelector, videoStream);

		localVideoSrc = RTC.getVideoSrc(localVideo);

		var myResourceJid = null;
		if(connection.emuc.myroomjid)
		{
		   myResourceJid = Strophe.getResourceFromJid(connection.emuc.myroomjid);
		}
		VideoLayout.updateLargeVideo(localVideoSrc, 0,
		    myResourceJid);
		    
		if (stream.getVideoTracks().length == 0)
		{
			localVideoSelector.css("display", "none");
		}		    

	    };

	    /**
	     * Checks if removed video is currently displayed and tries to display
	     * another one instead.
	     * @param removedVideoSrc src stream identifier of the video.
	     */
	    my.updateRemovedVideo = function(removedVideoSrc) {
		if (removedVideoSrc === RTC.getVideoSrc($('#largeVideo')[0])) {
		    // this is currently displayed as large
		    // pick the last visible video in the row
		    // if nobody else is left, this picks the local video
		    var pick
			= $('#remoteVideos>span[id!="mixedstream"]:visible:last>video')
			    .get(0);

		    if (!pick) {
			//console.info("Last visible video no longer exists");
			pick = $('#remoteVideos>span[id!="mixedstream"]>video').get(0);

			if (!pick || !RTC.getVideoSrc(pick)) {
			    // Try local video
			    //console.info("Fallback to local video...");
			    pick = $('#remoteVideos>span>span>video').get(0);
			}
		    }

		    // mute if localvideo
		    if (pick) {
			var container = pick.parentNode;
			var jid = null;
			if(container)
			{
			    if(container.id == "localVideoWrapper")
			    {
				jid = Strophe.getResourceFromJid(connection.emuc.myroomjid);
			    }
			    else
			    {
				jid = VideoLayout.getPeerContainerResourceJid(container);
			    }
			}

			VideoLayout.updateLargeVideo(RTC.getVideoSrc(pick), pick.volume, jid);
		    } else {
			//console.warn("Failed to elect large video");
		    }
		}
	    };

	    my.getLargeVideoState = function () {
		return largeVideoState;
	    };

	    /**
	     * Updates the large video with the given new video source.
	     */
	    my.updateLargeVideo = function(newSrc, vol, resourceJid) {
		//console.log('hover in', newSrc);

		if (RTC.getVideoSrc($('#largeVideo')[0]) !== newSrc) {

		    $('#activeSpeaker').css('visibility', 'hidden');
		    // Due to the simulcast the localVideoSrc may have changed when the
		    // fadeOut event triggers. In that case the getJidFromVideoSrc and
		    // isVideoSrcDesktop methods will not function correctly.
		    //
		    // Also, again due to the simulcast, the updateLargeVideo method can
		    // be called multiple times almost simultaneously. Therefore, we
		    // store the state here and update only once.

		    largeVideoState.newSrc = newSrc;
		    largeVideoState.isVisible = $('#largeVideo').is(':visible');
		    largeVideoState.isDesktop = isVideoSrcDesktop(resourceJid);
		    if(jid2Ssrc[largeVideoState.userResourceJid] ||
			(connection && connection.emuc.myroomjid &&
			    largeVideoState.userResourceJid ===
			    Strophe.getResourceFromJid(connection.emuc.myroomjid))) {
			largeVideoState.oldResourceJid = largeVideoState.userResourceJid;
		    } else {
			largeVideoState.oldResourceJid = null;
		    }
		    largeVideoState.userResourceJid = resourceJid;

		    // Screen stream is already rotated
		    largeVideoState.flipX = (newSrc === localVideoSrc) && flipXLocalVideo;

		    var userChanged = false;
		    if (largeVideoState.oldResourceJid !== largeVideoState.userResourceJid) {
			userChanged = true;
			// we want the notification to trigger even if userJid is undefined,
			// or null.
			$(document).trigger("selectedendpointchanged", [largeVideoState.userResourceJid]);
		    }

		    if (!largeVideoState.updateInProgress) {
			largeVideoState.updateInProgress = true;

			var doUpdate = function () {

			    Avatar.updateActiveSpeakerAvatarSrc(
				connection.emuc.findJidFromResource(
				    largeVideoState.userResourceJid));

			    if (!userChanged && largeVideoState.preload &&
				largeVideoState.preload !== null &&
				RTC.getVideoSrc($(largeVideoState.preload)[0]) === newSrc)
			    {

				//console.info('Switching to preloaded video');
				var attributes = $('#largeVideo').prop("attributes");

				// loop through largeVideo attributes and apply them on
				// preload.
				$.each(attributes, function () {
				    if (this.name !== 'id' && this.name !== 'src') {
					largeVideoState.preload.attr(this.name, this.value);
				    }
				});

				largeVideoState.preload.appendTo($('#largeVideoContainer'));
				$('#largeVideo').attr('id', 'previousLargeVideo');
				largeVideoState.preload.attr('id', 'largeVideo');
				$('#previousLargeVideo').remove();

				largeVideoState.preload.on('loadedmetadata', function (e) {
				    currentVideoWidth = this.videoWidth;
				    currentVideoHeight = this.videoHeight;
				    VideoLayout.positionLarge(currentVideoWidth, currentVideoHeight);
				});
				largeVideoState.preload = null;
				largeVideoState.preload_ssrc = 0;
			    } else {
				RTC.setVideoSrc($('#largeVideo')[0], largeVideoState.newSrc);
			    }

			    var videoTransform = document.getElementById('largeVideo')
				.style.webkitTransform;

			    if (largeVideoState.flipX && videoTransform !== 'scaleX(-1)') {
				document.getElementById('largeVideo').style.webkitTransform
				    = "scaleX(-1)";
			    }
			    else if (!largeVideoState.flipX && videoTransform === 'scaleX(-1)') {
				document.getElementById('largeVideo').style.webkitTransform
				    = "none";
			    }

			    // Change the way we'll be measuring and positioning large video

			    getVideoSize = largeVideoState.isDesktop
				? getDesktopVideoSize
				: getCameraVideoSize;
			    getVideoPosition = largeVideoState.isDesktop
				? getDesktopVideoPosition
				: getCameraVideoPosition;


			    // Only if the large video is currently visible.
			    // Disable previous dominant speaker video.
			    if (largeVideoState.oldResourceJid) {
				VideoLayout.enableDominantSpeaker(
				    largeVideoState.oldResourceJid,
				    false);
			    }

			    // Enable new dominant speaker in the remote videos section.
			    if (largeVideoState.userResourceJid) {
				VideoLayout.enableDominantSpeaker(
				    largeVideoState.userResourceJid,
				    true);
			    }

			    if (userChanged && largeVideoState.isVisible) {
				// using "this" should be ok because we're called
				// from within the fadeOut event.
				$(this).fadeIn(300);
			    }

			    if(userChanged) {
				Avatar.showUserAvatar(
				    connection.emuc.findJidFromResource(
					largeVideoState.oldResourceJid));
			    }

			    largeVideoState.updateInProgress = false;
			};

			if (userChanged) {
			    $('#largeVideo').fadeOut(300, doUpdate);
			} else {
			    doUpdate();
			}
		    }
		} else {
		    Avatar.showUserAvatar(
			connection.emuc.findJidFromResource(
			    largeVideoState.userResourceJid));
		}

	    };

	    my.handleVideoThumbClicked = function(videoSrc,
						  noPinnedEndpointChangedEvent, 
						  resourceJid) {
		// Restore style for previously focused video
		var oldContainer = null;
		if(focusedVideoInfo) {
		    var focusResourceJid = focusedVideoInfo.resourceJid;
		    oldContainer = getParticipantContainer(focusResourceJid);
		}

		if (oldContainer) {
		    oldContainer.removeClass("videoContainerFocused");
		}

		// Unlock current focused.
		if (focusedVideoInfo && focusedVideoInfo.src === videoSrc)
		{
		    focusedVideoInfo = null;
		    var dominantSpeakerVideo = null;
		    // Enable the currently set dominant speaker.
		    if (currentDominantSpeaker) {
			dominantSpeakerVideo
			    = $('#participant_' + currentDominantSpeaker + '>video')
				.get(0);

			if (dominantSpeakerVideo) {
			    VideoLayout.updateLargeVideo(
				RTC.getVideoSrc(dominantSpeakerVideo),
				1,
				currentDominantSpeaker);
			}
		    }

		    if (!noPinnedEndpointChangedEvent) {
			$(document).trigger("pinnedendpointchanged");
		    }
		    return;
		}

		// Lock new video
		focusedVideoInfo = {
		    src: videoSrc,
		    resourceJid: resourceJid
		};

		// Update focused/pinned interface.
		if (resourceJid)
		{
		    var container = getParticipantContainer(resourceJid);
		    container.addClass("videoContainerFocused");

		    if (!noPinnedEndpointChangedEvent) {
			$(document).trigger("pinnedendpointchanged", [resourceJid]);
		    }
		}

		if ($('#largeVideo').attr('src') === videoSrc &&
		    VideoLayout.isLargeVideoOnTop()) {
		    return;
		}

		// Triggers a "video.selected" event. The "false" parameter indicates
		// this isn't a prezi.
		$(document).trigger("video.selected", [false]);

		VideoLayout.updateLargeVideo(videoSrc, 1, resourceJid);

		$('audio').each(function (idx, el) {
		    if (el.id.indexOf('mixedmslabel') !== -1) {
			el.volume = 0;
			el.volume = 1;
		    }
		});
	    };

	    /**
	     * Positions the large video.
	     *
	     * @param videoWidth the stream video width
	     * @param videoHeight the stream video height
	     */
	    my.positionLarge = function (videoWidth, videoHeight) {
		var videoSpaceWidth = $('#videospace').width();
		var videoSpaceHeight = window.innerHeight;

		var videoSize = getVideoSize(videoWidth,
					     videoHeight,
					     videoSpaceWidth,
					     videoSpaceHeight);

		var largeVideoWidth = videoSize[0];
		var largeVideoHeight = videoSize[1];

		var videoPosition = getVideoPosition(largeVideoWidth,
						     largeVideoHeight,
						     videoSpaceWidth,
						     videoSpaceHeight);

		var horizontalIndent = videoPosition[0];
		var verticalIndent = videoPosition[1];

		positionVideo($('#largeVideo'),
			      largeVideoWidth,
			      largeVideoHeight,
			      horizontalIndent, verticalIndent);
	    };

	    /**
	     * Shows/hides the large video.
	     */
	    my.setLargeVideoVisible = function(isVisible) {
		var resourceJid = largeVideoState.userResourceJid;

		if (isVisible) {
		    $('#largeVideo').css({visibility: 'visible'});
		    $('.watermark').css({visibility: 'visible'});
		    VideoLayout.enableDominantSpeaker(resourceJid, true);
		}
		else {
		    $('#largeVideo').css({visibility: 'hidden'});
		    $('#activeSpeaker').css('visibility', 'hidden');
		    $('.watermark').css({visibility: 'hidden'});
		    VideoLayout.enableDominantSpeaker(resourceJid, false);
		    if(focusedVideoInfo) {
			var focusResourceJid = focusedVideoInfo.resourceJid;
			var oldContainer = getParticipantContainer(focusResourceJid);

			if (oldContainer && oldContainer.length > 0) {
			    oldContainer.removeClass("videoContainerFocused");
			}
			focusedVideoInfo = null;
			if(focusResourceJid) {
			    Avatar.showUserAvatar(
				connection.emuc.findJidFromResource(focusResourceJid));
			}
		    }
		}
	    };

	    /**
	     * Indicates if the large video is currently visible.
	     *
	     * @return <tt>true</tt> if visible, <tt>false</tt> - otherwise
	     */
	    my.isLargeVideoVisible = function() {
		return $('#largeVideo').is(':visible');
	    };

	    my.isLargeVideoOnTop = function () {
		return true;
	    };

	    /**
	     * Checks if container for participant identified by given peerJid exists
	     * in the document and creates it eventually.
	     * 
	     * @param peerJid peer Jid to check.
	     * @param userId user email or id for setting the avatar
	     * 
	     * @return Returns <tt>true</tt> if the peer container exists,
	     * <tt>false</tt> - otherwise
	     */
	    my.ensurePeerContainerExists = function(peerJid, userId) {

		var resourceJid = Strophe.getResourceFromJid(peerJid);

		var videoSpanId = 'participant_' + resourceJid;

		if ($('#' + videoSpanId).length > 0) {
		    // If there's been a focus change, make sure we add focus related
		    // interface!!
		    if (Moderator.isModerator() && $('#remote_popupmenu_' + resourceJid).length <= 0) {
			addRemoteVideoMenu(peerJid,
			    document.getElementById(videoSpanId));
		    }
		}
		else {
		    var container =
			VideoLayout.addRemoteVideoContainer(peerJid, videoSpanId, userId);
		    Avatar.setUserAvatar(peerJid, userId);
		    // Set default display name.
		    setDisplayName(videoSpanId);

		    VideoLayout.connectionIndicators[videoSpanId] = new ConnectionIndicator(container, peerJid);

		    var nickfield = document.createElement('span');
		    nickfield.className = "nick";
		    nickfield.appendChild(document.createTextNode(resourceJid));
		    container.appendChild(nickfield);

		    // In case this is not currently in the last n we don't show it.
		    if (localLastNCount
			&& localLastNCount > 0
			&& $('#remoteVideos>span').length >= localLastNCount + 2) {
			showPeerContainer(resourceJid, 'hide');
		    }
		    else
			VideoLayout.resizeThumbnails();
		}
	    };

	    my.addRemoteVideoContainer = function(peerJid, spanId) {
		var container = document.createElement('span');
		container.id = spanId;
		container.className = 'videocontainer';
		var remotes = document.getElementById('remoteVideos');

		// If the peerJid is null then this video span couldn't be directly
		// associated with a participant (this could happen in the case of prezi).
		if (Moderator.isModerator() && peerJid !== null)
		    addRemoteVideoMenu(peerJid, container);

		remotes.appendChild(container);
		AudioLevels.updateAudioLevelCanvas(peerJid);

		return container;
	    };

	    /**
	     * Creates an audio or video stream element.
	     */
	    my.createStreamElement = function (sid, stream) {
		var isVideo = stream.getVideoTracks().length > 0;

		var element = isVideo
				? document.createElement('video')
				: document.createElement('audio');
		var id = (isVideo ? 'remoteVideo_' : 'remoteAudio_')
			    + sid + '_' + RTC.getStreamID(stream);

		element.id = id;
		element.autoplay = true;
		element.oncontextmenu = function () { return false; };

		return element;
	    };

	    my.addRemoteStreamElement
		= function (container, sid, stream, peerJid, thessrc) {
		var newElementId = null;

		var isVideo = stream.getVideoTracks().length > 0;

		if (container) {
		    var streamElement = VideoLayout.createStreamElement(sid, stream);
		    newElementId = streamElement.id;

		    container.appendChild(streamElement);

		    var sel = $('#' + newElementId);
		    sel.hide();

		    // If the container is currently visible we attach the stream.
		    if (!isVideo
			|| (container.offsetParent !== null && isVideo)) {
			var videoStream = simulcast.getReceivingVideoStream(stream);
			RTC.attachMediaStream(sel, videoStream);

			if (isVideo)
			    waitForRemoteVideo(sel, thessrc, stream, peerJid);
		    }

		    stream.onended = function () {
			//console.log('stream ended', this);

			VideoLayout.removeRemoteStreamElement(
			    stream, isVideo, container);

			// NOTE(gp) it seems that under certain circumstances, the
			// onended event is not fired and thus the contact list is not
			// updated.
			//
			// The onended event of a stream should be fired when the SSRCs
			// corresponding to that stream are removed from the SDP; but
			// this doesn't seem to always be the case, resulting in ghost
			// contacts.
			//
			// In an attempt to fix the ghost contacts problem, I'm moving
			// the removeContact() method call in app.js, inside the
			// 'muc.left' event handler.
		    };

		    // Add click handler.
		    container.onclick = function (event) {
			/*
			 * FIXME It turns out that videoThumb may not exist (if there is
			 * no actual video).
			 */
			var videoThumb = $('#' + container.id + '>video').get(0);
			if (videoThumb) {
			    VideoLayout.handleVideoThumbClicked(
				RTC.getVideoSrc(videoThumb),
				false,
				Strophe.getResourceFromJid(peerJid));
			}

			event.stopPropagation();
			event.preventDefault();
			return false;
		    };

		    // Add hover handler
		    $(container).hover(
			function() {
			    VideoLayout.showDisplayName(container.id, true);
			},
			function() {
			    var videoSrc = null;
			    if ($('#' + container.id + '>video')
				    && $('#' + container.id + '>video').length > 0) {
				videoSrc = RTC.getVideoSrc($('#' + container.id + '>video').get(0));
			    }

			    // If the video has been "pinned" by the user we want to
			    // keep the display name on place.
			    if (!VideoLayout.isLargeVideoVisible()
				    || videoSrc !== RTC.getVideoSrc($('#largeVideo')[0]))
				VideoLayout.showDisplayName(container.id, false);
			}
		    );
		}

		return newElementId;
	    };

	    /**
	     * Removes the remote stream element corresponding to the given stream and
	     * parent container.
	     * 
	     * @param stream the stream
	     * @param isVideo <tt>true</tt> if given <tt>stream</tt> is a video one.
	     * @param container
	     */
	    my.removeRemoteStreamElement = function (stream, isVideo, container) {
		if (!container)
		    return;

		var select = null;
		var removedVideoSrc = null;
		if (isVideo) {
		    select = $('#' + container.id + '>video');
		    removedVideoSrc = RTC.getVideoSrc(select.get(0));
		}
		else
		    select = $('#' + container.id + '>audio');


		// Mark video as removed to cancel waiting loop(if video is removed
		// before has started)
		select.removed = true;
		select.remove();

		var audioCount = $('#' + container.id + '>audio').length;
		var videoCount = $('#' + container.id + '>video').length;

		if (!audioCount && !videoCount) {
		    //console.log("Remove whole user", container.id);
		    if(VideoLayout.connectionIndicators[container.id])
			VideoLayout.connectionIndicators[container.id].remove();
		    // Remove whole container
		    container.remove();

		    VideoLayout.resizeThumbnails();
		}

		if (removedVideoSrc)
		    VideoLayout.updateRemovedVideo(removedVideoSrc);
	    };

	    /**
	     * Show/hide peer container for the given resourceJid.
	     */
	    function showPeerContainer(resourceJid, state) {
		var peerContainer = $('#participant_' + resourceJid);

		if (!peerContainer)
		    return;

		var isHide = state === 'hide';
		var resizeThumbnails = false;

		if (!isHide) {
		    if (!peerContainer.is(':visible')) {
			resizeThumbnails = true;
			peerContainer.show();
		    }

		    if (state == 'show')
		    {
			// peerContainer.css('-webkit-filter', '');
			var jid = connection.emuc.findJidFromResource(resourceJid);
			Avatar.showUserAvatar(jid, false);
		    }
		    else // if (state == 'avatar')
		    {
			// peerContainer.css('-webkit-filter', 'grayscale(100%)');
			var jid = connection.emuc.findJidFromResource(resourceJid);
			Avatar.showUserAvatar(jid, true);
		    }
		}
		else if (peerContainer.is(':visible') && isHide)
		{
		    resizeThumbnails = true;
		    peerContainer.hide();
		    if(VideoLayout.connectionIndicators['participant_' + resourceJid])
			VideoLayout.connectionIndicators['participant_' + resourceJid].hide();
		}

		if (resizeThumbnails) {
		    VideoLayout.resizeThumbnails();
		}

		// We want to be able to pin a participant from the contact list, even
		// if he's not in the lastN set!

	    };

	    /**
	     * Sets the display name for the given video span id.
	     */
	    function setDisplayName(videoSpanId, displayName) {
		var nameSpan = $('#' + videoSpanId + '>span.displayname');
		var defaultLocalDisplayName = interfaceConfig.DEFAULT_LOCAL_DISPLAY_NAME;

		// If we already have a display name for this video.
		if (nameSpan.length > 0) {
		    var nameSpanElement = nameSpan.get(0);

		    if (nameSpanElement.id === 'localDisplayName' &&
			$('#localDisplayName').text() !== displayName) {
			
			if (displayName && displayName.length > 0 && displayName.indexOf(" (me)") == -1)
			    $('#localDisplayName').text(displayName + ' (me)');
			else
			    $('#localDisplayName').text(defaultLocalDisplayName);
		    } else {
			if (displayName && displayName.length > 0)
			    $('#' + videoSpanId + '_name').text(displayName);
			else
			    $('#' + videoSpanId + '_name').text(interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME);
		    }
		} else {
		    var editButton = null;

		    nameSpan = document.createElement('span');
		    nameSpan.className = 'displayname';
		    $('#' + videoSpanId)[0].appendChild(nameSpan);

		    if (videoSpanId === 'localVideoContainer') {
			editButton = createEditDisplayNameButton();
			nameSpan.innerText = defaultLocalDisplayName;
		    }
		    else {
			nameSpan.innerText = interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME;
		    }

		    if (displayName && displayName.length > 0) {
			nameSpan.innerText = displayName;
		    }

		    if (!editButton) {
			nameSpan.id = videoSpanId + '_name';
		    } else {
			nameSpan.id = 'localDisplayName';
			$('#' + videoSpanId)[0].appendChild(editButton);

			var editableText = document.createElement('input');
			editableText.className = 'displayname';
			editableText.type = 'text';
			editableText.id = 'editDisplayName';

			if (displayName && displayName.length) {
			    editableText.value
				= displayName.substring(0, displayName.indexOf(' (me)'));
			}

			editableText.setAttribute('style', 'display:none;');
			editableText.setAttribute('placeholder', 'ex. Jane Pink');
			$('#' + videoSpanId)[0].appendChild(editableText);

			$('#localVideoContainer .displayname')
			    .bind("click", function (e) {

			    e.preventDefault();
			    e.stopPropagation();
			    $('#localDisplayName').hide();
			    $('#editDisplayName').show();
			    $('#editDisplayName').focus();
			    $('#editDisplayName').select();

			    $('#editDisplayName').one("focusout", function (e) {
				VideoLayout.inputDisplayNameHandler(this.value);
			    });

			    $('#editDisplayName').on('keydown', function (e) {
				if (e.keyCode === 13) {
				    e.preventDefault();
				    VideoLayout.inputDisplayNameHandler(this.value);
				}
			    });
			});
		    }
		}
	    }

	    my.inputDisplayNameHandler = function (name) {
		if (nickname !== name) {
		    nickname = name;
		    window.localStorage.displayname = nickname;
		    connection.emuc.addDisplayNameToPresence(nickname);
		    connection.emuc.sendPresence();
		}

		if (!$('#localDisplayName').is(":visible")) {
		    var tempDisplayName = nickname;
		    if (tempDisplayName.indexOf(" (me)") == -1) tempDisplayName = tempDisplayName + " (me)";
		    
		    if (nickname)
			$('#localDisplayName').text(tempDisplayName);
		    else
			$('#localDisplayName').text(interfaceConfig.DEFAULT_LOCAL_DISPLAY_NAME);
			
		    $('#localDisplayName').show();
		}

		$('#editDisplayName').hide();
	    };

	    /**
	     * Shows/hides the display name on the remote video.
	     * @param videoSpanId the identifier of the video span element
	     * @param isShow indicates if the display name should be shown or hidden
	     */
	    my.showDisplayName = function(videoSpanId, isShow) {
		var nameSpan = $('#' + videoSpanId + '>span.displayname').get(0);
		if (isShow) {
		    if (nameSpan && nameSpan.innerHTML && nameSpan.innerHTML.length) 
			nameSpan.setAttribute("style", "display:inline-block;");
		}
		else {
		    if (nameSpan)
			nameSpan.setAttribute("style", "display:none;");
		}
	    };

	    /**
	     * Shows the presence status message for the given video.
	     */
	    my.setPresenceStatus = function (videoSpanId, statusMsg) {

		if (!$('#' + videoSpanId).length) {
		    // No container
		    return;
		}

		var statusSpan = $('#' + videoSpanId + '>span.status');
		if (!statusSpan.length) {
		    //Add status span
		    statusSpan = document.createElement('span');
		    statusSpan.className = 'status';
		    statusSpan.id = videoSpanId + '_status';
		    $('#' + videoSpanId)[0].appendChild(statusSpan);

		    statusSpan = $('#' + videoSpanId + '>span.status');
		}

		// Display status
		if (statusMsg && statusMsg.length) {
		    $('#' + videoSpanId + '_status').text(statusMsg);
		    statusSpan.get(0).setAttribute("style", "display:inline-block;");
		}
		else {
		    // Hide
		    statusSpan.get(0).setAttribute("style", "display:none;");
		}
	    };

	    /**
	     * Shows a visual indicator for the moderator of the conference.
	     */
	    my.showModeratorIndicator = function () {
		if (Moderator.isModerator()) {
		    var indicatorSpan = $('#localVideoContainer .focusindicator');

		    if (indicatorSpan.children().length === 0)
		    {
			createModeratorIndicatorElement(indicatorSpan[0]);
		    }
		} else {
		    Object.keys(connection.emuc.members).forEach(function (jid) {
			var member = connection.emuc.members[jid];
			if (member.role === 'moderator') {
			    var moderatorId
				= 'participant_' + Strophe.getResourceFromJid(jid);

			    var moderatorContainer
				= document.getElementById(moderatorId);

			    if (Strophe.getResourceFromJid(jid) === 'focus') {
				// Skip server side focus
				return;
			    }
			    if (!moderatorContainer) {
				console.error("No moderator container for " + jid);
				return;
			    }
			    var indicatorSpan
				= $('#' + moderatorId + ' .focusindicator');

			    if (!indicatorSpan || indicatorSpan.length === 0) {
				indicatorSpan = document.createElement('span');
				indicatorSpan.className = 'focusindicator';

				moderatorContainer.appendChild(indicatorSpan);

				createModeratorIndicatorElement(indicatorSpan);
			    }
			}
		    });
		}
	    };

	    /**
	     * Shows video muted indicator over small videos.
	     */
	    my.showVideoIndicator = function(videoSpanId, isMuted) {
		var videoMutedSpan = $('#' + videoSpanId + '>span.videoMuted');

		if (isMuted === 'false') {
		    if (videoMutedSpan.length > 0) {
			videoMutedSpan.remove();
		    }
		}
		else {
		    if(videoMutedSpan.length == 0) {
			videoMutedSpan = document.createElement('span');
			videoMutedSpan.className = 'videoMuted';

			$('#' + videoSpanId)[0].appendChild(videoMutedSpan);

			var mutedIndicator = document.createElement('i');
			mutedIndicator.className = 'icon-camera-disabled';
			Util.setTooltip(mutedIndicator,
			    "Participant has<br/>stopped the camera.",
			    "top");
			videoMutedSpan.appendChild(mutedIndicator);
		    }

		    VideoLayout.updateMutePosition(videoSpanId);

		}
	    };

	    my.updateMutePosition = function (videoSpanId) {
		var audioMutedSpan = $('#' + videoSpanId + '>span.audioMuted');
		var connectionIndicator = $('#' + videoSpanId + '>div.connectionindicator');
		var videoMutedSpan = $('#' + videoSpanId + '>span.videoMuted');
		if(connectionIndicator.length > 0
		    && connectionIndicator[0].style.display != "none") {
		    audioMutedSpan.css({right: "23px"});
		    videoMutedSpan.css({right: ((audioMutedSpan.length > 0? 23 : 0) + 30) + "px"});
		}
		else
		{
		    audioMutedSpan.css({right: "0px"});
		    videoMutedSpan.css({right: (audioMutedSpan.length > 0? 30 : 0) + "px"});
		}
	    }
	    /**
	     * Shows audio muted indicator over small videos.
	     * @param {string} isMuted
	     */
	    my.showAudioIndicator = function(videoSpanId, isMuted) {
		var audioMutedSpan = $('#' + videoSpanId + '>span.audioMuted');

		if (isMuted === 'false') {
		    if (audioMutedSpan.length > 0) {
			audioMutedSpan.popover('hide');
			audioMutedSpan.remove();
		    }
		}
		else {
		    if(audioMutedSpan.length == 0 ) {
			audioMutedSpan = document.createElement('span');
			audioMutedSpan.className = 'audioMuted';
			Util.setTooltip(audioMutedSpan,
			    "Participant is muted",
			    "top");

			$('#' + videoSpanId)[0].appendChild(audioMutedSpan);
			var mutedIndicator = document.createElement('i');
			mutedIndicator.className = 'icon-mic-disabled';
			audioMutedSpan.appendChild(mutedIndicator);

		    }
		    VideoLayout.updateMutePosition(videoSpanId);
		}
	    };

	    /*
	     * Shows or hides the audio muted indicator over the local thumbnail video.
	     * @param {boolean} isMuted
	     */
	    my.showLocalAudioIndicator = function(isMuted) {
		VideoLayout.showAudioIndicator('localVideoContainer', isMuted.toString());
	    };

	    /**
	     * Resizes the large video container.
	     */
	    my.resizeLargeVideoContainer = function () {

		var availableHeight = window.innerHeight;
		var availableWidth = Util.getAvailableVideoWidth();

		if (availableWidth < 0 || availableHeight < 0) return;

		$('#videospace').width(availableWidth);
		$('#videospace').height(availableHeight);
		$('#largeVideoContainer').width(availableWidth);
		$('#largeVideoContainer').height(availableHeight);

		var avatarSize = interfaceConfig.ACTIVE_SPEAKER_AVATAR_SIZE;
		var top = availableHeight / 2 - avatarSize / 4 * 3;
		$('#activeSpeaker').css('top', top);

		VideoLayout.resizeThumbnails();
	    };

	    /**
	     * Resizes thumbnails.
	     */
	    my.resizeThumbnails = function() {
		var videoSpaceWidth = $('#remoteVideos').width();

		var thumbnailSize = VideoLayout.calculateThumbnailSize(videoSpaceWidth);
		var width = thumbnailSize[0];
		var height = thumbnailSize[1];

		// size videos so that while keeping AR and max height, we have a
		// nice fit
		$('#remoteVideos').height(height);
		$('#remoteVideos>span').width(width);
		$('#remoteVideos>span').height(height);

		$('.userAvatar').css('left', (width - height) / 2);

		$(document).trigger("remotevideo.resized", [width, height]);
	    };

	    /**
	     * Enables the dominant speaker UI.
	     *
	     * @param resourceJid the jid indicating the video element to
	     * activate/deactivate
	     * @param isEnable indicates if the dominant speaker should be enabled or
	     * disabled
	     */
	    my.enableDominantSpeaker = function(resourceJid, isEnable) {

		var videoSpanId = null;
		var videoContainerId = null;
		if (resourceJid
			=== Strophe.getResourceFromJid(connection.emuc.myroomjid)) {
		    videoSpanId = 'localVideoWrapper';
		    videoContainerId = 'localVideoContainer';
		}
		else {
		    videoSpanId = 'participant_' + resourceJid;
		    videoContainerId = videoSpanId;
		}

		var displayName = resourceJid;
		var nameSpan = $('#' + videoContainerId + '>span.displayname');
		if (nameSpan.length > 0)
		    displayName = nameSpan.text();

		//console.log("UI enable dominant speaker",   displayName,   resourceJid,    isEnable);

		videoSpan = document.getElementById(videoContainerId);

		if (!videoSpan) {
		    return;
		}

		var video = $('#' + videoSpanId + '>video');

		if (video && video.length > 0) {
		    if (isEnable) {
			var isLargeVideoVisible = VideoLayout.isLargeVideoOnTop();
			VideoLayout.showDisplayName(videoContainerId, isLargeVideoVisible);

			if (!videoSpan.classList.contains("dominantspeaker"))
			    videoSpan.classList.add("dominantspeaker");
		    }
		    else {
			VideoLayout.showDisplayName(videoContainerId, false);

			if (videoSpan.classList.contains("dominantspeaker"))
			    videoSpan.classList.remove("dominantspeaker");
		    }

		    Avatar.showUserAvatar(
			connection.emuc.findJidFromResource(resourceJid));
		}
	    };

	    /**
	     * Gets the selector of video thumbnail container for the user identified by
	     * given <tt>userJid</tt>
	     * @param resourceJid user's Jid for whom we want to get the video container.
	     */
	    function getParticipantContainer(resourceJid)
	    {
		if (!resourceJid)
		    return null;

		if (resourceJid === Strophe.getResourceFromJid(connection.emuc.myroomjid))
		    return $("#localVideoContainer");
		else
		    return $("#participant_" + resourceJid);
	    }

	    /**
	     * Sets the size and position of the given video element.
	     *
	     * @param video the video element to position
	     * @param width the desired video width
	     * @param height the desired video height
	     * @param horizontalIndent the left and right indent
	     * @param verticalIndent the top and bottom indent
	     */
	    function positionVideo(video,
				   width,
				   height,
				   horizontalIndent,
				   verticalIndent) {
		video.width(width);
		video.height(height);
		video.css({  top: verticalIndent + 'px',
			     bottom: verticalIndent + 'px',
			     left: horizontalIndent + 'px',
			     right: horizontalIndent + 'px'});
	    }

	    /**
	     * Calculates the thumbnail size.
	     *
	     * @param videoSpaceWidth the width of the video space
	     */
	    my.calculateThumbnailSize = function (videoSpaceWidth) {
		// Calculate the available height, which is the inner window height minus
	       // 39px for the header minus 2px for the delimiter lines on the top and
	       // bottom of the large video, minus the 36px space inside the remoteVideos
	       // container used for highlighting shadow.
	       var availableHeight = 100;

		var numvids = $('#remoteVideos>span:visible').length;
		if (localLastNCount && localLastNCount > 0) {
		    numvids = Math.min(localLastNCount + 1, numvids);
		}

	       // Remove the 3px borders arround videos and border around the remote
	       // videos area and the 4 pixels between the local video and the others
	       //TODO: Find out where the 4 pixels come from and remove them
	       var availableWinWidth = videoSpaceWidth - 2 * 3 * numvids - 70 - 4;

	       var availableWidth = availableWinWidth / numvids;
	       var aspectRatio = 16.0 / 9.0;
	       var maxHeight = Math.min(160, availableHeight);
	       availableHeight = Math.min(maxHeight, availableWidth / aspectRatio);
	       if (availableHeight < availableWidth / aspectRatio) {
		   availableWidth = Math.floor(availableHeight * aspectRatio);
	       }

	       return [availableWidth, availableHeight];
	   };

	   /**
	    * Returns an array of the video dimensions, so that it keeps it's aspect
	    * ratio and fits available area with it's larger dimension. This method
	    * ensures that whole video will be visible and can leave empty areas.
	    *
	    * @return an array with 2 elements, the video width and the video height
	    */
	   function getDesktopVideoSize(videoWidth,
					videoHeight,
					videoSpaceWidth,
					videoSpaceHeight) {
	       if (!videoWidth)
		   videoWidth = currentVideoWidth;
	       if (!videoHeight)
		   videoHeight = currentVideoHeight;

	       var aspectRatio = videoWidth / videoHeight;

	       var availableWidth = Math.max(videoWidth, videoSpaceWidth);
	       var availableHeight = Math.max(videoHeight, videoSpaceHeight);

	       videoSpaceHeight -= $('#remoteVideos').outerHeight();

	       if (availableWidth / aspectRatio >= videoSpaceHeight)
	       {
		   availableHeight = videoSpaceHeight;
		   availableWidth = availableHeight * aspectRatio;
	       }

	       if (availableHeight * aspectRatio >= videoSpaceWidth)
	       {
		   availableWidth = videoSpaceWidth;
		   availableHeight = availableWidth / aspectRatio;
	       }

	       return [availableWidth, availableHeight];
	   }

	   /**
	    * Creates the edit display name button.
	    * 
	    * @returns the edit button
	    */
	    function createEditDisplayNameButton() {
		var editButton = document.createElement('a');
		editButton.className = 'displayname';
		Util.setTooltip(editButton,
				'Click to edit your<br/>display name',
				"top");
		editButton.innerHTML = '<i class="fa fa-pencil"></i>';

		return editButton;
	    }

	    /**
	     * Creates the element indicating the moderator(owner) of the conference.
	     *
	     * @param parentElement the parent element where the owner indicator will
	     * be added
	     */
	    function createModeratorIndicatorElement(parentElement) {
		var moderatorIndicator = document.createElement('i');
		moderatorIndicator.className = 'fa fa-star';
		parentElement.appendChild(moderatorIndicator);

		Util.setTooltip(parentElement,
			"The owner of<br/>this conference",
			"top");
	    }

	    /**
	     * Updates the remote video menu.
	     *
	     * @param jid the jid indicating the video for which we're adding a menu.
	     * @param isMuted indicates the current mute state
	     */
	    my.updateRemoteVideoMenu = function(jid, isMuted) {
		var muteMenuItem
		    = $('#remote_popupmenu_'
			    + Strophe.getResourceFromJid(jid)
			    + '>li>a.mutelink');

		var mutedIndicator = "<i class='icon-mic-disabled'></i>";

		if (muteMenuItem.length) {
		    var muteLink = muteMenuItem.get(0);

		    if (isMuted === 'true') {
			muteLink.innerHTML = mutedIndicator + ' Muted';
			muteLink.className = 'mutelink disabled';
		    }
		    else {
			muteLink.innerHTML = mutedIndicator + ' Mute';
			muteLink.className = 'mutelink';
		    }
		}
	    };

	    /**
	     * Returns the current dominant speaker resource jid.
	     */
	    my.getDominantSpeakerResourceJid = function () {
		return currentDominantSpeaker;
	    };

	    /**
	     * Returns the corresponding resource jid to the given peer container
	     * DOM element.
	     *
	     * @return the corresponding resource jid to the given peer container
	     * DOM element
	     */
	    my.getPeerContainerResourceJid = function (containerElement) {
		var i = containerElement.id.indexOf('participant_');

		if (i >= 0)
		    return containerElement.id.substring(i + 12); 
	    };

	    /**
	     * Adds the remote video menu element for the given <tt>jid</tt> in the
	     * given <tt>parentElement</tt>.
	     *
	     * @param jid the jid indicating the video for which we're adding a menu.
	     * @param parentElement the parent element where this menu will be added
	     */
	    function addRemoteVideoMenu(jid, parentElement) {
		var spanElement = document.createElement('span');
		spanElement.className = 'remotevideomenu';

		parentElement.appendChild(spanElement);

		var menuElement = document.createElement('i');
		menuElement.className = 'fa fa-angle-down';
		menuElement.title = 'Remote user controls';
		spanElement.appendChild(menuElement);

	//        <ul class="popupmenu">
	//        <li><a href="#">Mute</a></li>
	//        <li><a href="#">Eject</a></li>
	//        </ul>

		var popupmenuElement = document.createElement('ul');
		popupmenuElement.className = 'popupmenu';
		popupmenuElement.id
		    = 'remote_popupmenu_' + Strophe.getResourceFromJid(jid);
		spanElement.appendChild(popupmenuElement);

		var muteMenuItem = document.createElement('li');
		var muteLinkItem = document.createElement('a');

		var mutedIndicator = "<i class='icon-mic-disabled'></i>";

		if (!mutedAudios[jid]) {
		    muteLinkItem.innerHTML = mutedIndicator + 'Mute';
		    muteLinkItem.className = 'mutelink';
		}
		else {
		    muteLinkItem.innerHTML = mutedIndicator + ' Muted';
		    muteLinkItem.className = 'mutelink disabled';
		}

		muteLinkItem.onclick = function(){
		    if ($(this).attr('disabled') != undefined) {
			event.preventDefault();
		    }
		    var isMute = mutedAudios[jid] == true;
		    connection.moderate.setMute(jid, !isMute);
		    popupmenuElement.setAttribute('style', 'display:none;');

		    if (isMute) {
			this.innerHTML = mutedIndicator + ' Muted';
			this.className = 'mutelink disabled';
		    }
		    else {
			this.innerHTML = mutedIndicator + ' Mute';
			this.className = 'mutelink';
		    }
		};

		muteMenuItem.appendChild(muteLinkItem);
		popupmenuElement.appendChild(muteMenuItem);

		var ejectIndicator = "<i class='fa fa-eject'></i>";

		var ejectMenuItem = document.createElement('li');
		var ejectLinkItem = document.createElement('a');
		ejectLinkItem.innerHTML = ejectIndicator + ' Kick out';
		ejectLinkItem.onclick = function(){
		    connection.moderate.eject(jid);
		    popupmenuElement.setAttribute('style', 'display:none;');
		};

		ejectMenuItem.appendChild(ejectLinkItem);
		popupmenuElement.appendChild(ejectMenuItem);

		var paddingSpan = document.createElement('span');
		paddingSpan.className = 'popupmenuPadding';
		popupmenuElement.appendChild(paddingSpan);
	    }

	    /**
	     * On audio muted event.
	     */
	    $(document).bind('audiomuted.muc', function (event, jid, isMuted) {
		/*
		 // FIXME: but focus can not mute in this case ? - check
		if (jid === connection.emuc.myroomjid) {

		    // The local mute indicator is controlled locally
		    return;
		}*/
		var videoSpanId = null;
		if (jid === connection.emuc.myroomjid) {
		    videoSpanId = 'localVideoContainer';
		} else {
		    VideoLayout.ensurePeerContainerExists(jid);
		    videoSpanId = 'participant_' + Strophe.getResourceFromJid(jid);
		}

		mutedAudios[jid] = isMuted;

		if (Moderator.isModerator()) {
		    VideoLayout.updateRemoteVideoMenu(jid, isMuted);
		}

		if (videoSpanId)
		    VideoLayout.showAudioIndicator(videoSpanId, isMuted);
	    });

	    /**
	     * On video muted event.
	     */
	    $(document).bind('videomuted.muc', function (event, jid, isMuted) {
		var videoSpanId = null;
		if (jid === connection.emuc.myroomjid) {
		    videoSpanId = 'localVideoContainer';
		} else {
		    VideoLayout.ensurePeerContainerExists(jid);
		    videoSpanId = 'participant_' + Strophe.getResourceFromJid(jid);
		}

		if (videoSpanId)
		    VideoLayout.showVideoIndicator(videoSpanId, isMuted);
	    });

	    /**
	     * Display name changed.
	     */
	    $(document).bind('displaynamechanged', function (event, jid, displayName, status) {
		var name = null;
		if (jid === 'localVideoContainer'
		    || jid === connection.emuc.myroomjid) {
		    name = nickname;
		    setDisplayName('localVideoContainer',
				   displayName);
		} else {
		    VideoLayout.ensurePeerContainerExists(jid);
		    name = $('#participant_' + Strophe.getResourceFromJid(jid) + "_name").text();
		    setDisplayName(
			'participant_' + Strophe.getResourceFromJid(jid),
			displayName,
			status);
		}
	    });

	    /**
	     * On dominant speaker changed event.
	     */
	    $(document).bind('dominantspeakerchanged', function (event, resourceJid) {
		// We ignore local user events.
		if (connection.emuc.myroomjid && resourceJid === Strophe.getResourceFromJid(connection.emuc.myroomjid))
		    return;

		// Update the current dominant speaker.
		if (resourceJid !== currentDominantSpeaker) {
		    var oldSpeakerVideoSpanId = "participant_" + currentDominantSpeaker,
			newSpeakerVideoSpanId = "participant_" + resourceJid;
		    if($("#" + oldSpeakerVideoSpanId + ">span.displayname").text() ===
			interfaceConfig.DEFAULT_DOMINANT_SPEAKER_DISPLAY_NAME) {
			setDisplayName(oldSpeakerVideoSpanId, null);
		    }
		    if($("#" + newSpeakerVideoSpanId + ">span.displayname").text() ===
			interfaceConfig.DEFAULT_REMOTE_DISPLAY_NAME) {
			setDisplayName(newSpeakerVideoSpanId,
			    interfaceConfig.DEFAULT_DOMINANT_SPEAKER_DISPLAY_NAME);
		    }
		    currentDominantSpeaker = resourceJid;
		} else {
		    return;
		}

		// Obtain container for new dominant speaker.
		var container  = document.getElementById(
			'participant_' + resourceJid);

		// Local video will not have container found, but that's ok
		// since we don't want to switch to local video.
		if (container && !focusedVideoInfo)
		{
		    var video = container.getElementsByTagName("video");

		    // Update the large video if the video source is already available,
		    // otherwise wait for the "videoactive.jingle" event.
		    if (video.length && video[0].currentTime > 0)
			VideoLayout.updateLargeVideo(RTC.getVideoSrc(video[0]), resourceJid);
		}
	    });

	    /**
	     * On last N change event.
	     *
	     * @param event the event that notified us
	     * @param lastNEndpoints the list of last N endpoints
	     * @param endpointsEnteringLastN the list currently entering last N
	     * endpoints
	     */
	    $(document).bind('lastnchanged', function ( event,
							lastNEndpoints,
							endpointsEnteringLastN,
							stream) {
		if (lastNCount !== lastNEndpoints.length)
		    lastNCount = lastNEndpoints.length;

		lastNEndpointsCache = lastNEndpoints;

		// Say A, B, C, D, E, and F are in a conference and LastN = 3.
		//
		// If LastN drops to, say, 2, because of adaptivity, then E should see
		// thumbnails for A, B and C. A and B are in E's server side LastN set,
		// so E sees them. C is only in E's local LastN set.
		//
		// If F starts talking and LastN = 3, then E should see thumbnails for
		// F, A, B. B gets "ejected" from E's server side LastN set, but it
		// enters E's local LastN ejecting C.

		// Increase the local LastN set size, if necessary.
		if (lastNCount > localLastNCount) {
		    localLastNCount = lastNCount;
		}

		// Update the local LastN set preserving the order in which the
		// endpoints appeared in the LastN/local LastN set.

		var nextLocalLastNSet = lastNEndpoints.slice(0);
		for (var i = 0; i < localLastNSet.length; i++) {
		    if (nextLocalLastNSet.length >= localLastNCount) {
			break;
		    }

		    var resourceJid = localLastNSet[i];
		    if (nextLocalLastNSet.indexOf(resourceJid) === -1) {
			nextLocalLastNSet.push(resourceJid);
		    }
		}

		localLastNSet = nextLocalLastNSet;

		var updateLargeVideo = false;

		// Handle LastN/local LastN changes.
		$('#remoteVideos>span').each(function( index, element ) {
		    var resourceJid = VideoLayout.getPeerContainerResourceJid(element);

		    var isReceived = true;
		    if (resourceJid
			&& lastNEndpoints.indexOf(resourceJid) < 0
			&& localLastNSet.indexOf(resourceJid) < 0) {
			//console.log("Remove from last N", resourceJid);
			showPeerContainer(resourceJid, 'hide');
			isReceived = false;
		    } else if (resourceJid
			&& $('#participant_' + resourceJid).is(':visible')
			&& lastNEndpoints.indexOf(resourceJid) < 0
			&& localLastNSet.indexOf(resourceJid) >= 0) {
			showPeerContainer(resourceJid, 'avatar');
			isReceived = false;
		    }

		    if (!isReceived) {
			// resourceJid has dropped out of the server side lastN set, so
			// it is no longer being received. If resourceJid was being
			// displayed in the large video we have to switch to another
			// user.
			var largeVideoResource = largeVideoState.userResourceJid;
			if (!updateLargeVideo && resourceJid === largeVideoResource) {
			    updateLargeVideo = true;
			}
		    }
		});

		if (!endpointsEnteringLastN || endpointsEnteringLastN.length < 0)
		    endpointsEnteringLastN = lastNEndpoints;

		if (endpointsEnteringLastN && endpointsEnteringLastN.length > 0) {
		    endpointsEnteringLastN.forEach(function (resourceJid) {

			var isVisible = $('#participant_' + resourceJid).is(':visible');
			showPeerContainer(resourceJid, 'show');
			if (!isVisible) {
			    //console.log("Add to last N", resourceJid);

			    var jid = connection.emuc.findJidFromResource(resourceJid);
			    var mediaStream = mediaStreams[jid][MediaStream.VIDEO_TYPE];
			    var sel = $('#participant_' + resourceJid + '>video');

			    var videoStream = simulcast.getReceivingVideoStream(
				mediaStream.stream);
			    RTC.attachMediaStream(sel, videoStream);
			    if (lastNPickupJid == mediaStream.peerjid) {
				// Clean up the lastN pickup jid.
				lastNPickupJid = null;

				// Don't fire the events again, they've already
				// been fired in the contact list click handler.
				VideoLayout.handleVideoThumbClicked(
				    $(sel).attr('src'),
				    false,
				    Strophe.getResourceFromJid(mediaStream.peerjid));

				updateLargeVideo = false;
			    }
			    waitForRemoteVideo(sel, mediaStream.ssrc, mediaStream.stream, resourceJid);
			}
		    })
		}

		// The endpoint that was being shown in the large video has dropped out
		// of the lastN set and there was no lastN pickup jid. We need to update
		// the large video now.

		if (updateLargeVideo) {

		    var resource, container, src;
		    var myResource
			= Strophe.getResourceFromJid(connection.emuc.myroomjid);

		    // Find out which endpoint to show in the large video.
		    for (var i = 0; i < lastNEndpoints.length; i++) {
			resource = lastNEndpoints[i];
			if (!resource || resource === myResource)
			    continue;

			container = $("#participant_" + resource);
			if (container.length == 0)
			    continue;

			src = $('video', container).attr('src');
			if (!src)
			    continue;

			// videoSrcToSsrc needs to be update for this call to succeed.
			VideoLayout.updateLargeVideo(src);
			break;

		    }
		}
	    });

	    $(document).bind('videoactive.jingle', function (event, videoelem) {
		if (videoelem.attr('id').indexOf('mixedmslabel') === -1) {
		    // ignore mixedmslabela0 and v0

		    videoelem.show();
		    VideoLayout.resizeThumbnails();

		    var videoParent = videoelem.parent();
		    var parentResourceJid = null;
		    if (videoParent)
			parentResourceJid
			    = VideoLayout.getPeerContainerResourceJid(videoParent[0]);

		    // Update the large video to the last added video only if there's no
		    // current dominant, focused speaker or prezi playing or update it to
		    // the current dominant speaker.

		    if ((!focusedVideoInfo && !VideoLayout.getDominantSpeakerResourceJid()) || (parentResourceJid &&  VideoLayout.getDominantSpeakerResourceJid() === parentResourceJid)) 
		    {
			VideoLayout.updateLargeVideo(
			    RTC.getVideoSrc(videoelem[0]),
			    1,
			    parentResourceJid);
		    }

		    VideoLayout.showModeratorIndicator();
		}
	    });

	    $(document).bind('simulcastlayerschanging', function (event, endpointSimulcastLayers) {
		endpointSimulcastLayers.forEach(function (esl) {

		    var resource = esl.endpoint;

		    // if lastN is enabled *and* the endpoint is *not* in the lastN set,
		    // then ignore the event (= do not preload anything).
		    //
		    // The bridge could probably stop sending this message if it's for
		    // an endpoint that's not in lastN.

		    if (lastNCount != -1
			&& (lastNCount < 1 || lastNEndpointsCache.indexOf(resource) === -1)) {
			return;
		    }

		    var primarySSRC = esl.simulcastLayer.primarySSRC;

		    // Get session and stream from primary ssrc.
		    var res = simulcast.getReceivingVideoStreamBySSRC(primarySSRC);
		    var session = res.session;
		    var electedStream = res.stream;

		    if (session && electedStream) {
			var msid = simulcast.getRemoteVideoStreamIdBySSRC(primarySSRC);

			//console.info([esl, primarySSRC, msid, session, electedStream]);

			var msidParts = msid.split(' ');

			var preload = (Strophe.getResourceFromJid(ssrc2jid[primarySSRC]) == largeVideoState.userResourceJid);

			if (preload) {
			    if (largeVideoState.preload)
			    {
				$(largeVideoState.preload).remove();
			    }
			    //console.info('Preloading remote video');
			    largeVideoState.preload = $('<video autoplay></video>');
			    // ssrcs are unique in an rtp session
			    largeVideoState.preload_ssrc = primarySSRC;

			    RTC.attachMediaStream(largeVideoState.preload, electedStream)
			}

		    } else {
			console.error('Could not find a stream or a session.', session, electedStream);
		    }
		});
	    });

	    /**
	     * On simulcast layers changed event.
	     */
	    $(document).bind('simulcastlayerschanged', function (event, endpointSimulcastLayers) {
		endpointSimulcastLayers.forEach(function (esl) {

		    var resource = esl.endpoint;

		    // if lastN is enabled *and* the endpoint is *not* in the lastN set,
		    // then ignore the event (= do not change large video/thumbnail
		    // SRCs).
		    //
		    // Note that even if we ignore the "changed" event in this event
		    // handler, the bridge must continue sending these events because
		    // the simulcast code in simulcast.js uses it to know what's going
		    // to be streamed by the bridge when/if the endpoint gets back into
		    // the lastN set.

		    if (lastNCount != -1
			&& (lastNCount < 1 || lastNEndpointsCache.indexOf(resource) === -1)) {
			return;
		    }

		    var primarySSRC = esl.simulcastLayer.primarySSRC;

		    // Get session and stream from primary ssrc.
		    var res = simulcast.getReceivingVideoStreamBySSRC(primarySSRC);
		    var session = res.session;
		    var electedStream = res.stream;

		    if (session && electedStream) {
			var msid = simulcast.getRemoteVideoStreamIdBySSRC(primarySSRC);

			//console.info('Switching simulcast substream.');
			//console.info([esl, primarySSRC, msid, session, electedStream]);

			var msidParts = msid.split(' ');
			var selRemoteVideo = $(['#', 'remoteVideo_', session.sid, '_', msidParts[0]].join(''));

			var updateLargeVideo = (Strophe.getResourceFromJid(ssrc2jid[primarySSRC])
			    == largeVideoState.userResourceJid);
			var updateFocusedVideoSrc = (focusedVideoInfo && focusedVideoInfo.src && focusedVideoInfo.src != '' &&
			    (RTC.getVideoSrc(selRemoteVideo[0]) == focusedVideoInfo.src));

			var electedStreamUrl;
			if (largeVideoState.preload_ssrc == primarySSRC)
			{
			    RTC.setVideoSrc(selRemoteVideo[0], RTC.getVideoSrc(largeVideoState.preload[0]));
			}
			else
			{
			    if (largeVideoState.preload
				&& largeVideoState.preload != null) {
				$(largeVideoState.preload).remove();
			    }

			    largeVideoState.preload_ssrc = 0;

			    RTC.attachMediaStream(selRemoteVideo, electedStream);
			}

			var jid = ssrc2jid[primarySSRC];
			jid2Ssrc[jid] = primarySSRC;

			if (updateLargeVideo) {
			    VideoLayout.updateLargeVideo(RTC.getVideoSrc(selRemoteVideo[0]), null,
				Strophe.getResourceFromJid(jid));
			}

			if (updateFocusedVideoSrc) {
			    focusedVideoInfo.src = RTC.getVideoSrc(selRemoteVideo[0]);
			}

			var videoId;
			if(resource == Strophe.getResourceFromJid(connection.emuc.myroomjid))
			{
			    videoId = "localVideoContainer";
			}
			else
			{
			    videoId = "participant_" + resource;
			}
			var connectionIndicator = VideoLayout.connectionIndicators[videoId];
			if(connectionIndicator)
			    connectionIndicator.updatePopoverData();

		    } else {
			console.error('Could not find a stream or a session.', session, electedStream);
		    }
		});
	    });

	    /**
	     * Constructs new connection indicator.
	     * @param videoContainer the video container associated with the indicator.
	     * @constructor
	     */
	    function ConnectionIndicator(videoContainer, jid)
	    {
		this.videoContainer = videoContainer;
		this.bandwidth = null;
		this.packetLoss = null;
		this.bitrate = null;
		this.showMoreValue = false;
		this.resolution = null;
		this.transport = [];
		this.popover = null;
		this.jid = jid;
		this.create();
	    }

	    /**
	     * Values for the connection quality
	     * @type {{98: string, 81: string, 64: string, 47: string, 30: string, 0: string}}
	     */
	    ConnectionIndicator.connectionQualityValues = {
		98: "18px", //full
		81: "15px",//4 bars
		64: "11px",//3 bars
		47: "7px",//2 bars
		30: "3px",//1 bar
		0: "0px"//empty
	    };

	    ConnectionIndicator.getIP = function(value)
	    {
		return value.substring(0, value.lastIndexOf(":"));
	    };

	    ConnectionIndicator.getPort = function(value)
	    {
		return value.substring(value.lastIndexOf(":") + 1, value.length);
	    };

	    ConnectionIndicator.getStringFromArray = function (array) {
		var res = "";
		for(var i = 0; i < array.length; i++)
		{
		    res += (i == 0? "" : ", ") + array[i];
		}
		return res;
	    }
	    /**
	     * Generates the html content.
	     * @returns {string} the html content.
	     */
	    ConnectionIndicator.prototype.generateText = function () {
		var downloadBitrate, uploadBitrate, packetLoss, resolution;

		if(this.bitrate === null)
		{
		    downloadBitrate = "N/A";
		    uploadBitrate = "N/A";
		}
		else
		{
		    downloadBitrate = this.bitrate.download? this.bitrate.download + " Kbps" : "N/A";
		    uploadBitrate = this.bitrate.upload? this.bitrate.upload + " Kbps" : "N/A";
		}

		if(this.packetLoss === null)
		{
		    packetLoss = "N/A";
		}
		else
		{

		    packetLoss = "<span class='jitsipopover_green'>&darr;</span>" +
			(this.packetLoss.download != null? this.packetLoss.download : "N/A") +
			"% <span class='jitsipopover_orange'>&uarr;</span>" +
			(this.packetLoss.upload != null? this.packetLoss.upload : "N/A") + "%";
		}

		var resolutionValue = null;
		if(this.resolution && this.jid != null)
		{
		    var keys = Object.keys(this.resolution);
		    if(keys.length == 1)
		    {
			for(var ssrc in this.resolution)
			{
			    resolutionValue = this.resolution[ssrc];
			}
		    }
		    else if(keys.length > 1)
		    {
			var displayedSsrc = simulcast.getReceivingSSRC(this.jid);
			resolutionValue = this.resolution[displayedSsrc];
		    }
		}

		if(this.jid==null)
		{
		    resolution = "";
		    if(this.resolution == null || !Object.keys(this.resolution)
			|| Object.keys(this.resolution).length == 0)
		    {
			resolution = "N/A";
		    }
		    else
			for(var i in this.resolution)
			{
			    resolutionValue = this.resolution[i];
			    if(resolutionValue)
			    {
				if(resolutionValue.height &&
				    resolutionValue.width)
				{
				    resolution += (resolution == ""? "" : ", ")
					+ resolutionValue.width + "x" + resolutionValue.height;
				}
			    }
			}
		}
		else if(!resolutionValue ||
		    !resolutionValue.height ||
		    !resolutionValue.width)
		{
		    resolution = "N/A";
		}
		else
		{
		    resolution = resolutionValue.width + "x" + resolutionValue.height;
		}

		var result = "<table style='width:100%'><tr><td><span class='jitsipopover_blue'>Bitrate:</span></td><td><span class='jitsipopover_green'>&darr;</span>" +
		    downloadBitrate + " <span class='jitsipopover_orange'>&uarr;</span>" +
		    uploadBitrate + "</td></tr><tr><td>" +
		    "<tr><td><span class='jitsipopover_blue'>Packet loss: </span></td><td>" + packetLoss  + "</td></tr><tr><td>" +
		    "<span class='jitsipopover_blue'>Resolution:</span></td><td>" + resolution + "</td></tr></table>";

		if(this.videoContainer.id == "localVideoContainer")
		    result += "<div class=\"jitsipopover_showmore\" onclick = \"ofmeet.VideoLayout.connectionIndicators['" +
			 this.videoContainer.id + "'].showMore()\">" + (this.showMoreValue? "Show less" : "Show More") + "</div><br />";

		if(this.showMoreValue)
		{
		    var downloadBandwidth, uploadBandwidth, transport;
		    if(this.bandwidth === null)
		    {
			downloadBandwidth = "N/A";
			uploadBandwidth = "N/A";
		    }
		    else
		    {
			downloadBandwidth = this.bandwidth.download? this.bandwidth.download + " Kbps" : "N/A";
			uploadBandwidth = this.bandwidth.upload? this.bandwidth.upload + " Kbps" : "N/A";
		    }

		    if(!this.transport || this.transport.length === 0)
		    {
			transport = "<tr><td><span class='jitsipopover_blue'>Address:</span></td><td> N/A</td></tr>";
		    }
		    else
		    {
			var data = {remoteIP: [], localIP:[], remotePort:[], localPort:[]};
			for(var i = 0; i < this.transport.length; i++)
			{
			    var ip =  ConnectionIndicator.getIP(this.transport[i].ip);
			    var port = ConnectionIndicator.getPort(this.transport[i].ip);
			    var localIP = ConnectionIndicator.getIP(this.transport[i].localip);
			    var localPort = ConnectionIndicator.getPort(this.transport[i].localip);
			    if(data.remoteIP.indexOf(ip) == -1)
			    {
			       data.remoteIP.push(ip);
			    }

			    if(data.remotePort.indexOf(port) == -1)
			    {
				data.remotePort.push(port);
			    }

			    if(data.localIP.indexOf(localIP) == -1)
			    {
				data.localIP.push(localIP);
			    }

			    if(data.localPort.indexOf(localPort) == -1)
			    {
				data.localPort.push(localPort);
			    }

			}
			var localTransport = "<tr><td><span class='jitsipopover_blue'>Local address" +
			    (data.localIP.length > 1? "es" : "") + ": </span></td><td> " +
			     ConnectionIndicator.getStringFromArray(data.localIP) + "</td></tr>";
			transport = "<tr><td><span class='jitsipopover_blue'>Remote address"+
			    (data.remoteIP.length > 1? "es" : "") + ":</span></td><td> " +
			    ConnectionIndicator.getStringFromArray(data.remoteIP) + "</td></tr>";
			if(this.transport.length > 1)
			{
			    transport += "<tr><td><span class='jitsipopover_blue'>Remote ports:</span></td><td>";
			    localTransport += "<tr><td><span class='jitsipopover_blue'>Local ports:</span></td><td>";
			}
			else
			{
			    transport += "<tr><td><span class='jitsipopover_blue'>Remote port:</span></td><td>";
			    localTransport += "<tr><td><span class='jitsipopover_blue'>Local port:</span></td><td>";
			}

			transport += ConnectionIndicator.getStringFromArray(data.remotePort);
			localTransport += ConnectionIndicator.getStringFromArray(data.localPort);
			transport += "</td></tr>";
			transport += localTransport + "</td></tr>";
			transport +="<tr><td><span class='jitsipopover_blue'>Transport:</span></td><td>" + this.transport[0].type + "</td></tr>";

		    }

		    result += "<table  style='width:100%'><tr><td><span class='jitsipopover_blue'>Estimated bandwidth:</span> </td><td>" +
			"<span class='jitsipopover_green'>&darr;</span>" + downloadBandwidth +
			" <span class='jitsipopover_orange'>&uarr;</span>" +
			uploadBandwidth + "</td></tr>";

		    result += transport + "</table>";

		}

		return result;
	    };

	    /**
	     * Shows or hide the additional information.
	     */
	    ConnectionIndicator.prototype.showMore = function () {
		this.showMoreValue = !this.showMoreValue;
		this.updatePopoverData();
	    };

	    /**
	     * Creates the indicator
	     */
	    ConnectionIndicator.prototype.create = function () {
		this.connectionIndicatorContainer = document.createElement("div");
		this.connectionIndicatorContainer.className = "connectionindicator";
		this.connectionIndicatorContainer.style.display = "none";
		this.videoContainer.appendChild(this.connectionIndicatorContainer);
		this.popover = new JitsiPopover($("#" + this.videoContainer.id + " > .connectionindicator"),
		    {content: "<div class=\"connection_info\">Come back here for " +
			"connection information once the conference starts</div>", skin: "black"});

		function createIcon(classes)
		{
		    var icon = document.createElement("span");
		    for(var i in classes)
		    {
			icon.classList.add(classes[i]);
		    }
		    icon.appendChild(document.createElement("i")).classList.add("icon-connection");
		    return icon;
		}
		this.emptyIcon = this.connectionIndicatorContainer.appendChild(
		    createIcon(["connection", "connection_empty"]));
		this.fullIcon = this.connectionIndicatorContainer.appendChild(
		    createIcon(["connection", "connection_full"]));

	    };

	    /**
	     * Removes the indicator
	     */
	    ConnectionIndicator.prototype.remove = function()
	    {
		this.connectionIndicatorContainer.remove();
		this.popover.forceHide();

	    };

	    /**
	     * Updates the data of the indicator
	     * @param percent the percent of connection quality
	     * @param object the statistics data.
	     */
	    ConnectionIndicator.prototype.updateConnectionQuality = function (percent, object) {

		if(percent === null)
		{
		    this.connectionIndicatorContainer.style.display = "none";
		    this.popover.forceHide();
		    return;
		}
		else
		{
		    if(this.connectionIndicatorContainer.style.display == "none") {
			this.connectionIndicatorContainer.style.display = "block";
			VideoLayout.updateMutePosition(this.videoContainer.id);
		    }
		}
		this.bandwidth = object.bandwidth;
		this.bitrate = object.bitrate;
		this.packetLoss = object.packetLoss;
		this.transport = object.transport;
		if(object.resolution)
		{
		    this.resolution = object.resolution;
		}
		for(var quality in ConnectionIndicator.connectionQualityValues)
		{
		    if(percent >= quality)
		    {
			this.fullIcon.style.width = ConnectionIndicator.connectionQualityValues[quality];
		    }
		}
		this.updatePopoverData();
	    };

	    /**
	     * Updates the resolution
	     * @param resolution the new resolution
	     */
	    ConnectionIndicator.prototype.updateResolution = function (resolution) {
		this.resolution = resolution;
		this.updatePopoverData();
	    };

	    /**
	     * Updates the content of the popover
	     */
	    ConnectionIndicator.prototype.updatePopoverData = function () {
		this.popover.updateContent("<div class=\"connection_info\">" + this.generateText() + "</div>");
	    };

	    /**
	     * Hides the popover
	     */
	    ConnectionIndicator.prototype.hide = function () {
		this.popover.forceHide();
	    };

	    /**
	     * Hides the indicator
	     */
	    ConnectionIndicator.prototype.hideIndicator = function () {
		this.connectionIndicatorContainer.style.display = "none";
		if(this.popover)
		    this.popover.forceHide();
	    };

	    /**
	     * Updates the data for the indicator
	     * @param id the id of the indicator
	     * @param percent the percent for connection quality
	     * @param object the data
	     */
	    function updateStatsIndicator(id, percent, object) {
		if(VideoLayout.connectionIndicators[id])
		    VideoLayout.connectionIndicators[id].updateConnectionQuality(percent, object);
	    }

	    /**
	     * Updates local stats
	     * @param percent
	     * @param object
	     */
	    my.updateLocalConnectionStats = function (percent, object) {
		var resolution = null;
		if(object.resolution !== null)
		{
		    resolution = object.resolution;
		    object.resolution = resolution[connection.emuc.myroomjid];
		    delete resolution[connection.emuc.myroomjid];
		}
		updateStatsIndicator("localVideoContainer", percent, object);
		for(var jid in resolution)
		{
		    if(resolution[jid] === null)
			continue;
		    var id = 'participant_' + Strophe.getResourceFromJid(jid);
		    if(VideoLayout.connectionIndicators[id])
		    {
			VideoLayout.connectionIndicators[id].updateResolution(resolution[jid]);
		    }
		}

	    };

	    /**
	     * Updates remote stats.
	     * @param jid the jid associated with the stats
	     * @param percent the connection quality percent
	     * @param object the stats data
	     */
	    my.updateConnectionStats = function (jid, percent, object) {
		var resourceJid = Strophe.getResourceFromJid(jid);

		var videoSpanId = 'participant_' + resourceJid;
		updateStatsIndicator(videoSpanId, percent, object);
	    };

	    /**
	     * Removes the connection
	     * @param jid
	     */
	    my.removeConnectionIndicator = function (jid) {
		if(VideoLayout.connectionIndicators['participant_' + Strophe.getResourceFromJid(jid)])
		    VideoLayout.connectionIndicators['participant_' + Strophe.getResourceFromJid(jid)].remove();
	    };

	    /**
	     * Hides the connection indicator
	     * @param jid
	     */
	    my.hideConnectionIndicator = function (jid) {
		if(VideoLayout.connectionIndicators['participant_' + Strophe.getResourceFromJid(jid)])
		    VideoLayout.connectionIndicators['participant_' + Strophe.getResourceFromJid(jid)].hide();
	    };

	    /**
	     * Hides all the indicators
	     */
	    my.onStatsStop = function () {
		for(var indicator in VideoLayout.connectionIndicators)
		{
		    VideoLayout.connectionIndicators[indicator].hideIndicator();
		}
	    };

	    return my;
	}(VideoLayout || {}));


	/* global $ */
	/**
	 * Utility functions.
	 */
	var Util = (function (my) {

	    /**
	     * Returns the text width for the given element.
	     *
	     * @param el the element
	     */
	    my.getTextWidth = function (el) {
		return (el.clientWidth + 1);
	    };

	    /**
	     * Returns the text height for the given element.
	     *
	     * @param el the element
	     */
	    my.getTextHeight = function (el) {
		return (el.clientHeight + 1);
	    };

	    /**
	     * Casts the given number to integer.
	     *
	     * @param number the number to cast
	     */
	    my.toInteger = function (number) {
		return Math.round(Number(number));
	    };

	    /**
	     * Plays the sound given by id.
	     *
	     * @param id the identifier of the audio element.
	     */

	    /**
	     * Escapes the given text.
	     */
	    my.escapeHtml = function (unsafeText) {
		return $('<div/>').text(unsafeText).html();
	    };

	    /**
	     * Returns the available video width.
	     */
	    my.getAvailableVideoWidth = function () {
		var rightPanelWidth = 0;

		return window.innerWidth - rightPanelWidth;
	    };

	    my.imageToGrayScale = function (canvas) {
		var context = canvas.getContext('2d');
		var imgData = context.getImageData(0, 0, canvas.width, canvas.height);
		var pixels  = imgData.data;

		for (var i = 0, n = pixels.length; i < n; i += 4) {
		    var grayscale
			= pixels[i] * .3 + pixels[i+1] * .59 + pixels[i+2] * .11;
		    pixels[i  ] = grayscale;        // red
		    pixels[i+1] = grayscale;        // green
		    pixels[i+2] = grayscale;        // blue
		    // pixels[i+3]              is alpha
		}
		// redraw the image in black & white
		context.putImageData(imgData, 0, 0);
	    };

	    my.setTooltip = function (element, tooltipText, position) {
		element.setAttribute("data-content", tooltipText);
		element.setAttribute("data-toggle", "popover");
		element.setAttribute("data-placement", position);
		element.setAttribute("data-html", true);
		element.setAttribute("data-container", "body");
	    };

	    my.createExpBackoffTimer = function (step) {
		var count = 1;
		return function (reset) {
		    // Reset call
		    if (reset) {
			count = 1;
			return;
		    }
		    // Calculate next timeout
		    var timeout = Math.pow(2, count - 1);
		    count += 1;
		    return timeout * step;
		};
	    };

	    return my;
	}(Util || {}));



	/**
	 * trackUsage.
	 */

	(function () {

		function trackUsage(eventname, obj) {
		    //console.log('track', eventname, obj);
		    // implement your own tracking mechanism here
		}
		if (typeof exports !== 'undefined') {
		    module.exports = trackUsage;
		} else {
		    window.trackUsage = trackUsage;
		}

	})();


	/**
	 *
	 * SimulcastUtils
	 *
	 */
	function SimulcastUtils() {
	    this.logger = new SimulcastLogger("SimulcastUtils", 1);
	}

	/**
	 *
	 * @type {{}}
	 * @private
	 */
	SimulcastUtils.prototype._emptyCompoundIndex = {};

	/**
	 *
	 * @param lines
	 * @param videoSources
	 * @private
	 */
	SimulcastUtils.prototype._replaceVideoSources = function (lines, videoSources) {
	    var i, inVideo = false, index = -1, howMany = 0;

	    this.logger.info('Replacing video sources...');

	    for (i = 0; i < lines.length; i++) {
		if (inVideo && lines[i].substring(0, 'm='.length) === 'm=') {
		    // Out of video.
		    break;
		}

		if (!inVideo && lines[i].substring(0, 'm=video '.length) === 'm=video ') {
		    // In video.
		    inVideo = true;
		}

		if (inVideo && (lines[i].substring(0, 'a=ssrc:'.length) === 'a=ssrc:'
		    || lines[i].substring(0, 'a=ssrc-group:'.length) === 'a=ssrc-group:')) {

		    if (index === -1) {
			index = i;
		    }

		    howMany++;
		}
	    }

	    //  efficiency baby ;)
	    lines.splice.apply(lines,
		[index, howMany].concat(videoSources));

	};

	SimulcastUtils.prototype.isValidDescription = function (desc)
	{
	    return desc && desc != null
		&& desc.type && desc.type != ''
		&& desc.sdp && desc.sdp != '';
	};

	SimulcastUtils.prototype._getVideoSources = function (lines) {
	    var i, inVideo = false, sb = [];

	    this.logger.info('Getting video sources...');

	    for (i = 0; i < lines.length; i++) {
		if (inVideo && lines[i].substring(0, 'm='.length) === 'm=') {
		    // Out of video.
		    break;
		}

		if (!inVideo && lines[i].substring(0, 'm=video '.length) === 'm=video ') {
		    // In video.
		    inVideo = true;
		}

		if (inVideo && lines[i].substring(0, 'a=ssrc:'.length) === 'a=ssrc:') {
		    // In SSRC.
		    sb.push(lines[i]);
		}

		if (inVideo && lines[i].substring(0, 'a=ssrc-group:'.length) === 'a=ssrc-group:') {
		    sb.push(lines[i]);
		}
	    }

	    return sb;
	};

	SimulcastUtils.prototype.parseMedia = function (lines, mediatypes) {
	    var i, res = [], type, cur_media, idx, ssrcs, cur_ssrc, ssrc,
		ssrc_attribute, group, semantics, skip = true;

	    this.logger.info('Parsing media sources...');

	    for (i = 0; i < lines.length; i++) {
		if (lines[i].substring(0, 'm='.length) === 'm=') {

		    type = lines[i]
			.substr('m='.length, lines[i].indexOf(' ') - 'm='.length);
		    skip = mediatypes !== undefined && mediatypes.indexOf(type) === -1;

		    if (!skip) {
			cur_media = {
			    'type': type,
			    'sources': {},
			    'groups': []
			};

			res.push(cur_media);
		    }

		} else if (!skip && lines[i].substring(0, 'a=ssrc:'.length) === 'a=ssrc:') {

		    idx = lines[i].indexOf(' ');
		    ssrc = lines[i].substring('a=ssrc:'.length, idx);
		    if (cur_media.sources[ssrc] === undefined) {
			cur_ssrc = {'ssrc': ssrc};
			cur_media.sources[ssrc] = cur_ssrc;
		    }

		    ssrc_attribute = lines[i].substr(idx + 1).split(':', 2)[0];
		    cur_ssrc[ssrc_attribute] = lines[i].substr(idx + 1).split(':', 2)[1];

		    if (cur_media.base === undefined) {
			cur_media.base = cur_ssrc;
		    }

		} else if (!skip && lines[i].substring(0, 'a=ssrc-group:'.length) === 'a=ssrc-group:') {
		    idx = lines[i].indexOf(' ');
		    semantics = lines[i].substr(0, idx).substr('a=ssrc-group:'.length);
		    ssrcs = lines[i].substr(idx).trim().split(' ');
		    group = {
			'semantics': semantics,
			'ssrcs': ssrcs
		    };
		    cur_media.groups.push(group);
		} else if (!skip && (lines[i].substring(0, 'a=sendrecv'.length) === 'a=sendrecv' ||
		    lines[i].substring(0, 'a=recvonly'.length) === 'a=recvonly' ||
		    lines[i].substring(0, 'a=sendonly'.length) === 'a=sendonly' ||
		    lines[i].substring(0, 'a=inactive'.length) === 'a=inactive')) {

		    cur_media.direction = lines[i].substring('a='.length);
		}
	    }

	    return res;
	};

	/**
	 * The _indexOfArray() method returns the first a CompoundIndex at which a
	 * given element can be found in the array, or _emptyCompoundIndex if it is
	 * not present.
	 *
	 * Example:
	 *
	 * _indexOfArray('3', [ 'this is line 1', 'this is line 2', 'this is line 3' ])
	 *
	 * returns {row: 2, column: 14}
	 *
	 * @param needle
	 * @param haystack
	 * @param start
	 * @returns {}
	 * @private
	 */
	SimulcastUtils.prototype._indexOfArray = function (needle, haystack, start) {
	    var length = haystack.length, idx, i;

	    if (!start) {
		start = 0;
	    }

	    for (i = start; i < length; i++) {
		idx = haystack[i].indexOf(needle);
		if (idx !== -1) {
		    return {row: i, column: idx};
		}
	    }
	    return this._emptyCompoundIndex;
	};

	SimulcastUtils.prototype._removeSimulcastGroup = function (lines) {
	    var i;

	    for (i = lines.length - 1; i >= 0; i--) {
		if (lines[i].indexOf('a=ssrc-group:SIM') !== -1) {
		    lines.splice(i, 1);
		}
	    }
	};

	SimulcastUtils.prototype._compileVideoSources = function (videoSources) {
	    var sb = [], ssrc, addedSSRCs = [];

	    this.logger.info('Compiling video sources...');

	    // Add the groups
	    if (videoSources.groups && videoSources.groups.length !== 0) {
		videoSources.groups.forEach(function (group) {
		    if (group.ssrcs && group.ssrcs.length !== 0) {
			sb.push([['a=ssrc-group:', group.semantics].join(''), group.ssrcs.join(' ')].join(' '));

			// if (group.semantics !== 'SIM') {
			group.ssrcs.forEach(function (ssrc) {
			    addedSSRCs.push(ssrc);
			    sb.splice.apply(sb, [sb.length, 0].concat([
				["a=ssrc:", ssrc, " cname:", videoSources.sources[ssrc].cname].join(''),
				["a=ssrc:", ssrc, " msid:", videoSources.sources[ssrc].msid].join('')]));
			});
			//}
		    }
		});
	    }

	    // Then add any free sources.
	    if (videoSources.sources) {
		for (ssrc in videoSources.sources) {
		    if (addedSSRCs.indexOf(ssrc) === -1) {
			sb.splice.apply(sb, [sb.length, 0].concat([
			    ["a=ssrc:", ssrc, " cname:", videoSources.sources[ssrc].cname].join(''),
			    ["a=ssrc:", ssrc, " msid:", videoSources.sources[ssrc].msid].join('')]));
		    }
		}
	    }

	    return sb;
	};

	function SimulcastReceiver() {
	    this.simulcastUtils = new SimulcastUtils();
	    this.logger = new SimulcastLogger('SimulcastReceiver', 1);
	}

	SimulcastReceiver.prototype._remoteVideoSourceCache = '';
	SimulcastReceiver.prototype._remoteMaps = {
	    msid2Quality: {},
	    ssrc2Msid: {},
	    msid2ssrc: {},
	    receivingVideoStreams: {}
	};

	SimulcastReceiver.prototype._cacheRemoteVideoSources = function (lines) {
	    this._remoteVideoSourceCache = this.simulcastUtils._getVideoSources(lines);
	};

	SimulcastReceiver.prototype._restoreRemoteVideoSources = function (lines) {
	    this.simulcastUtils._replaceVideoSources(lines, this._remoteVideoSourceCache);
	};

	SimulcastReceiver.prototype._ensureGoogConference = function (lines) {
	    var sb;

	    this.logger.info('Ensuring x-google-conference flag...')

	    if (this.simulcastUtils._indexOfArray('a=x-google-flag:conference', lines) === this.simulcastUtils._emptyCompoundIndex) {
		// TODO(gp) do that for the audio as well as suggested by fippo.
		// Add the google conference flag
		sb = this.simulcastUtils._getVideoSources(lines);
		sb = ['a=x-google-flag:conference'].concat(sb);
		this.simulcastUtils._replaceVideoSources(lines, sb);
	    }
	};

	SimulcastReceiver.prototype._restoreSimulcastGroups = function (sb) {
	    this._restoreRemoteVideoSources(sb);
	};

	/**
	 * Restores the simulcast groups of the remote description. In
	 * transformRemoteDescription we remove those in order for the set remote
	 * description to succeed. The focus needs the signal the groups to new
	 * participants.
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastReceiver.prototype.reverseTransformRemoteDescription = function (desc) {
	    var sb;

	    if (!this.simulcastUtils.isValidDescription(desc)) {
		return desc;
	    }

	    if (config.enableSimulcast) {
		sb = desc.sdp.split('\r\n');

		this._restoreSimulcastGroups(sb);

		desc = new RTCSessionDescription({
		    type: desc.type,
		    sdp: sb.join('\r\n')
		});
	    }

	    return desc;
	};

	SimulcastUtils.prototype._ensureOrder = function (lines) {
	    var videoSources, sb;

	    videoSources = this.parseMedia(lines, ['video'])[0];
	    sb = this._compileVideoSources(videoSources);

	    this._replaceVideoSources(lines, sb);
	};

	SimulcastReceiver.prototype._updateRemoteMaps = function (lines) {
	    var remoteVideoSources = this.simulcastUtils.parseMedia(lines, ['video'])[0],
		videoSource, quality;

	    // (re) initialize the remote maps.
	    this._remoteMaps.msid2Quality = {};
	    this._remoteMaps.ssrc2Msid = {};
	    this._remoteMaps.msid2ssrc = {};

	    var self = this;
	    if (remoteVideoSources && remoteVideoSources.groups && remoteVideoSources.groups.length !== 0) {
		remoteVideoSources.groups.forEach(function (group) {
		    if (group.semantics === 'SIM' && group.ssrcs && group.ssrcs.length !== 0) {
			quality = 0;
			group.ssrcs.forEach(function (ssrc) {
			    videoSource = remoteVideoSources.sources[ssrc];
			    self._remoteMaps.msid2Quality[videoSource.msid] = quality++;
			    self._remoteMaps.ssrc2Msid[videoSource.ssrc] = videoSource.msid;
			    self._remoteMaps.msid2ssrc[videoSource.msid] = videoSource.ssrc;
			});
		    }
		});
	    }
	};

	SimulcastReceiver.prototype._setReceivingVideoStream = function (resource, ssrc) {
	    this._remoteMaps.receivingVideoStreams[resource] = ssrc;
	};

	/**
	 * Returns a stream with single video track, the one currently being
	 * received by this endpoint.
	 *
	 * @param stream the remote simulcast stream.
	 * @returns {webkitMediaStream}
	 */
	SimulcastReceiver.prototype.getReceivingVideoStream = function (stream) {
	    var tracks, i, electedTrack, msid, quality = 0, receivingTrackId;

	    var self = this;
	    if (config.enableSimulcast) {

		stream.getVideoTracks().some(function (track) {
		    return Object.keys(self._remoteMaps.receivingVideoStreams).some(function (resource) {
			var ssrc = self._remoteMaps.receivingVideoStreams[resource];
			var msid = self._remoteMaps.ssrc2Msid[ssrc];
			if (msid == [stream.id, track.id].join(' ')) {
			    electedTrack = track;
			    return true;
			}
		    });
		});

		if (!electedTrack) {
		    // we don't have an elected track, choose by initial quality.
		    tracks = stream.getVideoTracks();
		    for (i = 0; i < tracks.length; i++) {
			msid = [stream.id, tracks[i].id].join(' ');
			if (this._remoteMaps.msid2Quality[msid] === quality) {
			    electedTrack = tracks[i];
			    break;
			}
		    }

		    // TODO(gp) if the initialQuality could not be satisfied, lower
		    // the requirement and try again.
		}
	    }

	    return (electedTrack)
		? new webkitMediaStream([electedTrack])
		: stream;
	};

	SimulcastReceiver.prototype.getReceivingSSRC = function (jid) {
	    var resource = Strophe.getResourceFromJid(jid);
	    var ssrc = this._remoteMaps.receivingVideoStreams[resource];

	    // If we haven't receiving a "changed" event yet, then we must be receiving
	    // low quality (that the sender always streams).
	    if (!ssrc && connection.jingle) {
		var session;
		var i, j, k;

		var keys = Object.keys(connection.jingle.sessions);
		for (i = 0; i < keys.length; i++) {
		    var sid = keys[i];

		    if (ssrc) {
			// stream found, stop.
			break;
		    }

		    session = connection.jingle.sessions[sid];
		    if (session.remoteStreams) {
			for (j = 0; j < session.remoteStreams.length; j++) {
			    var remoteStream = session.remoteStreams[j];

			    if (ssrc) {
				// stream found, stop.
				break;
			    }
			    var tracks = remoteStream.getVideoTracks();
			    if (tracks) {
				for (k = 0; k < tracks.length; k++) {
				    var track = tracks[k];
				    var msid = [remoteStream.id, track.id].join(' ');
				    var _ssrc = this._remoteMaps.msid2ssrc[msid];
				    var _jid = ssrc2jid[_ssrc];
				    var quality = this._remoteMaps.msid2Quality[msid];
				    if (jid == _jid && quality == 0) {
					ssrc = _ssrc;
					// stream found, stop.
					break;
				    }
				}
			    }
			}
		    }
		}
	    }

	    return ssrc;
	};

	SimulcastReceiver.prototype.getReceivingVideoStreamBySSRC = function (ssrc)
	{
	    var session, electedStream;
	    var i, j, k;
	    if (connection.jingle) {
		var keys = Object.keys(connection.jingle.sessions);
		for (i = 0; i < keys.length; i++) {
		    var sid = keys[i];

		    if (electedStream) {
			// stream found, stop.
			break;
		    }

		    session = connection.jingle.sessions[sid];
		    if (session.remoteStreams) {
			for (j = 0; j < session.remoteStreams.length; j++) {
			    var remoteStream = session.remoteStreams[j];

			    if (electedStream) {
				// stream found, stop.
				break;
			    }
			    var tracks = remoteStream.getVideoTracks();
			    if (tracks) {
				for (k = 0; k < tracks.length; k++) {
				    var track = tracks[k];
				    var msid = [remoteStream.id, track.id].join(' ');
				    var tmp = this._remoteMaps.msid2ssrc[msid];
				    if (tmp == ssrc) {
					electedStream = new webkitMediaStream([track]);
					// stream found, stop.
					break;
				    }
				}
			    }
			}
		    }
		}
	    }

	    return {
		session: session,
		stream: electedStream
	    };
	};

	/**
	 * Gets the fully qualified msid (stream.id + track.id) associated to the
	 * SSRC.
	 *
	 * @param ssrc
	 * @returns {*}
	 */
	SimulcastReceiver.prototype.getRemoteVideoStreamIdBySSRC = function (ssrc) {
	    return this._remoteMaps.ssrc2Msid[ssrc];
	};

	function SimulcastSender() {
	    this.simulcastUtils = new SimulcastUtils();
	    this.logger = new SimulcastLogger('SimulcastSender', 1);
	}

	SimulcastSender.prototype.displayedLocalVideoStream = null;

	SimulcastSender.prototype._generateGuid = (function () {
	    function s4() {
		return Math.floor((1 + Math.random()) * 0x10000)
		    .toString(16)
		    .substring(1);
	    }

	    return function () {
		return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
		    s4() + '-' + s4() + s4() + s4();
	    };
	}());

	// Returns a random integer between min (included) and max (excluded)
	// Using Math.round() gives a non-uniform distribution!
	SimulcastSender.prototype._generateRandomSSRC = function () {
	    var min = 0, max = 0xffffffff;
	    return Math.floor(Math.random() * (max - min)) + min;
	};

	SimulcastSender.prototype.getLocalVideoStream = function () {
	    return (this.displayedLocalVideoStream != null)
		? this.displayedLocalVideoStream
		// in case we have no simulcast at all, i.e. we didn't perform the GUM
		: connection.jingle.localVideo;
	};

	function NativeSimulcastSender() {
	    SimulcastSender.call(this); // call the super constructor.
	}

	NativeSimulcastSender.prototype = Object.create(SimulcastSender.prototype);

	NativeSimulcastSender.prototype._localExplosionMap = {};
	NativeSimulcastSender.prototype._isUsingScreenStream = false;
	NativeSimulcastSender.prototype._localVideoSourceCache = '';

	NativeSimulcastSender.prototype.reset = function () {
	    this._localExplosionMap = {};
	    this._isUsingScreenStream = isUsingScreenStream;
	};

	NativeSimulcastSender.prototype._cacheLocalVideoSources = function (lines) {
	    this._localVideoSourceCache = this.simulcastUtils._getVideoSources(lines);
	};

	NativeSimulcastSender.prototype._restoreLocalVideoSources = function (lines) {
	    this.simulcastUtils._replaceVideoSources(lines, this._localVideoSourceCache);
	};

	NativeSimulcastSender.prototype._appendSimulcastGroup = function (lines) {
	    var videoSources, ssrcGroup, simSSRC, numOfSubs = 2, i, sb, msid;

	    this.logger.info('Appending simulcast group...');

	    // Get the primary SSRC information.
	    videoSources = this.simulcastUtils.parseMedia(lines, ['video'])[0];

	    // Start building the SIM SSRC group.
	    ssrcGroup = ['a=ssrc-group:SIM'];

	    // The video source buffer.
	    sb = [];

	    // Create the simulcast sub-streams.
	    for (i = 0; i < numOfSubs; i++) {
		// TODO(gp) prevent SSRC collision.
		simSSRC = this._generateRandomSSRC();
		ssrcGroup.push(simSSRC);

		if (videoSources.base) 
		{
			sb.splice.apply(sb, [sb.length, 0].concat(
			    [["a=ssrc:", simSSRC, " cname:", videoSources.base.cname].join(''),
				["a=ssrc:", simSSRC, " msid:", videoSources.base.msid].join('')]
			));
		}

		this.logger.info(['Generated substream ', i, ' with SSRC ', simSSRC, '.'].join(''));

	    }

	    // Add the group sim layers.
	    sb.splice(0, 0, ssrcGroup.join(' '))

	    this.simulcastUtils._replaceVideoSources(lines, sb);
	};

	// Does the actual patching.
	NativeSimulcastSender.prototype._ensureSimulcastGroup = function (lines) {

	    this.logger.info('Ensuring simulcast group...');

	    if (this.simulcastUtils._indexOfArray('a=ssrc-group:SIM', lines) === this.simulcastUtils._emptyCompoundIndex) {
		this._appendSimulcastGroup(lines);
		this._cacheLocalVideoSources(lines);
	    } else {
		// verify that the ssrcs participating in the SIM group are present
		// in the SDP (needed for presence).
		this._restoreLocalVideoSources(lines);
	    }
	};

	/**
	 * Produces a single stream with multiple tracks for local video sources.
	 *
	 * @param lines
	 * @private
	 */
	NativeSimulcastSender.prototype._explodeSimulcastSenderSources = function (lines) {
	    var sb, msid, sid, tid, videoSources, self;

	    this.logger.info('Exploding local video sources...');

	    videoSources = this.simulcastUtils.parseMedia(lines, ['video'])[0];

	    self = this;
	    if (videoSources.groups && videoSources.groups.length !== 0) {
		videoSources.groups.forEach(function (group) {
		    if (group.semantics === 'SIM') {
			group.ssrcs.forEach(function (ssrc) {

			    // Get the msid for this ssrc..
			    if (self._localExplosionMap[ssrc]) {
				// .. either from the explosion map..
				msid = self._localExplosionMap[ssrc];
			    } else {
				// .. or generate a new one (msid).
				sid = videoSources.sources[ssrc].msid
				    .substring(0, videoSources.sources[ssrc].msid.indexOf(' '));

				tid = self._generateGuid();
				msid = [sid, tid].join(' ');
				self._localExplosionMap[ssrc] = msid;
			    }

			    // Assign it to the source object.
			    videoSources.sources[ssrc].msid = msid;

			    // TODO(gp) Change the msid of associated sources.
			});
		    }
		});
	    }

	    sb = this.simulcastUtils._compileVideoSources(videoSources);

	    this.simulcastUtils._replaceVideoSources(lines, sb);
	};

	/**
	 * GUM for simulcast.
	 *
	 * @param constraints
	 * @param success
	 * @param err
	 */
	NativeSimulcastSender.prototype.getUserMedia = function (constraints, success, err) {

	    // There's nothing special to do for native simulcast, so just do a normal GUM.
	    navigator.webkitGetUserMedia(constraints, function (hqStream) {
		success(hqStream);
	    }, err);
	};

	/**
	 * Prepares the local description for public usage (i.e. to be signaled
	 * through Jingle to the focus).
	 *
	 * @param desc
	 * @returns {RTCSessionDescription}
	 */
	NativeSimulcastSender.prototype.reverseTransformLocalDescription = function (desc) {
	    var sb;

	    if (!this.simulcastUtils.isValidDescription(desc) || this._isUsingScreenStream) {
		return desc;
	    }


	    sb = desc.sdp.split('\r\n');

	    this._explodeSimulcastSenderSources(sb);

	    desc = new RTCSessionDescription({
		type: desc.type,
		sdp: sb.join('\r\n')
	    });

	    this.logger.fine(['Exploded local video sources', desc.sdp].join(' '));

	    return desc;
	};

	/**
	 * Ensures that the simulcast group is present in the answer, _if_ native
	 * simulcast is enabled,
	 *
	 * @param desc
	 * @returns {*}
	 */
	NativeSimulcastSender.prototype.transformAnswer = function (desc) {

	    if (!this.simulcastUtils.isValidDescription(desc) || this._isUsingScreenStream) {
		return desc;
	    }

	    var sb = desc.sdp.split('\r\n');

	    // Even if we have enabled native simulcasting previously
	    // (with a call to SLD with an appropriate SDP, for example),
	    // createAnswer seems to consistently generate incomplete SDP
	    // with missing SSRCS.
	    //
	    // So, subsequent calls to SLD will have missing SSRCS and presence
	    // won't have the complete list of SRCs.
	    this._ensureSimulcastGroup(sb);

	    desc = new RTCSessionDescription({
		type: desc.type,
		sdp: sb.join('\r\n')
	    });

	    this.logger.fine(['Transformed answer', desc.sdp].join(' '));

	    return desc;
	};


	/**
	 *
	 *
	 * @param desc
	 * @returns {*}
	 */
	NativeSimulcastSender.prototype.transformLocalDescription = function (desc) {
	    return desc;
	};

	/**
	 * Removes the ssrc-group:SIM from the remote description bacause Chrome
	 * either gets confused and thinks this is an FID group or, if an FID group
	 * is already present, it fails to set the remote description.
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastReceiver.prototype.transformRemoteDescription = function (desc) {

	    if (desc && desc.sdp) {
		var sb = desc.sdp.split('\r\n');

		this._updateRemoteMaps(sb);
		this._cacheRemoteVideoSources(sb);

		// NOTE(gp) this needs to be called after updateRemoteMaps because we
		// need the simulcast group in the _updateRemoteMaps() method.
		this.simulcastUtils._removeSimulcastGroup(sb);

		if (desc.sdp.indexOf('a=ssrc-group:SIM') !== -1) {
		    // We don't need the goog conference flag if we're not doing
		    // simulcast.
		    this._ensureGoogConference(sb);
		}

		desc = new RTCSessionDescription({
		    type: desc.type,
		    sdp: sb.join('\r\n')
		});

		this.logger.fine(['Transformed remote description', desc.sdp].join(' '));
	    }

	    return desc;
	};

	NativeSimulcastSender.prototype._setLocalVideoStreamEnabled = function (ssrc, enabled) {
	    // Nothing to do here, native simulcast does that auto-magically.
	};

	NativeSimulcastSender.prototype.constructor = NativeSimulcastSender;

	function SimpleSimulcastSender() {
	    SimulcastSender.call(this);
	}

	SimpleSimulcastSender.prototype = Object.create(SimulcastSender.prototype);

	SimpleSimulcastSender.prototype.localStream = null;
	SimpleSimulcastSender.prototype._localMaps = {
	    msids: [],
	    msid2ssrc: {}
	};

	/**
	 * Groups local video sources together in the ssrc-group:SIM group.
	 *
	 * @param lines
	 * @private
	 */
	SimpleSimulcastSender.prototype._groupLocalVideoSources = function (lines) {
	    var sb, videoSources, ssrcs = [], ssrc;

	    this.logger.info('Grouping local video sources...');

	    videoSources = this.simulcastUtils.parseMedia(lines, ['video'])[0];

	    for (ssrc in videoSources.sources) {
		// jitsi-meet destroys/creates streams at various places causing
		// the original local stream ids to change. The only thing that
		// remains unchanged is the trackid.
		this._localMaps.msid2ssrc[videoSources.sources[ssrc].msid.split(' ')[1]] = ssrc;
	    }

	    var self = this;
	    // TODO(gp) add only "free" sources.
	    this._localMaps.msids.forEach(function (msid) {
		ssrcs.push(self._localMaps.msid2ssrc[msid]);
	    });

	    if (!videoSources.groups) {
		videoSources.groups = [];
	    }

	    videoSources.groups.push({
		'semantics': 'SIM',
		'ssrcs': ssrcs
	    });

	    sb = this.simulcastUtils._compileVideoSources(videoSources);

	    this.simulcastUtils._replaceVideoSources(lines, sb);
	};

	/**
	 * GUM for simulcast.
	 *
	 * @param constraints
	 * @param success
	 * @param err
	 */
	SimpleSimulcastSender.prototype.getUserMedia = function (constraints, success, err) {

	    // TODO(gp) what if we request a resolution not supported by the hardware?
	    // TODO(gp) make the lq stream configurable; although this wouldn't work with native simulcast
	    var lqConstraints = {
		audio: false,
		video: {
		    mandatory: {
			maxWidth: 320,
			maxHeight: 180,
			maxFrameRate: 15
		    }
		}
	    };

	    this.logger.info('HQ constraints: ', constraints);
	    this.logger.info('LQ constraints: ', lqConstraints);


	    // NOTE(gp) if we request the lq stream first webkitGetUserMedia
	    // fails randomly. Tested with Chrome 37. As fippo suggested, the
	    // reason appears to be that Chrome only acquires the cam once and
	    // then downscales the picture (https://code.google.com/p/chromium/issues/detail?id=346616#c11)

	    var self = this;
	    navigator.webkitGetUserMedia(constraints, function (hqStream) {

		self.localStream = hqStream;

		// reset local maps.
		self._localMaps.msids = [];
		self._localMaps.msid2ssrc = {};

		// add hq trackid to local map
		self._localMaps.msids.push(hqStream.getVideoTracks()[0].id);

		navigator.webkitGetUserMedia(lqConstraints, function (lqStream) {

		    self.displayedLocalVideoStream = lqStream;

		    // NOTE(gp) The specification says Array.forEach() will visit
		    // the array elements in numeric order, and that it doesn't
		    // visit elements that don't exist.

		    // add lq trackid to local map
		    self._localMaps.msids.splice(0, 0, lqStream.getVideoTracks()[0].id);

		    self.localStream.addTrack(lqStream.getVideoTracks()[0]);
		    success(self.localStream);
		}, err);
	    }, err);
	};

	/**
	 * Prepares the local description for public usage (i.e. to be signaled
	 * through Jingle to the focus).
	 *
	 * @param desc
	 * @returns {RTCSessionDescription}
	 */
	SimpleSimulcastSender.prototype.reverseTransformLocalDescription = function (desc) {
	    var sb;

	    if (!this.simulcastUtils.isValidDescription(desc)) {
		return desc;
	    }

	    sb = desc.sdp.split('\r\n');

	    this._groupLocalVideoSources(sb);

	    desc = new RTCSessionDescription({
		type: desc.type,
		sdp: sb.join('\r\n')
	    });

	    this.logger.fine('Grouped local video sources');
	    this.logger.fine(desc.sdp);

	    return desc;
	};

	/**
	 * Ensures that the simulcast group is present in the answer, _if_ native
	 * simulcast is enabled,
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimpleSimulcastSender.prototype.transformAnswer = function (desc) {
	    return desc;
	};


	/**
	 *
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimpleSimulcastSender.prototype.transformLocalDescription = function (desc) {

	    var sb = desc.sdp.split('\r\n');

	    this.simulcastUtils._removeSimulcastGroup(sb);

	    desc = new RTCSessionDescription({
		type: desc.type,
		sdp: sb.join('\r\n')
	    });

	    this.logger.fine('Transformed local description');
	    this.logger.fine(desc.sdp);

	    return desc;
	};

	SimpleSimulcastSender.prototype._setLocalVideoStreamEnabled = function (ssrc, enabled) {
	    var trackid;

	    var self = this;
	    this.logger.log(['Requested to', enabled ? 'enable' : 'disable', ssrc].join(' '));
	    if (Object.keys(this._localMaps.msid2ssrc).some(function (tid) {
		// Search for the track id that corresponds to the ssrc
		if (self._localMaps.msid2ssrc[tid] == ssrc) {
		    trackid = tid;
		    return true;
		}
	    }) && self.localStream.getVideoTracks().some(function (track) {
		// Start/stop the track that corresponds to the track id
		if (track.id === trackid) {
		    track.enabled = enabled;
		    return true;
		}
	    })) {
		this.logger.log([trackid, enabled ? 'enabled' : 'disabled'].join(' '));
		$(document).trigger(enabled
		    ? 'simulcastlayerstarted'
		    : 'simulcastlayerstopped');
	    } else {
		this.logger.error("I don't have a local stream with SSRC " + ssrc);
	    }
	};

	SimpleSimulcastSender.prototype.constructor = SimpleSimulcastSender;

	function NoSimulcastSender() {
	    SimulcastSender.call(this);
	}

	NoSimulcastSender.prototype = Object.create(SimulcastSender.prototype);

	/**
	 * GUM for simulcast.
	 *
	 * @param constraints
	 * @param success
	 * @param err
	 */
	NoSimulcastSender.prototype.getUserMedia = function (constraints, success, err) {
	    navigator.webkitGetUserMedia(constraints, function (hqStream) {
		success(hqStream);
	    }, err);
	};

	/**
	 * Prepares the local description for public usage (i.e. to be signaled
	 * through Jingle to the focus).
	 *
	 * @param desc
	 * @returns {RTCSessionDescription}
	 */
	NoSimulcastSender.prototype.reverseTransformLocalDescription = function (desc) {
	    return desc;
	};

	/**
	 * Ensures that the simulcast group is present in the answer, _if_ native
	 * simulcast is enabled,
	 *
	 * @param desc
	 * @returns {*}
	 */
	NoSimulcastSender.prototype.transformAnswer = function (desc) {
	    return desc;
	};


	/**
	 *
	 *
	 * @param desc
	 * @returns {*}
	 */
	NoSimulcastSender.prototype.transformLocalDescription = function (desc) {
	    return desc;
	};

	NoSimulcastSender.prototype._setLocalVideoStreamEnabled = function (ssrc, enabled) {

	};

	NoSimulcastSender.prototype.constructor = NoSimulcastSender;

	/**
	 *
	 * @constructor
	 */
	function SimulcastManager() {

	    // Create the simulcast utilities.
	    this.simulcastUtils = new SimulcastUtils();

	    // Create remote simulcast.
	    this.simulcastReceiver = new SimulcastReceiver();

	    // Initialize local simulcast.

	    // TODO(gp) move into SimulcastManager.prototype.getUserMedia and take into
	    // account constraints.
	    if (!config.enableSimulcast) {
		this.simulcastSender = new NoSimulcastSender();
	    } else {

		var isChromium = window.chrome,
		    vendorName = window.navigator.vendor;
		if(isChromium !== null && isChromium !== undefined
		    /* skip opera */
		    && vendorName === "Google Inc."
		    /* skip Chromium as suggested by fippo */
		    && !window.navigator.appVersion.match(/Chromium\//) ) {
		    var ver = parseInt(window.navigator.appVersion.match(/Chrome\/(\d+)\./)[1], 10);
		    if (ver > 37) {
			this.simulcastSender = new NativeSimulcastSender();
		    } else {
			this.simulcastSender = new NoSimulcastSender();
		    }
		} else {
		    this.simulcastSender = new NoSimulcastSender();
		}

	    }
	}

	/**
	 * Restores the simulcast groups of the remote description. In
	 * transformRemoteDescription we remove those in order for the set remote
	 * description to succeed. The focus needs the signal the groups to new
	 * participants.
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastManager.prototype.reverseTransformRemoteDescription = function (desc) {
	    return this.simulcastReceiver.reverseTransformRemoteDescription(desc);
	};

	/**
	 * Removes the ssrc-group:SIM from the remote description bacause Chrome
	 * either gets confused and thinks this is an FID group or, if an FID group
	 * is already present, it fails to set the remote description.
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastManager.prototype.transformRemoteDescription = function (desc) {
	    return this.simulcastReceiver.transformRemoteDescription(desc);
	};

	/**
	 * Gets the fully qualified msid (stream.id + track.id) associated to the
	 * SSRC.
	 *
	 * @param ssrc
	 * @returns {*}
	 */
	SimulcastManager.prototype.getRemoteVideoStreamIdBySSRC = function (ssrc) {
	    return this.simulcastReceiver.getRemoteVideoStreamIdBySSRC(ssrc);
	};

	/**
	 * Returns a stream with single video track, the one currently being
	 * received by this endpoint.
	 *
	 * @param stream the remote simulcast stream.
	 * @returns {webkitMediaStream}
	 */
	SimulcastManager.prototype.getReceivingVideoStream = function (stream) {
	    return this.simulcastReceiver.getReceivingVideoStream(stream);
	};

	/**
	 *
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastManager.prototype.transformLocalDescription = function (desc) {
	    return this.simulcastSender.transformLocalDescription(desc);
	};

	/**
	 *
	 * @returns {*}
	 */
	SimulcastManager.prototype.getLocalVideoStream = function() {
	    return this.simulcastSender.getLocalVideoStream();
	};

	/**
	 * GUM for simulcast.
	 *
	 * @param constraints
	 * @param success
	 * @param err
	 */
	SimulcastManager.prototype.getUserMedia = function (constraints, success, err) {

	    this.simulcastSender.getUserMedia(constraints, success, err);
	};

	/**
	 * Prepares the local description for public usage (i.e. to be signaled
	 * through Jingle to the focus).
	 *
	 * @param desc
	 * @returns {RTCSessionDescription}
	 */
	SimulcastManager.prototype.reverseTransformLocalDescription = function (desc) {
	    return this.simulcastSender.reverseTransformLocalDescription(desc);
	};

	/**
	 * Ensures that the simulcast group is present in the answer, _if_ native
	 * simulcast is enabled,
	 *
	 * @param desc
	 * @returns {*}
	 */
	SimulcastManager.prototype.transformAnswer = function (desc) {
	    return this.simulcastSender.transformAnswer(desc);
	};

	SimulcastManager.prototype.getReceivingSSRC = function (jid) {
	    return this.simulcastReceiver.getReceivingSSRC(jid);
	};

	SimulcastManager.prototype.getReceivingVideoStreamBySSRC = function (msid) {
	    return this.simulcastReceiver.getReceivingVideoStreamBySSRC(msid);
	};

	/**
	 *
	 * @param lines
	 * @param mediatypes
	 * @returns {*}
	 */
	SimulcastManager.prototype.parseMedia = function(lines, mediatypes) {
	    var sb = lines.sdp.split('\r\n');
	    return this.simulcastUtils.parseMedia(sb, mediatypes);
	};

	SimulcastManager.prototype._setReceivingVideoStream = function(resource, ssrc) {
	    this.simulcastReceiver._setReceivingVideoStream(resource, ssrc);
	};

	SimulcastManager.prototype._setLocalVideoStreamEnabled = function(ssrc, enabled) {
	    this.simulcastSender._setLocalVideoStreamEnabled(ssrc, enabled);
	};

	SimulcastManager.prototype.resetSender = function() {
	    if (typeof this.simulcastSender.reset === 'function'){
		this.simulcastSender.reset();
	    }
	};

	/**
	 *
	 * @constructor
	 */
	function SimulcastLogger(name, lvl) {
	    this.name = name;
	    this.lvl = lvl;
	}

	SimulcastLogger.prototype.log = function (text) {
	    if (this.lvl) {
		//console.log(text);
	    }
	};

	SimulcastLogger.prototype.info = function (text) {
	    if (this.lvl > 1) {
		//console.info(text);
	    }
	};

	SimulcastLogger.prototype.fine = function (text) {
	    if (this.lvl > 2) {
		//console.log(text);
	    }
	};

	SimulcastLogger.prototype.error = function (text) {
	    console.error(text);
	};

	var simulcast = null;

	$(document).bind('simulcastlayerschanged', function (event, endpointSimulcastLayers) {
	    endpointSimulcastLayers.forEach(function (esl) {
		var ssrc = esl.simulcastLayer.primarySSRC;
		simulcast._setReceivingVideoStream(esl.endpoint, ssrc);
	    });
	});

	$(document).bind('startsimulcastlayer', function (event, simulcastLayer) {
	    var ssrc = simulcastLayer.primarySSRC;
	    simulcast._setLocalVideoStreamEnabled(ssrc, true);
	});

	$(document).bind('stopsimulcastlayer', function (event, simulcastLayer) {
	    var ssrc = simulcastLayer.primarySSRC;
	    simulcast._setLocalVideoStreamEnabled(ssrc, false);
	});


	/**
	 * SettingsMenu
	 */

	var SettingsMenu = (function(my) {

	    var email = '';
	    var displayName = '';
	    var userId;

	    if(supportsLocalStorage()) {
		if(!window.localStorage.jitsiMeetId) {
		    window.localStorage.jitsiMeetId = generateUniqueId();
		    //console.log("generated id", window.localStorage.jitsiMeetId);
		}
		userId = window.localStorage.jitsiMeetId || '';
		email = window.localStorage.email || '';
		displayName = window.localStorage.displayname || '';
	    } else {
		//console.log("local storage is not supported");
		userId = generateUniqueId();
	    }

	    my.update = function() {
		var newDisplayName = Util.escapeHtml($('#setDisplayName').get(0).value);
		if(newDisplayName) {
		    displayName = newDisplayName;
		    connection.emuc.addDisplayNameToPresence(displayName);
		    window.localStorage.displayname = displayName;
		}

		var newEmail = Util.escapeHtml($('#setEmail').get(0).value);
		connection.emuc.addEmailToPresence(newEmail);
		email = newEmail;
		window.localStorage.email = newEmail;

		connection.emuc.sendPresence();
		Avatar.setUserAvatar(connection.emuc.myroomjid, email);
	    };

	    my.isVisible = function() {
		return $('#settingsmenu').is(':visible');
	    };

	    my.getUID = function() {
		return userId;
	    };

	    my.getEmail = function() {
		return email;
	    };

	    my.getDisplayName = function() {
		return displayName;
	    };

	    my.setDisplayName = function(newDisplayName) {
		displayName = newDisplayName;
		window.localStorage.displayname = displayName;
	    };

	    function supportsLocalStorage() {
		try {
		    return 'localStorage' in window && window.localStorage !== null;
		} catch (e) {
		    //console.log("localstorage is not supported");
		    return false;
		}
	    }

	    function generateUniqueId() {
		function _p8() {
		    return (Math.random().toString(16)+"000000000").substr(2,8);
		}
		return _p8() + _p8() + _p8() + _p8();
	    }

	    $(document).bind('displaynamechanged', function(event, peerJid, newDisplayName) {
	       if(peerJid === 'localVideoContainer' ||
		   peerJid === connection.emuc.myroomjid) {
		   SettingsMenu.setDisplayName(newDisplayName);
	       }
	    });

	    return my;
	}(SettingsMenu || {}));



	/**
	 * Calculates packet lost percent using the number of lost packets and the
	 * number of all packet.
	 * @param lostPackets the number of lost packets
	 * @param totalPackets the number of all packets.
	 * @returns {number} packet loss percent
	 */

	function calculatePacketLoss(lostPackets, totalPackets) {
	    if(!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0)
		return 0;
	    return Math.round((lostPackets/totalPackets)*100);
	}

	/**
	 * Peer statistics data holder.
	 * @constructor
	 */

	function PeerStats()
	{
	    this.ssrc2Loss = {};
	    this.ssrc2AudioLevel = {};
	    this.ssrc2bitrate = {};
	    this.ssrc2resolution = {};
	}

	/**
	 * The bandwidth
	 * @type {{}}
	 */
	PeerStats.bandwidth = {};

	/**
	 * The bit rate
	 * @type {{}}
	 */
	PeerStats.bitrate = {};



	/**
	 * The packet loss rate
	 * @type {{}}
	 */
	PeerStats.packetLoss = null;

	/**
	 * Sets packets loss rate for given <tt>ssrc</tt> that blong to the peer
	 * represented by this instance.
	 * @param ssrc audio or video RTP stream SSRC.
	 * @param lossRate new packet loss rate value to be set.
	 */
	PeerStats.prototype.setSsrcLoss = function (ssrc, lossRate)
	{
	    this.ssrc2Loss[ssrc] = lossRate;
	};

	/**
	 * Sets resolution for given <tt>ssrc</tt> that belong to the peer
	 * represented by this instance.
	 * @param ssrc audio or video RTP stream SSRC.
	 * @param resolution new resolution value to be set.
	 */
	PeerStats.prototype.setSsrcResolution = function (ssrc, resolution)
	{
	    if(resolution === null && this.ssrc2resolution[ssrc])
	    {
		delete this.ssrc2resolution[ssrc];
	    }
	    else if(resolution !== null)
		this.ssrc2resolution[ssrc] = resolution;
	};

	/**
	 * Sets the bit rate for given <tt>ssrc</tt> that blong to the peer
	 * represented by this instance.
	 * @param ssrc audio or video RTP stream SSRC.
	 * @param bitrate new bitrate value to be set.
	 */
	PeerStats.prototype.setSsrcBitrate = function (ssrc, bitrate)
	{
	    if(this.ssrc2bitrate[ssrc])
	    {
		this.ssrc2bitrate[ssrc].download += bitrate.download;
		this.ssrc2bitrate[ssrc].upload += bitrate.upload;
	    }
	    else {
		this.ssrc2bitrate[ssrc] = bitrate;
	    }
	};

	/**
	 * Sets new audio level(input or output) for given <tt>ssrc</tt> that identifies
	 * the stream which belongs to the peer represented by this instance.
	 * @param ssrc RTP stream SSRC for which current audio level value will be
	 *        updated.
	 * @param audioLevel the new audio level value to be set. Value is truncated to
	 *        fit the range from 0 to 1.
	 */
	PeerStats.prototype.setSsrcAudioLevel = function (ssrc, audioLevel)
	{
	    // Range limit 0 - 1
	    this.ssrc2AudioLevel[ssrc] = Math.min(Math.max(audioLevel, 0), 1);
	};

	/**
	 * Array with the transport information.
	 * @type {Array}
	 */
	PeerStats.transport = [];


	/**
	 * <tt>StatsCollector</tt> registers for stats updates of given
	 * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular
	 * stats are extracted and put in {@link PeerStats} objects. Once the processing
	 * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>
	 * instance as an event source.
	 *
	 * @param peerconnection webRTC peer connection object.
	 * @param interval stats refresh interval given in ms.
	 * @param {function(StatsCollector)} audioLevelsUpdateCallback the callback
	 * called on stats update.
	 * @constructor
	 */
	function StatsCollector(peerconnection, audioLevelsInterval,
				audioLevelsUpdateCallback, statsInterval,
				statsUpdateCallback)
	{
	    this.peerconnection = peerconnection;
	    this.baselineAudioLevelsReport = null;
	    this.currentAudioLevelsReport = null;
	    this.currentStatsReport = null;
	    this.baselineStatsReport = null;
	    this.audioLevelsIntervalId = null;

	    /**
	     * Gather PeerConnection stats once every this many milliseconds.
	     */
	    this.GATHER_INTERVAL = 10000;

	    /**
	     * Log stats via the focus once every this many milliseconds.
	     */
	    this.LOG_INTERVAL = 60000;

	    /**
	     * Gather stats and store them in this.statsToBeLogged.
	     */
	    this.gatherStatsIntervalId = null;

	    /**
	     * Send the stats already saved in this.statsToBeLogged to be logged via
	     * the focus.
	     */
	    this.logStatsIntervalId = null;

	    /**
	     * Stores the statistics which will be send to the focus to be logged.
	     */
	    this.statsToBeLogged =
	    {
	      timestamps: [],
	      stats: {}
	    };

	    // Updates stats interval
	    this.audioLevelsIntervalMilis = audioLevelsInterval;

	    this.statsIntervalId = null;
	    this.statsIntervalMilis = statsInterval;
	    // Map of jids to PeerStats
	    this.jid2stats = {};

	    this.audioLevelsUpdateCallback = audioLevelsUpdateCallback;
	    this.statsUpdateCallback = statsUpdateCallback;
	}

	/**
	 * Stops stats updates.
	 */
	StatsCollector.prototype.stop = function ()
	{
	    if (this.audioLevelsIntervalId)
	    {
		clearInterval(this.audioLevelsIntervalId);
		this.audioLevelsIntervalId = null;
		clearInterval(this.statsIntervalId);
		this.statsIntervalId = null;
		clearInterval(this.logStatsIntervalId);
		this.logStatsIntervalId = null;
		clearInterval(this.gatherStatsIntervalId);
		this.gatherStatsIntervalId = null;
	    }
	};

	/**
	 * Callback passed to <tt>getStats</tt> method.
	 * @param error an error that occurred on <tt>getStats</tt> call.
	 */
	StatsCollector.prototype.errorCallback = function (error)
	{
	    console.error("Get stats error", error);
	    this.stop();
	};

	/**
	 * Starts stats updates.
	 */
	StatsCollector.prototype.start = function ()
	{
	    var self = this;
	    this.audioLevelsIntervalId = setInterval(
		function ()
		{
		    // Interval updates
		    self.peerconnection.getStats(
			function (report)
			{
			    var results = null;
			    if(!report || !report.result || typeof report.result != 'function')
			    {
				results = report;
			    }
			    else
			    {
				results = report.result();
			    }
			    //console.error("Got interval report", results);
			    self.currentAudioLevelsReport = results;
			    self.processAudioLevelReport();
			    self.baselineAudioLevelsReport =
				self.currentAudioLevelsReport;
			},
			self.errorCallback
		    );
		},
		self.audioLevelsIntervalMilis
	    );

	    this.statsIntervalId = setInterval(
		function () {
		    // Interval updates
		    self.peerconnection.getStats(
			function (report)
			{
			    var results = null;
			    if(!report || !report.result || typeof report.result != 'function')
			    {
				//firefox
				results = report;
			    }
			    else
			    {
				//chrome
				results = report.result();
			    }
			    //console.error("Got interval report", results);
			    self.currentStatsReport = results;
			    try
			    {
				self.processStatsReport();
			    }
			    catch(e)
			    {
				console.error("Unsupported key:" + e);
			    }

			    self.baselineStatsReport = self.currentStatsReport;
			},
			self.errorCallback
		    );
		},
		self.statsIntervalMilis
	    );

	    if (config.logStats) {
		this.gatherStatsIntervalId = setInterval(
		    function () {
			self.peerconnection.getStats(
			    function (report) {
				self.addStatsToBeLogged(report.result());
			    },
			    function () {
			    }
			);
		    },
		    this.GATHER_INTERVAL
		);

		this.logStatsIntervalId = setInterval(
		    function() { self.logStats(); },
		    this.LOG_INTERVAL);
	    }
	};

	/**
	 * Converts the stats to the format used for logging, and saves the data in
	 * this.statsToBeLogged.
	 * @param reports Reports as given by webkitRTCPerConnection.getStats.
	 */
	StatsCollector.prototype.addStatsToBeLogged = function (reports) {
	    var self = this;
	    var num_records = this.statsToBeLogged.timestamps.length;
	    this.statsToBeLogged.timestamps.push(new Date().getTime());
	    reports.map(function (report) {
		var stat = self.statsToBeLogged.stats[report.id];
		if (!stat) {
		    stat = self.statsToBeLogged.stats[report.id] = {};
		}
		stat.type = report.type;
		report.names().map(function (name) {
		    var values = stat[name];
		    if (!values) {
			values = stat[name] = [];
		    }
		    while (values.length < num_records) {
			values.push(null);
		    }
		    values.push(report.stat(name));
		});
	    });
	};

	StatsCollector.prototype.logStats = function () {
	    if (!focusJid) {
		return;
	    }

	    var deflate = true;

	    var content = JSON.stringify(this.statsToBeLogged);
	    if (deflate) {
		content = String.fromCharCode.apply(null, Pako.deflateRaw(content));
	    }
	    content = Base64.encode(content);

	    // XEP-0337-ish
	    var message = $msg({to: focusJid, type: 'normal'});
	    message.c('log', { xmlns: 'urn:xmpp:eventlog',
			       id: 'PeerConnectionStats'});
	    message.c('message').t(content).up();
	    if (deflate) {
		message.c('tag', {name: "deflated", value: "true"}).up();
	    }
	    message.up();

	    connection.send(message);

	    // Reset the stats
	    this.statsToBeLogged.stats = {};
	    this.statsToBeLogged.timestamps = [];
	};
	var keyMap = {
	    "firefox": {
		"ssrc": "ssrc",
		"packetsReceived": "packetsReceived",
		"packetsLost": "packetsLost",
		"packetsSent": "packetsSent",
		"bytesReceived": "bytesReceived",
		"bytesSent": "bytesSent"
	    },
	    "chrome": {
		"receiveBandwidth": "googAvailableReceiveBandwidth",
		"sendBandwidth": "googAvailableSendBandwidth",
		"remoteAddress": "googRemoteAddress",
		"transportType": "googTransportType",
		"localAddress": "googLocalAddress",
		"activeConnection": "googActiveConnection",
		"ssrc": "ssrc",
		"packetsReceived": "packetsReceived",
		"packetsSent": "packetsSent",
		"packetsLost": "packetsLost",
		"bytesReceived": "bytesReceived",
		"bytesSent": "bytesSent",
		"googFrameHeightReceived": "googFrameHeightReceived",
		"googFrameWidthReceived": "googFrameWidthReceived",
		"googFrameHeightSent": "googFrameHeightSent",
		"googFrameWidthSent": "googFrameWidthSent",
		"audioInputLevel": "audioInputLevel",
		"audioOutputLevel": "audioOutputLevel"
	    }
	};

	/**
	 * Stats processing logic.
	 */
	StatsCollector.prototype.processStatsReport = function () {
	    if (!this.baselineStatsReport) {
		return;
	    }

	    for (var idx in this.currentStatsReport) {
		var now = this.currentStatsReport[idx];
		try {
		    if (getStatValue(now, 'receiveBandwidth') ||
			getStatValue(now, 'sendBandwidth')) {
			PeerStats.bandwidth = {
			    "download": Math.round(
				    (getStatValue(now, 'receiveBandwidth')) / 1000),
			    "upload": Math.round(
				    (getStatValue(now, 'sendBandwidth')) / 1000)
			};
		    }
		}
		catch(e){/*not supported*/}

		if(now.type == 'googCandidatePair')
		{
		    var ip, type, localIP, active;
		    try {
			ip = getStatValue(now, 'remoteAddress');
			type = getStatValue(now, "transportType");
			localIP = getStatValue(now, "localAddress");
			active = getStatValue(now, "activeConnection");
		    }
		    catch(e){/*not supported*/}
		    if(!ip || !type || !localIP || active != "true")
			continue;
		    var addressSaved = false;
		    for(var i = 0; i < PeerStats.transport.length; i++)
		    {
			if(PeerStats.transport[i].ip == ip &&
			    PeerStats.transport[i].type == type &&
			    PeerStats.transport[i].localip == localIP)
			{
			    addressSaved = true;
			}
		    }
		    if(addressSaved)
			continue;
		    PeerStats.transport.push({localip: localIP, ip: ip, type: type});
		    continue;
		}

		if(now.type == "candidatepair")
		{
		    if(now.state == "succeeded")
			continue;

		    var local = this.currentStatsReport[now.localCandidateId];
		    var remote = this.currentStatsReport[now.remoteCandidateId];
		    PeerStats.transport.push({localip: local.ipAddress + ":" + local.portNumber,
			ip: remote.ipAddress + ":" + remote.portNumber, type: local.transport});

		}

		if (now.type != 'ssrc' && now.type != "outboundrtp" &&
		    now.type != "inboundrtp") {
		    continue;
		}

		var before = this.baselineStatsReport[idx];
		if (!before) {
		    //console.warn(getStatValue(now, 'ssrc') + ' not enough data');
		    continue;
		}

		var ssrc = getStatValue(now, 'ssrc');
		if(!ssrc)
		    continue;
		var jid = ssrc2jid[ssrc];
		if (!jid) {
		    //console.warn("No jid for ssrc: " + ssrc);
		    continue;
		}

		var jidStats = this.jid2stats[jid];
		if (!jidStats) {
		    jidStats = new PeerStats();
		    this.jid2stats[jid] = jidStats;
		}


		var isDownloadStream = true;
		var key = 'packetsReceived';
		if (!getStatValue(now, key))
		{
		    isDownloadStream = false;
		    key = 'packetsSent';
		    if (!getStatValue(now, key))
		    {
			console.warn("No packetsReceived nor packetSent stat found");
			continue;
		    }
		}
		var packetsNow = getStatValue(now, key);
		if(!packetsNow || packetsNow < 0)
		    packetsNow = 0;

		var packetsBefore = getStatValue(before, key);
		if(!packetsBefore || packetsBefore < 0)
		    packetsBefore = 0;
		var packetRate = packetsNow - packetsBefore;
		if(!packetRate || packetRate < 0)
		    packetRate = 0;
		var currentLoss = getStatValue(now, 'packetsLost');
		if(!currentLoss || currentLoss < 0)
		    currentLoss = 0;
		var previousLoss = getStatValue(before, 'packetsLost');
		if(!previousLoss || previousLoss < 0)
		    previousLoss = 0;
		var lossRate = currentLoss - previousLoss;
		if(!lossRate || lossRate < 0)
		    lossRate = 0;
		var packetsTotal = (packetRate + lossRate);

		jidStats.setSsrcLoss(ssrc,
		    {"packetsTotal": packetsTotal,
			"packetsLost": lossRate,
			"isDownloadStream": isDownloadStream});


		var bytesReceived = 0, bytesSent = 0;
		if(getStatValue(now, "bytesReceived"))
		{
		    bytesReceived = getStatValue(now, "bytesReceived") -
			getStatValue(before, "bytesReceived");
		}

		if(getStatValue(now, "bytesSent"))
		{
		    bytesSent = getStatValue(now, "bytesSent") -
			getStatValue(before, "bytesSent");
		}

		var time = Math.round((now.timestamp - before.timestamp) / 1000);
		if(bytesReceived <= 0 || time <= 0)
		{
		    bytesReceived = 0;
		}
		else
		{
		    bytesReceived = Math.round(((bytesReceived * 8) / time) / 1000);
		}

		if(bytesSent <= 0 || time <= 0)
		{
		    bytesSent = 0;
		}
		else
		{
		    bytesSent = Math.round(((bytesSent * 8) / time) / 1000);
		}

		jidStats.setSsrcBitrate(ssrc, {
		    "download": bytesReceived,
		    "upload": bytesSent});

		var resolution = {height: null, width: null};
		try {
		    if (getStatValue(now, "googFrameHeightReceived") &&
			getStatValue(now, "googFrameWidthReceived")) {
			resolution.height = getStatValue(now, "googFrameHeightReceived");
			resolution.width = getStatValue(now, "googFrameWidthReceived");
		    }
		    else if (getStatValue(now, "googFrameHeightSent") &&
			getStatValue(now, "googFrameWidthSent")) {
			resolution.height = getStatValue(now, "googFrameHeightSent");
			resolution.width = getStatValue(now, "googFrameWidthSent");
		    }
		}
		catch(e){/*not supported*/}

		if(resolution.height && resolution.width)
		{
		    jidStats.setSsrcResolution(ssrc, resolution);
		}
		else
		{
		    jidStats.setSsrcResolution(ssrc, null);
		}


	    }

	    var self = this;
	    // Jid stats
	    var totalPackets = {download: 0, upload: 0};
	    var lostPackets = {download: 0, upload: 0};
	    var bitrateDownload = 0;
	    var bitrateUpload = 0;
	    var resolutions = {};
	    Object.keys(this.jid2stats).forEach(
		function (jid)
		{
		    Object.keys(self.jid2stats[jid].ssrc2Loss).forEach(
			function (ssrc)
			{
			    var type = "upload";
			    if(self.jid2stats[jid].ssrc2Loss[ssrc].isDownloadStream)
				type = "download";
			    totalPackets[type] +=
				self.jid2stats[jid].ssrc2Loss[ssrc].packetsTotal;
			    lostPackets[type] +=
				self.jid2stats[jid].ssrc2Loss[ssrc].packetsLost;
			}
		    );
		    Object.keys(self.jid2stats[jid].ssrc2bitrate).forEach(
			function (ssrc) {
			    bitrateDownload +=
				self.jid2stats[jid].ssrc2bitrate[ssrc].download;
			    bitrateUpload +=
				self.jid2stats[jid].ssrc2bitrate[ssrc].upload;

			    delete self.jid2stats[jid].ssrc2bitrate[ssrc];
			}
		    );
		    resolutions[jid] = self.jid2stats[jid].ssrc2resolution;
		}
	    );

	    PeerStats.bitrate = {"upload": bitrateUpload, "download": bitrateDownload};

	    PeerStats.packetLoss = {
		total:
		    calculatePacketLoss(lostPackets.download + lostPackets.upload,
			totalPackets.download + totalPackets.upload),
		download:
		    calculatePacketLoss(lostPackets.download, totalPackets.download),
		upload:
		    calculatePacketLoss(lostPackets.upload, totalPackets.upload)
	    };
	    this.statsUpdateCallback(
		{
		    "bitrate": PeerStats.bitrate,
		    "packetLoss": PeerStats.packetLoss,
		    "bandwidth": PeerStats.bandwidth,
		    "resolution": resolutions,
		    "transport": PeerStats.transport
		});
	    PeerStats.transport = [];

	};

	/**
	 * Stats processing logic.
	 */
	StatsCollector.prototype.processAudioLevelReport = function ()
	{
	    if (!this.baselineAudioLevelsReport)
	    {
		return;
	    }

	    for (var idx in this.currentAudioLevelsReport)
	    {
		var now = this.currentAudioLevelsReport[idx];

		if (now.type != 'ssrc')
		{
		    continue;
		}

		var before = this.baselineAudioLevelsReport[idx];
		if (!before)
		{
		   //console.warn(getStatValue(now, 'ssrc') + ' not enough data');
		    continue;
		}

		var ssrc = getStatValue(now, 'ssrc');
		var jid = ssrc2jid[ssrc];
		if (!jid)
		{
		    //console.warn("No jid for ssrc: " + ssrc);
		    continue;
		}

		var jidStats = this.jid2stats[jid];
		if (!jidStats)
		{
		    jidStats = new PeerStats();
		    this.jid2stats[jid] = jidStats;
		}

		// Audio level
		var audioLevel = null;

		try {
		    audioLevel = getStatValue(now, 'audioInputLevel');
		    if (!audioLevel)
			audioLevel = getStatValue(now, 'audioOutputLevel');
		}
		catch(e) {/*not supported*/
		    console.warn("Audio Levels are not available in the statistics.");
		    clearInterval(this.audioLevelsIntervalId);
		    return;
		}

		if (audioLevel)
		{
		    // TODO: can't find specs about what this value really is,
		    // but it seems to vary between 0 and around 32k.
		    audioLevel = audioLevel / 32767;
		    jidStats.setSsrcAudioLevel(ssrc, audioLevel);
		    if(jid != connection.emuc.myroomjid)
			this.audioLevelsUpdateCallback(jid, audioLevel);
		}

	    }


	};

	function getStatValue(item, name) {
	    if(!keyMap[RTC.browser][name])
		throw "The property isn't supported!";
	    var key = keyMap[RTC.browser][name];
	    return RTC.browser == "chrome"? item.stat(key) : item[key];
	}


	/**
	 * Strophe.ofmuc plugin
	 */


	Strophe.addConnectionPlugin('ofmuc', {
	    connection: null,
	    roomJid: null,
	    members: {},

	    init: function (conn) {
		this.connection = conn;
		this.connection.addHandler(this.onMessage.bind(this), null, 'message'); 
		this.connection.addHandler(this.onPresence.bind(this), null, 'presence');        
		this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable'); 
        	this.connection.addHandler(this.onRayo.bind(this), 'urn:xmpp:rayo:1');  
        	
		console.log("strophe plugin ofmuc enabled");          	
	    },   

	    onPresence: function (pres) {
		//console.log('ofmuc onPresence', $(pres))  

		var from = pres.getAttribute('from');
		var type = pres.getAttribute('type');

		if (type != null) {
		   return true;
		}

		if (!this.roomJid || Strophe.getBareJidFromJid(from) != this.roomJid) return true;        

		var member = {};
		member.show = $(pres).find('>show').text();
		member.status = $(pres).find('>status').text();
		var tmp = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item');
		member.affiliation = tmp.attr('affiliation');
		member.role = tmp.attr('role');

		if (from == this.roomJid) {

		} else if (this.members[from] === undefined) {
		    this.members[from] = member;

		    if (config.userAvatar && config.userAvatar != "null")
		    {
			this.avatarShare(config.userAvatar);
		    }           
		}
		return true;
	    },

	    onPresenceUnavailable: function (pres) {
		//console.log('onPresenceUnavailable', $(pres));

		var from = pres.getAttribute('from');
		if (!this.roomJid) return true;  

		delete this.members[from];
		return true;
	    },   

	    onMessage: function (msg) {
		//console.log('onMessage', $(msg))
		var that = this;
		var from = msg.getAttribute('from');
	
		if (!that.roomJid) that.roomJid = Strophe.getBareJidFromJid(from);        


		$(msg).find('avatarshare').each(function() 
		{
			that.members[from].avatar = $(this).text();	
			Avatar.setUserAvatar(from);
		});

		return true;
	    },

	    onRayo: function (packet) 
	    {
		//console.log("onRayo", packet);
		var from = $(packet).attr('from');

		var jid = null;
		var videoSpanId = null;
		var node = null;

		$(packet).find('header').each(function() 
		{		
			var name = $(this).attr('name');
			var value = $(this).attr('value');

			//console.log("onRayo header", name, value);

			if (name == "caller_id")
			{	
				if (value.indexOf("@") > -1)
				{
					var callerId = value.substring(4); // remove sip:

					node = Strophe.getNodeFromJid(callerId);
					jid = callerId + "/" + node;
				} else {
					node = value;
					jid = node + "@" + config.hosts.domain + "/" + node
				}
				videoSpanId = 'participant_' + node;
			}

		});	

		$(packet).find('answered').each(function() 
		{	
			var callId = Strophe.getNodeFromJid(from); 

			//console.log("onRayo callid", callId, jid);

			if (jid)
			{
				VideoLayout.ensurePeerContainerExists(jid);	
				var container = document.getElementById(videoSpanId);

				if (container) 
				{	
					$(container).show();			
					$(container).attr("title", Strophe.getBareJidFromJid(jid));
				}
			}
		});

		$(packet).find('hangup').each(function() 
		{	
			var callId = Strophe.getNodeFromJid(from); 

			//console.log("onRayo callid", callId, jid);	

			if (jid) 
			{
				var container = document.getElementById(videoSpanId);

				if (container) 
				{
				    VideoLayout.removeConnectionIndicator(jid);
				    // hide here, wait for video to close before removing
				    $(container).hide();
				    VideoLayout.resizeThumbnails();
				}
			}		
		});	

		return true;
	    },
	    
	    avatarShare: function(avatar) {
		//console.log("ofmuc.avatarShare", avatar)
		var msg = $msg({to: this.roomJid, type: 'groupchat'});
		msg.c('avatarshare', {xmlns: 'http://igniterealtime.org/protocol/avatarshare'}).t(avatar).up();
		this.connection.send(msg);        
	    }       
	});


	/**
	 * ofmeet-screenshare
	 */

	/**
	 * Indicates that desktop stream is currently in use(for toggle purpose).
	 * @type {boolean}
	 */
	var isUsingScreenStream = false;
	/**
	 * Indicates that switch stream operation is in progress and prevent from triggering new events.
	 * @type {boolean}
	 */
	var switchInProgress = false;

	/**
	 * Method used to get screen sharing stream.
	 *
	 * @type {function (stream_callback, failure_callback}
	 */
	var obtainDesktopStream = null;

	/**
	 * Flag used to cache desktop sharing enabled state. Do not use directly as it can be <tt>null</tt>.
	 * @type {null|boolean}
	 */
	var _desktopSharingEnabled = null;

	/**
	 * Method obtains desktop stream from WebRTC 'screen' source.
	 * Flag 'chrome://flags/#enable-usermedia-screen-capture' must be enabled.
	 */
	function obtainWebRTCScreen(streamCallback, failCallback) {
	    getUserMediaWithConstraints(
		['screen'],
		streamCallback,
		failCallback
	    );
	}

	/**
	 * Constructs inline install URL for Chrome desktop streaming extension.
	 * The 'chromeExtensionId' must be defined in config.js.
	 * @returns {string}
	 */
	function getWebStoreInstallUrl()
	{
	    return "https://chrome.google.com/webstore/detail/" + config.chromeExtensionId;
	}

	/**
	 * Checks whether extension update is required.
	 * @param minVersion minimal required version
	 * @param extVersion current extension version
	 * @returns {boolean}
	 */
	function isUpdateRequired(minVersion, extVersion)
	{
	    try
	    {
		var s1 = minVersion.split('.');
		var s2 = extVersion.split('.');

		var len = Math.max(s1.length, s2.length);
		for (var i = 0; i < len; i++)
		{
		    var n1 = 0,
			n2 = 0;

		    if (i < s1.length)
			n1 = parseInt(s1[i]);
		    if (i < s2.length)
			n2 = parseInt(s2[i]);

		    if (isNaN(n1) || isNaN(n2))
		    {
			return true;
		    }
		    else if (n1 !== n2)
		    {
			return n1 > n2;
		    }
		}

		// will happen if boths version has identical numbers in
		// their components (even if one of them is longer, has more components)
		return false;
	    }
	    catch (e)
	    {
		console.error("Failed to parse extension version", e);
		messageHandler.showError('Error',
		    'Error when trying to detect desktopsharing extension.');
		return true;
	    }
	}


	function checkExtInstalled(isInstalledCallback) 
	{
		isInstalledCallback($('#ofmeet-extension-installed').length > 0);  
	}

	function doGetStreamFromExtension(streamCallback, failCallback) 
	{
	    var pending = window.setTimeout(

		function () {
			failCallback("Extension failed to get the stream");
		}, 1000);

	    window.postMessage({ type: 'ofmeetGetScreen', id: pending }, '*');

	    window.addEventListener('message', function (event) 
	    {
		if(event.origin != window.location.origin)
			return;

		if(event.data.type == 'ofmeetGotScreen') 
		{
			if (event.data.sourceId === '') 
			{
				// user canceled
				failCallback("Extension failed to get the stream");

			} else {

				if (event.data.sourceId) 
				{
					getUserMediaWithConstraints(['desktop'],

						function (stream) {
							streamCallback(stream);
						},
						failCallback,
						null, null, null,
						event.data.sourceId);
				} else {
					failCallback("Extension failed to get the stream from ofmeet extension");
				}
			}

		} else if (event.data.type == 'ofmeetGetScreenPending') {
			window.clearTimeout(event.data.id);
		}		
	    });    
	}
	/**
	 * Asks Chrome extension to call chooseDesktopMedia and gets chrome 'desktop' stream for returned stream token.
	 */
	function obtainScreenFromExtension(streamCallback, failCallback) {
	    checkExtInstalled(
		function (isInstalled) {
		    if (isInstalled) {
			doGetStreamFromExtension(streamCallback, failCallback);
		    } else {
			window.open(getWebStoreInstallUrl(), "_blank");
			messageHandler.showError('Error', 'Install manually and reload webpage');
		    }
		}
	    );
	}

	/**
	 * @returns {boolean} <tt>true</tt> if desktop sharing feature is available and enabled.
	 */
	function isDesktopSharingEnabled() {
	    if (_desktopSharingEnabled === null) {
		if (obtainDesktopStream === obtainScreenFromExtension) {
		    // Parse chrome version
		    var userAgent = navigator.userAgent.toLowerCase();
		    // We can assume that user agent is chrome, because it's enforced when 'ext' streaming method is set
		    var ver = parseInt(userAgent.match(/chrome\/(\d+)\./)[1], 10);
		    //console.log("Chrome version" + userAgent, ver);
		    _desktopSharingEnabled = ver >= 34;
		} else {
		    _desktopSharingEnabled = obtainDesktopStream === obtainWebRTCScreen;
		}
	    }
	    return _desktopSharingEnabled;
	}

	/**
	 * Call this method to toggle desktop sharing feature.
	 * @param method pass "ext" to use chrome extension for desktop capture(chrome extension required),
	 *        pass "webrtc" to use WebRTC "screen" desktop source('chrome://flags/#enable-usermedia-screen-capture'
	 *        must be enabled), pass any other string or nothing in order to disable this feature completely.
	 */
	function setDesktopSharing(method) {
	    // Check if we are running chrome
	    if (!navigator.webkitGetUserMedia) {
		obtainDesktopStream = null;
		//console.info("Desktop sharing disabled");
	    } else if (method == "ext") {
		obtainDesktopStream = obtainScreenFromExtension;
		//console.info("Using Chrome extension for desktop sharing");
	    } else if (method == "webrtc") {
		obtainDesktopStream = obtainWebRTCScreen;
		//console.info("Using Chrome WebRTC for desktop sharing");
	    }

	    // Reset enabled cache
	    _desktopSharingEnabled = null;
	}

	/**
	 * Initializes <link rel=chrome-webstore-item /> with extension id set in config.js to support inline installs.
	 * Host site must be selected as main website of published extension.
	 */
	function initInlineInstalls()
	{
	    $("link[rel=chrome-webstore-item]").attr("href", getWebStoreInstallUrl());
	}

	function getSwitchStreamFailed(error) {
	    console.error("Failed to obtain the stream to switch to", error);
	    switchInProgress = false;
	}

	function streamSwitchDone() {
	    //window.setTimeout(
	    //    function () {
	    switchInProgress = false;
	    //Toolbar.changeDesktopSharingButtonState(isUsingScreenStream);
	    //    }, 100
	    //);
	}

	function newStreamCreated(stream) {

	    var oldStream = connection.jingle.localVideo;

	    connection.jingle.localVideo = stream;

	    VideoLayout.changeLocalVideo(stream, !isUsingScreenStream);

	    var conferenceHandler = getConferenceHandler();
	    if (conferenceHandler) {
		// FIXME: will block switchInProgress on true value in case of exception
		conferenceHandler.switchStreams(stream, oldStream, streamSwitchDone);
	    } else {
		// We are done immediately
		console.error("No conference handler");
		messageHandler.showError('Error',
		    'Unable to switch video stream.');
		streamSwitchDone();
	    }
	}


	/* a simple MUC connection plugin
	 * can only handle a single MUC room
	 */

	Strophe.addConnectionPlugin('emuc', {
	    connection: null,
	    roomjid: null,
	    myroomjid: null,
	    members: {},
	    list_members: [], // so we can elect a new focus
	    presMap: {},
	    preziMap: {},
	    joined: false,
	    isOwner: false,
	    role: null,
	    
	    init: function (conn) {
		this.connection = conn;
		console.log("strophe plugin emuc enabled");  		
	    },
	    initPresenceMap: function (myroomjid) {
		this.presMap['to'] = myroomjid;
        	this.presMap['xns'] = 'http://igniterealtime.org/protocol/ofmeet';
	    },
	    doJoin: function (jid, password) {
		this.myroomjid = jid;

		//console.info("Joined MUC as " + this.myroomjid);

		this.initPresenceMap(this.myroomjid);

		if (!this.roomjid) {
		    this.roomjid = Strophe.getBareJidFromJid(jid);
		    // add handlers (just once)
		    this.connection.addHandler(this.onPresence.bind(this), null, 'presence', null, null, this.roomjid, {matchBare: true});
		    this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable', null, this.roomjid, {matchBare: true});
		    this.connection.addHandler(this.onPresenceError.bind(this), null, 'presence', 'error', null, this.roomjid, {matchBare: true});
		    this.connection.addHandler(this.onMessage.bind(this), null, 'message', null, null, this.roomjid, {matchBare: true});
		}
		if (password !== undefined) {
		    this.presMap['password'] = password;
		}
		this.sendPresence();
	    },
	    doLeave: function() {
		//console.log("do leave", this.myroomjid);
		var pres = $pres({to: this.myroomjid, type: 'unavailable' });
		this.presMap.length = 0;
		this.connection.send(pres);
	    },
	    onPresence: function (pres) {
		var from = pres.getAttribute('from');
		var type = pres.getAttribute('type');
		if (type != null) {
		    return true;
		}

		// Parse etherpad tag.
		var etherpad = $(pres).find('etherpad');
		if (etherpad.length) {
		    $(document).trigger('etherpadadded.muc', [from, etherpad.text()]);
		}

		// Parse prezi tag.
		var presentation = $(pres).find('prezi');
		if (presentation.length)
		{
		    var url = presentation.attr('url');
		    var current = presentation.find('>current').text();

		    //console.log('presentation info received from', from, url);

		    if (this.preziMap[from] == null) {
			this.preziMap[from] = url;

			$(document).trigger('presentationadded.muc', [from, url, current]);
		    }
		    else {
			$(document).trigger('gotoslide.muc', [from, url, current]);
		    }
		}
		else if (this.preziMap[from] != null) {
		    var url = this.preziMap[from];
		    delete this.preziMap[from];
		    $(document).trigger('presentationremoved.muc', [from, url]);
		}

		// Parse audio info tag.
		var audioMuted = $(pres).find('audiomuted');
		if (audioMuted.length) {
		    $(document).trigger('audiomuted.muc', [from, audioMuted.text()]);
		}

		// Parse video info tag.
		var videoMuted = $(pres).find('videomuted');
		if (videoMuted.length) {
		    $(document).trigger('videomuted.muc', [from, videoMuted.text()]);
		}

		var stats = $(pres).find('stats');
		if(stats.length)
		{
		    var statsObj = {};
		    Strophe.forEachChild(stats[0], "stat", function (el) {
			statsObj[el.getAttribute("name")] = el.getAttribute("value");
		    });
		    ConnectionQuality.updateRemoteStats(from, statsObj);
		}

		// Parse status.
		if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length) {
		    // http://xmpp.org/extensions/xep-0045.html#createroom-instant
		    this.isOwner = true;
		    var create = $iq({type: 'set', to: this.roomjid})
			    .c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'})
			    .c('x', {xmlns: 'jabber:x:data', type: 'submit'});
		    this.connection.sendIQ(create); // fire away
		}

		// Parse roles.
		var member = {};
		member.show = $(pres).find('>show').text();
		member.status = $(pres).find('>status').text();
		var tmp = $(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item');
		member.affiliation = tmp.attr('affiliation');
		member.role = tmp.attr('role');

		// Focus recognition
		member.jid = tmp.attr('jid');
		member.isFocus = false;
		if (member.jid
		    && member.jid.indexOf(Moderator.getFocusUserJid() + "/") == 0) {
		    member.isFocus = true;
		}

		var nicktag = $(pres).find('nick[xmlns="http://jabber.org/protocol/nick"]');
		member.displayName = (nicktag.length > 0 ? nicktag.text() : null);

		if (from == this.myroomjid) {
		    if (member.affiliation == 'owner') this.isOwner = true;
		    if (this.role !== member.role) {
			this.role = member.role;
			$(document).trigger('local.role.changed.muc', [from, member, pres]);
		    }
		    if (!this.joined) {
			this.joined = true;
			$(document).trigger('joined.muc', [from, member]);
			this.list_members.push(from);
		    }
		} else if (this.members[from] === undefined) {
		    // new participant
		    this.members[from] = member;
		    this.list_members.push(from);
		    $(document).trigger('entered.muc', [from, member, pres]);
		} else {
		    // Presence update for existing participant
		    // Watch role change:
		    if (this.members[from].role != member.role) {
			this.members[from].role = member.role
			$(document).trigger('role.changed.muc', [from, member, pres]);
		    }
		}
		// Always trigger presence to update bindings
		//console.log('presence change from', from, pres);
		$(document).trigger('presence.muc', [from, member, pres]);

		// Trigger status message update
		if (member.status) {
		    $(document).trigger('presence.status.muc', [from, member, pres]);
		}

		return true;
	    },
	    onPresenceUnavailable: function (pres) {
		var from = pres.getAttribute('from');
		// Status code 110 indicates that this notification is "self-presence".
		if (!$(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length) {
		    delete this.members[from];
		    this.list_members.splice(this.list_members.indexOf(from), 1);
		    $(document).trigger('left.muc', [from]);
		}
		// If the status code is 110 this means we're leaving and we would like
		// to remove everyone else from our view, so we trigger the event.
		else if (this.list_members.length > 1) {
		    for (var i = 0; i < this.list_members.length; i++) {
			var member = this.list_members[i];
			delete this.members[i];
			this.list_members.splice(i, 1);
			$(document).trigger('left.muc', member);
		    }
		}
		if ($(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length) {
		    $(document).trigger('kicked.muc', [from]);
		}
		return true;
	    },
	    onPresenceError: function (pres) {
		var from = pres.getAttribute('from');
		if ($(pres).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
		    $(document).trigger('passwordrequired.muc', [from]);
		} else if ($(pres).find(
			'>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
		    var toDomain = Strophe.getDomainFromJid(pres.getAttribute('to'));
		    if(toDomain === config.hosts.anonymousdomain) {
			// we are connected with anonymous domain and only non anonymous users can create rooms
			// we must authorize the user
			$(document).trigger('passwordrequired.main');
		    } else {
			console.warn('onPresError ', pres);
			messageHandler.openReportDialog(null,
			    'Oops! Something went wrong and we couldn`t connect to the conference.',
			pres);
		    }
		} else {
		    console.warn('onPresError ', pres);
		    messageHandler.openReportDialog(null,
			'Oops! Something went wrong and we couldn`t connect to the conference.',
			pres);
		}
		return true;
	    },
	    sendMessage: function (body, nickname) {
		var msg = $msg({to: this.roomjid, type: 'groupchat'});
		msg.c('body', body).up();
		
		if (nickname) {
		    msg.c('nick', {xmlns: 'http://jabber.org/protocol/nick'}).t(nickname).up().up();
		}
		this.connection.send(msg);
	    },
	    setSubject: function (subject){
		var msg = $msg({to: this.roomjid, type: 'groupchat'});
		msg.c('subject', subject);
		this.connection.send(msg);
		//console.log("topic changed to " + subject);
	    },
	    onMessage: function (msg) {
		// FIXME: this is a hack. but jingle on muc makes nickchanges hard
		var from = msg.getAttribute('from');
		var nick = $(msg).find('>nick[xmlns="http://jabber.org/protocol/nick"]').text() || Strophe.getResourceFromJid(from);

		var txt = $(msg).find('>body').text();
		var type = msg.getAttribute("type");

		if(type == "error")
		{
		    //Chat.chatAddError($(msg).find('>text').text(), txt);
		    return true;
		}

		var subject = $(msg).find('>subject');

		if(subject.length)
		{
		    var subjectText = subject.text();
		    
		    if(subjectText || subjectText == "") 
		    {
			$(document).trigger('message.subject.muc', [from, nick, subjectText]);
		    }
		}

		if (txt) 
		{
			$(document).trigger('message.body.muc', [from, nick, txt]);
		}
		return true;
	    },
	    lockRoom: function (key) {
		//http://xmpp.org/extensions/xep-0045.html#roomconfig
		var ob = this;
		this.connection.sendIQ($iq({to: this.roomjid, type: 'get'}).c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'}),
		    function (res) {
			if ($(res).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
			    var formsubmit = $iq({to: ob.roomjid, type: 'set'}).c('query', {xmlns: 'http://jabber.org/protocol/muc#owner'});
			    formsubmit.c('x', {xmlns: 'jabber:x:data', type: 'submit'});
			    formsubmit.c('field', {'var': 'FORM_TYPE'}).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();
			    formsubmit.c('field', {'var': 'muc#roomconfig_roomsecret'}).c('value').t(key).up().up();
			    // Fixes a bug in prosody 0.9.+ https://code.google.com/p/lxmppd/issues/detail?id=373
			    formsubmit.c('field', {'var': 'muc#roomconfig_whois'}).c('value').t('anyone').up().up();
			    // FIXME: is muc#roomconfig_passwordprotectedroom required?
			    this.connection.sendIQ(formsubmit,
				function (res) {
				    // password is required
				    if (sharedKey)
				    {
					//console.log('set room password');
					//Toolbar.lockLockButton();
				    }
				    else
				    {
					//console.log('removed room password');
					//Toolbar.unlockLockButton();
				    }
				},
				function (err) {
				    console.warn('setting password failed', err);
				    messageHandler.showError('Lock failed',
					'Failed to lock conference.',
					err);
				    setSharedKey('');
				}
			    );
			} else {
			    console.warn('room passwords not supported');
			    messageHandler.showError('Warning',
				'Room passwords are currently not supported.');
			    setSharedKey('');

			}
		    },
		    function (err) {
			console.warn('setting password failed', err);
			messageHandler.showError('Lock failed',
			    'Failed to lock conference.',
			    err);
			setSharedKey('');
		    }
		);
	    },
	    kick: function (jid) {
		var kickIQ = $iq({to: this.roomjid, type: 'set'})
		    .c('query', {xmlns: 'http://jabber.org/protocol/muc#admin'})
		    .c('item', {nick: Strophe.getResourceFromJid(jid), role: 'none'})
		    .c('reason').t('You have been kicked.').up().up().up();

		this.connection.sendIQ(
			kickIQ,
			function (result) {
			    //console.log('Kick participant with jid: ', jid, result);
			},
			function (error) {
			    //console.log('Kick participant error: ', error);
			});
	    },
	    sendPresence: function () {
	    
		if (!this.presMap['to']) {
			// Too early to send presence - not initialized
			return;
		}	    
		var pres = $pres({to: this.presMap['to'] });
		pres.c('x', {xmlns: this.presMap['xns']});

		if (this.presMap['password']) {
		    pres.c('password').t(this.presMap['password']).up();
		}

		//pres.up();	// BAO made child elements of <x>

		// Send XEP-0115 'c' stanza that contains our capabilities info
		if (connection.caps) {
		    connection.caps.node = config.clientNode;
		    pres.c('c', connection.caps.generateCapsAttrs()).up();
		}

		pres.c('user-agent', {xmlns: 'http://jitsi.org/jitmeet/user-agent'})
		    .t(navigator.userAgent).up();

		if(this.presMap['bridgeIsDown']) {
		    pres.c('bridgeIsDown').up();
		}

		if(this.presMap['email']) {
		    pres.c('email').t(this.presMap['email']).up();
		}

		if(this.presMap['userId']) {
		    pres.c('userId').t(this.presMap['userId']).up();
		}

		if (this.presMap['displayName']) {
		    // XEP-0172
		    pres.c('nick', {xmlns: 'http://jabber.org/protocol/nick'})
			.t(this.presMap['displayName']).up();
		}

		if (this.presMap['audions']) {
		    pres.c('audiomuted', {xmlns: this.presMap['audions']})
			.t(this.presMap['audiomuted']).up();
		}

		if (this.presMap['videons']) {
		    pres.c('videomuted', {xmlns: this.presMap['videons']})
			.t(this.presMap['videomuted']).up();
		}

		if(this.presMap['statsns'])
		{
		    var stats = pres.c('stats', {xmlns: this.presMap['statsns']});
		    for(var stat in this.presMap["stats"])
			if(this.presMap["stats"][stat] != null)
			    stats.c("stat",{name: stat, value: this.presMap["stats"][stat]}).up();
		    pres.up();
		}

		if (this.presMap['prezins']) {
		    pres.c('prezi',
			    {xmlns: this.presMap['prezins'],
			    'url': this.presMap['preziurl']})
			    .c('current').t(this.presMap['prezicurrent']).up().up();
		}

		if (this.presMap['etherpadns']) {
		    pres.c('etherpad', {xmlns: this.presMap['etherpadns']})
			.t(this.presMap['etherpadname']).up();
		}

		if (this.presMap['medians'])
		{
		    pres.c('media', {xmlns: this.presMap['medians']});
		    var sourceNumber = 0;
		    Object.keys(this.presMap).forEach(function (key) {
			if (key.indexOf('source') >= 0) {
			     sourceNumber++;
			}
		    });
		    if (sourceNumber > 0)
			for (var i = 1; i <= sourceNumber/3; i ++) {
			    pres.c('source',
				   {type: this.presMap['source' + i + '_type'],
				   ssrc: this.presMap['source' + i + '_ssrc'],
				   direction: this.presMap['source'+ i + '_direction']
							    || 'sendrecv' }
			    ).up();
			}
		}

		pres.up();
		connection.send(pres);
	    },
	    addDisplayNameToPresence: function (displayName) {
		this.presMap['displayName'] = displayName;
	    },
	    addMediaToPresence: function (sourceNumber, mtype, ssrcs, direction) {
		if (!this.presMap['medians'])
		    this.presMap['medians'] = 'http://estos.de/ns/mjs';

		this.presMap['source' + sourceNumber + '_type'] = mtype;
		this.presMap['source' + sourceNumber + '_ssrc'] = ssrcs;
		this.presMap['source' + sourceNumber + '_direction'] = direction;
	    },
	    clearPresenceMedia: function () {
		var self = this;
		Object.keys(this.presMap).forEach( function(key) {
		    if(key.indexOf('source') != -1) {
			delete self.presMap[key];
		    }
		});
	    },
	    addCurrentSlideToPresence: function (currentSlide) {
		this.presMap['prezicurrent'] = currentSlide;
	    },
	    addAudioInfoToPresence: function(isMuted) {
		this.presMap['audions'] = 'http://jitsi.org/jitmeet/audio';
		this.presMap['audiomuted'] = isMuted.toString();
	    },
	    addVideoInfoToPresence: function(isMuted) {
		this.presMap['videons'] = 'http://jitsi.org/jitmeet/video';
		this.presMap['videomuted'] = isMuted.toString();
	    },
	    addConnectionInfoToPresence: function(stats) {
		this.presMap['statsns'] = 'http://jitsi.org/jitmeet/stats';
		this.presMap['stats'] = stats;
	    },
	    findJidFromResource: function(resourceJid) {
		if(resourceJid && 
		    resourceJid === Strophe.getResourceFromJid(connection.emuc.myroomjid)) {
		    return connection.emuc.myroomjid;
		}
		var peerJid = null;
		Object.keys(this.members).some(function (jid) {
		    peerJid = jid;
		    return Strophe.getResourceFromJid(jid) === resourceJid;
		});
		return peerJid;
	    },
	    addBridgeIsDownToPresence: function() {
		this.presMap['bridgeIsDown'] = true;
	    },
	    addEmailToPresence: function(email) {
		this.presMap['email'] = email;
	    },
	    addUserIdToPresence: function(userId) {
		this.presMap['userId'] = userId;
	    },
	    isModerator: function() {
		return this.role === 'moderator';
	    }
	});


	/**
	 * Moderator
	 *
	 * Contains logic responsible for enabling/disabling functionality available
	 * only to moderator users.
	 */
	var Moderator = (function (my) {

	    var focusUserJid;
	    var getNextTimeout = Util.createExpBackoffTimer(1000);
	    var getNextErrorTimeout = Util.createExpBackoffTimer(1000);

	    my.isModerator = function () {
		return connection.emuc.isModerator();
	    };

	    my.onModeratorStatusChanged = function (isModerator) {

		$(document).trigger('local.role.moderator', [isModerator]);
	    };

	    my.init = function () {
		$(document).bind(
		    'role.changed.muc',
		    function (event, jid, info, pres) {
			//console.info("Role changed for " + jid + ", new role: " + info.role);
			VideoLayout.showModeratorIndicator();
		    }
		);

		$(document).bind(
		    'local.role.changed.muc',
		    function (event, jid, info, pres) {
			//console.info("My role changed, new role: " + info.role);
			VideoLayout.showModeratorIndicator();
			Moderator.onModeratorStatusChanged(Moderator.isModerator());
		    }
		);

		$(document).bind(
		    'left.muc',
		    function (event, jid) {
			//console.info("Someone left is it focus ? " + jid);
			var resource = Strophe.getResourceFromJid(jid);
			if (resource === 'focus' && !sessionTerminated) {
			    //console.info("Focus has left the room - leaving conference");
			    //hangUp();
			    // We'd rather reload to have everything re-initialized
			    // FIXME: show some message before reload
			    location.reload();
			}
		    }
		);
	    };

	    my.setFocusUserJid = function (focusJid) {
		if (!focusUserJid) {
		    focusUserJid = focusJid;
		    //console.info("Focus jid set to: " + focusUserJid);
		}
	    };

	    my.getFocusUserJid = function () {
		return focusUserJid;
	    };

	    my.getFocusComponent = function () {
		// Get focus component address
		var focusComponent = config.hosts.focus;
		// If not specified use default: 'focus.domain'
		if (!focusComponent) {
		    focusComponent = 'focus.' + config.hosts.domain;
		}
		return focusComponent;
	    };

	    my.createConferenceIq = function () {
		// Generate create conference IQ
		var elem = $iq({to: Moderator.getFocusComponent(), type: 'set'});
		elem.c('conference', {
		    xmlns: 'http://jitsi.org/protocol/focus',
		    room: roomName
		});
		if (config.hosts.bridge !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'bridge', value: config.hosts.bridge})
			.up();
		}
		if (config.channelLastN !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'channelLastN', value: config.channelLastN})
			.up();
		}
		if (config.adaptiveLastN !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'adaptiveLastN', value: config.adaptiveLastN})
			.up();
		}
		if (config.adaptiveSimulcast !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'adaptiveSimulcast', value: config.adaptiveSimulcast})
			.up();
		}
		if (config.openSctp !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'openSctp', value: config.openSctp})
			.up();
		}
		if (config.enableFirefoxSupport !== undefined)
		{
		    elem.c(
			'property',
			{ name: 'enableFirefoxHacks', value: config.enableFirefoxSupport})
			.up();
		}
		elem.up();
		return elem;
	    };

	    // FIXME: we need to show the fact that we're waiting for the focus
	    // to the user(or that focus is not available)
	    my.allocateConferenceFocus = function (roomName, callback) {
		// Try to use focus user JID from the config
		Moderator.setFocusUserJid(config.focusUserJid);
		// Send create conference IQ
		var iq = Moderator.createConferenceIq();
		connection.sendIQ(
		    iq,
		    function (result) {
			if ('true' === $(result).find('conference').attr('ready')) {
			    // Reset both timers
			    getNextTimeout(true);
			    getNextErrorTimeout(true);
			    Moderator.setFocusUserJid(
				$(result).find('conference').attr('focusjid'));
			    callback();
			} else {
			    var waitMs = getNextTimeout();
			    //console.info("Waiting for the focus... " + waitMs);
			    // Reset error timeout
			    getNextErrorTimeout(true);
			    window.setTimeout(
				function () {
				    Moderator.allocateConferenceFocus(
					roomName, callback);
				}, waitMs);
			}
		    },
		    function (error) {
			var waitMs = getNextErrorTimeout();
			console.error("Focus error, retry after " + waitMs, error);
			// Show message
			messageHandler.notify(
			    'Conference focus', 'disconnected',
			    Moderator.getFocusComponent() +
			    ' not available - retry in ' + (waitMs / 1000) + ' sec');
			// Reset response timeout
			getNextTimeout(true);
			window.setTimeout(
			    function () {
				Moderator.allocateConferenceFocus(roomName, callback);
			    }, waitMs);
		    }
		);
	    };

	    return my;
	}(Moderator || {}));

	/**
	 * Strophe.moderate connection plugin.
	 */

	Strophe.addConnectionPlugin('moderate', {
	    connection: null,
	    init: function (conn) {
		this.connection = conn;

		this.connection.addHandler(this.onMute.bind(this),
					   'http://jitsi.org/jitmeet/audio',
					   'iq',
					   'set',
					   null,
					   null);
					   
		console.log("strophe plugin moderate enabled");  					   
	    },
	    setMute: function (jid, mute) {
		//console.info("set mute", mute);
		var iqToFocus = $iq({to: focusJid, type: 'set'})
		    .c('mute', {
			xmlns: 'http://jitsi.org/jitmeet/audio',
			jid: jid
		    })
		    .t(mute.toString())
		    .up();

		this.connection.sendIQ(
		    iqToFocus,
		    function (result) {
			//console.log('set mute', result);
		    },
		    function (error) {
			//console.log('set mute error', error);
			// FIXME: this causes an exception
			//messageHandler.openReportDialog(null, 'Failed to mute ' +
			  //  $("#participant_" + jid).find(".displayname").text() ||
			    //"participant" + '.', error);
		    });
	    },
	    onMute: function (iq) {
		var from = iq.getAttribute('from');
		if (from !== focusJid) {
		    console.warn("Ignored mute from non focus peer");
		    return false;
		}
		var mute = $(iq).find('mute');
		if (mute.length) {
		    var doMuteAudio = mute.text() === "true";
		    setAudioMuted(doMuteAudio);
		    forceMuted = doMuteAudio;
		}
		return true;
	    },
	    eject: function (jid) {
		// We're not the focus, so can't terminate
		//connection.jingle.terminateRemoteByJid(jid, 'kick');
		connection.emuc.kick(jid);
	    }
	});

	/**
	 * Strophe.inum plugin.
	 */

	 Strophe.addConnectionPlugin('inum', 
	 {
	       connection: null,
	       audioChannels: {},
	       localStream: null,
	       dtmfSender: null,
	       relayHost: null,
	       relayLocalPort:  null,
    	       relayRemotePort: null,

		init: function (conn) 
		{
			this.connection = conn; 
        		this.connection.addHandler(this.onRayo.bind(this), 'urn:xmpp:rayo:1');  
        	
			console.log("strophe plugin inum enabled");                              
		},
		
		onRayo: function (packet) 
		{
			//console.log("inum - onRayo", packet);
			var from = $(packet).attr('from');
			var callId = Strophe.getNodeFromJid(from); 
			var callerId = null;
			var calledId = null;			

			$(packet).find('header').each(function() 
			{		
				var name = $(this).attr('name');
				var value = $(this).attr('value');

				//console.log("inum - onRayo header", name, value);

				if (name == "caller_id") callerId = value;
				if (name == "called_id") calledId = value;				
			});	

			$(packet).find('answered').each(function() 
			{	
				$(document).trigger('inum.answered', [callId, callerId, calledId]);
			});

			$(packet).find('hangup').each(function() 
			{	
				$(document).trigger('inum.hangup', [callId, callerId, calledId]);			
			});	

			return true;
		},

		sendTones: function (tones)
		{
			if (this.dtmfSender) 
			{
				this.dtmfSender.insertDTMF(tones);
			}		
		},
		
		hangup: function (callId)
		{
		    var self = this;
		    
		    var req = $iq(
			{
			    type: 'set',
			    to: callId
			}
		    );
		    req.c('hangup',
			{
			    xmlns: "urn:xmpp:rayo:1"
			});

		    this.connection.sendIQ(req,
		    
			function (result)
			{
			    console.info('Hangup result ', result);
			    $(document).trigger('inum.cleared', [callId]);
			},
			function (error)
			{
			    console.info('Hangup error ', error);
			}
		    );
		},
        
		dial: function (confId, to)
		{
		    var self = this;
		    
		    this.relayHost = null;
		    this.relayLocalPort = null;
		    this.relayRemotePort = null;  
    
		    var req = $iq(
			{
			    type: 'set',
			    to: config.hosts.call_control
			}
		    );
		    req.c('dial',
			{
			    xmlns: "urn:xmpp:rayo:1",
			    to: to,
			    from: connection.jid
			});
		    req.c('header',
			{
			    name: 'JvbRoomId',
			    value: confId
			});

		    this.connection.sendIQ(req,
		    
			function (result)
			{
			    console.info('Dial result ', result);

			    var resource = $(result).find('ref').attr('uri');
			    self.call_resource = resource.substr('xmpp:'.length);
			    
			    console.info("Received call resource: " + self.call_resource);
			    
			    $(document).trigger('inum.dialled', [confId, to, self.call_resource]);			    
			},
			
			function (error)
			{
			    console.error('inum plugin dial error ', error);
			}
		    );
		},
		
		createWebrtcDevice: function()
		{
			console.log("createWebrtcDevice request");

			var that = this;                   

			navigator.webkitGetUserMedia({audio: true, video: false}, function(stream) 
			{
				that.localStream = stream;

				var iq = $iq({to: config.hosts.bridge, type: 'get'});

				iq.c('conference', {xmlns: 'http://jitsi.org/protocol/colibri'});                       
				iq.c('content', {name: 'audio'}).c('channel', {initiator: 'true', expire: '15', "rtp-level-relay-type": "mixer", endpoint: that.connection.jid});

				that.connection.sendIQ(iq, function (offer) 
				{
					that.handleOffer(offer);

				}, function (err) {

					console.error('createWebrtcDevice', err);                                                
				});                                                           

			}, function(error) {

				console.error("No audio device found");
			});
		},

		handleOffer: function(offer) 
		{
			//var offerSDP = new SDP('v=0\r\no=- 5151055458874951233 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\nm=audio 1 RTP/SAVPF 111 0 126\r\nc=IN IP4 0.0.0.0\r\na=rtcp:1 IN IP4 0.0.0.0\r\na=mid:audio\r\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\r\na=sendrecv\r\na=rtpmap:111 opus/48000/2\r\na=fmtp:111 minptime=10\r\na=rtpmap:0 PCMU/8000\r\na=rtpmap:126 telephone-event/8000\r\na=maxptime:60\r\nm=video 1 RTP/SAVPF 100 116 117\r\nc=IN IP4 0.0.0.0\r\na=rtcp:1 IN IP4 0.0.0.0\r\na=mid:video\r\na=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\na=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\na=sendrecv\r\na=rtpmap:100 VP8/90000\r\na=rtcp-fb:100 ccm fir\r\na=rtcp-fb:100 nack\r\na=rtcp-fb:100 goog-remb\r\na=rtpmap:116 red/90000\r\na=rtpmap:117 ulpfec/90000\r\n');                   
			
			var offerSDP = new SDP('v=0\r\no=- 5151055458874951233 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\nm=audio 1 RTP/SAVPF 0 126\r\nc=IN IP4 0.0.0.0\r\na=rtcp:1 IN IP4 0.0.0.0\r\na=mid:audio\r\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\r\na=sendrecv\r\na=rtpmap:0 PCMU/8000\r\na=rtpmap:126 telephone-event/8000\r\na=maxptime:60\r\nm=video 1 RTP/SAVPF 100 116 117\r\nc=IN IP4 0.0.0.0\r\na=rtcp:1 IN IP4 0.0.0.0\r\na=mid:video\r\na=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\na=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\r\na=sendrecv\r\na=rtpmap:100 VP8/90000\r\na=rtcp-fb:100 ccm fir\r\na=rtcp-fb:100 nack\r\na=rtcp-fb:100 goog-remb\r\na=rtpmap:116 red/90000\r\na=rtpmap:117 ulpfec/90000\r\n');                   			
			offerSDP.media[1] = null;

			console.log("handleOffer", offer, this.localStream, offerSDP);

			var that = this;
			var confId = null;
			var audioId = null;

			$(offer).find('conference').each(function() 
			{
				confId = $(this).attr('id');
				that.audioChannels[confId] = {confId: confId};

				$(this).find('content').each(function() 
				{                              
					var name = $(this).attr('name');                                

					if (name == "audio")
					{
						$(this).find('channel').each(function() 
						{
							audioId = $(this).attr('id');
							that.audioChannels[confId].audioId = audioId;

							//console.log("createWebrtcDevice audio track " + that.audioChannels[confId].audioId);                                                                                                                                                                                    

							$(this).find('source').each(function() 
							{              
								var ssrc = $(this).attr('ssrc');

								offerSDP.media[0] += 'a=ssrc:' + ssrc + ' ' + 'cname:mixed' + '\r\n';
								offerSDP.media[0] += 'a=ssrc:' + ssrc + ' ' + 'label:mixedlabela0' + '\r\n';
								offerSDP.media[0] += 'a=ssrc:' + ssrc + ' ' + 'msid:mixedmslabela0 mixedlabela0' + '\r\n';
								offerSDP.media[0] += 'a=ssrc:' + ssrc + ' ' + 'mslabel:mixedmslabela0' + '\r\n';                                                                                                            
							});

							$(this).find('transport').each(function() 
							{              
								var pwd = $(this).attr('pwd');
								var ufrag = $(this).attr('ufrag');

								if (ufrag) offerSDP.media[0] += 'a=ice-ufrag:' + ufrag + '\r\n';
								if (pwd) offerSDP.media[0] += 'a=ice-pwd:' + pwd + '\r\n';

								$(this).find('candidate').each(function() 
								{              
									offerSDP.media[0] += SDPUtil.candidateFromJingle(this);                                                                                          
								});

								$(this).find('fingerprint').each(function() 
								{              
									var hash = $(this).attr('hash');
									var setup  = $(this).attr('setup');
									var fingerprint = $(this).text();

									if (hash && fingerprint) offerSDP.media[0] += 'a=fingerprint:' + hash + ' ' + fingerprint + '\r\n';
									if (setup) offerSDP.media[0] += 'a=setup:' + setup + '\r\n';    

								});                                                                                                           
							});                                                                                           
						});
					}
				});                                                           
			});

			offerSDP.raw = offerSDP.session + offerSDP.media.join('');
			that.audioChannels[confId].sdp = offerSDP.raw;

			//console.log("createWebrtcDevice offerSDP.raw", offerSDP.raw);         

			that.audioChannels[confId].peerconnection = new webkitRTCPeerConnection(config.iceServers, {'optional': [{'DtlsSrtpKeyAgreement': 'true'}]}); 

			that.audioChannels[confId].peerconnection.onicecandidate = function(event)
			{
				//console.log('createWebrtcDevice candidate', event.candidate);

				if (!event.candidate) 
				{
					that.sendAnswer(confId);
				}

			}

			that.audioChannels[confId].peerconnection.onaddstream = function(data)
			{
				console.log("createWebrtcDevice onstream", data);

				if (that.audioChannels[confId].peerconnection.signalingState == "have-remote-offer")
				{
					that.audio = new Audio();
					that.audio.autoplay = true;
					that.audio.volume = 1;
					that.audio.src = URL.createObjectURL(data.stream);                                                       
				}

				that.audioChannels[confId].peerconnection.createAnswer(function(desc)
				{
					that.audioChannels[confId].peerconnection.setLocalDescription(desc);
					$(document).trigger('inum.connected', [confId, audioId]);					
				}); 
				
				that.dtmfSender = that.audioChannels[confId].peerconnection.createDTMFSender(that.localStream.getTracks()[0]);
				
				that.dtmfSender.ontonechange = function(tone)
				{
					console.log("sent dtmf tone", tone);
					$(document).trigger('inum.tone', [confId, audioId, tone]);
				};
				
			}                                         

			that.audioChannels[confId].peerconnection.addStream(that.localStream);			
			that.audioChannels[confId].peerconnection.setRemoteDescription(new RTCSessionDescription({type: "offer", sdp : offerSDP.raw}));						

			$(document).trigger('inum.offered', [confId, audioId]);
		},

		sendAnswer: function (confId) 
		{
			var audioId = this.audioChannels[confId].audioId;

			//console.log("sendAnswer", confId, audioId, this.audioChannels[confId].peerconnection.localDescription.sdp);

			var that = this;

			var remoteSDP = new SDP(this.audioChannels[confId].peerconnection.localDescription.sdp);   

			//console.log("remoteSDP ", remoteSDP);

			var iq = $iq({to: config.hosts.bridge, type: 'set'});

			iq.c('conference', {xmlns: 'http://jitsi.org/protocol/colibri', id: confId});                  
			iq.c('content', {name: 'audio'}).c('channel', {id: audioId});

			var tmp = SDPUtil.find_lines(remoteSDP.media[0], 'a=ssrc:');

			iq.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });

			tmp.forEach(function (line) 
			{
				var idx = line.indexOf(' ');
				var linessrc = line.substr(0, idx).substr(7);
				iq.attrs({ssrc: linessrc});

				var kv = line.substr(idx + 1);
				iq.c('parameter');

				if (kv.indexOf(':') == -1) {
				    iq.attrs({ name: kv });
				} else {
				    iq.attrs({ name: kv.split(':', 2)[0] });
				    iq.attrs({ value: kv.split(':', 2)[1] });
				}
				iq.up();
			});

			iq.up(); // end of source

			var rtpmap = SDPUtil.find_lines(remoteSDP.media[0], 'a=rtpmap:');

			rtpmap.forEach(function (val) 
			{
				var rtpmap = SDPUtil.parse_rtpmap(val);
				iq.c('payload-type', rtpmap);
				iq.up();
			});


			iq.c('transport', {xmlns: 'urn:xmpp:jingle:transports:ice-udp:1'});                                                                                              
			var fingerprints = SDPUtil.find_lines(remoteSDP.media[0], 'a=fingerprint:', remoteSDP.session);

			fingerprints.forEach(function (line) 
			{
			    var tmp = SDPUtil.parse_fingerprint(line);
			    tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';
			    iq.c('fingerprint').t(tmp.fingerprint);
			    delete tmp.fingerprint;
			    var line = SDPUtil.find_line(remoteSDP.media[0], 'a=setup:', remoteSDP.session);

			    if (line) {
					tmp.setup = line.substr(8);
			    }
			    iq.attrs(tmp);
			    iq.up();
			});

			var candidates = SDPUtil.find_lines(remoteSDP.media[0], 'a=candidate:', remoteSDP.session);

			candidates.forEach(function (line) {
				var tmp = SDPUtil.candidateToJingle(line);
				iq.c('candidate', tmp).up();
			});
			
			console.log('handleOffer: send jingle nodes request'); 
			
			var iqRelay = $iq({type: "get", to: "relay." + that.connection.domain}).c('channel', {xmlns: "http://jabber.org/protocol/jinglenodes#channel", protocol: 'udp'});

			that.connection.sendIQ(iqRelay, function(response)
			{
				if ($(response).attr('type') == "result")
				{
					console.log('handleOffer: jingle nodes response', response);  

					$(response).find('channel').each(function() 
					{
						that.relayHost = $(this).attr('host');
						that.relayLocalPort = $(this).attr('localport');
						that.relayRemotePort = $(this).attr('remoteport');
						
						var candidate = new RTCIceCandidate({sdpMLineIndex: "0", candidate: "a=candidate:3707591233 1 udp 2113937151 " + that.relayHost + " " + that.relayLocalPort + " typ host generation 0 "});
						that.audioChannels[confId].peerconnection.addIceCandidate(candidate);
						
						var relayCandidate = "a=candidate:3707591233 1 udp 2113937151 " + that.relayHost + " " + that.relayRemotePort + " typ host generation 0 ";
						iq.c('candidate', SDPUtil.candidateToJingle(relayCandidate)).up();						
					});
				}
				
				
				
			}, function(err) {
				console.error("sendAnswer: jingle nodes request error", err);
			});			
       			
			
			tmp = SDPUtil.iceparams(remoteSDP.media[0], remoteSDP.session);

			if (tmp) {
				iq.attrs(tmp);

			}

			that.connection.sendIQ(iq,

				function (res) {
				    console.log('sendAnswer ok', res);  
				    $(document).trigger('inum.delivered', [confId, audioId]);				    
				},

				function (err) {
				    console.error('sendAnswer error', err);                                 
				}
			);                                                                                                                                                                                                                             

		},

		expireWebrtcDevice: function(confId, audioId)
		{
			console.log("expireWebrtcDevice " + confId);

			if (this.audioChannels[confId] && this.audioChannels[confId].peerconnection)
			{
				this.audioChannels[confId].peerconnection.close();
			}
			
			if (this.localStream)
			{				
				this.localStream.getAudioTracks().forEach(function (track) {
				    track.stop();
				});
				this.localStream.getVideoTracks().forEach(function (track) {
				    track.stop();
				});				
			}

			var iq = $iq({to: config.hosts.bridge, type: 'get'});

			iq.c('conference', {xmlns: 'http://jitsi.org/protocol/colibri', id: confId});                  
			iq.c('content', {name: 'audio'}).c('channel', {id: audioId, expire: '0'});

			var that = this;

			this.connection.sendIQ(iq, 

				function (res) {
				    console.log('expireWebrtcDevice response', res);
				    $(document).trigger('inum.expired', [confId, audioId]);					    
				},

				function (err) {
				    console.error('expireWebrtcDevice error', err);                                                 
				}
			); 
			
			this.audioChannels[confId].peerconnection = null;
			this.localStream = null;
			this.dtmfSender = null
		}                              
	});  
 
 	/**
 	 * Strophe.vCard plugin.
	 */
	 
	 Strophe.addConnectionPlugin('vCard', 
	 {
		_connection: null,

		init: function (conn) {
		    this._connection = conn;
		    Strophe.addNamespace('vCard', 'vcard-temp');
		},
		
		get: function(jid, callback, errorback) 
		{
		    var iq = $iq({type: 'get', to: Strophe.getBareJidFromJid(jid)}).c('vCard', {xmlns: 'vcard-temp'});

		    this._connection.sendIQ(iq, function(response)
		    {
			    var response = $(response);
			    var username = Strophe.getNodeFromJid(jid);
			    var name = response.find('vCard FN').text();
			    var photo = response.find('vCard PHOTO');

			    var avatar = "";

			    if (photo.find('BINVAL').text() != "" && photo.find('TYPE').text() != "")
				avatar = 'data:' + photo.find('TYPE').text() + ';base64,' + photo.find('BINVAL').text();

			    var family = response.find('vCard N FAMILY') ? response.find('vCard N FAMILY').text() : "";
					var middle = response.find('vCard N MIDDLE') ? response.find('vCard N MIDDLE').text() : "";
			    var given = response.find('vCard N GIVEN') ? response.find('vCard N GIVEN').text() : "";

			    var nickname = response.find('vCard NICKNAME') ? response.find('vCard NICKNAME').text() : "";

			    var email = response.find('vCard EMAIL USERID') ? response.find('vCard EMAIL USERID').text() : "";
			    var url = response.find('vCard URL') ? response.find('vCard URL').text() : "";

			    var workPhone = "";
			    var homePhone = "";
			    var workMobile = "";
			    var homeMobile = "";

			    response.find('vCard TEL').each(function()
			    {
				if ($(this).find('VOICE').size() > 0 && $(this).find('WORK').size() > 0)
					workPhone = $(this).find('NUMBER').text();

				if ($(this).find('VOICE').size() > 0 && $(this).find('HOME').size() > 0)
					homePhone = $(this).find('NUMBER').text();

				if ($(this).find('CELL').size() > 0 && $(this).find('WORK').size() > 0)
					workMobile = $(this).find('NUMBER').text();

				if ($(this).find('CELL').size() > 0 && $(this).find('HOME').size() > 0)
					homeMobile = $(this).find('NUMBER').text();

			    });

			    var street = "";
			    var locality = "";
			    var region = "";
			    var pcode = "";
			    var country = "";

			    response.find('vCard ADR').each(function()
			    {
				if ($(this).find('WORK').size() > 0)
				{
					street = $(this).find('STREET').text();
					locality = $(this).find('LOCALITY').text();
					region = $(this).find('REGION').text();
					pcode = $(this).find('PCODE').text();
					country = $(this).find('CTRY').text();
				}
			    });

			    var orgName = response.find('vCard ORG ORGNAME') ? response.find('vCard ORG ORGNAME').text() : "";
			    var orgUnit = response.find('vCard ORG ORGUNIT') ? response.find('vCard ORG ORGUNIT').text() : "";

			    var title = response.find('vCard TITLE') ? response.find('vCard TITLE').text() : "";

			    var callbackResponse = {username: username, name: name, avatar: avatar, family: family, given: given, nickname: nickname, middle: middle, email: email, url: url, homePhone: homePhone, workPhone: workPhone, homeMobile: homeMobile, workMobile: workMobile, street: street, locality: locality, region: region, pcode: pcode, country: country, orgName: orgName, orgUnit: orgUnit, title: title};

			    if (callback) callback(callbackResponse);
			    
		    }, function(error) {
			
			if (errorback) errorback(error);
		    });
		},
		
		set: function(user, callback, errorback) 
		{
			var avatar = user.avatar.split(";base64,");

			var iq = $iq({to: this._connection.domain, type: 'set'}).c('vCard', {xmlns: 'vcard-temp'})
			.c("N").c("FAMILY").t(user.family).up().c("GIVEN").t(user.given).up().c("MIDDLE").t(user.middle).up().up()
			.c("ORG").c("ORGNAME").t(user.orgName).up().c("ORGUNIT").t(user.orgUnit).up().up()
			.c("FN").t(user.name).up()
			.c("URL").t(user.url).up()
			.c("TITLE").t(user.title).up()
			.c("NICKNAME").t(user.nickname).up()
			.c("PHOTO").c("TYPE").t(avatar[0].substring(5)).up().c("BINVAL").t(avatar[1]).up().up()
			.c("EMAIL").c("WORK").up().c("INTERNET").up().c("PREF").up().c("USERID").t(user.email).up().up()
			.c("TEL").c("PAGER").up().c("WORK").up().c("NUMBER").up().up()
			.c("TEL").c("CELL").up().c("WORK").up().c("NUMBER").t(user.workMobile).up().up()
			.c("TEL").c("VOICE").up().c("WORK").up().c("NUMBER").t(user.workPhone).up().up()
			.c("TEL").c("FAX").up().c("WORK").up().c("NUMBER").up().up()
			.c("TEL").c("PAGER").up().c("HOME").up().c("NUMBER").up().up()
			.c("TEL").c("CELL").up().c("HOME").up().c("NUMBER").t(user.homeMobile).up().up()
			.c("TEL").c("VOICE").up().c("HOME").up().c("NUMBER").t(user.homePhone).up().up()
			.c("TEL").c("FAX").up().c("HOME").up().c("NUMBER").up().up()
			.c("URL").t(user.url).up()
			.c("ADR").c("WORK").up().c("STREET").t(user.street).up().c("LOCALITY").t(user.locality).up().c("REGION").t(user.region).up().c("PCODE").t(user.pcode).up().c("CTRY").t(user.country).up().up()
			.c("ADR").c("HOME").up().c("STREET").up().c("LOCALITY").up().c("REGION").up().c("PCODE").up().c("CTRY").up().up()

			this._connection.sendIQ(iq, callback, errorback);
		},
	 });


	Strophe.addConnectionPlugin('workgroup',
	{
		_connection: null,
		_handler: null,

		/** Function: init
		* Plugin init
		*
		* Parameters:
		*   (Strophe.Connection) conn - Strophe connection
		*/
		init: function(conn)
		{
			this._connection = conn;

			this._connection.addHandler(this._handlePresence.bind(this), null,"presence", null, null, null);  
			this._connection.addHandler(this._handleMessage.bind(this), null,"message", null, null, null); 		
			this._connection.addHandler(this._handleWorkgroups.bind(this), "http://jabber.org/protocol/workgroup", 'iq');	

			console.log("strophe plugin: workgroup enabled");        
		},


		setHandler: function(handler) 
		{  
			this._handler = handler;
		},

		subscribe: function(workgroup) 
		{  
			this._connection.send($pres({type: 'subscribe', to: workgroup + "@workgroup." + this._connection.domain })); 
		},

		unsubscribe: function(workgroup) 
		{  
			this._connection.send($pres({type: 'unsubscribe', to: workgroup + "@workgroup." + this._connection.domain })); 
		},

		joinWorkgroup: function(workgroup, maxChats, callback, errorback) 
		{
			var jid = workgroup + "@workgroup." + this._connection.domain;	
			this._connection.send($pres({to: jid}).c('agent-status', {xmlns: 'http://jabber.org/protocol/workgroup'}));		
			this._connection.send($pres({to: jid}).c('status').t("Online"));		
			var iq = $iq({type: 'get', to: jid}).c('agent-status-request', {xmlns: 'http://jabber.org/protocol/workgroup'});
			var that = this;

			this._connection.sendIQ(iq,
				function (res) {
					if (callback) callback(res);			
				},

				function (err) {
					if (errorback) errorback(of.util.translateError(err))			    
				}
			);		
		},

		leaveWorkgroup: function(workgroup) 
		{
			var jid = workgroup + "@workgroup." + this._connection.domain;	
			this._connection.send($pres({to: jid, type: "unavailable"}).c('agent-status', {xmlns: 'http://jabber.org/protocol/workgroup'}));		
			this._connection.send($pres({to: jid, type: "unavailable"}).c('status').t("Online"));				
		},	

		joinQueue: function(workgroup, form, callback, errorback) 
		{
			var iq = $iq({to: workgroup + "@workgroup." + this._connection.domain, type: 'set'}).c('join-queue', {xmlns: 'http://jabber.org/protocol/workgroup'});	
			iq.c('queue-notifications').up();
			iq.c('x', {xmlns: 'jabber:x:data', type: 'submit'});

			var items = Object.getOwnPropertyNames(form)

			for (var i=0; i< items.length; i++)
			{
				iq.c('field', {var: items[i]}).c('value').t(form[items[i]]).up().up();
			}

			iq.up();

			this._connection.sendIQ(iq,
				function (res) {
					if (callback) callback(res);			
				},

				function (err) {
					if (errorback) errorback(of.util.translateError(err));				    
				}
			);     	       	
		},   

		leaveQueue: function(workgroup, callback, errorback) 
		{
			var iq = $iq({to: workgroup + "@workgroup." + this._connection.domain, type: 'set'}).c('depart-queue', {xmlns: 'http://jabber.org/protocol/workgroup'});	

			this._connection.sendIQ(iq,
				function (res) {
					if (callback) callback(res);			
				},

				function (err) {
					if (errorback) errorback(of.util.translateError(err));				    
				}
			);     	       	
		}, 

		acceptOffer: function(workgroup, jid, id, callback, errorback) 
		{
			var iq = $iq({to: workgroup + "@workgroup." + this._connection.domain, type: 'set'}).c('offer-accept', {xmlns: 'http://jabber.org/protocol/workgroup', jid: jid, id: id});	

			this._connection.sendIQ(iq,
				function (res) {
					if (callback) callback(res);			
				},

				function (err) {
					if (errorback) errorback(of.util.translateError(err));			    
				}
			);      	       	
		},	

		rejectOffer: function(workgroup, jid, id, callback, errorback) 
		{
			var iq = $iq({to: workgroup + "@workgroup." + this._connection.domain, type: 'set'}).c('offer-reject', {xmlns: 'http://jabber.org/protocol/workgroup', jid: jid, id: id});	

			this._connection.sendIQ(iq,
				function (res) {
					if (callback) callback(res);			
				},

				function (err) {
					if (errorback) errorback(of.util.translateError(err));			    
				}
			);      	       	
		},   	

		_handleMessage: function(message) 
		{  	
			$(message).find('queue-status').each(function ()  	
			{
				var position = 0;
				var time = 0;

				$(this).find('position').each(function ()  	
				{
					position = $(this).text();
				});

				$(this).find('time').each(function ()  	
				{
					time = $(this).text();
				});

				$(document).trigger("Event.Workgroup.QueueStatus",
				{
					from: $(message).attr("from"),
					position: position,
					time: time
				});		
			});

			return true;	
		},

		_handlePresence: function(presence) 
		{  	
			var to = $(presence).attr('to');
			var from = $(presence).attr('from');	

			var xquery = presence.getElementsByTagName("x");
			var agentStatus = presence.getElementsByTagName("agent-status");	
			var notifyQueue = presence.getElementsByTagName("notify-queue");	
			var notifyQueueDetails = presence.getElementsByTagName("notify-queue-details");		
			var inviteAccepted = presence.getElementsByTagName("inviteaccepted");
			var inviteCompleted = presence.getElementsByTagName("invitecompleted");	
			var workgroupPresence = presence.getElementsByTagName("workgroup");

			if (agentStatus.length > 0 || notifyQueueDetails.length > 0 || notifyQueue.length > 0) {

				this._handleAgentPresence($(presence));	

			} else if (workgroupPresence.length > 0) {
				var type = $(presence).attr('type');  
				var open = type != "unavailable" && type != "unsubscribe" && type != "subscribe";		
				var workgroup = Strophe.getNodeFromJid(from);

				$(document).trigger("Event.Workgroup.Status", {id: workgroup, open: open, type: type});			
			}	
			return true;	
		},

		_handleWorkgroups: function(iq) {

			var _myself = this; 
			var iq = $(iq);

			var workgroupJid = iq.attr('from');
			var workgroupName = Strophe.getNodeFromJid(workgroupJid);

			if (iq.attr('type') != "result" && iq.attr('type') != "error") this._connection.send($iq({type: 'result', to: iq.attr('from'), id: iq.attr('id')}));		

			iq.find('offer').each(function() 
			{
				var id = $(this).attr('id');
				var jid = $(this).attr('jid').toLowerCase();	
				var properties = {id: id, jid: jid};

				iq.find('value').each(function() 
				{	
					var name = $(this).attr('name');		
					var value = $(this).text();
					properties[name] = value;
				});

				$(document).trigger("Event.Workgroup.Offer", {workgroup: workgroupJid, name: workgroupName, properties: properties});			
			});

			iq.find('offer-revoke').each(function() 
			{
				id = $(this).attr('id');
				jid = $(this).attr('jid').toLowerCase();
				var properties = {id: id, jid: jid};
				var reason = "offer timed out";

				$(this).find('reason').each(function() 
				{			
					reason = $(this).text();
				});

				$(document).trigger("Event.Workgroup.Revoke", {workgroup: workgroupJid, name: workgroupName, properties: properties, reason: reason});	
			});
			return true;
		},

		_handleAgentPresence:  function(presence) 
		{
			var from = presence.attr('from');
			var status = presence.attr('type') || "available";
			var maxChats = 0, currentChats = 0, workgroup;				

			presence.find('agent-status').each(function() 
			{
				workgroup = $(this).attr("jid");

				presence.find('max-chats').each(function() 
				{
					maxChats = $(this).text();	
				});	

				presence.find('current-chats').each(function() 
				{
					currentChats = $(this).text();				
				});

				$(document).trigger("Event.Workgroup.TraderStatus",
				{
					   from: from,
					   status: status,
					   workgroup: workgroup,
					   maxChats: maxChats
				});			
			});

			presence.find('notify-queue-details').each(function() 
			{
				presence.find('user').each(function() 
				{
					var jid = $(this).attr('jid');
					var position, time, joinTime

					$(this).find('position').each(function() 
					{
						position = $(this).text() == "0" ? "first": jQuery(this).text();				
					});

					$(this).find('time').each(function() 
					{
						time = $(this).text();				
					});

					$(this).find('join-time').each(function() 
					{
						joinTime = $(this).text();				
					});

					$(document).trigger("Event.Workgroup.QueueDetails",
					{
					   from: from,
					   workgroup: from,
					   position: position,
					   time: time,
					   joinTime: joinTime
					});										
				});

			});

			presence.find('notify-queue').each(function() 
			{
				var free = true;
				var count, oldest, waitTime, status

				presence.find('count').each(function() 
				{
					count = jQuery(this).text();				
				});

				presence.find('oldest').each(function() 
				{
					oldest = jQuery(this).text();				
				});

				presence.find('time').each(function() 
				{
					waitTime = jQuery(this).text();				
				});

				presence.find('status').each(function() 
				{
					status = jQuery(this).text();				
				});

				if (count && oldest && waitTime && status)
				{
					free = false;		
				}

				$(document).trigger("Event.Workgroup.QueueSummary",
				{
				   workgroup: from,
				   free: free,
				   count: count,
				   oldest: oldest,
				   waitTime: waitTime,
				   status: status
				});			
			});	

			return true;     
		}	
	});



	/**
	 * messageHandler
	 */

	var messageHandler = (function(my) {

	    /**
	     * Shows a message to the user.
	     *
	     * @param titleString the title of the message
	     * @param messageString the text of the message
	     */
	    my.openMessageDialog = function(titleString, messageString) {
		$.prompt(messageString,
		    {
			title: titleString,
			persistent: false
		    }
		);
	    };

	    /**
	     * Shows a message to the user with two buttons: first is given as a parameter and the second is Cancel.
	     *
	     * @param titleString the title of the message
	     * @param msgString the text of the message
	     * @param persistent boolean value which determines whether the message is persistent or not
	     * @param leftButton the fist button's text
	     * @param submitFunction function to be called on submit
	     * @param loadedFunction function to be called after the prompt is fully loaded
	     * @param closeFunction function to be called after the prompt is closed
	     */
	    my.openTwoButtonDialog = function(titleString, msgString, persistent, leftButton,
					      submitFunction, loadedFunction, closeFunction) {
		var buttons = {};
		buttons[leftButton] = true;
		buttons.Cancel = false;
		$.prompt(msgString, {
		    title: titleString,
		    persistent: false,
		    buttons: buttons,
		    defaultButton: 1,
		    loaded: loadedFunction,
		    submit: submitFunction,
		    close: closeFunction
		});
	    };

	    /**
	     * Shows a message to the user with two buttons: first is given as a parameter and the second is Cancel.
	     *
	     * @param titleString the title of the message
	     * @param msgString the text of the message
	     * @param persistent boolean value which determines whether the message is persistent or not
	     * @param buttons object with the buttons. The keys must be the name of the button and value is the value
	     * that will be passed to submitFunction
	     * @param submitFunction function to be called on submit
	     * @param loadedFunction function to be called after the prompt is fully loaded
	     */
	    my.openDialog = function(titleString, msgString, persistent, buttons, submitFunction, loadedFunction) {
		$.prompt(msgString, {
		    title: titleString,
		    persistent: false,
		    buttons: buttons,
		    defaultButton: 1,
		    loaded: loadedFunction,
		    submit: submitFunction
		});
	    };

	    /**
	     * Shows a dialog with different states to the user.
	     *
	     * @param statesObject object containing all the states of the dialog
	     * @param loadedFunction function to be called after the prompt is fully loaded
	     * @param stateChangedFunction function to be called when the state of the dialog is changed
	     */
	    my.openDialogWithStates = function(statesObject, loadedFunction, stateChangedFunction) {


		var myPrompt = $.prompt(statesObject);

		myPrompt.on('impromptu:loaded', loadedFunction);
		myPrompt.on('impromptu:statechanged', stateChangedFunction);
	    };

	    /**
	     * Shows a dialog prompting the user to send an error report.
	     *
	     * @param titleString the title of the message
	     * @param msgString the text of the message
	     * @param error the error that is being reported
	     */
	    my.openReportDialog = function(titleString, msgString, error) {
		my.openMessageDialog(titleString, msgString);
		//console.log(error);
		//FIXME send the error to the server
	    };

	    /**
	     *  Shows an error dialog to the user.
	     * @param title the title of the message
	     * @param message the text of the messafe
	     */
	    my.showError = function(title, message) {
		if(!(title || message)) {
		    title = title || "Oops!";
		    message = message || "There was some kind of error";
		}
		messageHandler.openMessageDialog(title, message);
	    };

	    my.notify = function(displayName, cls, message) {
		toastr.info(
		    '<span class="nickname">' +
			displayName +
		    '</span><br>' +
		    '<span class=' + cls + '>' +
			message +
		    '</span>');
	    };

	    return my;
	}(messageHandler || {}));


	/**
	 * Provides a wrapper class for the MediaStream.
	 * 
	 * TODO : Add here the src from the video element and other related properties
	 * and get rid of some of the mappings that we use throughout the UI.
	 */

	var MediaStream = (function() {
	    /**
	     * Creates a MediaStream object for the given data, session id and ssrc.
	     *
	     * @param data the data object from which we obtain the stream,
	     * the peerjid, etc.
	     * @param sid the session id
	     * @param ssrc the ssrc corresponding to this MediaStream
	     *
	     * @constructor
	     */
	    function MediaStreamProto(data, sid, ssrc) {
		this.stream = data.stream;
		this.peerjid = data.peerjid;
		this.ssrc = ssrc;
		this.session = connection.jingle.sessions[sid];
		this.type = (this.stream.getVideoTracks().length > 0)
			    ? MediaStream.VIDEO_TYPE : MediaStream.AUDIO_TYPE;
		this.muted = false;
	    }

	    return MediaStreamProto;
	})();

	MediaStream.VIDEO_TYPE = 'Video';
	MediaStream.AUDIO_TYPE = 'Audio';


	/**
	 * Provides statistics for the local stream.
	 */
	var LocalStatsCollector = (function() {
	    /**
	     * Size of the webaudio analizer buffer.
	     * @type {number}
	     */
	    var WEBAUDIO_ANALIZER_FFT_SIZE = 2048;

	    /**
	     * Value of the webaudio analizer smoothing time parameter.
	     * @type {number}
	     */
	    var WEBAUDIO_ANALIZER_SMOOTING_TIME = 0.8;

	    /**
	     * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.
	     *
	     * @param stream the local stream
	     * @param interval stats refresh interval given in ms.
	     * @param {function(LocalStatsCollector)} updateCallback the callback called on stats
	     *                                   update.
	     * @constructor
	     */
	    function LocalStatsCollectorProto(stream, interval, updateCallback) {
		window.AudioContext = window.AudioContext || window.webkitAudioContext;
		this.stream = stream;
		this.intervalId = null;
		this.intervalMilis = interval;
		this.audioLevelsUpdateCallback = updateCallback;
		this.audioLevel = 0;
	    }

	    /**
	     * Starts the collecting the statistics.
	     */
	    LocalStatsCollectorProto.prototype.start = function () {
		if (!window.AudioContext)
		    return;

		var context = new AudioContext();
		var analyser = context.createAnalyser();
		analyser.smoothingTimeConstant = WEBAUDIO_ANALIZER_SMOOTING_TIME;
		analyser.fftSize = WEBAUDIO_ANALIZER_FFT_SIZE;


		var source = context.createMediaStreamSource(this.stream);
		source.connect(analyser);


		var self = this;

		this.intervalId = setInterval(
		    function () {
			var array = new Uint8Array(analyser.frequencyBinCount);
			analyser.getByteTimeDomainData(array);
			var audioLevel = TimeDomainDataToAudioLevel(array);
			if(audioLevel != self.audioLevel) {
			    self.audioLevel = animateLevel(audioLevel, self.audioLevel);
			    self.audioLevelsUpdateCallback(LocalStatsCollectorProto.LOCAL_JID, self.audioLevel);
			}
		    },
		    this.intervalMilis
		);

	    };

	    /**
	     * Stops collecting the statistics.
	     */
	    LocalStatsCollectorProto.prototype.stop = function () {
		if (this.intervalId) {
		    clearInterval(this.intervalId);
		    this.intervalId = null;
		}
	    };

	    /**
	     * Converts time domain data array to audio level.
	     * @param array the time domain data array.
	     * @returns {number} the audio level
	     */
	    var TimeDomainDataToAudioLevel = function (samples) {

		var maxVolume = 0;

		var length = samples.length;

		for (var i = 0; i < length; i++) {
		    if (maxVolume < samples[i])
			maxVolume = samples[i];
		}

		return parseFloat(((maxVolume - 127) / 128).toFixed(3));
	    };

	    /**
	     * Animates audio level change
	     * @param newLevel the new audio level
	     * @param lastLevel the last audio level
	     * @returns {Number} the audio level to be set
	     */
	    function animateLevel(newLevel, lastLevel)
	    {
		var value = 0;
		var diff = lastLevel - newLevel;
		if(diff > 0.2)
		{
		    value = lastLevel - 0.2;
		}
		else if(diff < -0.4)
		{
		    value = lastLevel + 0.4;
		}
		else
		{
		    value = newLevel;
		}

		return parseFloat(value.toFixed(3));
	    }

	    /**
	     * Indicates that this audio level is for local jid.
	     * @type {string}
	     */
	    LocalStatsCollectorProto.LOCAL_JID = 'local';

	    return LocalStatsCollectorProto;
	})();


	/*
	 * Toastr
	 * Copyright 2012-2014 John Papa and Hans Fjllemark.
	 * All Rights Reserved.
	 * Use, reproduction, distribution, and modification of this code is subject to the terms and
	 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
	 *
	 * Author: John Papa and Hans Fjllemark
	 * ARIA Support: Greta Krafsig
	 * Project: https://github.com/CodeSeven/toastr
	 */
	; (function (define) {
	    define(['jquery'], function ($) {
		return (function () {
		    var $container;
		    var listener;
		    var toastId = 0;
		    var toastType = {
			error: 'error',
			info: 'info',
			success: 'success',
			warning: 'warning'
		    };

		    var toastr = {
			clear: clear,
			remove: remove,
			error: error,
			getContainer: getContainer,
			info: info,
			options: {},
			subscribe: subscribe,
			success: success,
			version: '2.0.3',
			warning: warning
		    };

		    return toastr;

		    //#region Accessible Methods
		    function error(message, title, optionsOverride) {
			return notify({
			    type: toastType.error,
			    iconClass: getOptions().iconClasses.error,
			    message: message,
			    optionsOverride: optionsOverride,
			    title: title
			});
		    }

		    function getContainer(options, create) {
			if (!options) { options = getOptions(); }
			$container = $('#' + options.containerId);
			if ($container.length) {
			    return $container;
			}
			if(create) {
			    $container = createContainer(options);
			}
			return $container;
		    }

		    function info(message, title, optionsOverride) {
			return notify({
			    type: toastType.info,
			    iconClass: getOptions().iconClasses.info,
			    message: message,
			    optionsOverride: optionsOverride,
			    title: title
			});
		    }

		    function subscribe(callback) {
			listener = callback;
		    }

		    function success(message, title, optionsOverride) {
			return notify({
			    type: toastType.success,
			    iconClass: getOptions().iconClasses.success,
			    message: message,
			    optionsOverride: optionsOverride,
			    title: title
			});
		    }

		    function warning(message, title, optionsOverride) {
			return notify({
			    type: toastType.warning,
			    iconClass: getOptions().iconClasses.warning,
			    message: message,
			    optionsOverride: optionsOverride,
			    title: title
			});
		    }

		    function clear($toastElement) {
			var options = getOptions();
			if (!$container) { getContainer(options); }
			if (!clearToast($toastElement, options)) {
			    clearContainer(options);
			}
		    }

		    function remove($toastElement) {
			var options = getOptions();
			if (!$container) { getContainer(options); }
			if ($toastElement && $(':focus', $toastElement).length === 0) {
			    removeToast($toastElement);
			    return;
			}
			if ($container.children().length) {
			    $container.remove();
			}
		    }
		    //#endregion

		    //#region Internal Methods

		    function clearContainer(options){
			var toastsToClear = $container.children();
			for (var i = toastsToClear.length - 1; i >= 0; i--) {
			    clearToast($(toastsToClear[i]), options);
			};
		    }

		    function clearToast($toastElement, options){
			if ($toastElement && $(':focus', $toastElement).length === 0) {
			    $toastElement[options.hideMethod]({
				duration: options.hideDuration,
				easing: options.hideEasing,
				complete: function () { removeToast($toastElement); }
			    });
			    return true;
			}
			return false;
		    }

		    function createContainer(options) {
			$container = $('<div/>')
			    .attr('id', options.containerId)
			    .addClass(options.positionClass)
			    .attr('aria-live', 'polite')
			    .attr('role', 'alert');

			$container.appendTo($(options.target));
			return $container;
		    }

		    function getDefaults() {
			return {
			    tapToDismiss: true,
			    toastClass: 'toast',
			    containerId: 'toast-container',
			    debug: false,

			    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
			    showDuration: 300,
			    showEasing: 'swing', //swing and linear are built into jQuery
			    onShown: undefined,
			    hideMethod: 'fadeOut',
			    hideDuration: 1000,
			    hideEasing: 'swing',
			    onHidden: undefined,

			    extendedTimeOut: 1000,
			    iconClasses: {
				error: 'toast-error',
				info: 'toast-info',
				success: 'toast-success',
				warning: 'toast-warning'
			    },
			    iconClass: 'toast-info',
			    positionClass: 'toast-top-right',
			    timeOut: 5000, // Set timeOut and extendedTimeout to 0 to make it sticky
			    titleClass: 'toast-title',
			    messageClass: 'toast-message',
			    target: 'body',
			    closeHtml: '<button>&times;</button>',
			    newestOnTop: true
			};
		    }

		    function publish(args) {
			if (!listener) { return; }
			listener(args);
		    }

		    function notify(map) {
			var options = getOptions(),
			    iconClass = map.iconClass || options.iconClass;

			if (typeof (map.optionsOverride) !== 'undefined') {
			    options = $.extend(options, map.optionsOverride);
			    iconClass = map.optionsOverride.iconClass || iconClass;
			}

			toastId++;

			$container = getContainer(options, true);
			var intervalId = null,
			    $toastElement = $('<div/>'),
			    $titleElement = $('<div/>'),
			    $messageElement = $('<div/>'),
			    $closeElement = $(options.closeHtml),
			    response = {
				toastId: toastId,
				state: 'visible',
				startTime: new Date(),
				options: options,
				map: map
			    };

			if (map.iconClass) {
			    $toastElement.addClass(options.toastClass).addClass(iconClass);
			}

			if (map.title) {
			    $titleElement.append(map.title).addClass(options.titleClass);
			    $toastElement.append($titleElement);
			}

			if (map.message) {
			    $messageElement.append(map.message).addClass(options.messageClass);
			    $toastElement.append($messageElement);
			}

			if (options.closeButton) {
			    $closeElement.addClass('toast-close-button').attr("role", "button");
			    $toastElement.prepend($closeElement);
			}

			if (options.reposition) {
			    options.reposition();
			}

			$toastElement.hide();
			if (options.newestOnTop) {
			    $container.prepend($toastElement);
			} else {
			    $container.append($toastElement);
			}


			$toastElement[options.showMethod](
			    { duration: options.showDuration, easing: options.showEasing, complete: options.onShown }
			);

			if (options.timeOut > 0) {
			    intervalId = setTimeout(hideToast, options.timeOut);
			}

			$toastElement.hover(stickAround, delayedHideToast);
			if (!options.onclick && options.tapToDismiss) {
			    $toastElement.click(hideToast);
			}

			if (options.closeButton && $closeElement) {
			    $closeElement.click(function (event) {
				if( event.stopPropagation ) {
				    event.stopPropagation();
				} else if( event.cancelBubble !== undefined && event.cancelBubble !== true ) {
				    event.cancelBubble = true;
				}
				hideToast(true);
			    });
			}

			if (options.onclick) {
			    $toastElement.click(function () {
				options.onclick();
				hideToast();
			    });
			}

			publish(response);

			if (options.debug && console) {
			    //console.log(response);
			}

			return $toastElement;

			function hideToast(override) {
			    if ($(':focus', $toastElement).length && !override) {
				return;
			    }
			    return $toastElement[options.hideMethod]({
				duration: options.hideDuration,
				easing: options.hideEasing,
				complete: function () {
				    removeToast($toastElement);
				    if (options.onHidden && response.state !== 'hidden') {
					options.onHidden();
				    }
				    response.state = 'hidden';
				    response.endTime = new Date();
				    publish(response);
				}
			    });
			}

			function delayedHideToast() {
			    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
				intervalId = setTimeout(hideToast, options.extendedTimeOut);
			    }
			}

			function stickAround() {
			    clearTimeout(intervalId);
			    $toastElement.stop(true, true)[options.showMethod](
				{ duration: options.showDuration, easing: options.showEasing }
			    );
			}
		    }

		    function getOptions() {
			return $.extend({}, getDefaults(), toastr.options);
		    }

		    function removeToast($toastElement) {
			if (!$container) { $container = getContainer(); }
			if ($toastElement.is(':visible')) {
			    return;
			}
			$toastElement.remove();
			$toastElement = null;
			if ($container.children().length === 0) {
			    $container.remove();
			}
		    }
		    //#endregion

		})();
	    });
	}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
	    if (typeof module !== 'undefined' && module.exports) { //Node
		module.exports = factory(require('jquery'));
	    } else {
		window['toastr'] = factory(window['jQuery']);
	    }
	}));

	/* ========================================================================
	 * Bootstrap: tooltip.js v3.1.1
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2014 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {


	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================

	  var Tooltip = function (element, options) {
	    this.type       =
	    this.options    =
	    this.enabled    =
	    this.timeout    =
	    this.hoverState =
	    this.$element   = null

	    this.init('tooltip', element, options)
	  }

	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false
	  }

	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled  = true
	    this.type     = type
	    this.$element = $(element)
	    this.options  = this.getOptions(options)

	    var triggers = this.options.trigger.split(' ')

	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]

	      if (trigger == 'click') {
		this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
		var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
		var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

		this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
		this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }

	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }

	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }

	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
		show: options.delay,
		hide: options.delay
	      }
	    }

	    return options
	  }

	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()

	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })

	    return options
	  }

	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	    clearTimeout(self.timeout)

	    self.hoverState = 'in'

	    if (!self.options.delay || !self.options.delay.show) return self.show()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }

	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	    clearTimeout(self.timeout)

	    self.hoverState = 'out'

	    if (!self.options.delay || !self.options.delay.hide) return self.hide()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }

	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)

	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)

	      if (e.isDefaultPrevented()) return
	      var that = this;

	      var $tip = this.tip()

	      this.setContent()

	      if (this.options.animation) $tip.addClass('fade')

	      var placement = typeof this.options.placement == 'function' ?
		this.options.placement.call(this, $tip[0], this.$element[0]) :
		this.options.placement

	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	      $tip
		.detach()
		.css({ top: 0, left: 0, display: 'block' })
		.addClass(placement)

	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight

	      if (autoPlace) {
		var $parent = this.$element.parent()

		var orgPlacement = placement
		var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
		var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
		var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
		var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

		placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
			    placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
			    placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
			    placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
			    placement

		$tip
		  .removeClass(orgPlacement)
		  .addClass(placement)
	      }

	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	      this.applyPlacement(calculatedOffset, placement)
	      this.hoverState = null

	      var complete = function() {
		that.$element.trigger('shown.bs.' + that.type)
	      }

	      var deltas = {
		  "bottom": $tip[0].getBoundingClientRect().bottom - window.innerHeight,
		  "right": $tip[0].getBoundingClientRect().right - window.innerWidth,
		  "left": -$tip[0].getBoundingClientRect().left,
		  "top": -$tip[0].getBoundingClientRect().top
	      };
	      for(var direction in deltas) {
		  if (deltas[direction] > 0) {
		      var delta = deltas[direction];
		      if(direction === "right" || direction === "bottom") {
			  delta = -delta;
		      }
		      direction = direction === "top" || direction === "bottom" ? "top" : "left";
		      var currentPosition = parseInt($tip.css(direction), 10);
		      $tip.css(direction, currentPosition + delta);
		      if(direction === "left") {
			  $tip.children(".arrow").css(direction, parseInt($tip.children(".arrow").css(direction), 10) - delta);
		      } else {
			  $tip.children(".arrow").css(direction, 50 - $tip[0].getBoundingClientRect().height / delta + "%");
		      }
		  }
	      }

	      $.support.transition && this.$tip.hasClass('fade') ?
		$tip
		  .one($.support.transition.end, complete)
		  .emulateTransitionEnd(150) :
		complete()
	    }
	  }

	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var replace
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight

	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)

	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0

	    offset.top  = offset.top  + marginTop
	    offset.left = offset.left + marginLeft

	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
		$tip.css({
		  top: Math.round(props.top),
		  left: Math.round(props.left)
		})
	      }
	    }, offset), 0)

	    $tip.addClass('in')

	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight

	    if (placement == 'top' && actualHeight != height) {
	      replace = true
	      offset.top = offset.top + height - actualHeight
	    }

	    if (/bottom|top/.test(placement)) {
	      var delta = 0

	      if (offset.left < 0) {
		delta       = offset.left * -2
		offset.left = 0

		$tip.offset(offset)

		actualWidth  = $tip[0].offsetWidth
		actualHeight = $tip[0].offsetHeight
	      }

	      this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
	    } else {
	      this.replaceArrow(actualHeight - height, actualHeight, 'top')
	    }

	    if (replace) $tip.offset(offset)
	  }

	  Tooltip.prototype.replaceArrow = function (delta, dimension, position) {
	    this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + '%') : '')
	  }

	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()

	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }

	  Tooltip.prototype.hide = function () {
	    var that = this
	    var $tip = this.tip()
	    var e    = $.Event('hide.bs.' + this.type)

	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      that.$element.trigger('hidden.bs.' + that.type)
	    }

	    this.$element.trigger(e)

	    if (e.isDefaultPrevented()) return

	    $tip.removeClass('in')

	    $.support.transition && this.$tip.hasClass('fade') ?
	      $tip
		.one($.support.transition.end, complete)
		.emulateTransitionEnd(150) :
	      complete()

	    this.hoverState = null

	    return this
	  }

	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }

	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }

	  Tooltip.prototype.getPosition = function () {
	    var el = this.$element[0]
	    return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
	      width: el.offsetWidth,
	      height: el.offsetHeight
	    }, this.$element.offset())
	  }

	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
		/* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
	  }

	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options

	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	    return title
	  }

	  Tooltip.prototype.tip = function () {
	    return this.$tip = this.$tip || $(this.options.template)
	  }

	  Tooltip.prototype.arrow = function () {
	    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
	  }

	  Tooltip.prototype.validate = function () {
	    if (!this.$element[0].parentNode) {
	      this.hide()
	      this.$element = null
	      this.options  = null
	    }
	  }

	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }

	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }

	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }

	  Tooltip.prototype.toggle = function (e) {
	    var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
	    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	  }

	  Tooltip.prototype.destroy = function () {
	    clearTimeout(this.timeout)
	    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
	  }


	  // TOOLTIP PLUGIN DEFINITION
	  // =========================

	  var old = $.fn.tooltip

	  $.fn.tooltip = function (option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option

	      if (!data && option == 'destroy') return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  $.fn.tooltip.Constructor = Tooltip


	  // TOOLTIP NO CONFLICT
	  // ===================

	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }

	}(jQuery);


	/* ========================================================================
	 * Bootstrap: popover.js v3.1.1
	 * http://getbootstrap.com/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2014 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {

	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================

	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }

	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })


	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================

	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

	  Popover.prototype.constructor = Popover

	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }

	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()

	    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	    $tip.find('.popover-content')[ // we use append for html objects to maintain js events
	      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
	    ](content)

	    $tip.removeClass('fade top bottom left right in')

	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }

	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }

	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options

	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
		    o.content.call($e[0]) :
		    o.content)
	  }

	  Popover.prototype.arrow = function () {
	    return this.$arrow = this.$arrow || this.tip().find('.arrow')
	  }

	  Popover.prototype.tip = function () {
	    if (!this.$tip) this.$tip = $(this.options.template)
	    return this.$tip
	  }


	  // POPOVER PLUGIN DEFINITION
	  // =========================

	  var old = $.fn.popover

	  $.fn.popover = function (option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option

	      if (!data && option == 'destroy') return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  $.fn.popover.Constructor = Popover


	  // POPOVER NO CONFLICT
	  // ===================

	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }

	}(jQuery);


	var connection = null;
	var authenticatedUser = false;
	var activecall = null;
	var RTC = null;
	var nickname = null;
	var sharedKey = '';
	var focusJid = null;
	var roomUrl = null;
	var roomName = null;
	var ssrc2jid = {};
	var mediaStreams = {};
	var bridgeIsDown = false;
	//TODO: this array must be removed when firefox implement multistream support
	var notReceivedSSRCs = [];

	var jid2Ssrc = {};

	/**
	 * The stats collector that process stats data and triggers updates to app.js.
	 * @type {StatsCollector}
	 */
	var statsCollector = null;

	/**
	 * The stats collector for the local stream.
	 * @type {LocalStatsCollector}
	 */
	var localStatsCollector = null;

	/**
	 * Indicates whether ssrc is camera video or desktop stream.
	 * FIXME: remove those maps
	 */
	var ssrc2videoType = {};
	/**
	 * Currently focused video "src"(displayed in large video).
	 * @type {String}
	 */
	var focusedVideoInfo = null;
	var mutedAudios = {};
	/**
	 * Remembers if we were muted by the focus.
	 * @type {boolean}
	 */
	var forceMuted = false;
	/**
	 * Indicates if we have muted our audio before the conference has started.
	 * @type {boolean}
	 */
	var preMuted = false;

	var localVideoSrc = null;
	var flipXLocalVideo = true;
	var isFullScreen = false;
	var currentVideoWidth = null;
	var currentVideoHeight = null;
	/**
	 * Method used to calculate large video size.
	 * @type {function ()}
	 */
	var getVideoSize;
	/**
	 * Method used to get large video position.
	 * @type {function ()}
	 */
	var getVideoPosition;

	var sessionTerminated = false;
	
	of.util = (function(self, Strophe, $, of) {

		self.sendRequest = function(request, callback, errorback)
		{
			of.connection.sendIQ($iq({to: of.connection.domain, type: 'get'}).c("request", request),
				function (resp) {
				    if (callback) callback(self.translateResponse(resp));
				},

				function (err) {
				    if (errorback) errorback(self.translateError(err));
				}
			);	
		};

		self.translateError = function (err) {
		    var error = {id: "Event.Error"};

		    $(err).find('error').each(function() 
		    {
			error.code = $(this).attr("code");
		    });	

		    $(err).find('text').each(function() 
		    {
			error.description = $(this).text();
		    });				    

		   return error;				    
		};

		self.translateResponse = function (resp) {
		    var response = {};

		    $(resp).find('response').each(function() 
		    {
			response = JSON.parse($(this).text());
		    });				    

		   return response;				    
		};	

		self.guid = function() 
		{
			return MD5.hexdigest(new String((new Date()).getTime())) 
		};

		self.usernamesToId = function(usernames) 
		{	
			return MD5.hexdigest(usernames.sort(function(a, b) {return a < b ? 1 : a >= b ? -1 : 0;}).join(""));
		};

		self.jidsToId = function(jid) 
		{	
			return MD5.hexdigest(jid.map(function(e) {return Strophe.getNodeFromJid(e)}).sort(function(a, b) {return a < b ? 1 : a >= b ? -1 : 0;}).join(""));
		};	

		self.makeJidFromUsername = function(username) 
		{
			var jid = username;
			if (username.indexOf("@") == -1) jid = jid + "@" + of.connection.domain;
			return jid;
		};	

		self.isArray = function( obj ) 
		{
		    return toString.call(obj) === "[object Array]";
		};

		self.getBareJid = function(jid) 
		{
			return Strophe.getBareJidFromJid(jid)
		}

		self.makeJidFromRoomName = function(service, name) 
		{
			return "pw-" + name + "@" + service + "." + of.connection.domain;
		}

		self.makeRoomJid = function(service, jids) 
		{
			return self.makeRoomName(jids) + "@" + service + "." + of.connection.domain;
		}	

		self.makeRoomName = function(jids) 
		{
			jids.push(of.connection.jid)
			return "pw-" + self.jidsToId(jids);
		}

		self.getId = function(jid) 
		{
			if (!jid) jid = of.connection.jid;
			var resource = Strophe.getResourceFromJid(jid);
			var capabilities = resource ? resource.split(":") : []

			return {

				username: Strophe.getNodeFromJid(jid),
				domain: Strophe.getDomainFromJid(jid),
				address: Strophe.getBareJidFromJid(jid),                	
				resource: {
					id: resource,
					browser: capabilities[0] || "",
					version: capabilities[1] || "",    
					os: capabilities[2] || ""                  		
				}
			};
		};	

		self.encodeString = function(value) {
			return hashed_auth_str = Base64.encode(value);   
		};

		self.decodeString = function(value) 
		{
			return hashed_auth_str = Base64.decode(value);   
		},

		self.getGravatar = function(email, size, className) 
		{
			return "<img class='" + className + "' src='http://s.gravatar.com/avatar/" + MD5.hexdigest(email) + "?s=" + size + "'>";
		};

		self.escapeXmppNode = function(input) 
		{
			var node = input;
			node = node.replace(/\\/g, "\\5c");
			node = node.replace(/ /g, "\\20");
			node = node.replace(/\"/, "\\22");
			node = node.replace(/&/g, "\\26");
			node = node.replace(/\'/, "\\27");
			node = node.replace(/\//g, "\\2f");
			node = node.replace(/:/g, "\\3a");
			node = node.replace(/</g, "\\3c");
			node = node.replace(/>/g, "\\3e");
			node = node.replace(/@/g, "\\40");         
			return node;
		};

		self.setEmoticons = function(body) 	
		{
			if (body)
			{	
				body = body.replace(/:\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZSAPrkL1pSI/jhMFlTTPPYNPvnLZCEJnttUuvIOfniMIF7du7OOJ6RJsKgN/vmLYRtLoRsL4FoL/niL/HTNu/cKvHUNYRtL/nhMPnjL/rlLoNrL8WnNYFmMPbcMvffMdixO969OI+DJvHUNu/PN+7MOO/QN+zLOaudJ3xvUWdeI4J8dntsUoBmMIJ3JYVwLu3MOL+aOPznLPLVNYF8dvDRN926Of3oLHxwUerGOtq1OsKiN/jgMJ2QJ4+LhPTaM9TDKXRqJe/POPvlLmdeJD44IdPBK+LQKuDOK9LAK5yPKHZzdO3aLExFIoJ9dlhSTPfeMY+KhPzoLPHx8dbV1f3pK////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABSACwAAAAAEAAQAAAH1YBSgoIKKywcBzODi1JQER84LyQIORpQjE4wJgRPAhcePiMNA4NQMEFPGQVRUTFCOyI6l1IRJk8OISlUVCkGBQI0D1IKHwQZUQEBu8lUDh01Kis4TwVUDAa7BidUUQkLKCwvAlG75eU2ABMQHCQX5ObnABUWBwgeMfDlURIlNzM5PpC0oGCOQosiT0AokaJhxI4kTBj8MHKCCA8MMlwIgtJAhIAlPIAMCXEEA4ENPQYN0EGjQwIAACQ8kbGB1CIoD2osmFChBAgXKRkJUoECgoUbTRgFAgA7' border='0'>");
				body = body.replace(/:-\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZSAPrkL1pSI/jhMFlTTPPYNPvnLZCEJnttUuvIOfniMIF7du7OOJ6RJsKgN/vmLYRtLoRsL4FoL/niL/HTNu/cKvHUNYRtL/nhMPnjL/rlLoNrL8WnNYFmMPbcMvffMdixO969OI+DJvHUNu/PN+7MOO/QN+zLOaudJ3xvUWdeI4J8dntsUoBmMIJ3JYVwLu3MOL+aOPznLPLVNYF8dvDRN926Of3oLHxwUerGOtq1OsKiN/jgMJ2QJ4+LhPTaM9TDKXRqJe/POPvlLmdeJD44IdPBK+LQKuDOK9LAK5yPKHZzdO3aLExFIoJ9dlhSTPfeMY+KhPzoLPHx8dbV1f3pK////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABSACwAAAAAEAAQAAAH1YBSgoIKKywcBzODi1JQER84LyQIORpQjE4wJgRPAhcePiMNA4NQMEFPGQVRUTFCOyI6l1IRJk8OISlUVCkGBQI0D1IKHwQZUQEBu8lUDh01Kis4TwVUDAa7BidUUQkLKCwvAlG75eU2ABMQHCQX5ObnABUWBwgeMfDlURIlNzM5PpC0oGCOQosiT0AokaJhxI4kTBj8MHKCCA8MMlwIgtJAhIAlPIAMCXEEA4ENPQYN0EGjQwIAACQ8kbGB1CIoD2osmFChBAgXKRkJUoECgoUbTRgFAgA7' border='0'>");
				body = body.replace(/:\(/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZiANDn8cji74aKjsXg7qrR6kdpgLLV63p8gFBSVnqDibjY7FhdYbDU64eKjpDD5Z7L6M7m8M/m8E1QVIrB5JfH5rHV67TW65bG5rzb7cXg75jH5qvS6nh7gGaava/T6pLE5b7c7a3T6kVof26evmiq1LXX65jI5onA5Hix1szk78Pe7lqWu6fP6Xh8gIe/5KLN6FhreU1rgW+t1YiKjl1uej1lfjxlfo7D5Y3C5U9RVFlseUlpgMDd7sXa5Mbg77rZ7LfY7E5RVIK942SavH2z18He7qu+yF5uekBmf8ni70NER3+74nZzdG93e4+cosbb5J2wu6q+yMHd7p/L6FFTVsfh74/D5YSPlXqJkzk4On+84o+co6m9yL7b7Whyep6xu4WQlnmDiPHx8c3l8NbV1dHn8f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABiACwAAAAAEAAQAAAH6IBigoIcMDY1Oi2Di2ICSCRaJxNCMiICjAgrLg8bFQYhLzdDCIMCK1YEP0UDGSoYHhodDYJILgRdUAtjYwtfUgwfO2IcJA8/VRJBAABBEkkgLCgHMEsbRSlXCWVlCU5jAwY4NDYnFQNjANvqEAFAFwU1EwYZ6OrbEQEKFAU6QiEqKXqAyZGjSY8xPiw4ONJCxgsMXJSEeVJmSxYjPAgQYSJGxA0PWKKMgRBhjBEvJUzEECRgiAYGIAYECOCDR4kpI2YMQtDhAwsDQBRYIGBiBBVGDXagwHGBggMiMXQyEnSARoECRw4wCgQAOw==' border='0'>");
				body = body.replace(/:-\(/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZiANDn8cji74aKjsXg7qrR6kdpgLLV63p8gFBSVnqDibjY7FhdYbDU64eKjpDD5Z7L6M7m8M/m8E1QVIrB5JfH5rHV67TW65bG5rzb7cXg75jH5qvS6nh7gGaava/T6pLE5b7c7a3T6kVof26evmiq1LXX65jI5onA5Hix1szk78Pe7lqWu6fP6Xh8gIe/5KLN6FhreU1rgW+t1YiKjl1uej1lfjxlfo7D5Y3C5U9RVFlseUlpgMDd7sXa5Mbg77rZ7LfY7E5RVIK942SavH2z18He7qu+yF5uekBmf8ni70NER3+74nZzdG93e4+cosbb5J2wu6q+yMHd7p/L6FFTVsfh74/D5YSPlXqJkzk4On+84o+co6m9yL7b7Whyep6xu4WQlnmDiPHx8c3l8NbV1dHn8f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABiACwAAAAAEAAQAAAH6IBigoIcMDY1Oi2Di2ICSCRaJxNCMiICjAgrLg8bFQYhLzdDCIMCK1YEP0UDGSoYHhodDYJILgRdUAtjYwtfUgwfO2IcJA8/VRJBAABBEkkgLCgHMEsbRSlXCWVlCU5jAwY4NDYnFQNjANvqEAFAFwU1EwYZ6OrbEQEKFAU6QiEqKXqAyZGjSY8xPiw4ONJCxgsMXJSEeVJmSxYjPAgQYSJGxA0PWKKMgRBhjBEvJUzEECRgiAYGIAYECOCDR4kpI2YMQtDhAwsDQBRYIGBiBBVGDXagwHGBggMiMXQyEnSARoECRw4wCgQAOw==' border='0'>");
				body = body.replace(/:D/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZVAMjHx2deI/PYNPvnLVlTTPjhMIFmMI6AKIJ8doBmMIRsL4RtL+/PN4RtLu7OOIF8dsKiN7+aOPnhMCMfIIFoL/3oLPvmLXxvUfrkL8KgN/DRN/HUNe/QN+zWLp+dnd69OPLVNa2rq4VwLsWnNe7MOPHUNlpXWHRpJY+LhOvIOe3MONixO9q1Orq5ud26OXxwUfHTNuzLOfbcMurGOoNrL3ttUvrlLntsUvTaM4F7dqudJ+rUL3ZzdFlRJI+DJvznLPjgMPvlLtC8LdG9LUxEI5uLKVlQJPffMe/POFhSTEtEI+vUL5qKKvniMIJ9dp6RJvfeMfzoLI+KhFpSI5CEJvHx8dbV1f3pK////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABVACwAAAAAEAAQAAAH2oBVgoI5NwkGNQ+Di1VSFCszKiQpLDRSjEkRMQJQBRJHOAwZBINSEUhQNgNRUT9BQCUQl1UUMVAWPgFXVwFUAwUaDVU5KwI2UVNTu8lXFjIuCDczUANXT1S7VDpXUU0OFwkqBVG75eUVGDAKBiQS5ObnGBsLNSlME8lU+lQBUxNFHF48YIHDSAgsABICwBKiB5QPPKrQYLBDiQcsGLF4INIBhAhBUjKUWHLCRIsWJk50EDACxSACEDTIEHLgwBAoIEaQWiSlgQsHMDZw+CDCJSNBCC4oWPDCCaNAADs=' border='0'>");
				body = body.replace(/:x/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAPcAAKyrq/Hx8dbV1YNyMP3oN2ZiWunNPiMfIPXeOu7UPe/cNuzSPT44I396asjHx395anRqKXBoUHpvRvrkOGdeJ+zRPvbfOufLP4J9du7VPe3TPbq5ufPbO9PCM9m+PfLaO+iMbfPcO9TDM3hrOndpOvbeOpuHNOiNbvnjOJ+NM+DNNdzIN7SdOO7aNuiDY+DGPN/MNfDYPNyAY7GZOGNMMPXdO5CELGFVKrioMPHZPMa2McuxPHVqKWBUNtxWO/zmOPDXPGRdTuh8XO/VPC8pIjArItvAPcNrUX11XtyFaKqcL+7bNtzBPXBpUNrAPeXJP6udLvzoN/nkOOh5WJ2KM9i8PoteK/rlOOrVOFlRJoY4K+rPPvvlOPjjOXBcKvjhOe/VPfHYPIFvMeiObuiLbJ5fS8SzMnBNRcOxMod4L29mUIJ2Kox+LWZZWefROXFrXJ5eSpmKL+XIP5yJNHBlKu3YNvTdO+HPNG5MOHVrKXs8NPznN7agN+hcP/jiOcKxM892W3ZmLuiOb9zCPZ2QLZJdTGxgOOjNPm9nUPbgOnRpKXlOOrObOH9yLOLQNP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAAAAACwAAAAAEAAQAAAI7gABCBz4gIQYEg8GKhSoZoYcA1sMPDHxZiGAHlUqhAlhJ0SOBR4iDGwTZEcaL1hQTJDypUYGDwUA6Omz6MYRH2s6HOiAo4gbDSYAaBGSpBCZKVagHHik48CfDxcwnHFxQtAJQDYcUXikIEsdBBUkAIADYgwIGgoeqX1E4EeiBAMAECkjA48IEWvZtliRIW6gFGxg3Nm6NoqKRi/EIrnwwY8SCHnSEliiiA4fDAIZJSgxYQ8hBjwgMIgDZs5ARE6AlOhyhYsZNBZiMIk50JCRBBwQWEDAYcigJhYjsDi0QMMCA1RoWwTQYMSAEQ0WBgQAOw==' border='0'>");
				body = body.replace(/;\\/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZaAOvQPvLaO4J9dvbfOvrkOHxzUu3TPXtxUvjiOYNyMPvlOOrOPvznN/TcO1lUTPfhOZ6RLfvmOPTdO4FvMWdeJ+7UPe3SPde7PtzBPfnjOfXeO+jMP/XdO+vRPoF9dsCoOoFwMP3oN/HZPFpSJufLP/znOOzRPoR0MIJxMNi9PbmqMIBvMfnkOIJyMPrlOL6kOtrAPcCnOsKrOffgOT44I5uMLnNpKdK/NFlRJu/WPO/bNtPCM+7aNnVrKa+cNPDXPIp8Lsy4NuXOOkxFJJWEMN3KNu/cNvnjOODNNXZzdDEsIe7bNunNPlhTTPPbO8e2Me/WPSMfILehN+LQNHRqKc+8NfPcO9TDM56QLcy5NvHx8dbV1Y+LhPzoN/3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABaACwAAAAAEAAQAAAH54BagoIeBysTBwKDi1pcIBckCwsbKShcjE0vUkRCDVlAPgAxDoNcLwABVTYsNxk1QQYfl1ogTAEPLjxdXUtIRQ0mCVoeF1ADLlQUXipKXREPIjACByQBCAw4I14QUUYMBBIABSsLDSxdKhBeU8pdCgMWLRMLEgRdXvj5Ie8GCQcbTjIwwHIFH4QnXQhw6FBAQIofMyLsGDKCRg8dJRAEwJBECwoAVhBEYNAlRJcSRzRUOCGISwwDDR4QUKCAAAINOWTM0uLggwkREgYM4BCgggxSi7gkgAHAgoEOGE7sZCSgQIsEDRkFAgA7' border='0'>");
				body = body.replace(/B-\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZdAOvQPvLaO4J9dvbfOvTcO+3TPXxzUntxUoNyMFlRJurOPllUTPzoN/rkOPTdO+/cNvznN/njOYJyMOvRPujMP8KrOdrAPfXdO+7UPTEsIfPbO+3SPdzBPenNPoJxMKudLufLP8CoOvjiOYBvMYF9doFvMZuNLsCnOuzRPr6kOte7PvPcO4R0MOHPNPXeO/DXPHZzdD44I4FwMNi9Pe/bNo6BLFpRJse3MdC9NKmbL6maL/rlOFlQJu/WPXNpKYJ2KoJ3KvfhOUtEJJ6XazEtLqqjesq1N+/WPOXOOlhTTPHZPJ2QLWZcKGdfNMiyN1hPJvvmOMe2MdTCM93JNurVOM+8NfvlOPnkOOfROZqMLrmqMIN+affgOfHx8dbV1Y+LhCMfIP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABdACwAAAAAEAAQAAAH4YBdgoIkByMlBwKDi11fMiogCgoUMx5fjEkpHT0BBA4aLwAnC4NfKQABAyJXDRFcKwUhl10yHQFBOxAMDBBQIgQoCF0kKk5FPAkJNkNNyU9GFgIHIEgwYNcxW0TXYFgABiMKBDrXGR9aGdc5AxsSJQoODTRRD2FhDzctVgMFCAcUGiJAsEcwDIMGFyYYEDDjRZUfNAo+AIIjAAcYXTwAWJFFyBIpLT7EMOECAwtBX04UIEDFhA8mNaa4OFJhVpcFIVAocTBgwIUAGCqQWvQFgQUAGwpM4MDCJiMBBiQgWMgoEAA7' border='0'>");
				body = body.replace(/8-\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZdAOvQPvLaO4J9dvbfOvTcO+3TPXxzUntxUoNyMFlRJurOPllUTPzoN/rkOPTdO+/cNvznN/njOYJyMOvRPujMP8KrOdrAPfXdO+7UPTEsIfPbO+3SPdzBPenNPoJxMKudLufLP8CoOvjiOYBvMYF9doFvMZuNLsCnOuzRPr6kOte7PvPcO4R0MOHPNPXeO/DXPHZzdD44I4FwMNi9Pe/bNo6BLFpRJse3MdC9NKmbL6maL/rlOFlQJu/WPXNpKYJ2KoJ3KvfhOUtEJJ6XazEtLqqjesq1N+/WPOXOOlhTTPHZPJ2QLWZcKGdfNMiyN1hPJvvmOMe2MdTCM93JNurVOM+8NfvlOPnkOOfROZqMLrmqMIN+affgOfHx8dbV1Y+LhCMfIP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABdACwAAAAAEAAQAAAH4YBdgoIkByMlBwKDi11fMiogCgoUMx5fjEkpHT0BBA4aLwAnC4NfKQABAyJXDRFcKwUhl10yHQFBOxAMDBBQIgQoCF0kKk5FPAkJNkNNyU9GFgIHIEgwYNcxW0TXYFgABiMKBDrXGR9aGdc5AxsSJQoODTRRD2FhDzctVgMFCAcUGiJAsEcwDIMGFyYYEDDjRZUfNAo+AIIjAAcYXTwAWJFFyBIpLT7EMOECAwtBX04UIEDFhA8mNaa4OFJhVpcFIVAocTBgwIUAGCqQWvQFgQUAGwpM4MDCJiMBBiQgWMgoEAA7' border='0'>");
				body = body.replace(/:p/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZZAPzoN4J9dvLaO+vQPvTcO3xzUurOPu3TPfjiOYNyMPbfOntxUllUTPrkOPTdO/fhOZCELMKrOYJyMNi9PenNPtzBPfPbO9rAPfvlOPPcO+jMP+7UPde7PvHZPO3SPYF9dvDXPMCoOvznN+ViRsCnOvnkOOzRPr5UP4BvMfXeO2VUKYFvMb6kOmdeJ4R0MFpRJllRJuvRPu/WPVpSJpdHN+fLP4JxMIFwMFhTTD44I+/WPOvWN+vXN/XdO0s9JezYN35qLfnjOY+CLNPBM/vmOMa2Md7KNeXOOoF2K+fROf3oN2ddKHVrKYtgMXZzdMa1MX5rLaudLp6QLenUOPfgOdhdRPrlOPJmSY6CLPHx8dbV1Y+LhP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABZACwAAAAAEAAQAAAH34BZgoIfCygrCwGDi1lbNxw1BgYaEzZbjDgsFDICBA4WIAMkDINbLAMCCgglDUFUGQchl1k3FAIPWC0AAC1CCAQmCVkfHDIKVjAvXFwvMEQPHRcBCzUCCCJSEMsQUSINDgMFKAYEJQDL6FwAGAoeEisGDg3n6VxK7AcJCxoWPE/1XIr86BGjQIAJIKYgyTGDCYQZPpbsEFDBSRYbAzIgGELjxIkqNIyk2OBC0BYSBwg8UDHiyggVKXREmJWFQQgTHZJAaQLkyIYIpBZtSXBhgIcDMSq4oMkoQAEJCQwyCgQAOw==' border='0'>");
				body = body.replace(/X-\(/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZdAO64qOu2pXJNOm5IM9qehI2GhOixn92iilZGQuSsmOOqley2plZPTYhrZNKSdNqehdKTdeGnkaZtUHJOO3NdVOCmj42GhdGSdOWtmY2Hhe24qLd2UsuJaNibgcyKanRQPsyLauiyoMiFYnFMON2iidGRc6JoSNufhteZfeewnc2MbL19Xc6Nbbp5VtWWenNgVuWumuq0o+q1pHNgV6lyVtyhiIlsZYlsZHJdU8+PcM+Ob96ji7+AYd6kjN+kjaVsTsmHZeKplG9KNeCmkH95dnZzdM6NbnleV8SYiXlfWIhsZKJ/dbmQhOy3p6F+de23p4drY1ZOTOixnohrY8SXiLmQg+u1pOmzouaum9WXeu65qH94duavnPHx8dbV1e65qf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABdACwAAAAAEAAQAAAH5oBdgoJbOAMDFFuDi10FQhsiHiBALSMFjFEmHC4PBwcnKCw/DIMFJkYEERhcXDBBNQ4SFoJCHAQKUjEBATIhCSQ5E11bGy4RR1VPAAAaTEkKHSuFIg8YMU4IX18IS1ZcOyovAx4HXAEN2ds3CwYVJQIDIOUBSjbaNusGQxcCFEAnMGRo0KYNQIAUPXTM2NICRZAQCwBo+QKgyZUEBHgU6TKCRY0EVKA0aDAFCRYfED4IKvDDAQkFXAwYSJHARxYaGQYxkJCjw44KQ3oQgECD1CILE1aoKHFBB48PORkReiFAwAwijAIBADs=' border='0'>");
				body = body.replace(/:\^O/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZTAMe3KPjhMFlTTPPYNPzoLIJ8doBmMOvIOe/QN3tsUvrkL+zLOY6AKPnjL3ttUu7OOOrGOoF8doRsL+HPKuDOK4FmMHxvUfLVNYRtLsWnNd69OINrL9ixO+/PN/TaM3xwUfHUNe3MOIRtLzEsIfDRN0xJSvffMdq1OnRqJe7MOIVwLr+aOMKgN/bcMt26OfjgMPnhMIFoL/HUNsKiN4F7dtTDKY+LhPHTNoJ9dj46L/niMLakK8W1KnZzdFlRJJ2QJ+/POO3YLeDMLIJ2JvvnLbWkK4F2JuDNLO3ZLVhSTPniL/rlLllQJD45L/vmLcW1KffeMVpXWI+KhPHx8cjHx9bV1ZCEJv3pKyMfIP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABTACwAAAAAEAAQAAAH0IBTgoI0CQYVDhGDi1NSMRwQISkHJxtSjEkrCwNQATAmHh0sAoNSK0BQQTwEBE9ILzIzl1MxC1BHI1gAAFgjFAEkGFM0HANLEzUAV1cANRNOLS4FCRBQRMvY2AQ6DxYGIQE/VuPk5Ao3EhUpME1U7u/uOQogIg4HJiglUfv8JShKCD5EOOFBCJaDCA9SgKKhx5QNHV4YSXhwSIMLKgRJYSEjAJOEPhoMyGBjkIAZJFoUYcBgB5QLGUgtkoLBxYMbIBBoUFGSkaACFiSI+ICDUSAAOw==' border='0'>");
				body = body.replace(/:\^0/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZTAMe3KPjhMFlTTPPYNPzoLIJ8doBmMOvIOe/QN3tsUvrkL+zLOY6AKPnjL3ttUu7OOOrGOoF8doRsL+HPKuDOK4FmMHxvUfLVNYRtLsWnNd69OINrL9ixO+/PN/TaM3xwUfHUNe3MOIRtLzEsIfDRN0xJSvffMdq1OnRqJe7MOIVwLr+aOMKgN/bcMt26OfjgMPnhMIFoL/HUNsKiN4F7dtTDKY+LhPHTNoJ9dj46L/niMLakK8W1KnZzdFlRJJ2QJ+/POO3YLeDMLIJ2JvvnLbWkK4F2JuDNLO3ZLVhSTPniL/rlLllQJD45L/vmLcW1KffeMVpXWI+KhPHx8cjHx9bV1ZCEJv3pKyMfIP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABTACwAAAAAEAAQAAAH0IBTgoI0CQYVDhGDi1NSMRwQISkHJxtSjEkrCwNQATAmHh0sAoNSK0BQQTwEBE9ILzIzl1MxC1BHI1gAAFgjFAEkGFM0HANLEzUAV1cANRNOLS4FCRBQRMvY2AQ6DxYGIQE/VuPk5Ao3EhUpME1U7u/uOQogIg4HJiglUfv8JShKCD5EOOFBCJaDCA9SgKKhx5QNHV4YSXhwSIMLKgRJYSEjAJOEPhoMyGBjkIAZJFoUYcBgB5QLGUgtkoLBxYMbIBBoUFGSkaACFiSI+ICDUSAAOw==' border='0'>");
				body = body.replace(/;\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZTAPvnLVpSI/rkL/jhMPPYNFlTTIJ3JZ6RJnVrJHtsUvznLPniL6udJ4RtL4F7doNrL9q1OsKiN4RtLoFoL7+aOMKgN4VwLuzLOYFmMI+LhPHUNfrlLt26Oe/QN/ffMfbcMvLVNdixO/niMO3MOIRsL+7MOMWnNYJ8dvnhMP3oLOrGOnxvUfnjL+/PN4BmMO7OOHxwUd69OOLQKkxFIpCEJvDRN4F8dvHUNvTaM3ttUvHTNuvIOYF2Ju/cKo+CJ+rUL+HPKsW1Ke/cK8a2KXZzdPvmLcW0Ku3aLFhSTCMfIPvlLmdeI+/POD44IYJ9dp2QJ/jgMPfeMY+KhPHx8fzoLNbV1f3pK////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFMALAAAAAAQABAAAAfXgFOCgg4JLhg5NoOLU1ITISojJTsQD1KMSBQXBFEDKB44LRUFg1IUTFEbAFRUCkpQNxGXUxMXUT5PVrq6AAM1ElMOIQQbSQFWBwxWMlZFHxwnCSpRAAFLVj0IAQEyVCIvKy4jA1S75lYpAjokGCUo5ee66RoNOTseCvEGVlQLHTA2IOAwcsAcgxkGAESJQWTKgxY/eDShQWMGAiFUWICwIEhKhRsDjgQZAoQKABYETGQYVCBCjQ8iBAhYEAWECVKLpEjg8EKHhg4xLKxkJOjEChINYDhhFAgAOw==' border='0'>");
				body = body.replace(/;-\)/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZTAPvnLVpSI/rkL/jhMPPYNFlTTIJ3JZ6RJnVrJHtsUvznLPniL6udJ4RtL4F7doNrL9q1OsKiN4RtLoFoL7+aOMKgN4VwLuzLOYFmMI+LhPHUNfrlLt26Oe/QN/ffMfbcMvLVNdixO/niMO3MOIRsL+7MOMWnNYJ8dvnhMP3oLOrGOnxvUfnjL+/PN4BmMO7OOHxwUd69OOLQKkxFIpCEJvDRN4F8dvHUNvTaM3ttUvHTNuvIOYF2Ju/cKo+CJ+rUL+HPKsW1Ke/cK8a2KXZzdPvmLcW0Ku3aLFhSTCMfIPvlLmdeI+/POD44IYJ9dp2QJ/jgMPfeMY+KhPHx8fzoLNbV1f3pK////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFMALAAAAAAQABAAAAfXgFOCgg4JLhg5NoOLU1ITISojJTsQD1KMSBQXBFEDKB44LRUFg1IUTFEbAFRUCkpQNxGXUxMXUT5PVrq6AAM1ElMOIQQbSQFWBwxWMlZFHxwnCSpRAAFLVj0IAQEyVCIvKy4jA1S75lYpAjokGCUo5ee66RoNOTseCvEGVlQLHTA2IOAwcsAcgxkGAESJQWTKgxY/eDShQWMGAiFUWICwIEhKhRsDjgQZAoQKABYETGQYVCBCjQ8iBAhYEAWECVKLpEjg8EKHhg4xLKxkJOjEChINYDhhFAgAOw==' border='0'>");
				body = body.replace(/:8\}/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZcAPXgOoFRK/TbO+7HO+3CO4J5dXtiUPLVO/DNO+/KO/PZO/PYO/TcO/HSO1lQTIJ6deiuOu7IO9ePN/PaO+7JO+7GO755M+myO+amOumzOvHRO+q0OvLWO+itOntlUINZLIFTLOmxOuu4O4JWLOaiOb+ANNaLN+eoOtmaOINcLMGHNI+Hg3xmUIJXLNmWN+jWOLOlMuy/O+y8O4JYLO7FO+enOu3DO+irOuiqOr+BNPLUO/DPO/XhOsGyNOWgOejUONnEOKaZMM25NsGxNLOkMnJoKqeZMWVcKPTeOzEuJHZzdOu5O+jUOZqNL+WfOfLXO4x/Lc26NuisOvTdO1hQTCUiI6aXMOjVOKaZMefTOY+IhPXfOvHx8dbV1fXiOv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABcACwAAAAAEAAQAAAH4oBcgoIFBgEBBgWDi1wrICY+NSckEiNajFQWGCI2AxE0MjclDoMrFlIEOwcLChwaFRk5l1wgGAQNE1FbAFlABwMQH1wFJiI7E1tVRl5NSQwNMS4PBk42B0g8WENePUFbCxQ4HgE1AwtbXunqAAIIIS0BJxEKAOrr7RczBiQ0HFtXL9S9YKIgQQcWBSTI0MDgRxEYXmAcEaKDAAolXEbcqHCAwRYiUKxMeZJgQwpBWkpkGNBggQABCnQkWKJiFhcHOSDEoIAAQQICG1SQWqTlgwscIS50QJHCJqMHHlrMYPGAUSAAOw==' border='0'>");
				body = body.replace(/:_\|/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZpANDn8YaKjrLV60dpgMji78Xg7np8gKrR6lBSVjg4Oszk70xJSjxlfoiKjp7L6GNpbsni71VbYEVof4rB5G6evsbg77HV67XX65fH5rfY7I3C5afP6ZLE5WaavU1rgc/m8bjY7GSavM7m8Hh7gJjI5onA5Hh8gJbG5klpgJDD5Ye/5JjH5lqWu4eKjnix1nmDiGRqbrDU61hreV1uemiq1G+t1aW1vbq5uXqDicXg71lseT1lfl5uer7c7Y7D5YK9432z10Bmf6LN6LTW65mnr5CvxJi60KjD06/T6n+84py80avS6s7l8LrZ7Mrj74/D5Tg3Opinr8Pf7n+74nyKlIqfrK3T6oierJ/L6J+xu8He7lFTVm93e8Dd7qzF1HZzdMfh75GwxHqDiM/m8MPe7sHd7n2LlKCyu83l8PHx8dbV1SMfIP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABpACwAAAAAEAAQAAAH54BpgoIjMgw7OiaDi2kBQTRJJRM/NRIBjAgsKg5FFgJhQj4hCIMBLE9GVxEFORFVSisdLYJBKgdUWQpoaApnZjEcKGkjNA5NYGgfAMtMED0bLgYyU0taCh82MDA2AGgFAhozDCUWBWhiCzc3C1wiBBknAzsTAjlRa/j5RAQgGAM6P6yQSZAvX4IKQ1LwMFFDyBEoD17gwPHiQQIvB4B8SSPBB5IyENCIGIPGiZQLJDwIChBiRYweBQgQqNDlAhYKDQYh6MBhg4AMIIYcIEFhC6MWKFxoOIEhBRAPORkJMjBjwAAeBhgFAgA7' border='0'>");
				body = body.replace(/\?:\|/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZoAIJ9dvTcO3xzUvjiOevQPu3TPYNyMPzoN/rkOHtxUurOPvLaO1lUTPbfOvfgOe/WPeLPNIF9doBvMejMP+fLPyMfIPTdO+3SPfXdO8CoOti9PevRPvXeO4FwMO3ZNmdeJ8KrOezRPoR0MPPcO9e7PoJyMNzBPdTDM4FvMYJxMPvmOPDXPPznN9rAPcCnOtnDON3aOL6kOvvlOKy7RMGvNMWuOGeDcJavSe/WPNzCPefROT44I3ZzdHaPZtnUOvHZPMvFQXCKa8u3NtTCM73KOsa1MfPbO93KNp6xTXyTYnVqKenNPv3oN1hPJ4edXJCELLamMWiEb4aiU77LOu7UPYB0K4mnR/njOVhTTJCDLNrVOniGeM/GPvfhOY+kV5aqUp2QLca2MVlRJvnkOJOlVH+XYbXCP73JOvHx8dbV1Y+LhP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABoACwAAAAAEAAQAAAH4oBogoIRCRIoCQCDi2hqHSQUCgoTGilqjFgxOQ8LATpGKwQuDINqMTUvDQNQCFcOIwUZl2gdS0JNHixgRSwqAwEhBmgRJA80FWFMFU9rX1E9QC0ACRQLRzsQax8nU0FEUkkEAhIKAWMHa+npMAdmNhclKAoWCOjqazBIW2QFBgkTL6p8yKbOi5MZGDYIAKBhhQMPYk6oK3NmwAITPNCkIDBigIosSoYcuKGFAxURgtS4KBCgCwIZMhD44IADxCw0DDKE+GGhQQMMVriAILVIjYEWBC4U2GBCxE1GAASUMLCQUSAAOw==' border='0'>");
				body = body.replace(/:O/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZoAIJ9dvTcO3xzUvjiOevQPu3TPYNyMPzoN/rkOHtxUurOPvLaO1lUTPbfOvfgOe/WPeLPNIF9doBvMejMP+fLPyMfIPTdO+3SPfXdO8CoOti9PevRPvXeO4FwMO3ZNmdeJ8KrOezRPoR0MPPcO9e7PoJyMNzBPdTDM4FvMYJxMPvmOPDXPPznN9rAPcCnOtnDON3aOL6kOvvlOKy7RMGvNMWuOGeDcJavSe/WPNzCPefROT44I3ZzdHaPZtnUOvHZPMvFQXCKa8u3NtTCM73KOsa1MfPbO93KNp6xTXyTYnVqKenNPv3oN1hPJ4edXJCELLamMWiEb4aiU77LOu7UPYB0K4mnR/njOVhTTJCDLNrVOniGeM/GPvfhOY+kV5aqUp2QLca2MVlRJvnkOJOlVH+XYbXCP73JOvHx8dbV1Y+LhP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABoACwAAAAAEAAQAAAH4oBogoIRCRIoCQCDi2hqHSQUCgoTGilqjFgxOQ8LATpGKwQuDINqMTUvDQNQCFcOIwUZl2gdS0JNHixgRSwqAwEhBmgRJA80FWFMFU9rX1E9QC0ACRQLRzsQax8nU0FEUkkEAhIKAWMHa+npMAdmNhclKAoWCOjqazBIW2QFBgkTL6p8yKbOi5MZGDYIAKBhhQMPYk6oK3NmwAITPNCkIDBigIosSoYcuKGFAxURgtS4KBCgCwIZMhD44IADxCw0DDKE+GGhQQMMVriAILVIjYEWBC4U2GBCxE1GAASUMLCQUSAAOw==' border='0'>");
				body = body.replace(/:0/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZaAIJ9dvznN+rOPoNyMHxzUnVrKXtxUvjiOfrkOPTcO+3TPVlUTOvQPvLaO/TdO/vmOO3SPfnkOO7UPefLP+nNPti9Pde7PllRJufROYF9drOiMujMP8KrOYBvMfrlOO/cNvnjOb6kOuvRPmdeJ9rAPZ6QLcCnOoJyMLipMNPBM4R0MNzBPf3oNzArIvXeO+zRPoFwMIJxMFpSJvbfOsCoOvHZPPvlOIFvMd7EPFhTTODHO3FlKvznOPPcO/XdO/PbO/DXPKeXMN7FPHZzdKiYMK6bNLWkMaOTMfnjOKWUMcKxM3FmKq+cNMa2Md3INr6rNLWlMffgOe/WPd3JNr6rNcOyMse2Me/WPCMfIPzoN/Hx8dbV1Y+LhP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABaACwAAAAAEAAQAAAH4oBagoIZBh03BgCDi1pcMBYTAgIbFTFcjDkhFEVUCQ5PTDgmC4NcIUI7RgcRCCBQSzo0l1owFEdKHgFZWQEPVUkvA1oZFlJBHiglXV0lKA9ENSQABhMNBwEXMssyFwEIDgwEHQIJEVkFI8sjBVk2MxAnNwIOCFldH8v4LO4KAwYbP0AEWEawSxYEPkQQAFABSJQHWZoUKGCFBY8DDVYM0RKDQY8DKbCIxJICiQsJKgRxMaEggZMWIltMcXGFwywtC2i8qIFBgwYMDSRwILWIywASDCAoELFCxU1GAAicGLCQUSAAOw==' border='0'>");
				body = body.replace(/:\|/gi, "<img src='data:image/gif;base64,R0lGODlhEAAQAOZJAJCELPjiOevQPoJ9durOPntxUvTcO/TdO/rkOHxzUu3TPYNyMFlUTMSzMvznN/HZPO3SPe/WPdzBPevRPsKrOe7UPf3oN4JxMPXdO1lRJoFvMcCoOvPbO/vmOPXeO/nkOIR0MNe7Pr6kOuzRPufLP1pRJsCnOoBvMfDXPPPcO4JyMIF9dvvlONrAPffgOWdeJ/njOYFwMNi9PejMP+nNPvfhOcSyMs+8NVhTTJ6QLfnjOJCDLJ2PLfrlOI+CLPznOHZzdO/WPJ2QLY6CLNC9NKudLvLaO/bfOvzoN/Hx8dbV1Y+LhP3pN////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+JzxDT1BZPkNvcHlyaWdodCBKaXZlIFNvZnR3YXJlIDIwMDItMjAwMwAh+QQBAABJACwAAAAAEAAQAAAH2IBJgoIrBScaBQODi0lLMSEkBAQzMhdLjDgiNBFGBgccKAImDINLIgJGRwEfCDAuKQobl0kxNEY1Qy9ISC8+AQYjC0krIRFHPRklTEwlGR01Dy0DBSRGAQ45AMsARQ4IBwIJJwQGH0jL6ExILEcQKhoEBwjn6UwW7AoLBTMcMA716hBgmJBggAwULjrQW2bhRwAjEoAkuSAgRQAeOwBoFKLDQwUQgpaYUGDgho0GKIl4CEJhVhIGG0Y8OHDkCAYjFSiQWrRkQQsBEBRMkADCJaMBCVQsKMgoEAA7' border='0'>");
			}

			return body
		}; 

		self.urlParam = function(name)
		{
			var results = new RegExp('[\\?&]' + name + '=([^&#]*)').exec(window.location.href);
			if (!results) { return undefined; }
			return unescape(results[1] || undefined);
		};
		
		self.startAudioAlert = function() 
		{
			if (this.audioPlayer != null) {
				$(this.audioPlayer).remove();
			}

			this.audioPlayer = $("<audio>")
			.attr("id","audioplayer-messaging-" + Math.random().toString(36).substr(2, 6))
			.attr("autoplay","autoplay")
			.attr("src", "data:audio/wav;base64,UklGRqj8AQBXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZmFjdAQAAAAefwAAZGF0YXj8AQAI AAgABAAIAAMACwAFAAcABAAHAAUADAD8//7/EAARAPb/9/8UAB0A4//i/zcAQACK/3v/cwX3BbcG XwdGBcsFxweQCF8KcAsZCjIL6gn6CqcL5gymC/AM5womDN0KIQz2CkUMoAnOCqYIuwn4B/8I1wbB BwUFyQXIA2MEaQLdAr8ACAHp/gD/af1U/bD7afvy+X75R/ii98r29fUt9Sr0v/OM8m3yD/E68bPv EfBf7ifvWu1k7nzsvu2/60ntNesY7fPqGO3r6kftFuu77ZHraO5F7FbvTe1x8ITu3vEP8HPzyvFD 9crzPff09W/5Xviv++L6HP6L/YQAOQALAwYDcwW3Bd8HbggaCuwKPAxODR0Oaw/JD08RJhHgEkMS IRQOExAVhhOeFbET2RWFE68VEhM3FUkSaBQ+EUoT7w/eEXwOQxC/DGEO4wpVDN0IGgrJBs4HmARm BVwC5wIdAGgA4P3r/a37d/uE+Q35b/e69m/1gPSO82Dy1/Fy8EDwpe7V7gjtl+2i65bsfurD64/p K+vd6Njqd+jI6lzo8eqB6G3r/ego7MnpK+3b6mnuO+z47+jtt/HQ77TzAvLo9W70RfgQ98z6z/lh /bT8CgCl/8ACpwJcBY8F7wduCFgKJQuZDKgNnA7lD2AQ6BHYEZITARPrFNcT3xVeFIYWkhTKFm8U sBYBFEYWRhN8FUISYxQAEQwTiQ9uEdoNmg8ADJENAwpgC/EHFwnCBbMGiAM7BEwBuAEQ/0D/1PzF /Kz6WvqL+P/3kPbJ9aX0mvPk8qTxPvHD79XvMe5+7q3siu2V637sX+qb7b3rW+136x3tIuvP7fLr be6e7L7vHu5P8LTuCvKn8KXzcvI49Sr0G/c79lr5u/g8+8b6kP1V/c7/0P9ZApwC0gRaBfEGpQcw CR4KHws9DOQMKg5wDtsPyg9OEb4QXBKJETYT4hGUEysS5BNOEg8UthFhE/oQiBLiD04Rog7nDyMN PA58C2MMqAlaCsIHQAjEBQIGugO8A44BUAF2/wD/ZP21/Hf7lPqL+Xb40PeO9if2vvS19DTzUvO1 8UjynfAQ8UXvs+/B7TTvRe3D7tfsne687JTuvOzM7grtMO+D7cnvNe6H8BrvffEy8KDyffHj8+Hy Y/WK9Bf3bvb0+Hn45fqm+vX87/wP/zX/QgGdAV4D8gOWBVQGkAd1CM8J7wokDIUNsA0vDy8PzBBW EAUSSxENE+URrRNCEg4UPhL+ExISvRN1EQgT1BBUEhgQjBGwDuwPNg1CDnwLVAyxCU4KtwcgCMIF 6wWzA6ADtAFpAaL/H//C/Qn9r/vG+oX5WPjd94j2M/a49Mv0M/N188XxX/Kg8GPxlu+z8N3uCvAx 7r3v+O05727tr+7K7APvQ+1X767t+u9u7rnwS++u8WnwzPKr8Rj0IfOS9cb0JfeI9vb4jfgJ+9L6 Ef0R/TH/aP9cAcsBkQMtBLQFjAbIB8wI0wkEC58L+AxiDd0Ovg5REEcQABK6EZ4TSxIxFLoSoBS8 EpoUlBJhFA0SwRNMEe0SShC9ERMPXRCdDbgOAgzsDJ4KcgsRCcIJ7QZdBxUFWAUWAyMDRAEpASz/ 0/52/f38l/v4+vL5LfkW+CP3MfYM9eb0pPOa80DymPIs8bjxPvAU8Z7vf/D77inwqu7z73vu7e92 7iTwuO5Y8PLuqPBN74TxQvB18k/xpvOZ8hb1KfSG9sH1KPiD9+b5YPnR+3L7tf18/fr/9/93ArcC ewTgBJ8GOQeVCFIJgApgCy4MLw2+DeMOBg9DECsQghHuEFQSsxEsE08S6BM0EsYT9BGFE14R3RJs EMMRYg+mEC0OVg/ODNMNPQsoDJwJXwrGB1oI1QUxBukDHQTxAf8BBADl/yL+1v1Q/NT7mPr6+ff4 Lvh796L2B/YM9eP01fOC81DyEvK48G7xDvDG8FfvavD87knw4O468N/uWPAB76vwW+8f8dfv0fGc 8KHygPGq86Xy8/QI9G32o/UK+Fz35/lv+bD7V/uu/X39qv+b/8gB5wHCAwUEEgaMBoQIPwlTCjEL HwwmDbAN0Q4RD1QQDhBfEfUQXBKLEf8S4BFfE/kRehPDEUATZhHeEt8QTxLUDy0RtQ71D0kNaA6e C4kM+QnECjcI3whyBu8GlQToBLwC5AKyAKwAkf5M/tL8afz8+mX6Wvmp+NH3/vZx9oP1HfUV9Az0 8/L/8tHxRvIQ8VrxC/B08AfvQvDc7h7wuO498N7uivA27y/x9+/H8aHwnvKL8ZbzlfLN9OjzGfZJ 9b33Fvem+TL5c/sb+3X9SP1t/23/pwHbAdEDNwThBW4G4wecCOEJxQqcC6YMcg2sDkwPvhBgEOoR YREGE/IRoBMwEuQTShL7Ex8SzxOsEVITChGjEhsQohEHD2wQxw0TDz4MYw2TCpILxwiYCe8Gjwfv BFcFDgNKAxsBJQFM/yf/b/0h/b37SvvR+Sr53ff/9nf2d/UK9enz7/O28v/ytPEi8s3wa/EP8PDw he+H8BTvbfAD70Hw0e4z8LnuvvBX71rxAvA88gHxYPNM8pX0nfP19R/1effF9if5k/jx+oX6DP3T /Gr/c/90AawBpgMVBLYFVQbHB5AIsQmlCo8LsAwoDWwOqQ4TEM0PTxEAEaYSDBLSE2ESLxSKEl8U aBI5FPURuxMlEc4STBDcETEPphDqDUEPgAy4DekK+gssCREKTQf8B24F7wV3A8MDkAGnAZ7/i//L /Y/9//uU+1r6wvm6+AL4Uvd69rv1ufQS9NryH/PT8SLywfB48QvwBPGh767wRO938ArvfvAV76Tw Qe8E8avvgfEy8CDy4/Ax8xPyYPRe88f17vRP95n2G/mV+OD6gfra/Kn8z/7H/ukAEAHsAkQDRgXY BbYHjwibCZoKgQuwDB4Ncg6KDvYPvg9GEccQbRJzES8T+xG5EyAS3hM3EvwTHBLnE2oRJROXED4S cQ/9EAgOZw+ZDNgNAgsZDFYJPwqQB04I0AVpBtQDNAS5AeQB2f/R//X9wP0i/Lz7avrZ+eH4Lfhf 94n2/vUD9cP0tvOx847y4fKs8dXxg/DR8GHvkvAj70Xw2e5Z8PPunvBP7wDxwe+F8VjwQvIk8SPz G/JA9FLzk/XC9Cr3g/bR+E/4rfpc+pT8b/yj/q/+rgDnAMwCNwPSBGgF7AaxB8UIrwnfCvsL9gxP DlsO0A+pDz8RrRBcEmwRIhPIEYQTARLGE+8RsROnEVwTJRHPElUQ8RFnD+sQSw61D9oMGg5MC2QM kgmDCrQHbwjsBXwGEQRrBDoCaQJjAGgAqP6L/rP8W/yi+hD6Hvlo+Ij3qvYv9jX1APX18/fz1/L9 8s7xPvIC8ZfxTvA88frvx/Bx71nw8+6T8Dvv3vCT72/xO/BB8ijxJ/Mn8j70W/OE9b/08fZJ9nL4 6/dM+vb5bfxL/GP+bf57ALgAkQL+AqkESAWsBncHnwiZCXUKmAsoDGkNrw0WD+MOaxAxENcRYREs E8oRlxMhEvYTBxLbE6cRZxMdEcoSXRD3EWUP6RBHDrAP7gwzDnYLmwzNCcYKEAjZCDoG1gZdBMYE aAKfApkApgDC/qH+Cf2//E371frW+UT5EfhP90H2UPUV9QL05fO78u/ytfEl8uHwp/Fj8DHx6e/k 8J/vw/CB79Dwi+8V8d/vcPE/8OnxyfDc8tXx6fP48jX1avS09hH2QPjF9wH6p/nE+5j7s/2s/aj/ 0P/oAUUCXAT5BEwGFQdbCFoJKApKC9ULIQ1ODbUOqw4xELcPTxGdEEkSJhHdEqERbBMAEtITrxF6 EzwR+hKBEC8Sjg8fEUAOqA8ADUoOgwuoDPoJ9wpNCCYJnQZMB7gENwW2AvkC4gD+AAT/7P5C/f/8 hvsf+/j5a/lr+Lj3DfdD9rr1zPS39LbzbfNU8iPy3PCW8UrwBfGy78HwcO++8HXvyvCM7wfxzO9x 8U3wB/Ly8MvyxfHF89Xy+PQn9GD2sfXx92b3q/lL+X/7Sft6/Xf9cP+X/4EB1AF+AwAEigU5Bm0H RgiRCZQKrAvyDB8Nfw6LDhQQlg83EWMQDhL5EK0SVxERE20RJRNNEQwT2RCRElEQ+xGcDzQReg7w DzENkQ66C+0MCwoPC2YIPAmsBlgH6ARoBRsDbgNWAYIBav9l/1v9HP2z+0z7/vlo+X74zPcZ90f2 3/X39LL0svO286Lyx/Kh8Svy+/Bl8SXwmPBD74jwOe+F8Djvw/CB7yzx9+/q8dPwpfKd8aHzuPK8 9OzzDPZP9Xj33vY9+cj4NPv0+hP9B/0c/0H/HwFrATcDrwMuBdAFLAcACPkI8Qm/CuMLNwx6DdYN Qw9iD/sQMBDZEeYQnxI+Ef8SOxH8EhoRzBK6EGQSHBC4EVIP2BBODr4PJg17Dt0LDg1IClELogiC CecGmwchBaUFOQOHA3cBowGo/6X/9v3H/T387vu4+kb69fhQ+B/3Sfbe9fH0oPSV86PziPLZ8qvx JPLy8JHxV/Aq8fLv5fCq7+Pwpe/g8Knv+vC/75zxc/BW8kbxUfNa8pD0ufPW9Rn1SPex9uH4cPif +lL6XPw1/IP+i/7PABsByAI/A94EgQXVBqwHtwi7CWkKigv4CzwNWQ29DoYOARCHDxYRKRDHEcoQ exJRERoTHxHdEt0QkBI8EN4RUg/YEFQOvQ8wDX0O2gsGDW4KdgvZCL8JMgfsB1sF4wWPA+8DvAHl Afz/+v8r/gD+iPwz/Ob6avps+dP46fcu97H25fU79UX0vPOZ8unyufEa8trwifFA8B7x0e8E8cPv 6PCo7wnx1u9R8SLwwfGa8GvyUPE48zzySfRd85L1zPQD92D2nPgg+Gv6F/oy/Aj8KP4o/hQAPAAT AmoC+QN4BC4G5gZuCGIJGgoyC8cLCg0pDYYOTg6/D0IPyBD9D5YRcBAOErkQYRKxEFESihAuEkEQ 5BFxD/sQhQ79D1oNsw7qCw8Ndgp8C+gIyAlQBwoIngUpBvUDWwQYAk4CIAAjAGn+O/6q/FX8AfuE +nf51fgT+E33vfbf9YX1j/R39G7zevNf8sXyl/Hm8anwAvGg79rwhO+u8Fbv2vCO7znx/++w8Yjw UvI58SfzJvIi9DHzTPVx9LD2+vVi+Nr3Dfql+ej7svvM/cD91v/6/8UBGgLKA0YErQVXBpoHagg/ CSwKFgs3DOMMPg4JDnwPGQ+fENQPcRFVEPQRcRAQEngQGRI4EM4RxQ9MESIPnRA+DqIPOA2GDhMM Rg2hCq4LGgn+CXoHNgi4BUMGAwRgBEACdQKZAKQA4P7B/kb9Af14+wb7lPnn+DL4avfC9t71mvWZ 9I/0gfOm84ry1PKh8TbyBPGu8XLwbvEp8BXxxe/V8H7vJvHl75HxW/A/8hjxDvME8jn0S/Nb9Yj0 vvYP9jH4nvfS+WL5gfs6+4/9df3H/+r/uAECAr4DNQSjBVIGfgdbCDoJNgrdCvsLQwx6DYgN3g59 Du0PfA8DEVYQABKFEC4SmhBGEk0Q8RG4D0URCw+DECwOig8aDVoO7AsMDZMKnAsPCfIJegcxCMcF UwYIBGMEPgJrAoMAiQDE/pb+Hv3K/Hf7Avv/+WP5gfjF90P3a/bH9cr0RPQU82XzLPJ78jTx7PGc 8InxPvA88fDvEfHG7yXx2+9N8QnwvfGC8DjyDfHr8tDx9/P38i31RPSI9sf1IPiJ98H5T/mI+z/7 Vv0z/UX/TP8oAVkBRgOtA5kFQgZkBy4IOAkwCsUK4wswDGoNYA20Dm4O1g8kD6MQwA9EEf4PjhE3 EMwRRRDfEcQPTREZD5UQNg6aDyANYw7BC9YMaApfC+EIswlbBwsIuwU9BhIEZgQ6AmcCVgBHAJ3+ af7d/Hn8QPu6+r35FPlR+IH37PYA9sH1vfSg9IHzwfOQ8q7yaPGY8THwOPHO79fwZO+/8FXv7/CP 7yfx1e+N8UjwJfL28Ofyx/HS88jy/vQT9Fr2jPXg9zv3hvkL+VH7+fov/QL9Jv8u/xgBRAEPA24D 8AR6BdkGiAeCCFYJYwpoCzgMcw1jDbMOfg7oDzQPsxCuDy4R+g98EQoQkBHTD1EReg/yENEONRAa DmwPLQ1uDuMLCA2OCo0LCQnZCVEH8we0BTMG/ANMBE8CbwKVAI8A+P7N/iL9wvw5+6H6t/kC+Tb4 VPfX9tz1m/WD9Jz0ePOn827y2/KO8Tby6PCx8VvwYfEH8P/woe+38E3vD/Gs72fxFPAX8tPw8fLS 8ejz3vIN9R/0UPZ/9br3BvdN+b/4IPu7+jH9Af0N/wb/DwE/AfcCUAPwBHEFvAZsB4EIWgkPCgcL kAutDLMM6Q3+DVEPHw+cEJ0PHBH0D3oRBRCNEdEPSxE/D6cQpA76D8gNCw/KDPANpAuyDFQKQAvj CKkJRQfjB54FFAbjAyUEJAI4AlkAPwCw/nD+/vyT/Gz74frg+TL5iPi79/P2+/VR9Sj0T/QV80Hz 8fGB8iTx8/GV8H7xGfAj8bnvAPGa7/jwk+8y8dnvdPEg8Nvxj/Cw8n3xpvOM8tf02PM29l/1pvf1 9kP5sPjt+oT6vfx8/Ij+aP6YALIA3wI0A7cENAWhBkoHWggnCfkJ8ApaC2oMnAzHDaYN5g52DscP Eg9yEGAPwxCeDxARwA86EUUPrxC0Dg4QzQ0RD6oMxg19C3cMKQoFC7cIbgk6B8wHogUOBukDLAQL AhgCWgA9AJX+Tf7w/H38Svuu+tD5E/lV+HX3E/cQ9sj1sPTR9KnzmvNR8lzy8fDO8VzwSPHN7/nw fO/a8F7vAfGZ7zLxzu+a8UPwIPLW8NfyofG8853y1/TU8xz2NPWT99T2MfmW+OL6cPq+/Hr8kf53 /n0AkABaApMCQQSkBP4FjQbwB6kI8QnjCkoLVAycDM4Nng3jDl4Oqg/tDkcQSQ+oEFsPvBBDD58Q 4A42EGkOsw/LDQUPvQzZDZcLnAxAChcLxwh8CRsHnQeOBewF2wMQBDICQAKGAGoA7/6u/hn9qfw2 +5P6vvn4+Dn4Tvf19uf1xvWg9Lb0evO983Py9vKe8UTy4vDT8XTwRPHN773wOO/g8GbvB/GW73zx G/Am8tzw4/Kn8cnzqfLe9NzzF/Yo9Wb3mPYB+V744fpq+pn8RvyA/mH+ZABvAFACiQIlBIQE/QWM BqgHVghPCR4KpwqVCyMMOA2SDdAOUw6fD/AOTBBGD6oQYQ/BEBoPaRDHDhAQLg5mD2gNkg56DI4N WwtRDBsK7Aq/CGsJKQezB4wF8AXhAxIEHAIjAnMASwDH/nX+Lv2y/JH7+/ok+mr5hvig9832s/Ww 9Xn0gPQ385zzP/Lf8n7xQ/LW8MLxTfBv8fjvOvHH70Px0e9K8dvvbvH77wzyr/DE8nzxuPOM8s30 wPMr9j31hve49hX5a/ip+iH6Yvz++yL+5/0sACIAWQKGAiQEegQNBo0GtQdcCEUJFwqyCqAL+wsG DfsMHQ7iDRkPcQ6yDwYPUxB2D9EQPQ+VEO8OQRBTDo4Paw2JDnkMeg1YCz4MEwrcCq4IVgk+B8MH pQX9BesDFgQ7AjYCgQBVAM/+ef4r/ar8kPvo+hX6S/ml+L/3W/dU9h/2/vQd9fHz5vOZ8rDyPPEj 8qfwlPEM8Ezxye8/8cTvQvHO723xAvDI8WbwRPLs8PXyrvHC85byy/S58wv2EvVt95z29/hM+KX6 J/pZ/Pr7Lf76/ff/5P/WAfABiwPMA5MFCAahB04IKAnyCaAKjwvjC/AM7gwXDrEN3g5TDowPrg7x D9oOGRDMDgsQew6yDw8OPg+CDacOfgyNDW4LXAwcCuoKngg8CSQHmweaBesFAQQwBF8CYwK+AKAA Av+4/iL9oPyb+/f6B/o2+aX4tfdW90n2KvYI9Qv10/Ml9ODyUfPy8bvyV/EC8o/wSPG+7zjxr+8r 8ajvZ/Hz7+LxfPBm8hLxE/PV8ejzxfLx9OXzCvYQ9W/3lPYH+Vf4pPoX+lj8+vso/uv99//p/9kB 8AGgA+QDbgXcBRAHoQesCGMJCgrWCoMLewzrDBAOtg3nDl4Oow+1DvwPxg4GEK4O6A9jDpIP2w0D DzENRw5IDEMNRQspDBwK6AqxCFoJOge4B6cF/QX0AxUETgJOAqoAfgAU/8D+c/32/AP8ZPtU+ov5 nPii91f3Q/YQ9uH0AfW88xX0t/Je8/3xtvJL8T/yzfDm8XDwsfE58LXxQfC18UTwy/FY8GjyB/EQ 88Tx/PPG8hf1B/RE9kr1jfe39v/4SPiA+u35HPys+/39tP0VAAYAzwHqAbAD+QNoBdUFGwewB6II UwkSCukKRQsvDGQMaA0pDT8OAg4vD7YO/Q/PDhcQxg4EEHQOtw/uDRoPEw0gDjcMLw0mC/4L+wmz Cq4ITgk+B7sHtAUHBgoENARnAmYCtgCMABz/xP55/fj89PtT+3L6r/ki+Tv4w/fI9rH2lvVl9S70 CPSo8ljz7vGd8izxNvK78Pfxf/DM8VfwxvFX8PTxivA78t7wtfJj8UzzDvIH9NvyFfUD9ED2R/WT 97z2A/lQ+KX6G/o7/NT7/P26/a//l/92AYYBLANcAx8FgwUfB7cHlghWCRMK7wpCCz4MRQxUDR8N PQ7EDfAOJw5ZD2YOnA9SDogPNA5hD+0NHg8uDUkOUwxXDTkLIgzrCaoKnAg1CS0Hpge0BQYGLgRb BJwCoQLqAMcAGv/H/o79F/3x+0v7ffqz+R35OPjW99n2n/aH9Zz1bvSf9Fvz7/Oh8hLzqPEs8rHw 7fFw8LnxOvC+8UHw5vF38GPyC/HW8orxe/NG8k30JvM+9Sv0UPZZ9Zn3xfYh+XD4rfog+k/87PsB /sP90v/B/5EBpwFZA5UDAAViBawGMQciCMgIwgmOClsLXwxZDGkNRg1sDt4NEg8zDmcPXA6QD1QO kA8RDj4Ppw3IDvoMEw40DDwNUgs+DBsK6ArMCHQJXgfeB9sFOAY2BF8EpwKsAgYB5AB+/zj/7v2C /Xb87PvT+hr6J/k9+Or35/al9ov1ovVx9Mn0hvME9LLyXPP88eXyhvGB8hvxWvL08Cfyv/AD8ovw Z/IF8d/yi/GN803yc/RU82P1XPSF9pf1u/fr9hr5avh8+uv5M/zI+xL+3P3D/7X/jQGmAUoDjQP/ BGgFmwYmByAIyQiECVQKvgqhC9QLzQynDLYNeg2hDkEOfw9cDpoPZA6kDxsOTA+LDaUO5AzuDQ0M CA0TC+4LAQrFCrsIXglbB9wH2gU0Bk4EgAS2Ar0CFwH9AHj/Lf/1/Yr9bPza+wP7Vfqk+dL4ePiO 9xH3Bfaq9XH00/SJ8/nzovJZ8/vx3fJ38a7yTPFz8hXxc/IX8YnyOvHO8n/xQvMH8sbzmPJz9Fbz dPVx9I32pPXJ9//2PfmZ+K76LPpB/OH71P2U/YP/a/8pATQBCwNBAw4FewWVBiYHKQjfCH4JVQq1 CqILuQu9DJ0Msw01DVUOtA3oDuINFA8NDkYPDw5OD5ENwA70DBIOIgwnDQEL5QvjCasKowhNCUoH zwfaBT4GcgS5BNMC7AIhAQoBj/9N/wP+nP16/Ov7CftZ+rj57fh5+JP3TPdM9k32PPVZ9TT0pvR2 88nzgfLo8obxr/JR8XHyEPF68h/xvfJx8RPz0/F/803yF/Tw8sb0tfOp9bH0uPba9fT3M/dM+ar4 yvpN+lL8+vv7/cz9n/+U/08BagH4AjYDoAQEBSEGowbQB4EIiwlrCrAKqQvKC9wMoAzCDUoNdA6c DcoO2w0SD9cNDw+oDdcORw1sDq0MxA3+C/0MJAsYDP4J0wrHCHgJXwfyB9sFQQZmBKYE2wL2AlgB SgHU/6f/Xf4M/sH8R/wI+1z6wvn++G/4hvdT91D2SvY/9XH1VPSo9HPzC/TO8oPzP/JB8/3x1vKJ 8YTyKPG78mrxAPO38XfzRvIW9PLy+PTt89L14PTj9g32+/c890T5pPie+hr6N/zf+wP+1v2e/5r/ VAF3AfYCPAOaBA0FJAaxBqgHWAj4CMEJNgofCzMLNwxDDF0NQA17DqEN2w7rDTAP3w0oD5QNxQ4z DVsOmwy0DdYL2wzwCtwL7QnBCrQIcAluBwUI+QVsBoIEzwT3Ah8DcAFqAd3/sP9n/hr+6vx+/JT7 BPtC+pD5GvlQ+MD30vZg9k31kPVt9Lv0ifMo9O3yw/OJ8nLzOfI78//xNPMB8kzzF/KX82vy4/PE 8lH0PPMl9Sb0B/Yi9RX3SPZM+KX3j/kB+fX6hfph/BL83/23/W3/aP8wAVQBHgN8A6QEHAVHBuUG rwdvCAMJ2QkuCiALQgtIDA8MIg3CDO0NLg1XDpcN0A7gDScPpQ3kDkkNfg6zDNoN6gv+DOMKzQvZ CbEKpQhdCWgH/gcLBooGqwQJBSUDVQN+AYMB/P/X/3X+L/4E/Z78mvsS+1n6sPkc+Vb4A/gt9/f2 BPYt9ij1LvUZ9DH09fLK85byZfMr8kLzB/JV8yrycvNL8rXzmvIf9A/zqPSm81H1ZPQo9k31Ivdb 9kv4oveP+Qj58fqK+mH8Gfz1/dT9ff+C/xkBQgGpAvMCPgSmBLMFOQZXBwwIAQnkCSIKFAs5C1EM CgwnDaAMyA0SDUQOVQ2NDl4NlQ5CDXoO4AwRDnQMlA3dC+8M7groC+YJyQq1CHkJVAfuB/oFdgaV BOsEIQNaA6YBsQFIADcAs/51/gr9n/yq+yX7VPqr+SD5Vfj/9yD3Dfcd9i32MPVx9WH01vS880/0 NfMM9Onyo/N+8lHzGPKF81XywPOa8jX0JfPe9OjzjvWp9GT2lfVZ95/2Yvi+9435Dfnx+o36hfxO /Pj92/2X/6H/IQFTAbsCEANABLIExAVZBh8H0wd9CFEJlAl6Cs8K1Qv4CyANjgzFDRANTg5QDZQO WA2bDhINRQ7FDO4NNwxYDYwLmQy4CrMLugmdCpwIZQlmBxIIBwaPBqUEBgUzA2oDpgG5ATgAKwDH /pr+af0g/Qz8m/vc+lH6evnO+A34Mvcc9zT2LvYs9Xv1bvTu9N/zffRk8yP0C/P38+Dy2vPC8vvz 7/Ic9A7zUfRB8+z08vOc9bP0ePap9Yb31/aV+P/3xflN+Qj7sPpt/DT8xf2k/Wj/c/87AW8BugIS A0cExwTCBWQGKwfrB2oIRAmUCYYKlgqdC20LgwwcDEgNjwzDDf4MPA5UDZ8OGQ1bDtMMDA5BDG8N eAuKDJ8KngukCYsKkAhZCWUHGAgZBq0GugQqBTQDdwPKAeoBSQBIAN/+vP50/Sv9Jfy7+9r6Vvq9 +Rv5mvjZ97b36vak9sL1j/WG9An1+vOA9GvzNvQY8wf07fIc9A/zMfQo83b0e/PO9NnzS/Vm9Oz1 F/Wx9vL1lvfs9rD4Hvjd+Wz5KPvQ+ov8Wfz1/eT9b/98/+oAGQFoAr0C1ANABHYFDAYqB/MHVwg5 CY4JkgqECpoLUAtyDPULIA1vDKkNrwzsDdAMCw6sDOgNfQy2DSYMXQ12C5IMpgqsC6sJmwqRCGcJ SAfxBwUGkAauBBgFWAOkA/cBIwKXAKkAGf/8/ov9Qv1G/N377/pm+sv5L/m/+A74z/cM9+72FvZC 9mD1pPWy9EH1RvSy9K/zM/Qh8zf0LvNL9ELzlPSX8xD1JvSY9bz0NvZ09f32Tfbf90H30vhI+P35 j/lR+wz7pfx6/A3+B/6C/6D/+AA3AXsC3ALqA2gEVgX0BagGXwfrB8AI/gjsCS8KOwtSC4AM5Asb DWsMqQ2gDOkNowzcDYMMvQ08DG4NxAvvDCkLRAxiCmgLewlvCn4IVQlFBwEIAgadBq8EJQU+A4sD 4QEMAnkAhQAj/xD/0f2c/ZH8Qvw1+8H6xPkq+cL4FPi99+/28/YZ9kf2ZPW49cn0PfVL9PX0/vO5 9MPzufTD86P0r/Om9LDzGfUu9Jv1wPRB9n71CvdX9gf4c/cB+Yn4HfrA+Uf7A/uG/GD81/3J/Vj/ df8IAVEBcwLUAuoDdgRIBfEFnQZeB88HqgjxCOQJ4wnsCrwK1wtXC3sM9gs0DYYM0Q2JDNUNegy/ DSsMbg2aC8IM+QoSDDUKNQtNCTgKRwghCTsH9Qf6BZQGpgQeBVADpwPnARwChACWACj/GP/P/Zn9 jvxB/FT75/pB+rn5K/mP+E34ofdG93z2QvZa9b311PQ39T/09vT+89n05/PP9OTz5fT98xj1OvRs 9ZP06PUf9Xf2vPUc93b2CPh29wX5jvge+sH5Xvsh+5z8gvzy/ff9Sv9o/7cA8wAIAmECmwMZBEUF 7wWGBkwHyQesCN8I3AnbCe0KlwqyC0ILagy1C+kMAQw+DScMZA0TDE0N7AshDaUL4Az+CiEMSApW C1QJTgo8CBYJHAfdB/AFigaxBC4FbgPMAyICXgK1ANAAM/8l/+39w/2Z/E/8cPv/+lb60/lW+bf4 Xfit95D32vbX9gz2WPaE9a/1yvQT9Rz0+vQB9OD06vP79BH0PPVU9LH15vQn9mb1x/YZ9nL31fZF +Lb3MPm1+ED65PmA+0r7ufyg/A3+DP5g/4L/zQARASYChQKHAwUE1ARwBR8G1gZBBwcIhQhsCcIJ 1gp6CqMLLwthDJ8L1gzVCw4N7AskDdoLEA2bC8sMOwtkDKYKwQsCCggLNwkoCjUIEAkYB9gH6wWK BpUEDwVSA6wDBAI/ArIA0wBm/1z/N/4a/tv8m/xq+wf7XPre+VH5uPhi+LP3lPfa9vr2MvZu9pn1 +PUg9bD10/R49Zv0b/Wb9GH1hvRe9YH0xvX69Dj2d/Xb9jD2pfcT93X4+/dl+fz4Z/oS+nv7Pvui /ID8+f32/Xj/of/HAAcBNAKVAoID/QPRBG8FCgbBBjQHBwg3CCEJNAkvCu4J+wq7Ct8LfAuyDLcL 8AzYCxQNxwsADYwLvAwFCyMMewqMC8EJwQr/COYJDQjgCP4GvAfgBXwGnQQdBVkDsgMGAkECvQDV AGP/X/8p/gr+5/ym/MD7aPun+jb6tPku+Zv4+Pd897j24PYQ9jr2WfXU9ez0j/Wp9GD1gfRJ9Wr0 Y/WG9In1tvTc9RP1P/Z+9bX2/PVx98/2R/i+9z75y/hH+ur5ePtB+6j8h/zu/e/9Lv9M/4kAywDZ ATICZQPcA/gEnwUxBvQGcQdPCH0IcAlsCXMKPApMC+UKCgxbC4gMvAv2DNMLCg3oCyQN3wshDW0L oQzhCggMJgo4CzAJKApGCCQJLwfxBxAGtQbcBGMFqQMZBEYClALbAAABjv+Q/z7+IP79/L38y/tz +7L6Qfqx+Sb5vvgd+O73P/cv9272n/ba9ff1HPVT9WH0LvVG9A71IPQo9T/0bfWW9L718fQp9m31 vvYL9mD3vvYs+Jr3Ffmd+Cb6zflP+w77jvxq/Nb90v00/1P/lADLAPUBUQJLA8IDpQQ4BeMFkwZE BxUIrQioCZEJoQp7CpwLHgtNDJILyAzjCxwNDwxSDQAMPg3VCxANeAunDP8KJgxpCn8LiwmQCpcI fgmDB1AIWQYIBwUFlgXFAzkEeQLGAjMBYwHh//b/pv6d/kf9Gv3Y+4L7x/pS+qr5Gvm8+Bz45vc6 9zP3cPaK9rv1EvY89af1yvR29Zf0L/VO9Pr0EPQw9U30e/Wi9PL1I/Wa9uP1Rveh9hX4gff9+ID4 //mg+RD7wPpa/C38w/2+/R7/Nf+JAMQA8QFNAl0D1wO4BFAFAwa2BkEHFQhcCEUJZQllCjIKSwsQ CzoM2wsgDSQMag1YDKUNRwyNDfwLOQ2dC9AMFws7DGgKegucCZkKqwiVCZwHbAhyBiUHMgXIBeoD XQSWAuICNQFgAeT/8v+Y/on+Xv0v/Sb81vsY+7T64vlf+ab4/PfQ9xr3B/c59mb2jPXp9QD1nPW7 9Ff1c/Q89Vf0OfVd9Fv1ffSm9c309PUq9WT2pvUj93b27fdT9+P4ZPj2+Zn5GfvR+k/8J/yR/YD9 5f72/kMAbQDHARoCdgP0A8IEWQUnBucGWwc5CIAIdAl/CYYKZQqCCw4LNQymC98M+As2DUwMlA19 DNANOwyHDd8LHQ1WC4YMmwq4C60JqQq9CKcJpwd2CIgGOAdRBeYFFASMBLQCBwNBAW4B8v/7/5n+ f/5W/R/9F/zF+wH7lPrp+Wn5+/hk+BT4Z/dk96n2jva+9b/10/Rp9YD0GvUy9Ar1HfQh9T/0RfVt 9I31tfTz9Sv1dva69Rz3b/bf90v3zvhL+Nv5cPkD+7T6P/wV/Jr9h/3r/gP/WwCLAL0BDQIuA6AD fgQNBQEGuAaPB3EIqgijCbgJzAqgCsgLXguWDNILDw04DHkNZwyrDWsMtA07DIMN4QseDXMLoAzf CgIM/QkGCwgJ+wnrB70IrAZdB3AFAgYqBJ0E2QIpA40BwwFFAF0A5P7N/mH9JP0y/Nr7/fqD+vD5 Y/n5+FX4HPhn91L3jPa09uX1IfZJ9cr17fRV9Wv06vT28/r0EfQd9S/0YvWD9M71/PRz9rj1EPdh 9uD3SPe7+DT4uvlK+cj6dvoU/N/7h/16/d/+7f5MAHwAvAENAikDoAOOBCIF7QWfBisH9wdkCEgJ WwlVCnAKiAt0C64M8wszDWIMsA2ODNcNdwy9DUMMgg3pCx0NXAuDDLUK0QvnCeoK+wjmCfcHxwjB BnYHgQUUBjUEqATaAiwDcQGhASMAMADR/rj+kv1f/Vn8B/xC+9r6Avp4+bz4Dvjm9yf3E/c89nv2 nvX99R31lvWs9Ez1YfQq9UD0F/Uu9D/1X/Rd9YP0mfW69DD2ZfXU9hz2pff+9qH4Gfij+S/5vPpo +vL7t/s3/R39f/57/gEAKQCvAQICEQOBA4IEFAXcBY4GKwf7B0kIMglgCVwKPwpSCwoLMwyVC8AM JAxeDZYM5w2LDNUNZwyuDQUMQQ1+C6oMrwrBC+AJ3wrlCNAJ4QewCLoGbgeJBRYGNgSmBMgCFgN3 AZ8BFgAXAMT+pv54/Tz9RPzo+xX7n/oQ+n75Dflp+Dv4hvdG93r2RvZe9dL14vRY9WD0HPUj9Ab1 FPQJ9Rn0HPU29GL1h/S29ef0OfZx9cv2FfaL9972ePjn93v5CPmc+kf62/ue+y39Gf2H/oz+8v8V AFcBmQHKAiYDHgSdBKwFUQZFBw4IXghKCYMJjApnCn0LIQtEDLQL3wweDFgNUgyLDWsMpA01DG0N 9wstDZgLxwziCvsLCwoYCxIJ/gnpB64IwAZtB4EFDwY8BKkE6gI3A6UB0wE2ADoAvP6b/nf9OP0x /NL7//qE+vD5W/n9+E74Gfhd90z3fvar9s/1DfYs9bP1yvQ29T/0wvTC89L00vPl9OjzMfU/9KH1 xfQh9lT1xPYF9n33z/ZX+L73UvnN+HT6DfrE+3/7CP3l/HP+cf7W//L/UQGNAboCGwMoBKQEgQUb BtUGkgf3B8cIOAkrCnQKjAssC0kMzQv/DDgMcw1xDLENXwyWDUEMcQ3pCw4NcQuHDMcK1wv6CfIK EAnxCQsI1QjXBoEHmgUoBksEtATpAiYDjgGuATsANwDx/s3+qP1p/Xz8Ivws+7T60vks+d74LPjk 9xn3JvdK9oL2n/X99Q31hvWN9D71QvQC9Qz0//QG9PD08/P39PnzX/Vy9N71//SK9rf1Zfeu9kT4 qfdJ+cj4Vvru+Y37P/vB/I38O/4n/tX/7/8+AX0BvAIdAycEowSFBSEG1AaNBxAI4wgpCRMKFwoX C+8KBQyLC6cMGwxKDZ0M3g2fDNwNigzEDSgMWQ2LC6MM4ArnCxMKAwskCf0JGgjhCPYGnQe3BUMG XgTEBAsDVAOnAckBTABJAPT+yP6u/Wf9avwK/Eb7zfos+pX5PvmX+Cf4XfcJ9yH2a/Z49cv1yvRa 9Vn0CvUD9Pf09PPi9ODz9/T+8yT1MvR29Yj07fUM9Xn2q/Ul92f2Efhm9wz5fPgx+rX5bPsZ+7H8 evwN/vL9ZP9r/9YA+AA8AngCzgM1BHYFEwa4BmUHAwjTCA8J9wkICv0KywrVC3MLjgzbCwANLwxY DTgMYA06DGQNEww7DYwLpAzgCu0LDAoHCxsJ9wn0B6sIzQZtB5UFEwZYBLQEBQNJA7gB2wFNAEwA 0f6m/pL9Qv1I/Nj7I/uX+g36afkR+Vj4JPhV91/3gPao9rv1HvYq9XX1ePTc9MPzuvSn8570jPO9 9LDzBvUI9Fv1afTU9e30afaV9R73Wvbs9zb37fhS+BD6k/lE++L6j/xN/Ov9yv1U/1P/zgDtADcC dwKpAwsEBgV8BVwG8waFBzwI1giwCRkKFAvYCuMLiwuoDPILFw0wDE8NOAxdDSAMPQ3UC+gMZAtu DLwKuAsBCuoKIgn2CQ8IzAjlBoQHpQUgBksEmwT4AjEDnwG0AVUAQwAH/9n+yP2B/W/8CfwE+3L6 +flT+ev4I/gJ+Cz3QPdY9pX2ovX59QH1j/WJ9Cz1H/QC9fjzxvS685j0fPPY9M3zI/Up9KP1tfQ9 9lv1EPdK9uX3Lvfh+Ef46vlo+Qz7ovpJ/Pn7vf2P/VH/Tv+3ANYAOAJ8Ap8DBAQLBYsFVwb1BpgH UQi2CIUJuQmfCoMKdwtTC2IMEwwyDUsMbA1nDJUNRAxlDeIL9wxhC20Mwgq4C/QJ2woQCd8JDAjE COYGfQerBSQGXASxBAcDQAOoAb0BUgA/APX+wf60/WL9dfwH/FX7xvo3+pb5SvmP+Db4WvcO9xn2 c/Zu9cf1uPRd9Ur0FPUF9Of01fPF9LTz1fTK8/P07PNM9Un0pvWz9Bv2M/Xd9gv2t/f39rT4C/jZ +VL5//qU+kT89fuS/V79/f7k/lEAVQDpARkCngP5A/cEcwVZBvgGmwdQCMAIjgmwCZEKgwp7CzIL NQyxC7sMAgwXDRYMKg0eDDgNBwwlDYYLkAzoCuULEQr8ChIJ3QkSCLwI7gZ9B8IFNAaFBNcEPANy A94B7gFjAEwAFf/e/sD9ZP2G/A78WvvC+kf6nPlD+YD4XPiK94T3mPbk9vH1HfYU9VT1NfQP9e7z yfSm86/0j/O09J7zAvXz80f1P/Sy9cH0N/ZM9d/2//Wg99b2mvjp97r5Jfnl+mz6JfzL+339PP3r /s/+TwBYAMEB7QEqA3MDjwT3BN4FYgZRB/cHwwiNCawJhAqZCpALOAs8DK4LtAzxCwMNHgwvDf8L EA3LC9UMVAtRDM8KwgskCgYLNwkBCikI3ggKB5oHuAUlBnUEwgQpA1cD4AHqAYYAbgBH/xf/5P2O /Xn8+ftP+7X6Lvp2+Sf5W/g9+Fr3efeL9sb2x/Uo9h/1tPWh9Eb1MPQV9f3zy/Sq84r0Y/PG9Kzz CvX283v1efQd9jD1x/bt9ZH3yvZ1+ML3evng+JH6Cvri+377YP0f/bf+mf4wADgAmQG9AQ4DVANs BNEEygVSBgkHoQc5COwILgn2CTcKHgszCzkMpwuxDAMMEQ0jDDYNDgweDa4LswxNC0QMrgqUC/IJ ygoYCdwJGQjFCPkGiAfMBT0GgATQBDYDYAPZAeYBfQBiADL/+f7t/Zb9vPxF/Jb7APuF+tr5Y/mW +CH4Ovdj92j2nfaQ9Qv29fSd9Yj0Q/Uo9Pz03/Pp9Mnz3PS/8/306vMk9RH0X/VU9Pf1/fSl9rr1 dPef9l34o/d++eL4mfoU+tT7cfsX/cv8df5F/s7/vf9mAXoBGgNdA3AEzgTZBVwGEwewBzwI9AhA CQwKIQoCC9EKvwtkC14MrwuyDPkLBw0iDDQN1AvkDG0LcQzTCsIL9QnNChoJ2QkaCL4I+AaFB8sF NwabBOwERwNxA+QB6AGLAHMAOv/8/vD9kf24/DX8j/vu+nv6xvlx+az4k/i297n3y/YZ9xv2R/Y3 9Xj1T/Qr9QT04PSz89D0pvPi9MPzAvXo80H1N/Sf9Zf0GvYl9bD2z/Vw95L2UfiR90n5o/hd+s75 f/sG+7/8aPzt/bH9N/8Y/2gAXACrAcEBxwLsAhkEYQRsBdsFUwbPBi0HvQfVB3gIUQj4CKgIVgnn CJQJ9AiiCeQIjwmkCEoJZQgACQAIlghdB+EHpAYTB98FPwb9BEAFBgQuBCIDMQM+AjYCWgE/AYIA VACs/2r/yv52/tH9X/0x/bP8e/zx+wT8cPuQ+/H6N/uY+uP6Q/q1+hn6gPro+YD67flR+sH5HPqH +VT6yfmF+gD60fpb+jn72fqZ+0H7+Puz+2z8Mvza/Kz8UP0t/eD9xf2N/of+Ef8T/6n/vf8uAEYA vADYADsBYAGwAd4BIwJQAoECsgLbAgcDFAM/A28DowPbAxwE1wMLBNgDDQS4A9sDewONAzgDQQPv Au0CkwKDAjsCIALNAaIBYAEsAe0AqwBrABwA5/+S/2//A//n/nP+gf4A/iP+l/3L/Un9h/37/Fv9 z/wG/Xf8oPwM/JP8A/x+/PP7hPz++5X8HvzR/Gf86/yU/B/91PxT/Rb9h/1b/c39qv3v/dn9E/79 /Wr+Zf62/rv+A/8T/1f/cv+V/7z/2v8GAAgANwBGAG8AZwCUALsA6gAfAVUBNgFkAWEBjQFxAZYB ewGXAXkBkAFyAX0BYwFeAVMBRwElAQoBIAH/ACkBCQHhALQApQBwAGEAJQAaAMX/sv9N/23/+/4l /6f+5f5j/qf+H/5x/uX9Lv6h/eH9Tf2+/SD9kP31/Hv92vxr/cn8Z/3R/Gf90/yA/f78k/0W/b39 T/2//VH9n/0v/eP9gv0J/rb9TP4G/pf+a/7T/rP+Bf/x/jj/Mf9b/1n/h/+L/6n/tf/M/93/8/8F ABgAKwA1AEoAXAB1AGcAgAB5AJAAewCTAIwAlgB7AIEAogCmANAA2QDFAMcAxwC9ALwArwCqAJgA iwBuAHsAUgBkADYATwAbADwACAAkAOf/FQDX/wgAzP/k/6X/yv+I/6f/ZP93/yv/Zv8W/0z///5B //f+OP/x/i3/7f4V/9D++f6w/vf+sf7u/q7+8f6y/v/+w/4G/9H+EP/h/h3/8P4n//3+Ov8W/zf/ G/8m/w3/Rv8p/1b/Of9m/03/eP9f/6D/j/+l/5X/sP+l/7H/n/+1/6T/tP+d/8X/rP/X/8H/3P+9 /+L/wf/n/7//6P++/+j/uv/l/7X/5/+q/+D/pv/h/5//9/+1/xEA0f8EAMf/FQDP/wsAyP/3/7P/ 7v+q/+7/rv/q/6f/8/+6//z/wv/5/8L/6P+x/+r/vf/n/7//8v/I/+X/wP/d/7z/3//C/+H/wf/t /9f/4v/S//z/8v/U/8n/BQABAIL/cP95BfkFCAalBs4GeQcgCiILtgm6CoEKmgvMCvIL9gkLC1kJ ZApaCE8JqgZ0B2QFDQZ/A/ADxAENAuL/8/8Q/uj9K/zG+4H66/m1+Ob3QPdC9tX1qPSI9CvzWvPX 8VfyqfBl8Z3vu/DW7k/wUO4m8BruTPA97sTwu+6o8bPv4/IF8Y/02/KT9g71//i695z7qvp4/sz9 fgEjAZgEnQSLB+cHTAoFC7AMsg2fDuMPARB8EeMQghIyEd8S7hCrEigQ4RHYDnwQOw26DjkLjQwI CSoKkAZuBxYEtgSOAekBKP89/7D8fPxq+vf5TPiZ90f2U/Vf9DPzp/JE8RDxcu+27+bth+6P7K7t lusf7erq6eyg6iDt1urI7X3r5e637H3wbe6O8qzwCfVl8+z3jfYo+x36pf71/T0C9gHRBe8FPAm/ CVAMKA3qDhgQARF3EoESLRRVEyQVjBNvFSMTDRUtEgsUuRB6EtcOdhCmDBIOPgpvC6YHnQgABbMF YgLPAtT/+/9Y/Tj9Afuf+sP4Hfiq9sf1wvSh8wTzqPFx8eDvH/Be7grvHu047i7suO2S65XtY+vX 7afrkO5o7MPvsO1r8XrvjfPR8Sz2rfQw+fb3iPyy+wQAg/+cA34DHQdoB3QKHQt2DXUO8w9LEfQR ihNUEyIVGBQFFjAUNhaoE6gVmRKRFA4R7hIcD84Q5AxoDmsKsQvhB+MINQX0BaMCHAMLAD4An/2S /T776/oZ+Yn46PYL9qr28fUW9S30/fP58nTzdfIf8urwiPFG8D3x7+8U8bvvJvG978LxYfB+8hrx 7fOg8pL1WvTO97/2MPpL+UL9qvyhAE8AlgOIA5kG0gZdCc8J5AuZDOoNyA5sD3gQUxB0EbAQ2RFt EJYRsg/REH8OgA/RDKkN6AqaC9UIWAm4BgcHjwSvBI8ChwKYAGwA3v6b/iL9xvzZ+3f7GfqR+Vb4 mvd398X2afau9Zr10/Sy9N7z8/MS80bzWPLB8sLxfPJt8W7yUPEP8/LxSvRA82z1afQc9y/2D/k9 +Hj72PoT/pv99gC5ANMDzQO8BvYGOQmqCbwLbAzsDd4OHQ8cEMwP3xDrD/oQeA9+EJQOgQ8/DQsO pQtODMkJQwrrBzwItwXXBUoDLwNrATMBmf87/wX+kP2X/Bj8X/vb+kX6vflD+bb4TPjD91b3xfZ4 9uL1afW+9ID0tPMD9DPzm/O58nHzivKJ85jy8/P38sb00fP69Qj1qvfN9pH5z/hM/Mb7iP9Q/zUC JwIeBU8FzAcrCFEK8QpnDDENHQ4JDz4PRRDSD+MQ2Q/pEHAPfxCaDpUPGg3rDWILCQxmCeQJbwe+ B1oFegVnA2gDhQFfAfH/vf9T/gv+Lf3e/HT7B/uj+Qn52fhN+Nr3SPcN93/2Nvad9XH11fS79BL0 H/Ri87/z7fJ7853y1PP38sb0+POd9dT0BvdJ9r34Efji+l36Vf3z/BMA4f/jAu4CygUSBnYI+AgM C8MLwg3WDo8P3hCZEP4RTBHWEjYRuRKUEAcSmg/5EBYOUw9eDG4NVQo8C0kI/AgCBnoGgwO4A5AB nAGg/4X//v3I/Zb8T/w6+9768vmB+cz4TPio9xT3n/b/9W/1rvRR9GvzpPOz8gjz+vGo8obxi/Jc 8b7yevFc8xnyXfQe8+r1wvTK97/2cvqg+Zj9Ff18ADgAmwOpA6oGDgeSCT8KBQznDEwOeQ8AEGAR KRGwErcRTxOhET8TCxGqEv0PihFdDsIPdwypDWoKaQtjCDMJPAbYBhMEeAQgAmECPABQAKj+nf7E /JH8uPpN+qH5JvlW+Mf3Tfet9lf2rvVV9ZL0WPR3837zgfLG8q3xP/IF8Uby//Dp8qzxgvM58rj0 gPNB9hn1Nfgo95f6u/lq/cv8ZQASAJgDmQOwBgAHwQlrCpMMkg2wDu4PTRDEEU4R6xKsEVsTXxEH E7UQUxKKDw8R/g1eDyIMVw0rCiwL+AfHCJUFIAaNA+oDfgGqAcb/y/9P/kT+4fy5/Hr7PftG+u/5 APmX+Of3bPeb9gD2VPWS9In0q/O888ryK/Mh8t/ywPG/8o/xE/PU8cPzfPIJ9dPzlPZw9fT4CPjX +zT7kf4l/qABhgG8BO4EvAc+CE8KDQvUDN8N0Q4cEE4Q0BEyEdYSbxEoEzwR9hKAEC4SKw+0EHsN 2w6YC80MnQmjCoMHVQhhBfsFagPfA3cBuwHa/wMA5v3e/dj7mvut+mD6Yvn9+EL4zfdR99f2Y/bi 9WH1xPSH9NfzvvPx8hfzMPLv8vvxQ/NI8qrzpfKT9JPz2vXq9Jr3wPar+fD4OPyx+xP/xf4fAh8C SQWXBTsI1AgoCxEMwA32DooP8xDhEHkShhE3E5YRSRMlEdcSPhDSEd4OVRAuDXsOSwtjDCcJDgrQ BnkHsgQpBZ8C4wLVAPUAOv9F/7j9qP1L/C38Cvvf+sL5hPmo+FX4TPfm9t/1UfUZ9YT0NPSH85Pz 0vII8y/y2/L28dzy4/FW81HyL/Qo85/1qfRQ93j24vk4+er8j/yv/4j/0gL0AsIFMgaNCDkJOwsv DIYNuA5QD7oQnRA0EjIR2RJoER0TEBHGEgMQmhGRDv8P2gwbDgELHgz7COEJ5QaUB/IEcAX2AkID VQGPAVX/Y/8z/Qn9AvzO+7L6bfqe+VP5jfg/+Hr3H/dn9vr1ZfXf9HP01/OY89ryJfNR8i3zVPJN 82Hy0vPp8sT02fMy9lT19vcz9zz6o/nV/HH8wf+c/90CCAPdBU0G4QihCb8L1AzSDR4Pgw8AEYMQ IRLtEJgS5BCLEk0Q6xE9D8IQ1g04Dx8MWg0zCjQLAQjJCPoFkgbsA1MEEwJaAnsAogDu/vr+eP1v /TX8I/zr+sX6xvmY+WT4F/jX9mH2BfaM9Q71fvRJ9LDzmvPn8jXzdfL88iDyOPNJ8r3zyvLl9P7z SPZp9X/4yvdK+9362P2X/c8A1gC8AwUEiQYQB1EJHwrTC+UM1Q0hD3QP/BBfEAMS4xCZEuEQoxIh ENAR7w58EGQN0g6vC/AMxAnRCrsHmAjFBXAGwwNBBBICbgIVAEYA4f3Z/Zv8gfxD+xn7IPro+fb4 tfgA+Lf32vaE9tz1bfXS9EX09PNT8y3za/Ls8hjyFvM18lrzb/Ie9DLzQvVa9NP2APbV+Cb4SPvK +g3+w/0WARoBFgRmBD0H4wdNCkULnAzXDZYODRD3D5kRsBBkEv8QuxK6EH4S+g+qEc0OXRBHDbQO bwuvDGUJbwpJBxsIPAXYBTwDpwN3AcAB5P8aAFT+cf7o/O38n/uU+0j6Kvop+QP5sPdl9zr2xfVb 9eL0YvTQ86Pz9fIN80ryt/Lc8aPysfH08vbxyfPM8uz0+PPj9hH2gfnw+OP7dfvG/p3+qwHIAZME 7QR+BycIRAo2C5sM0w2TDgkQ3A90Eb8QeRIdEfEStRB8EssPhhGMDh0QAw11DjwLfgw8CU8KWAcz CFEF/wWKAxgEiQHjAUf/av/f/eb9bPxg/Cz7Ffvy+c/55fi3+LH3cfeW9j/2bfX79GX01/N588by 7PIk8sjy9vHF8uLxQPNQ8hH0I/NV9XP0EPdE9kP5mfjE+1b7s/6J/poBtAHMBDUF/Ae/CIMKjwvE DAsOeA7zD4UPGxExEOERTxAAEuIPlRH2DpUQsw0zDxsMcg1KCngLRwg9CU8GEQdVBOQEjQL3AvYA SAFn/5b/9P0O/qH8qfxA+zL7J/oV+qD4b/gV97H2K/bG9ST1p/RQ9Lzzl/Pz8gnzRPLD8unxzPLh 8VPzYfIs9DjzzPX39B34cfc3+rP53vyV/KX/mv9wApwCWwXQBTYI+Qi3CrsL2wwkDoAO8Q+mD0UR ZBAmEkIQABKzD2QRmw4wEEANsQ6lC+0M2An0CtwHxwgCBrgGBASVBGkC2QJjAJ8AQ/5H/vn88/yQ +3b7ZvpE+kr5Hfkh+Ob3+vav9t71evXF9D/0zfMy8xLzXfLD8vfxmvK88dfy8/Ft84TygPSX8+v1 GPXo9zH3NPqm+fP8ofzV/8P/BgNIA0kG5Qb8CN4JdguZDHgN2Q76DocQzA9tEUoQ/RElENQRjQ8y EYYOExAnDY4OfgvDDJUJogqjB34InwVLBsgDSAQkAokCeAC6AOb+DP+A/ZX9DfwF/N761PpE+Rn5 iPcz95T2OPZy9fv0evTx857zBfPj8inyZPKS8TbyRfFy8nnxBvMB8lL0ZfNZ9pj1P/iT97n6QvpY /Rz9HgAVAAsDSwMCBosGtgiNCSULPAwRDWUOpg4tEMwPeRETEMYR4Q+UER8PwRASDpQPrAwQDgsL Rgw9CUQKcgdNCIcFNgbeA2gE4wE5ArX/2/9X/mr+4vzd/KL7kvt2+lv6RPkb+Qn4zPfb9on2oPUu 9Yf0+fOZ8+Xy+vI08pHyu/GF8prxyPLR8Yfzi/Kj9K3zRvZp9UP4hPe++jr6cf0k/YUAiADHAxsE iwYpByoJDgppC4kMMA2KDlMOww8iD7UQZQ8CESQPthBrDvMPSw20DugLMA03ClALYghMCX8GNgey BD8FDgN/A2oBuAHU/wUAd/6W/vv8/vzX+9D7QPog+or4M/iK9zL3Zfb59Wf17PR+9PDzpvP78v3y NPKX8rTxlPKb8dvy1vHp8+7ynfXC9Dj3bfZk+cH43Ptw+5r+Z/5DAUYBOASGBAIHlQeQCXAKxQvl DGMNtQ6zDi8QjA8nEZAPLREmD7oQPg7DDxQNbQ6TC8wM3gnqChYI+gg8Bu0GiQQVBY8C7wJkAIYA 8P78/nD9Yv0r/A/89frN+sL5kvmH+D34XvcH9x32svX79G309fNF8ybzX/Kk8sjxafJ58YLygPEF 8wPy5PPi8kn1VPQN9zD2W/mr+Nr7Yfva/qf+HQJBAu4EVgWpB2AIHwoUCysMUw2UDeUOsQ4nEEAP xhBID9gQ2Q5jEPENXQ/EDBIOSAtxDIIJfgqqB3MI1AVyBiYEogR2AssC0AACAVb/dP/M/cz9lvyN /Or6v/oR+bj4Cfiv99H2Xfa+9Tr1u/Qk9MXzDfPy8iPyWfJq8RzyG/Ej8hHx3/LO8UH0TfOl9br0 jPfF9tn5Nvlo/Pz7CP/R/vMBBgLUBCsFiAcqCPYJ3ArnCwUNnA3qDtEOUhAyD7kQIQ+pEI4OBBCd Df4OYgyiDdkK9As5CSkKeAc8CMwFZQbmA1AEzAH9AUYAXAC4/rf+Zv1Q/Sv8Dfzt+rv6pvlj+XD4 Gvgp97z27PVl9cD0HPS38+3yDvMx8pbypPFz8mvxpPKR8UnzM/JO9Dnz1fXU9MH34PYk+nr5tvxA /LL/if/pAhQDmAUDBjsI7whoCloLHww1DX4Nvw5eDrgPtg4gEJEOBhDmDUIP/AxIDroL6QwbChsL WggmCZ8GPAf4BHYFSwOfA6YB2QEtAEcAsf61/m39Xv3P+6b7+PmX+ff4kvi/90f3sPYt9o/18fSw 9AD0tfPr8g/zLfKQ8o7xjvJ48bPykvGv85byO/U/9MT22PXc+Bv4LPub+rT9U/1+AFsAWwOAAxUG gAalCFkJvwqrC6QMyQ0aDmwPtA4iEOMOUhCBDucPug0ND58M0Q02C0gMngl/CuEHnAguBr0GQQSg BCMCTAKRAJgA8v7Z/pj9cf1T/Bz8Gvva+tP5hvmr+Ev4aPfw9j72rvUF9Vf07PMd8zzzW/Ks8rXx cfJj8XnyY/H38tXxzvOv8hf1BvTS9tT1Cvk5+HT71fpf/gT+kgGNAUMEhAQJB5UHYQkqCkkLOwzo DAoODA5QD5sO+A+6Dh8QRA6aD40N0g5sDJcN5ArjCycJ+QlgBwYIqgUoBuoDPwQsAlwCpwC4AAv/ //6+/aP9FPzb+yf6ufkg+af45PdU99P2Ova29Qr1xfQO9Mrz9PIM8xfybvJb8T7yE/E+8gPx9fLC 8Un0LvOZ9Yr0ffeR9qf54PgR/Hj7wf5n/p8BkAFtBKAEKAepB28JMAqTC5EMWg2KDkoOmQ+2DhIQ nA71Dw0OXA8rDWgO7QsBDXMKXgvACIQJHQe3BzwFoAUlA1UDfAGHAeL/zf9q/jv+Ef3U/OD7l/uc +kP6a/kB+TT4tPf99mP24PUy9bf07fO+89HyJPMq8rPyofGU8nPx0vKq8WjzOvJx9Ejz4vXL9N33 7PYM+kD5y/xE/OT/qP+TApgCXAWoBdkHZwjiCZ8KtgunDB4NOQ7tDSgPSQ6RDxwOZQ+ODccOvgzm DUYLSQy3CYsK5weKCDQGqgZ9BNYEzwL7Ai4BNQGy/6H/KP4A/gL9yfxY+/76lfkO+Z74E/hx99H2 cvbI9Xv1w/SL9LjzsvPD8gbz+/Gl8oTxhPJJ8fzyx/EY9PPyKfUL9Nf2z/W/+Nf3+Po++or9Af1R AAgAEAMSA9cFJAZFCNAIigpYC4MMkA2sDd4OXA6fD4QOxw8lDmUPbA2cDlIMZg34CuULVgkYCrMH SwjMBTsGugPvAwUCDAJVADsAzv6V/mb9Gf00/N377fqL+sL5SvmN+A34Ufe39kL2jPUQ9T30/fMM 81nzVPLM8rLxkfJj8afycfEE88bx2POZ8g/13vPR9rj1zfjb92H7q/pp/vv9DQHfAOID+QN6BtQG rQg7CbcKfAtcDFQNeQ2PDhoOTA83DmYP5Q0YD0kNbA7+CwENlwpzC9sIhgknB6QHeAXJBbwD7gMJ AhcChQB4AO/+wf65/YL9Cfys+zr6qvk/+a74Dvhp9wv3YPYN9lT1FfVF9Cb0PPNj813y2/K+8Yvy U/HM8obxn/No8nb0P/PT9bb0iPd/9o/5rfjs+zb7l/4i/kwBEgEWBCcEnQb2BhEJrAlICyIMsAyx DbMN0A4bDk4PEQ5HD4cNog6xDL0NcwtdDAkK0gpfCAEJwgY3B90EJAXYAugCPgExAaP/b/87/vL9 //yr/ML7WPuN+hn6bfno+DL4l/cl93v28PUm9cv04fMQ9BXzdPNf8hPz7PH68sjxIvPm8bzzd/Kv 9GnzJPb29Ob31PZJ+mr5Gf2D/Kz/TP9jAkcCCQU1BYEH6wd4CQsKUwseDKgMmQ2BDZMO4Q0ID7MN 0Q4wDUgOUwxVDfQK0gtjCRIKrgc0CAsGcgZKBIEEmQKmAgkB+QBx/z7/N/7v/Yr8Jvy2+iT6vvkq +Zr48feg9/L2ovbt9bT17PTF9OHz+vP78ljzQvLy8sTxAfPF8aHzcvJH9BHzdPVM9PD22fXO+M/3 +/on+on96vwnAMT/7wLWAo0FvAUiCJgIfgo3CyAMDA1VDWcOCA4nDzYOWw/YDfYOKw08DhMMCw29 CpILKQnNCX4H/QelBfYFlwOwA+kB2QE1AAYAu/5t/m39E/0m/Lr75/pq+sr5QPmP+PD3hvfb9kX2 ffUb9S30YvRo87TznvI38xHyDPPZ8RDzzPF38yryNfTq8nb1OPQI99z1N/lC+N/7LPtg/t/9FgHZ AM0D0QNgBqIGfwjzCIwKOwsqDAcNRQ1JDvUNDA8KDigPyg3oDiQNOA7yC+YMgApOC94Ifwk9B7YH ggXNBbcD2AMcAhwCcABLABz/5v5u/RH9j/sB+4T67PlR+a34TPif91L3lvZY9or1W/V89Hr0gvPF 86/yLfP78RHz0PFr8yzy3POU8sT0h/MH9tn0rveY9pv5pvjs+y37ff7u/SQB1ADaA9QDTwaRBsMI SAnsCq0LTww7DVENWQ7EDdwOtA3GDkINUg5xDGcNSQsfDOEJmApRCOIIkAbzBqMEygTsAu4CPwEb AcH/gf9r/h3+JP3D/OT7cfvM+k/6ovkQ+ZD47/dY9572EPYv9Vr1bvSW9JXzCPT48p7zdvKP82Dy r/Nv8j/09vIn9d/zi/Zj9S34Gvd++pf5L/2P/Jz/Mv9LAiMCywTfBAwHVAcrCbQJ/Qq1C1EMMA00 DTcOgw2JDoANkQ4TDSEODgz+DLsKjgs9CeIJqQcpCPgFSwY4BGMEmQKgAvMA0QCY/2D/6v2O/Qr8 fvsF+3D62Pk8+eP4Pfj590b3C/dJ9hb2S/U/9Vj0gPSA893zxvKh83XyzvOi8hX04/LM9Jfz2vWr 9Ef3NvYC+QX4H/tK+oT95PwYAK7/xAKgAkEFYQXIBygIFQq8CqkLgAziDN4Nhw2VDq0NvQ52DYUO zgzODc4Lrgx/CkML9giXCUUHvgdfBaAFnAOvA9wBxgFNABkA4/6e/pj9PP1L/N37M/u4+gD6c/n5 +F/4vvcN92z2kvW49dT06vT581T0UPPY88Dys/OO8rDzefIX9NfywfSD8/b1x/Rp90n2hfmR+BX8 YPto/uX9BgHJAIkDiAPiBQ0GKgiWCCgKygq2C4YM4AzYDW8Neg6wDccOhw2cDrEMtQ2PC3MMKQrp CqIIPwn+BmwHPAWEBZUDswPiAd4BcgBKALf+bv7Z/Fv8uvsx+4b67/mG+eT4ffjP96j37/ap9uD1 zPXz9PP0/vNJ9EXzv/Oe8q7zgvIE9NnycfQ881L1I/R+9l31CPj+9u75APko/Gz7m/4V/jcB9wC8 A7YDVgaVBs8IVgmZClQLDwz4DAENBA5oDXEOcQ2BDgoNFQ4/DDYNHQv8C8YJfgomCLgIWwbCBp0E zwTsAvMCSAEpAcb/iP98/jH+Nf3X/Ab8l/vt+nP6zflB+c/4Ovid9+v2bPaZ9b314/QE9Q/0gfR+ 8y70HPMO9OnyOPQG87L0gPOk9Xj02fa59bv4u/cV+1L6Ov2e/Lz/Xf8xAgcCjwSZBOQGLQcHCYsJ ugp2CysMDQ3yDPQNdg2FDn8Nmw7tDPYN/AvsDLwKiwtPCQAKwQdECAwGZQZuBJ4EtALAAj0BLgGE /0r/mv0v/Xn8A/xG+7z6R/qw+UT5pPh0+Mf3dvfF9pz23fW99eb0C/Ua9HH0avM09CDzYvRH86D0 ffNM9Sj0Q/Yq9Zr3jvZJ+VP4U/uH+pn9Af0fAMT/lgJ6AjcFXgXJBzYIuQlgClwLLwyCDHoNIg0j DmsNfA43DUoOnwyfDaMLkQxnCjoL4QiHCTQHrgduBb0FsQPYAwEC+gF8AFMAIf/j/s79fP2Q/DD8 b/sI+0v6zflm+dj4JPiB9/H2KPZG9n31hPWm9Pb0BPSZ9JTzVvRG8130O/Ol9H7zZPVB9GL2PvUF +AX3L/pi+Sf8ffuH/hH+6gCpADkDKgOgBdAF2gdMCMAJaApYCykMcAxiDR8NNQ5/DaQOHA00DmoM cg1ICzEM/QnGCoIIIgnlBl8HNQWEBZwDwwPuAfEBkwB7ANX+mv4U/an8AfyR+9/6W/rv+WD5C/l5 +Cb4gvdE95f2bPav9ab10PQE9Rr0qPSo86v0pPPD9LXzPvUs9AD27fQc9xX2i/iX92T6kfly/Mf7 0P5d/j4BBAHUA+QDbwbGBnoIBwlLCgkLsguZDJsMnQ38DAgOFQ0sDqcMtA3lC+AM0gqvC4MJPwrw B4gIMQaaBoIEvgTMAuECRQE6Aej/w/+I/kz+Tv3+/Cz8zvsK+5X6JPqs+e74YPit9/n2CfdW9kz2 hPW09eT0QfVg9Oz0+PPO9NDz+fTr8331avRE9jH1pPen9pz50fhd+6r6if0K/cn/fP8UAu8BbwSJ BLcGEQe9CEoJdwo8C8ILqgyvDLoNRw1pDh8NQQ6YDLMNrAumDIEKYAsbCd4JkgcpCOcFVgZIBJAE ngK8AjoBQAGB/1f/sf1c/Zz8N/x1+//6g/oE+qH5H/nE+DX45fdJ9xL3bfZL9or1pfXY9Cz1T/QQ 9SP0DfUV9F71ZPTu9fb04Pbn9R34NPe9+e34m/vu+tX9XP0iANn/tgKsAlIFkgVzB/AHYwkTCu8K zAsXDBUNrwy7Df0MHQ7PDOwNQwxQDV4LVAwpCgQLughzCRQHnQdmBcgFrwPlAxoCKwKxAKkASP8n //b9wf3W/I38pftD+7/6XPqH+Qj5Pfic95T38PbS9iH2OPZ49bH17/RK9XD0EfUr9Az1FPRl9Wf0 +PXz9Cf3M/ba+BH4dfq7+W784fuW/jn+4gC7ABUDFwNnBagFhAcCCGQJFAroCsoL7wvwDK8Mxg0C DSgOpQzHDfgLCw3yCusLuAmQCkQI+givBjsHIQWDBXkDtAMGAiECWABKAIf+S/5l/Rn9OvzV+z77 1vpn+vj5ifkL+an4Jvjn91z3I/d+9mv2tfXo9SL1oPXR9Iz1rPSw9cj0HPYw9db27fXW9/X2Ovlr +Ov6OPrp/F38KP/T/mYBRwHnAwQEWgbGBkcI4AgOCtsKUQtHDCEMKQ2gDLwNtQzXDVMMbQ2aC6UM hgp2C0AJEwqzB14IFwaSBmMEuATFAvQCXQFqAer/3v+N/mn+av0z/TH85ftP+/v6Hvqz+dH4Qvgp +J33bffR9tL2LPZP9pv13PUZ9ZD1vvRu9Y/0pfW39Ar2G/UM9yb2hvjD9+z5Pfm4+yr7vP1Z/ez/ tv8LAvoBWgSHBIAG7QZ7CBkJKAr7CmMLVgxODGAN2AwADrQM3Q05DFMNVgtpDDcKKgvkCLEJWQcE CMgFSwYjBHYEpwLaAvYAAAEZ//L+3f2m/aj8Wfyp+0j7w/pc+uP5fPkH+Zf4QfjD93738vbG9iX2 NPaK9df1FfWr9d30s/Xe9P71I/WR9rP1bveZ9pr4z/cj+nP57Pti+xH+tv03AA0ArgK/AjQFjAU2 B8EHGQnaCZYKfAuZC50MVgxzDaYMyw2BDKwN+gsiDRYLIAzyCeUKjAhdCfMGlQdOBcEFsQP/AzMC YwK/AM8AUf9I/xv+/v3j/LP86Puq+7f6Y/pb+dz4tfg2+PD3aPdX98f2svYR9k72q/Xe9SP1sPXs 9K/11vQI9iv1hvak9bD34PZG+Zv4vvon+qT8MPyh/lr+swCXAPMCAwMpBXUFKwe1BwUJwglnCk4L kAubDFoMfw16DKcNOQxfDZULsQyoCqkLdQlfChQI1wiVBjQHAwV4BYUD1gPVAQACCQADAMr+pv6E /U/9efw4/H37L/u4+mj61vl++Rb5t/hQ+N/3n/cd9/f2YPZ+9tj1O/aJ9SH2aPVE9n31pvbf9VH3 jfZI+Ib3jvnf+B77i/oI/aD8CP/L/lsBXAHWAxQE2wVKBtAHeQhqCTwKmAqGC4ALjAwHDCcNGQw/ Dc8L7QwQCx8MHwoVC9QIsQlcBxgIxAVMBjgEmAS+Av0CQQFpAdn/4/+e/pX+bP1H/XL8QvxB+/v6 8PmA+VP54viW+B74BPiJ92z34vYB93L2jfbv9Uz2pvU49n71cPat9cz2AfbA9wD3JvmI+Gv63Pkg /LH78f2h/eb/u/8JAgoCMQRxBDcGsAYhCNAIpgmACv4K/gvtCw4NQQxyDTAMYQ21C+IM6gr7C90J 1QqNCGgJIQfWB4wFIAYUBHsEXgKdApYAowA5/y3/7v3M/dL8nvzL+4T7//q7+iL60flf+QH5nvg4 +Or3c/dJ98P2v/Yn9mj2wPU/9pX1UPaX9Y722PUd92P24vco9wL5Uvhr+tT5Lfy4+wX+t/1HAC8A xQLoAsUEIQXIBlsHhQhCCeAJvgr6Cv4LuQvWDA8MOA34Cx8NgwumDK0KugufCZ4KPQgSCcwGfQcw BbQFsgMQBEICiwLfAAYBhv+M/1z+UP4w/Q/9VPwt/Cr76Prt+ZL5Wfn8+KX4P/gb+Kr3nvcl9yn3 o/bM9jb2l/bz9aT29vXV9iD2kffe9r74JvjO+T75R/vR+ub8jPyx/nz+rQCjAMwC8ALNBCgFvwZS B2gIKgnXCcIKAQsUDIsLsgy5C+QMdguaDOEK+gv3Cf4K1wjHCYEHSAgbBrsGkQQPBSoDhgOGAbwB 3P/h/6f+m/55/VX9gvxS/Kr7dvvg+p36IPrV+W35G/m6+Ff4K/i895L3GPcq96H29/Zs9uv2U/YQ 93L2dPfR9g74bPf6+Fv4Kfqa+bf7Qvta/Qv9cP9S/8MB3wG1A/8DswU1BncHJgjeCKoJGwoRC/4K DAx1C5gMiwu2DDkLXwyUCqsLqAmuCmIIRAn8BrkHbwUCBvEDXgSCAtECEQFDAbb/zf+D/n3+WP07 /Xf8UfxM+wz7D/qx+YH5IvnW+HL4W/jx99/3cfdz9/j2GPeV9uD2TfbV9jf2/PZR9pT36vag+BH4 i/kC+eT6cfpg/AX8Df7L/fL/3f/8ARgC/gNMBPcFega4B20ITgkuCqUKrAtZC3sMugvrDKYL1wxC C2oMgQqZC4sJiApECCcJ7wasB24FCAYBBHIEVgKfAqEAvABb/1v/F/4A/g395/wm/Pv7TPsW+4P6 QPrM+Xv5E/m5+Hv4G/jZ92v3ZPfn9in3ovYF93L2D/dy9lT3uPbJ9yr3kPj194z59/jr+m36cPwP /GP+Mf6fAKkAkwLFApUE+ARxBgQHGAjaCFcJNgp3Cn0LJgtBDIILpwxwC50M/QoiDD8KUQs7CTkK /AfTCIoGOgcYBaUFsgMnBDsCjALeABIBnf+2/2f+ZP58/XD9S/wh/Aj7vPpt+iL6u/lq+TH52fiu +FL4NvjQ98z3V/d79/f2VvfD9lL3s/a09xr3gfj29z/5sfhU+tj5oPs8+y795PzO/p3+tACwAKEC ywKPBO0EXgbvBu4HqQhOCTMKYgpvC+EK+gsVCzYM1Ar0C0gKXAtyCXYKYghHCSQH7QfDBWUGYATk BNQCMAMoAVcB6v/+/6T+mP6a/YX9ufyV/OP7uPsZ++X6b/ov+rf5b/k2+en4k/g3+BT4pvfY92X3 r/cy96b3I/fU90z3Jfic98H4NPiU+Qn5vPpD+gr8qvvL/ZT91//U/6cBxgGSA9sDaQXgBREHugdk CCUJjwl6CmQKbgvfCvcL8QoTDKQKwAsRCiALLgknCgAI3AikBloHPwXKBdoDTARnAroC/QAsAbr/ z/92/m3+e/1q/Uj8GPz++q36XPoK+rP5V/kk+cb4qfhG+Df4y/fL91n3eff29lP3xPZC96n2k/f8 9kj4vff0+Gn48/l3+TD7xvqg/E38NP76/Q0A9v/1AQ8C6gM5BNUFUQaDBy0IEAnpCVYKXQsOCykM cAudDG4LnAwBCycMVAptC1sJWwoxCBIJ1AaZB3UFEgblA1kEMAJ7As4A8wB0/3j/Qv4w/kb9MP1R /Cn8cPs9+6/6bvru+aD5R/nv+Jb4N/js93L3ovck91n31PY+97L2Pves9of37vb992D3t/gd+Kz5 IfkJ+5P6ePwc/GL+Mv6JAI8AYgKOAl4EvAQjBrMGrwdbCBMJ8AkrCisL2gr1CzgLYwwhC0sMyQrp CxcKKwsICQUKxwefCGgGIQcJBaUFmAMKBB8CcgLSAAQBev+U/2v+cP4t/Q790PuO+xv70vpV+gb6 t/lg+Rz5vfii+EX4Ifi097z3RPdy9+72Rfex9mv30vbz92T3dfjl90z5w/ha+t75rvtJ+yD91Pzj /rb+vwC/ALgC5wKqBAoFbAYBBx0I3AiOCXgKbQp4CwcLKgwxC2AM+QofDHwKkguqCbAKlAiICVoH JgjyBaMGcAT5BMYCHwNaAZEB8/8JALT+sv6j/Y/9pfyC/Ln7hPvw+rj6Kfrl+X75K/nI+Gf4E/iV 98L3Rfd19+v2Tfe59kP3p/Zy99b2zfcp92/4zfdL+bP4hPoG+ur7evu9/XL90//K/7EBwQGwA/sD jAUEBi8HzAe0CH0J9QnmCtAK4QteC34McAuYDDILWgycCr0LpgmvCnMIWwkaB98HtAVXBjgEtwSw Ag0DRgGBAeT//v+1/rb+Wv0//eb7ovsb+8v6Qvrr+Zf5PPnz+If4ePgO+Oj3c/eD9wT3IfeW9vT2 W/bd9jf2LveI9uL3R/eN+Pb3l/kR+c36UvpB/OP77/2t/dv/wP/VAegB4gMsBMMFPAahB1AISwkw CmcKaQs2C1AMnAvBDJILvAw/C2cMjwqoC5YJmgphCEcJDgfWB4IFIwbeA1MEVwKhAucADgGE/5L/ Tf45/kb9Kv1B/BP8XPsf+4v6SPq++Wf5F/m7+Fn45/ep9yb3VffS9gX3dfbr9kr2+vZT9jP3iPaq 9//2Yvi893T52/i3+iz6b/wL/Hv+U/5LAEYAXQKJAkMEmAQKBocGuAdjCDQJCgpFCj0LCgseDFsL fgxmC4gMBgstDEIKVQs0CSkK+QfPCKQGVwcxBcUFsgMkBEcCmALcAAgBov+3/0L+NP7D/I785/um +wb7uPpL+vT5mfk2+Qn5o/ht+Pv36vd093z39fYu95z2+fZQ9iL3e/ao9wv3IviI9wP5bPgT+oj5 a/v4+vr8mvzC/or+rACfALkC4wKnBPkEmQYjB2UIKwmzCZwKrQqzCzgLUAxaC3kMNgtTDLEKxAvf Cd4KxAiqCYUHTQgLBrAGcwTqBOoCOwN1AaIBFAAdANH+xP7D/af9u/yO/M37k/v9+rf6LfrW+Yn5 LvnF+Fb4CfiN96/3LPde9832JveU9h/3hfY/95/2off19jb4jfcs+Y/4Qvqw+eX7dfvg/aD9n/99 /50BqwGKA8sDWwXBBSUHtQe0CHYJ9AnbCt4K4QtfC3kMhgukDFoLfQyaCrQLrQmnCmsIQwkLB8YH mwUzBhkEjgSOAt8CIwFPAbX/vP+O/oP+KP3+/Lv7Z/vw+pr6Gvqy+W75AfnW+Gj4QfjK97j3NPdA 96326fZI9qr2APa99gv2Lvd79pb35vZY+LD3Ufm2+I36CPoO/Jn71f2D/bX/jv/KAdABzwMNBN0F UgbgB4kIUQktCoEKfQtPC2UMvAveDKgLywxaC34Mpgq3C68Jpwp0CE8JGAfWB4wFHQbZA0EEVQKW AtIA7gB//3n/VP48/i/9CP0s/Pn7R/sC+2D6Cfqt+Uv5z/hh+PP3a/eK9/32FveB9s/2L/as9vz1 rfb19eD2I/ZY95L2Gvhf9xX5Y/iQ+vj5d/wP/CP+3f0fAAgAGAIoAv8DNQThBUwGqAdACBkJ3Qk/ CigL+QoEDGYLeAx2C5MM+woSDDcKOwshCQgK5gesCJAGOwcWBZ4FkwPwAyUCYgK2ANIAh/+L/xz+ +/2k/Fz8zPuA++j6j/o3+s/5j/ku+fP4hvha+OH30/dO9133yfYG92X28vZA9jD3gPZu9772B/hZ 98z4I/jj+UT5NPup+tH8avyT/k7+lQB3AI4CowKqBPcEtQY/B0YI/QijCXgKmAqPCzILOgxRC2AM Kws9DJ8KpgvDCbgKpQiFCVwHGAjhBW8GPQSiBLMC9gIrAUoB1v/P/5z+h/58/U79dPwy/Iv7Qvuo +kr6+/mX+Rv5qPhA+K/30/dF92H3xvYV92326fY89tP2Hvb19j32R/eE9vD3L/fL+BD4JfqK+fH7 gPuR/Tb9dP9B/2sBagFyA54DRAWXBR4Howe0CGkJBArdCvcK8wt4C4AMpQu4DHELhQy+CskLwgm2 CokIXgkzB+UHtgVABiQEiASlAucCHgE5Adb/1f9T/jX+wPx2/M37dvva+m/6FPqj+WP56vi7+D/4 FfiU94P39vYK92P2nPbr9W/2tPWM9sv1v/b69TT3cvbm9yb34/gu+Bj6dfmg+xT7Y/35/FX/FP9v AV4BdAOaA5wF+wWhBzsIHAnaCVwKPwsuCyoMlQucDKQLuQxSC2UMpwqqC7AJmQqCCEkJFge7B3cF +AXzA0sEYAKQAu0A+wCt/6P/d/5U/lH9HP1U/BP8U/v8+pr6N/qd+Sv5o/gR+CP4kPeW9/b2J/eG 9tv2L/aj9uj1nfbY9cD27fU592r24PcS9xD5Ufiv+hn6Kfyr+/X9nP3h/7D/4QHkAcUD5QO6BREG eAf/B/UIpgkgCgEL3QrVC00LUAxWC2cM2wrjCxgKBQsJCdoJzQeFCGEG/wbdBFAFagOzA+IBCAKT AJ4AGf8B/4P9P/2J/DX8kfsu+8b6XPoW+qf5bfn1+Mb4R/g1+K73rfcV9zL3ivbw9jj25fYp9vv2 OPZG94L2y/cP96H45Peu+fv4BPti+qP8I/xu/hL+cwBIAHICdgKTBM0EpwYaBzsI2AifCWkKlgqA Cx0LEgxaC1sMMQs1DKcKngvLCbEKqAhuCUsH9ge1BTcGKQR8BI4CuQITASABwf+0/3T+Uv5H/Qb9 Sfz9+1L77/qJ+h/6nPki+ZD4+fci+Ij3mff19jj3jPbU9h72r/by9Yz2wPWz9uL1Avco9qv32faB +LD35/k1+bX7KvtT/eL8Rv8A/z0BJAErAzsDKQVsBRAHgwesCE0JBwrWCvQK4AuUC5cM1QvjDIIL jAzTCtAL3Am+CqwIbglGB+sHvwVBBjoEkQSfAtECLwFDAZ7/h//v/av92PyB/ML7Vfve+mn6B/qH +WH53/ij+BT4C/h092v3xPbq9jL2cvav9UD2d/VP9oH1gPao9fD2FPac98P2kPjB9835EvlW+7H6 Gf2W/Bn/xv4fAfwAWQNwA5sF8AVVB90H/wisCSwKAAv6CuMLfAtzDJMLlQw6CzsMlwqNC5wJdgpv CCkJ9gaNB3EF3gXdAyIEWAJ8AvUAAgGm/4//Xv4w/k79DP1A/Or7ZfsC+2H67fk6+af4tPge+BT4 dveb9/T2Hvdq9tX2FvaI9sP1g/au9aD2wfUX9zX2sffR9uD4E/h++tH58/tY+7z9Vf2c/1r/igFt AYoDoAODBckFQQe6B84IdwnoCbQKyQqtC0ULOgwxCywMuwqvC/IJ1grtCLUJtQdaCEAGxAbJBC4F QwN8A+UB+AFNAEIArv50/pL9Qf19/BX8l/so+8P6S/oh+qb5bfnp+M/4Rfgx+J33qfcD9y/3fPbj 9iL22vYR9u32F/Y692P2uffk9n34r/eK+cz46vo7+oX88vtn/gD+TQATAHoCdAK4BO0EiwbuBjgI zgiRCU4KeQpLCx0LCwxcC08MLwsoDKoKlAvOCacKpghhCUYH4we5BSsGJgRuBIsCrAIUAQ4BwP+k /3D+Ov4+/fL8Qvzl+z/7y/p++gv6f/n2+Hz41fcJ+F73fvfO9hH3WPa69vn1dfap9V/2ifVv9ov1 0fbq9Vn3dPZw+Jz3/flE+WD7vfom/av8BP+p/vYAxgABAwIDDwVGBfMGXQenCEEJBArDChUL/QvU C9MM8Av4DLULuAwKC/oLFgr3CugIqAmKBysI/wV1BnsEzATfAg8DegGHAdz/wP8z/uz9GP29/AH8 k/sZ+6D6UfrS+Yz5BPnX+EX4K/iR94T31fbw9jb2gPay9Uf2cPUx9lH1WvZz9bj2zPVY93D2RPhf 94T5rfj++kP6zPw7/LH+Sf7mALIAPgNJAzEFawURB4MHpAg9CdIJjQq/CpILSgsyDGwLWgwjCxQM gApnC44JWwphCBIJ8wZ/B3MF2AXeAxwEZwJ+AgsBBgG6/5f/df5A/mv9Hv1e/AD8lPsv+4X6Cfpn +c344/hN+EP4ovfC9xL3SPeV9ur2Jvah9tX1g/as9bX2zvUG9xX21vf29iz5YvhO+pb56/tM+5X9 GP1n/w7/ZwE5AXMDeANbBZUFJweVB6sIQQnlCaQK0wquCyMLEAwcCw4MpQqNC+IJtwrSCJIJmQc3 CC0GqAazBAMFJQNTA8YB0gEyABQAkv5K/nv9H/1l/Pb7ivsQ+8f6TPoU+pD5Z/nV+Mb4MPgk+IL3 o/fz9iv3b/bo9iL2zfb/9eb2DPYo90n2svfR9nH4l/eJ+b342/of+on88PtU/uL9dAA3AMgCwAK1 BOUEnwb/BkoI2QipCWgKkQphC0cLMgyFC3cMZQtRDNQKvQv0CccK0giOCWQHAQjfBUkGQQSCBKwC zwJBAUIB0v+3/3/+RP5a/Qz9OvzY+2v7+/pO+sv5K/mE+Kb4APgB+FP3gffX9hH3WPav9uX1YfaL 9TX2VfVP9mT1jfab9VH3aPaC+LX3nvnY+B77d/rL/Ef8tv5P/pwAWQC3Aq0CxQTrBLQGFAduCAIJ 0gmHCu8KyguvC6gMzAvMDJkLmAz6CuoLEArpCuIIqAl+ByMIDQaFBn8EzAQIAzEDZgFpAar/gP93 /jL+QP3i/ET83vtn+/f6m/od+sz5RvkY+Yz4WPjB97/3FPcd92P2sPbi9XD2mvVZ9nr1bPaH9cr2 3fVa93H2Qvhc92T5jvjt+jL6m/z/+7D+RP74AMsA9QL7AvYELQXNBjcHZQj8CJEJQQqEClMLCwv2 Cy0LGQzuCtsLRQokC2QJMAozCOAI0wZaB1cFtAXUAxAEbwKPAg0BCwHD/57/m/5j/nX9K/2f/Ef8 ivsb+1n6zfnD+TT5G/mB+I/49PcO+GX3jffZ9iX3a/bS9g32vvbj9cL23vVM92b2Ofht9x75UPhZ +qX5zvsy+4r9DP1L//D+TgEgAVADVwNEBX4FDQd5B4gIIAnTCYkKuAqSCwsL8wsFC/ILnAqBC9oJ qgrTCIwJlwczCDUGsAa0BAUFTQOAA7oBxwEQAOv/1f6Y/qT9UP2s/Ev84vtz+xr7pPpe+uX5t/k1 +RD5ivh7+OT35fdD92X3s/Yq9272/fY39gz3PfZG9272vPfq9nX4nveB+br4yPoY+nP83fsw/r/9 TwAMAJUCkQJ8BKUEZwbGBgoIkQhUCfwJYgouCxQL9QtaC0gMOwsnDK4KjgveCbEKuwh0CVYH7QfP BTwGQgSIBNIC9wJSAVYB6v/N/63+ev5//TD9jPwu/GT78/ok+o75kPn5+N74Q/hZ+Lj3yfcb92H3 tPbp9iv2ovbb9Wn2kfWG9qD1sPbG9Wr3jvaT+Mz3pvnn+CL7fPrB/Dn8jf4e/ocATACdApMCqATP BJoG+AY/CM0IvAl3CuUKxwtyC2wMpwurDG0LZQzTCr4L7wnICsYIgglvBwoI8AVjBngEwwTeAgID GwETAcH/mv9z/jP+X/0F/W78DfyQ+yT7ufpC+gX6hPk8+bX4l/gC+OL3P/c594D25fYi9pf2x/V9 9qj1mPa09eT2A/Z094r2Ufh293P5p/j5+kT6ofwK/LH+Sf7yAMwA5wLqAuwEJgW7BicHNQjECIUJ Nwp6Ck4LAAvsCy0LIAzfCs4LUwo2C2cJOwo0COUIzAZVB1gFvQXvAzcEegKgAg8BFgHU/73/mP5o /p/9Yf2A/CT8Nvu1+pn6Gfrj+V35UfnD+Lf4I/g/+KT3sfcL91H3mvb99jT24/YU9uT2BfZs94n2 V/iL9y35avhx+sH53/tL+4r9EP1l/xD/ZQFAAWMDcANfBaAFGgeJB7YIUgkGCssKxwqqCyILHAwZ Cw8MpQqRC+sJxwrlCKkJqgdPCD8GwQbUBDUFPwNzA44BnAExABgA5P64/sn9fv3M/HD8A/yi+zT7 xfqE+g/61flb+SX5oPiU+AP49PdT9233t/Yo92/2+fYv9vr2KPYr91j2lPfA9kr4dfdM+YP4pPry +Sb8jvsb/q/9UwAlAD0CNgJIBHQEGgZ0Bq0HLggcCcYJOAoGC+gKzAtBCzIMJQseDKsKmQvwCdAK wgiHCXIHDwjzBWkGeATKBAwDQQOeAbEBPAAwAAv/5P7e/Zz9/Py1/NH7cfuk+h36EvqN+Vz51fjT +Er4Tvi898n3LfdT96n28vY19rv28vWq9tH1Cfcv9tL3CveE+Lf3pfns+PT6TfqC/PL7Rf7Z/T8A AwBCAjcCSgR3BCIGfgbtB3kIcAksCmkKPwsCC/QLOws1DP4K8Qt3CmILmglzCokIRAk3B9MH3AVT BkwEmASnAs0CQAFCAez/0f/D/o3+uv1x/ef8lPwK/K77SPvh+pL6MvrZ+Wn5PvnI+I34Afjh90T3 ivfj9jv3hvYX91z2KPdf9mL3kPbn9xP3sPjj99n5Ivkm+4D68/x2/BH/y/7uAM8A9AIDA88EDwVz BtoGBgiYCE4JCQo1CgsLvAqqC9wK0AufCpMLFgoCCxUJ6AnuB6QIhgYWByMFjAW/AwUEVAJ9AvcA /QDJ/7P/mf5q/rr9g/2X/EP8afv3+tb6Zvos+rH5oPkl+R35mviW+A74FPiD96f3BPdb96/2LPds 9mL3m/b/90P3jfjO93v5zfig+vn5Afxy+6T9N/2C/zj/bgFVAW4DiQNPBaAFIwegB8YIeAnhCbQK qAqWCwIL/Qv+CvwLiwp7C9oJtgrLCJMJmQdECC8GuQbMBDQFNwN4A5ABoQE+AC0A9/7K/uL9o/3/ /Lz8JPzT+2D7APus+kf68vmG+WL56vit+CX4/fdl96P3BfdS96j2Ifdu9h33YvZF94D2rPfh9lP4 g/dW+Zv4j/rp+Uj8xPtZ/v/9KQD5/yYCKAIgBFYE/QVbBocHCwgDCbUJFgrwCtUKygs1CzUMFQsY DLEKqQv2CeQK1gimCYgHNAgdBqcGvQQmBUEDggPTAfQBiwCKAEn/LP9N/iT+Gv3X/Mv7b/si+8L6 b/r9+dr5Yfk++cX4q/gz+Bv4lPel9w73QPeU9vn2PPYB90H2e/e99t/3IPes+PL3q/n5+O76Vvpx /PD7Q/7k/SQA7/8wAiwCIgRQBBMGewbgB3sIMgn5CTgKHQvUCs4LDAsQDNIK0QtXCksLgQlmCm0I PgksB9UH1wVcBlgEtgTAAvICagF6ARQABwD5/tn+BP7X/R796fxK/AX8kftB+8f6cfor+s35X/n0 +Jv4Gfgo+KD3u/cj92f3xfZA95T2Nvd/9nP3svbl9yD3tfj39735CvlB+7H6IP2+/Nn+mP7JALAA uwLQAp8E5QRFBqsG2gdyCCIJ4gkOCu0KoAqWC74KvQuRCpILCwoACx0J+wn3B7gIpgZBB1AFzwXo A0IEfAK3AjUBSgHw/+f/8f7d/rb9hf1u/Bj8wftm+//6ofpj+gT60fls+Tv50vit+DX4H/ie97H3 G/dQ96L2PveI9oX30PbN9xb3aPi290L5lPhn+sn5u/su+1798vws/+v+IQELASIDPwP+BE8F2AZa B3YILAmSCWoKbQpfC8oKywvFCsULdQpzC8sJtgrVCLAJrQdmCFwG7gboBFgFTQOVA+YBCQKGAIgA Uf9C/1D+KP5Y/Sb9c/ww/LT7avvw+pv6SPrt+Xn5D/me+B34Nfi098D3MPdr9872JPd/9iL3c/Y6 93/2nvfg9j74gPdD+Zj4cfrP+Sr8qPss/uH99v/L//8BBwLlAyEEqAUOBlsH7wfYCJEJ/QnYCsAK vgsOCxoMHQsuDM0K2wsCCvoK+QjVCcAHeQhrBg8HBAV5BYAD1AMhAlQCugDQAJ7/n/9O/in+5fyf /Bb8yPs8++T6lfox+ur5hflI+eD4rPgy+BP4k/eO9/32Gvd19u72PfYM91z2PveF9r33Bfd5+ML3 gfnZ+MT6K/pR/NX7Gf7G/QwA3f8YAiICCgRKBAQGeAbgB4gINgkLCkYKNgvrCvQLKAs3DA4LHQyV CpwLzAm+CsAImwmDBz0IHga2BpIE/gQdA2UDqQHKAWEAagA8/zL/Jf4M/in9AP1L/BP8cPsq+7P6 Z/rR+XL54Phd+F/43/fP90D3aPfO9gf3Yvbk9jP22PYb9hn3VfaK98L2Yvih92r5s/j3+mX64fx6 /Jj+Uv6ZAIAAigKeAmIEoAQ2BqgG1Qd6CCoJ+gk1CiILxgrKCxMLIgz9Cg8MZQpxC4cJegpyCEIJ NgfpB9kFbAZrBNoEBQNVA6MB0wF0AIgAFv8J/6L9cv3K/Iz84PuS+yX71/pv+hH60vl1+Rz5tviK +Bj47Pdn93b33PYI92H2+vZH9jP3fvZ798H2Efhc9+b4O/gE+mT5Y/vW+gz9nvzb/pj+2ADGAMwC 5wLUBCQFxAZPBz8I8gh7CVUKUgpFC74KuwvXCuALmQqgC/wJ8woXCfoJ+wfGCK0GVwcyBbQFxAMc BE0CiQL5ABEBvP+2/7f+r/6m/Yb90Pyi/Ov7rPsu++76R/r1+Uj52fjO+Fz4PvjD98z3Rvdj9872 M/eV9hL3YvYw93z2hvfL9jz4gvcb+W/4gfrx+VD85vvh/ZL9yf+s/6oBtQGMA7cDYwW8BSQHuQeC CDoJuwmcCmAKWAvZCuAL7QoDDIQKiwvNCcQK1Qi4CcQHjwiGBjMHRAXMBQEEZQTAAggDrgHgAYEA kwAo/x3/d/5h/rb9lf0k/Qj9l/x5/DT8G/yx+5H7RPsc+8z6nfpq+jT6DvrE+eX5mPn6+af5Dfq1 +V/6APrH+mT6cPsW+zn83/tL/f/8Zf4w/r3/of/0APYAYQKLAsADCgTBBC0FmQUYBjcGywZ7Bg4H qAZAB4gGHgc6BsEGsgUyBhAFfwVPBKgEdQPAA6MCzwLZAe8BJwEsAY4AkAAwADMAy//J/4D/hf9A /1P/BP8U/+z+Cv+N/qr+GP4u/hT+Mv7e/QH+tf3U/Y79p/1U/Wr9MP04/Rr9DP0m/Rf9Nv0g/af9 kP1W/kz+xP63/l//W/////7/jQCTADgBUAHgAQACcQKgAu4CKwM+A38DbgO5A5cD5wNoA6wDIgNb A7kC5wJNAm4C3AH1AW4BcwH8APkArAChAFkARAA6ACwA5v/R/3b/Xf+X/5P/nP+k/7z/2v/d/w0A 8f8yAOv/NgDa/y0Atv8KAIn/2f9i/7D/Uf+X/x7/YP8A/zT/4P4F/9H+5v7S/tr+6f7s/hX/Cv9V /0n/ov+Z/wgABACPAKAAxgDXAAIBFwEZAS8BFgEgARQBGQH/AAcB0wDPAJcAiQBbAEIAEADp/8n/ mP98/z//Tf8L/yr/5/4l/+7+T/8h/3f/U/+o/5z/9P///yoAQwCFALcAjgDTAG0AsQC3ABEByQAw AdMARQHOAEIBqwAaAX0A4ABBAJoAGQBmAN7/IADm/yQAIwBbAAoAMAAlAEYALgBJADMASQBbAGoA hwCcAKgAwADJAOsA3QD7AOwACwH3ABkBzQDoAKYAuABkAHAAKQArAPf/8P/F/7f/mP+D/3f/Yf9b /z//Zv9R/1T/OP8o/wn/X/9M/4H/f/+4/8X/9/8WAB4ASQA6AHMATACKAEwAiwA/AIIAMABwAC8A agAUAEgA+v8uAOP/DwDN/+7/uv/M/7z/xP+7/8X/2f/h//3/CgAxAEAAbQCCAJUAtgC6AN0A2wAD AewAHAHeAAcB6AASAdYACQHAAPIApADMAHkAmwBQAG0AIwA6AP7/CQDS/9z/vf+//8b/zP/A/8X/ xP/J/8j/z//K/9T/4P/x/9f/6//F/9X/3f/1/93/+//d//v/1v/4/8D/5P+r/8H/jf+a/3P/fP9d /2X/YP9f/3T/dv9u/2r/fv96/5b/lP+w/67/uP+y/+n/8f8SACEAQQBdAGcAjQCDALEAkwDCAJ0A 0ACUAMgAhgC5AHEAowBgAJAAPwBmACYASQAJACgA8v8GAOH/7P/Q/9j/wf/H/8L/yv/G/8//1f/b /+z////x/wUA8v8JAPP/CADi//T/1//i/9D/1P/M/9H/tf+0/6v/ov+U/4n/hv95/3//aP97/2b/ gv9o/5T/gv+3/6r/1f/I/+b/5P8QABwALABCAFUAcQBrAJAAYwCHAHQAowB+ALQAcACtAGoApABL AHwANwBmAB8ASQD9/yUA4f///8j/4v/L/+X/vP/N/7P/xf+u/7//pf+z/7H/uv+u/7v/r/+4/7X/ wv+8/8b/vP/M/8f/1f+9/8r/tf/C/6z/tP+m/63/nv+c/6n/pv+y/7T/tf+2/8P/wP/T/9T/5//q /+7/7v8LABAAJAA5AEQAXQBgAH4AcgCbAHwAqAB+AKQAgQCuAHEAmQBkAIoATwB4AD8AZAAhAD8A CQAmAPP/CQDd/+n/x//M/7H/uv+g/6L/mv+d/5n/n/+h/6X/n/+n/6D/q/+d/6v/mv+k/5D/mP+M /5v/jP+V/4n/lf+F/5H/gf+I/37/f/9//4H/gv+D/4b/hP+S/47/rv+t/7//wf/Y/97/8P/1/wcA FQAaACsAMABFADwATgBSAGUAXQB2AGMAewBiAH8AWAB3AFUAcABRAGMAQABTADQATAAqADsAJwA4 ABoAJQAXACEAEwAeAAoAFgACAAwAAwAPAPb/AQD8/w0A9/8IAPj/DwDu/wcA5v/9/9n/7P/P/+P/ vv/M/7D/w/+f/6v/n/+j/5b/nv+N/5X/i/+O/4f/h/+I/4D/jf+I/5j/lP+i/6P/rf+z/7H/t/+1 /7r/u//H/77/xf/A/8D/vf++/7//u/+4/7n/tv+x/7P/rv+3/6r/sv+m/7f/sv+7/6//wf+8/83/ yv/g/9z/5v/p//j//v8DAA0AFgAnAB4AMAAmADYAKAA8AC0ARAAxAEkALgBHACoAQQAmAD0AHQA0 ABMAKQAOACAAAAAQAAIADAD7/wQA9//8//b/+//q//P/5//s/97/4v/V/9n/yv/R/8j/yP+7/7v/ sf+1/6P/pP+Y/5n/jf+M/4H/ff96/3H/cP9k/2z/Yf9s/1z/bP9b/3D/Yv9z/2L/fP9t/4L/ev+I /4H/mv+V/6r/qP+4/7r/yP/O/9L/1//e/+r/6P/z/+//+//5/wIAAgALAAcAEAAUACAAGQAnACEA KwAnADAALAA3ACwANwA1AD8AOQBCADwASwA9AEcAOgBLADkARwAzAD4AJgAvAB0AKQASABoABQAR APr/AQDn//H/2f/d/8//0f/B/8P/uf+z/6f/pP+g/53/nP+X/5f/kv+X/47/lf+N/4//i/+O/4n/ jP+E/47/iv+O/4j/jv+K/47/j/+R/5H/kv+U/5j/mv+d/5n/of+b/6T/of+x/6z/uf+1/8D/u//O /8r/1P/Z/93/3v/u/+3/7//w////BAAGABAADgAbABcAJAAfACsAIQAsACgANgAtADgAKwA3ACUA NQAnAC8AKgAzACYALQAhACoAHAAjABsAHAAVABgAFAAVAAkACwAJAAkA/v8DAPz/+f/t//D/5f/h /9r/1P/P/87/yP+//7b/sv+t/6X/pP+Y/53/jP+T/4L/i/95/4n/eP+E/3L/hP90/4X/cv+I/3b/ iv96/43/fv+M/4j/k/+P/5v/lP+k/5v/rP+n/7L/sf+//7n/yf/D/9D/y//Z/93/4f/e/+v/7//s //P/+//4/wQABgALAAsAEwASAB4AHgAhACUAIQApACoALAAtADAALwAxADIAOAAyADYAMAAyACkA LAAnACoAJQAmAB4AGQARAAwADAAKAAQA+//6//P/8f/o/+P/2v/b/87/1f/M/8X/uf++/7f/t/+s /7P/pv+q/5v/o/+b/5n/lv+X/4n/kv+I/4j/e/+I/3z/jP97/4j/ef+H/3b/h/95/5b/iP+R/4P/ m/+O/6f/m/+1/6r/vP+5/8j/wf/U/9D/3//a/+//7P/4//f/BAAGABAAEQAZAB0AKgAsADAANQA8 AEEAQABDAEcATgBQAFMAUABYAFMAWwBYAFkAWABbAFEAWgBRAFcATgBWAEYARwA/AEAALwA2ACoA LQAeABsAEAAUAP/////y/+//5P/d/9b/zf/I/73/tv+p/6f/m/+b/4//kP94/4T/cf96/2n/ev9n /3L/Yf9x/1//cf9h/3X/Y/90/2b/gP9u/4r/eP+P/4L/lf+K/6X/l/+w/6P/tP+v/8L/uv/Z/83/ 2//T/+j/4v/y/+v/BAD9/wsABgAZABAAHAAaACYAIwAsACgAMwAyADYANAA3ADcAPAA7ADwAQAA6 AD0APAA4ADgANAAyAC8ALgApACIAHwAfABsAGwAWABIADQAQAAYACwD//wkA+//+//n//P/y//f/ 7f/y/+r/6f/g/+j/3v/j/9n/4//b/+D/1P/d/9P/1f/L/9T/y//N/8X/zv/E/8r/v//G/7v/xv+2 /8D/sv++/6v/v/+s/7n/rf+5/6j/t/+q/7f/qv+5/6j/tv+s/7f/pP+5/6n/tv+q/7r/q/++/63/ xf+y/8L/tv/L/7z/0v/C/9j/x//k/9L/6//f//L/6//+//v/CgABABMAEQAiABkAMwApADYAMQA+ AD4AQgBIAEYARgBNAE0AUABMAFIATgBSAFUAUABMAEsATABGAD8AQgA/ADcAMgAqACUAIwAiABsA FgAQAAsABQD9//b/8f/q/97/4f/X/9T/w//E/7T/vP+x/7D/of+s/53/nv+S/53/jv+X/4n/lv+E /5T/gP+W/4D/lv+F/53/i/+m/5L/rv+c/7X/qv/B/7j/yv++/9n/0f/j/9v/8v/w//7/+f8RAA0A GwAaACQAIgAyACwAOAA5AD0AQgBHAEEASwBNAFAATwBTAFEAUABUAFMAUQBXAFcATgBNAEkASABE AEQAPwA9ADYAMwAsACkAJgAhABsAFwASAAUACQAFAP3/9v/w/+f/5P/f/+D/1//W/83/0//K/87/ v//J/7r/xP+2/8X/tf/D/7b/wf+2/7//tv/E/7f/yP/B/8j/v//L/8H/z//C/9D/y//c/9D/3v/X /+T/1//k/9f/5v/b//D/4v/1/+n/+f/v/wIA9f8GAP7/DwAEABMADAAeABsAIgAjACcAJQAvACoA MwAvADoAMQA7ADwAPQA8ADgAOwA9ADwANgA7ADoAMwA4ADQAOAA1AD0ANwA3ADAAMgAvADAALgAx ACsALgAqAC0AJQApACIAJQAdACAAHwAdABMAGAAKABIACQANAP3/AwD7//7/9f/2/+v/7v/n/+v/ 3f/n/9X/3f/N/9P/xP/O/8L/yv+8/8j/u//P/7z/zv/F/83/wf/O/8L/1P/E/9P/xf/R/8b/1//M /+H/0//m/9b/7v/h//X/7v////f/BgD//xAACAAbABQAJAAbADUALQBGAEMATABIAFUAVQBpAGcA dgB3AIAAgACIAIkAkACVAJIAlACXAJcAlgCgAJoAogCgAKYAngClAKMAqACZAJsAjwCTAIsAhwB7 AHsAdQB0AGcAZgBdAFsAUABQADoAPAAuACgAHQAWAAgAAAD4//L/8P/o/+T/2//Z/8v/yv+9/8T/ tP+2/6v/tv+p/7P/pP+x/6T/rf+h/7X/qf+7/63/wf+1/8z/wP/R/8T/2//Q/+z/4v/6//D/AwD8 /xcAEgAuACgAPgA/AE8AUABjAGIAbgBuAIAAfQCKAJIAkwCfAKAAqACpALAArwC1ALIAuwCzALwA tAC8ALgAwQCxALwArwC5AKkAsQChAK8AlACbAIEAhQB5AIAAaQB1AFwAZABNAFIAOwBCADEALgAd ABkACwAJAP//+//8//L/9v/p//b/6v/q/97/2//V/97/1//f/9f/3P/S/+D/1v/d/9P/2//R/+X/ 3P/o/+T/8P/o//b/8//6//j/BAD+/wcA+/8WAA4AHgAYAC0AKQAxADUAPgA8AEQARQBHAEkAUQBV AGEAZABpAHIAdQB9AHoAgACBAIIAeQCDAIgAjwCLAJUAkgCaAJMAnQCWAKAAmgCfAJ0ApgCdAKIA mACfAJIAmACXAKQAlACcAJcAmwCNAJsAjwCTAIIAiQB8AH4AcQBxAGcAbABZAFkAVgBTAEgASQA6 ADsAMAAuACgAJQAaABUADwAKAAYA/P/5//L/5//j/+X/3f/f/9f/4f/W/9//zv/h/9b/3//Y/+T/ 2f/i/9v/5f/a/+f/3P/x/+b/9v/s/wIA/P8PAAkAHgAaACYAJQA/AEEAUwBSAGIAYgB1AHwAgwCL AJUApgCqALcAtQDHAMUA0QDPANkA2ADkANsA7ADiAPgA4wD6AOkA+wDlAPQA4gDyANoA5wDLAN0A vwDNALYAwQCiAKwAlwCiAI4AlwB/AIcAawBuAFwAYQA/AEMALgAuAB0AHAAIAA0A/P/6//L/7P/g /93/2v/Q/9L/xv/H/73/xv/D/8X/wP/E/7//0P/K/8//zP/W/83/3//X/+j/4v/z//D/BgALABkA HwAlACwAMAA3AEIATwBRAF8AZgBwAHQAfgCEAJUAjwChAJ0AsACsAMAAugDNAMAA1ADOAOIA0wDn AN8A9wDkAPgA6QD6AOgA/wDgAPgA3gDzANgA7wDMAOMAxgDbAL0AzQCtAL0AnQCqAJAAnwB8AIkA cwB8AGEAYgBSAFYARQBHAEAAQAAxADYAJwAoABwAHwASAA4ABgAIAAYABgD+//z//P/5//n//f/3 //f/7//t//P/7f/t/+//8v/0//L/8f/1//P//f/6/wgACQAOAA4AGwAgAC4AMgA1ADsAPwBEAE4A WQBUAFsAZQBtAHYAgAB7AIgAhgCWAJAAngCaAKYAowC1AKgAwQC8AM8AxQDaAMUA3ADOAOMAzADd AM0A5QDNAN4AzQDiAM4A4wDGAN0AwQDbAL4A0wCyAMMAqgC4AKMArQCMAJwAhgCTAHgAgwBnAG8A XABfAFMAVABFAEcAOQA9ACoAMwAeACEAFQATAAwACwD4//n/8v/u/+z/5v/n/+n/5v/p/+r/6//q /+z/6//q/+r/7P/s//D/9f/z//n//P8BAAkAFQAbABgAGQAiACUALwAzADwAQwBJAFEAVwBkAG0A eQB/AI8AjgCjAKMAugCxAMQAuADPAMAA1wDCAN0A0QDqANEA7ADQAOsA1ADtANQA7wDSAOoA2QDx ANAA5gDJAOAAwgDaALwA0ACmAMEAngCxAIoAnACBAJAAawB7AF8AcQBTAGIAPABHAC8ANQAYACIA CwASAP3/BQDx//T/4f/m/9j/3//N/9H/w//K/8D/xv+7/77/v//A/8T/xf/L/8r/1P/Y/+T/5v/x //L/+f8BAAMADwAXACYAKwAxADoASwBSAGQAYgByAHAAgQCCAJUAjgCjAKIAuwC0AM0AvADUAMYA 3wDNAOoA2QDzAOYAAAHoAAYB7gAJAfAACgHpAAUB5AACAeUAAAHZAPQA0ADtAMQA3AC2AM8AqQC/ AJYAqwCCAJcAbgCFAF4AawBPAF0APgBJACgALQAXAB4ACwASAPv/AQDx//T/5v/u/93/4f/H/8f/ xP/D/7f/uP+5/7f/tf+0/7f/tf+4/7j/uf+6/7v/vv/L/87/0v/W/9//4v/p/+//+v8DAAcADQAb ACQAJgA0ADkASgBJAFkAXwBuAHIAhQCAAJUAlgCpAJkAsQCgALsArQDIAKwAxgC2AM8AvgDYAMQA 3QDEANwAxQDjAMAA3wC9AN0AugDWALEAyQCmAMEAmgC0AIwApQCDAJkAdACIAGcAeABSAGEAPwBM AC0ANQAYACYAAwALAPT//f/m/+z/1v/V/8f/wv+6/7f/rv+r/6X/pf+Z/5r/nf+U/5r/mf+Z/5r/ n/+e/6P/o/+r/6b/sv+y/7X/u//G/8n/zv/O/93/4//k//D/9f///wEABwAUABwAGgApADIAQABA AE4AUgBpAGIAegB5AI0AggCWAJYAqgCZALMAowC6AKwAxACpAMcArwDKALAAygCuAMkArwDKAKEA uwCdALgAmgCzAI8AqgCDAJoAegCPAGYAeABhAHIAVABjAEwAWgA6AEcAKgA5ABwAKgAMABMA/v8I APT//P/p/+3/4P/o/9j/4f/O/9P/w//M/77/yf+6/77/vP++/7f/uP+9/8L/uv+8/73/xP/D/8f/ zv/P/9P/1//a/+L/4f/p/+r/9P/x//7//P8IAAgAEwATAB4AGAAnACcANgAvADoAOABFADwAUgBD AFoATwBfAFcAagBkAHMAawB+AGwAfwB0AIUAcwCIAHsAjAB8AJAAegCOAHYAiQB5AIwAbgCCAGkA ewBfAG8AVABiAEkAWQA7AEkAKwA2ACQALwAVAB0ACQASAPz/BgD1/wAA5v/q/9j/3v/S/9P/x//K /77/v/++/73/s/+6/63/sv+r/7H/q/+p/6P/pf+k/6T/of+j/6L/nv+k/6T/r/+s/7T/sf+8/73/ wv/G/8z/0P/Y/+D/5P/l/+z/8//5/wgACAATABcAIAAlAC0AMAA8ADoASgBGAFMAUgBcAFYAZwBa AGwAYgByAGQAeABtAH4AbgB3AGkAegBrAHgAZwB5AGUAdwBgAGsAVQBjAE8AXABDAFEAPABGAC0A NgAZACYADQAZAAEACAD3//j/5f/r/9X/2//I/8r/t/+4/6v/qP+f/57/lv+T/4T/hP+C/4D/fP91 /33/cv95/3H/dP9w/3T/cP95/3H/c/93/3z/d/+B/3//iv+H/5L/jv+a/5v/p/+n/7P/sf/A/8b/ 0f/S/93/4//w//T///8CAA0AHAAjADEAOgBDAEkAVgBXAGcAZwB5AG4AgQB2AIsAfwCWAIgAmQCM AKAAjQCgAI8AoACKAJ4AhwCdAIAAlwB1AIsAbgB9AF0AbQBQAGEAQgBNADEAPAAeACgACQARAPX/ /P/m/+v/zv/T/7r/vP+n/6X/kf+P/33/ev9q/2L/Xf9S/07/Qv89/zD/Mv8i/yn/Hv8h/xX/I/8R /yv/GP8w/yD/Of8l/z3/Lv9I/0D/X/9T/2//Zv+E/3T/lP+F/6X/n/+8/7v/0f/T/+f/7P/9/wQA GAAaACkAMABAAEcAUABbAGUAdgB7AJMAiQCgAJgArQCjALQApgDBAK0AxgCtAMkArQC/AKMAuwCc ALYAkwCjAIUAlQByAIEAWgBsAEMATwAwAD4AGAAcAPz/AQDp/+v/1P/P/7r/tP+n/6T/kf+H/3j/ c/9r/2D/WP9N/0v/Qf89/yv/N/8j/y//HP8q/xb/KP8V/yb/EP8o/xX/J/8a/y//Hf87/yT/S/86 /1b/S/9s/2D/fP91/5b/jP+n/5//vv+2/9P/zv/u/+v/+//6/wsADQAhACMAKgAuADUAQABGAE8A UABcAFYAYwBaAGoAYwBxAGUAcgBtAHwAcAB6AGsAfwBsAH0AawB3AGYAbwBgAGgAVwBhAE4AWgA+ AE0ANgA/ACAAJwARABcAAwAGAPT/9v/f/97/zv/L/7r/t/+q/6f/mf+S/4z/h/98/3L/a/9e/2L/ U/9a/0z/Tv9C/0v/P/9E/zb/R/85/0L/M/9J/zr/Rf83/0z/PP9K/z7/VP9D/1r/S/9i/1j/a/9g /3r/cv+F/4D/mf+Q/6j/nv+8/7X/yv/F/+T/4//3//b/CQAHABYAHgAlAC4AMgA8AEEASgBPAFcA UwBYAFkAXwBcAGIAXgBlAF8AZgBdAGEAVgBbAEwAUQBHAEYAOQBAAC4AMAAgAB4AEwARAAgAAgD6 /+7/3//W/8//x/+6/7D/qP+Y/5D/hP96/2v/Zf9S/1X/Qf9E/y3/Mv8g/yn/Ef8f/wf/E//4/hP/ +/4U//r+GP8B/xz/B/8r/xT/Mv8g/0H/LP9M/0D/YP9O/2X/Wf9//2//i/9//5r/lf+w/6L/wP+2 /8f/w//b/9j/6f/n//f/+/8HAAYAFwAcACgAKQAzADgAPgA/AEMASABKAFEATwBUAFEAUgBQAFUA SwBSAEgASQBBAEUAPgA/AC4ALgAiAB8AEQAQAAUAAADw/+z/4v/a/9b/x//L/7z/vv+u/7L/pf+f /47/j/+C/4T/df97/2f/cv9c/2b/Vf9d/0v/VP9G/0r/Pf9D/zH/Qf8v/z3/I/82/yH/Of8l/zb/ Jf89/yf/Q/8t/0v/NP9R/0P/XP9S/2v/XP96/2j/hv95/5b/if+j/5j/sf+o/77/t//L/8X/2//U /+f/3//u/+n/+//2/wYA/v8NAAgAFgAQACMAHgAqACQAMgAwAC8ALgA2ADUAOQA2AD0APwA8ADoA PQA8ADAANAAvAC4AKQAiAB4AFwASAAsABgD+//P/6v/l/9r/0f/I/8H/tP+y/6D/oP+Q/47/gP98 /2j/bf9X/2b/Tv9a/z3/Uf87/0j/Mf9B/yb/PP8f/zr/H/8z/xj/Lf8a/zD/Fv8t/xH/Mv8V/zj/ Hv89/yf/R/8r/1T/PP9d/0j/a/9V/3n/Z/+N/3j/of+P/7L/o//D/7P/2P/J/+v/3P/8/+3/CgAD ABUAEAAhABgAKwAfADMAKAA8ADEAQwA6AEAAPgBDAEEAQwBCAEEAPgA7ADYANwA0ADYAMQAuACUA IQAbABkADgAFAAAA9v/q/+P/2P/T/8X/vv+v/6r/mv+W/4L/f/9r/2//Vf9Y/z//Rv8u/zj/GP8p /wf/Hv8B/x7//v4a//j+Gv/6/iL/Bf8i/wb/M/8V/zv/Hv9F/yn/W/87/2P/Sv92/2D/gf9o/43/ ff+d/4z/rf+c/77/q//M/73/2v/Q/+3/3v////H/FQAHACQAFwAxACkAQwA/AEwATwBZAFcAZABi AGUAaQBpAHEAaQBuAGUAZwBfAGIAXABfAE8ATAA6ADsAKQApABkADwAEAPz/8f/l/9//0P/Q/7X/ vP+o/6L/k/+R/3//gv9s/3X/W/9k/0r/Wf89/0n/Lv8+/yX/Nf8V/yr/Ef8n/wj/If8B/yX/Bv8o /wX/KP8I/yf/BP8v/wv/Qf8f/1L/Lv9d/0D/cP9Q/4L/ZP+V/3j/pP+S/7f/p//M/7r/3f/J/+b/ 1f/y/+L//f/y/wkA/f8MAAMAGAALABwAFgAgABcAJQAhACsAJAArACIALwAoADAAJQAsACYAMQAp ACwAJgAnACIALAAgACYAFwAdAA4AFgAGAAkA+f/0/+T/5v/U/9f/vv/G/7H/uP+f/6X/j/+X/4D/ j/9y/3z/Xv9z/1P/a/9K/2T/Rv9b/zz/Wf86/1H/L/9P/y//Tf8t/0//L/9J/yz/Tf8v/07/Lf9R /y7/U/82/1r/P/9j/0j/b/9R/3v/Xv+G/27/mP+A/6L/k/+1/6T/yv+7/9//z//w/9//+v/s/woA /P8WAAwAIAAZACkAJwAwACgANQAwADgANQA7ADEAQAA/AEAAOQBDADkAOgA1AD4AMAA4AC4ANAAl AC0AGwAnABUAFQAKABAAAwD+/+//9f/l/97/zf/U/8X/uv+o/6j/k/+S/3n/gv9l/2//T/9b/z3/ Sv8o/zn/Ff8r/wr/J/8C/yL/+f4j//r+Jf8A/yj/A/8x/w7/PP8d/0P/Jf9R/zP/Wf89/2n/UP9z /13/g/9p/5P/ev+k/43/r/+Y/7n/qf/K/7r/2f/L/+v/3f/9/+//DwALACcAGwA0AC8ARQA/AFEA SwBZAFcAaABgAG0AbABuAG4AbQBvAHIAbgBwAGgAYgBaAFsAVgBLAEUAQgA7ADIAJwAdABYADAD5 //z/6f/p/9H/3f/F/8b/sP+y/57/pf+M/5X/ev+A/2X/cP9T/2P/Sv9T/zv/Sv8n/zr/Gf8v/w7/ Lv8F/yD//v4h/wL/IP/8/ij/Bv8x/w7/Pf8c/0z/K/9Z/z3/bP9P/4D/ZP+T/3//q/+U/7v/qf/Q /8H/4f/S//L/4v8AAPP/EQABABsADwAiABkAMgAiADUAMwA7ADcASABGAEgAQQBSAEkAVABKAFYA SgBRAEgATwBHAEsAQgBLAEEAPgAyADUALgAlAB0AGwAPAA0AAwAAAPD/7//f/+L/0v/O/73/wf+y /7b/of+s/5r/n/+I/5b/e/+Q/3n/iv9u/3//bf+I/3H/hP9o/4r/b/+O/3T/kP91/4z/eP+I/3P/ if91/4//fP+Q/3b/k/9//5j/fP+a/4b/pf+T/7X/ov+v/57/vP+j/8T/sv/R/8D/3//L/+j/1f/x /+X////z/wgA+/8VAAwAGQARACIAGQApAB8AMgAnADgALAA/ADYAQQA1AEUAOgBHADsARgBCAE0A QQBLAEQATABAAE4AQwBIAEEARwA6AD8AMgA5ADEAKgAfACAAFQAMAAIA/f/t/+T/1//T/8H/wP+s /6f/lv+T/3//ff9n/2r/Sv9W/zv/RP8s/0L/If85/xr/Mv8S/zj/E/85/xb/OP8e/0X/Jf9K/yv/ Uv81/2H/Rv9q/1f/ef9k/47/dv+c/4j/rv+f/7z/qf/S/8X/3//V//X/7P8SAAUAJAAeADoANABT AEwAYwBgAHIAcQB/AIIAiACMAJMAkwCSAJMAlACZAJQAmQCUAJUAhwCFAHcAdgBnAGEAUgBQAD4A OQArACUAFwAPAAIA+P/z/+L/3P/N/8n/tv+2/6L/pf+R/5n/gP+K/2//ev9h/2v/Wf9f/0b/V/81 /07/MP9D/yf/QP8i/z3/JP9C/yX/Rf8q/1P/N/9e/0T/af9R/3n/Yf+M/3T/nf+O/7P/of/E/7T/ 2v/K//D/4/8AAPT/DgAEABsAFAAhAB8AMAAnADcAMAA8ADwAQwA9AEoASQBPAFQAWQBTAF0AWQBk AGAAYABgAGQAZgBlAGwAagBuAHAAcgBqAGwAYQBmAFwAXQBTAFEASQBHADMAMwAjACAAFAARAAQA +//0/+v/4v/V/9P/xP/H/7b/tf+m/6z/nP+b/4r/mP+F/5T/gP+Q/3b/h/9z/4b/dv+D/3H/g/9r /4L/af99/27/e/9t/37/cP+A/3D/hf9y/47/eP+Y/4L/n/+I/6r/lv+3/6j/w/+5/87/xv/h/9n/ 8//m/wcAAwAYABcAKAAiADQAOABGAEgAUABRAFsAYgBjAGkAbgByAHQAegB5AIEAeQB+AHcAgAB2 AH4AcwB4AHAAdABpAG4AZgBoAGIAZABWAFsAUgBPAEAAQwA1ADUAIgAlABEACgD6//j/6v/m/9X/ 0f/H/7z/s/+l/6L/lv+P/4P/g/9z/3P/Xv9r/1j/Yv9R/2P/TP9e/0r/ZP9R/2T/U/9t/13/fP9n /37/c/+E/3f/k/+D/5r/if+i/5f/rP+j/77/sf/C/7f/zf/I/9b/z//j/9//7P/p/wEA+v8RAAoA IAAcADEAKgA/AD8ATABOAF4AYABoAG4AcwB7AHoAfQCDAIQAhwCKAIgAjgCEAIYAgQCIAHgAggB1 AHoAagBxAGkAbwBaAFsAUABZAEQARQA5ADYAKAAkABwAGQATABEACAAAAPX/7//m/+D/2v/R/8r/ w/+6/63/q/+i/5r/iv+M/3z/fv9s/3j/Yf9u/1v/bP9V/2P/Vf9p/1b/a/9W/3b/Yv96/2f/hP91 /5L/gP+g/5b/sP+j/8L/vP/O/8r/4f/f//P/8/8EAAAADwAPACMAJAAuAC0APABBAEwAVgBcAGAA ZwBpAG8AewB9AIcAjACSAI8AkwCYAKEAnwCoAJ4AqwCkALIAnwCrAJgApgCQAJkAgQCFAHEAegBb AGQARgBNACwALwAUABUA+v/3/+j/4f/N/8r/uv+u/6f/mf+Z/5D/i/9+/33/c/96/2n/df9o/3P/ XP9w/1//bf9f/3H/Y/9x/2X/eP9s/4P/eP+N/4H/k/+K/6L/m/+u/6X/uv+5/8v/yv/g/9v/8P/r /wUABQAYABoALAAuAEAARABOAFUAXABmAGwAewB0AIgAgACOAIEAlQCIAJkAiwCaAI8AoACLAJkA hACaAIEAkAB9AIsAcgB4AGoAcQBhAGwAXABeAEwAVQBFAEoAOAA8ACwAMwAlACYAGQAXAAcABQD3 //n/5v/j/9f/z//J/8L/vv+5/6r/qP+g/5v/l/+Q/5X/hf+O/4X/jP+B/5P/hv+V/4v/m/+Q/6D/ nP+p/6L/s/+x/73/uv/C/8X/zv/H/9X/1v/i/9//5v/l/+3/7P/v//H/9P/5/wAAAQAAAAUADgAX ABUAGwAeACYAJgAsADIAOQA4AEMAPABFAEoATwBTAFoAWQBfAGEAagBnAHcAbgB8AG0AegByAIEA awB5AGcAcwBfAG0AXQBkAFMAXQBNAFcARwBRAEAASQA7AEAANwA3ADAAMgAlACkAHgAgABEAFgAK AAwA/f8CAPD/8f/n/+v/2v/a/8j/yf+3/7X/qf+q/57/mv+X/5D/j/+L/4z/hf+G/4D/f/99/4H/ gf+I/4H/jP+E/5L/jP+e/5v/p/+o/7b/uP/H/8f/0f/W/+D/5P/y//T/AgAHABEAGAAgAC4AOgBD AEYAUgBYAGEAZQBxAHQAiACDAJMAjwChAJ8AtACuAMMAtADKAMAA2QDEAN8AxwDeAMQA3AC/ANoA tgDNAKQAuwCRAKwAfQCUAGgAdABJAFYALwA8ABEAFwD2//n/3P/j/8L/xv+x/7H/nP+Z/4r/gv98 /3T/c/9q/2X/WP9i/1j/W/9T/1r/Tv9c/1T/Wv9W/2D/Wf9t/2f/ev9w/4j/gP+T/5H/pv+n/7f/ uf/P/9D/5P/l//7/AwAUAB0AKgA2AEAATwBfAGwAbQCAAIUAlQCUAKoAoAC6AK0AxAC3ANAAvQDc AMQA3ADBANoAvADYALgA1QCxAMYAqgC+AJ8AtgCMAKIAjQCdAHgAjABrAH0AUABkAEUAVgA2AEEA JgAxAA8AGAD9/woA7P/x/97/4v/L/87/wP+//7T/tv+m/6n/oP+h/6D/mf+e/5r/nf+c/5z/n/+j /6b/rP+l/7b/tv/A/73/y//J/8//0v/d/93/6f/s/+//+P/7/wUAAAANAAgAEQAMABgADgAZAA8A HQATAB4AGgApABcAJAAhAC4AIQAxACkAMwArADwANABGADUASABFAFQARgBbAEwAYABUAGQAXQBx AGAAcQBmAHwAaAB6AGcAegBnAHwAZgB6AGcAewBjAHYAXgBvAFsAaQBVAGQASwBdAEUAVgA/AEsA MgA+ACkANQAdAC0AFwAfAAMAEgD4/wMA6v/x/9n/4P/I/8//vP/B/6v/rv+m/6T/lv+Y/4z/kP+F /4b/gP9+/3v/ef95/3j/dv92/3v/fv+A/4T/i/+K/5P/mf+j/6r/sf+0/8P/yf/P/9n/4v/u//b/ BQAOAB8AIgA4ADcAQwBMAF4AYgByAHQAiACFAJ0AlwCwAKgAyAC2ANcAyADmANMA7QDiAAEB3gAD AeAAAAHcAPoA0gDwAMUA4ACxANAAnAC5AIYAnwBuAIEATQBkACoAOQAOAB4A8v/9/9P/3/+2/8D/ pf+l/4j/if9z/3T/Y/9m/1f/VP9L/0X/Rv8+/zj/MP9A/zb/Qf88/0b/QP9T/1T/Yv9c/2n/aP9+ /4L/kf+U/6T/q//B/8n/3f/k//D//P8RABwAJgA1AEQAVABbAG0AcwCPAIgAogCXALkAqADIALkA 2wDIAOgA0gDyANEA8ADPAPYAzwDzAMsA6QC/AN8AuQDXAKkAxQCbALcAhQCkAHUAkwBgAHYATABg ADcARwAhADMADgAaAPv/BADi/+j/0v/Z/7z/xP+r/7T/nP+g/5H/kP+H/4T/f/9+/3j/eP93/3P/ ev92/3n/ef+A/4H/jP+M/5L/lf+o/6P/s/+0/8X/x//V/9//5P/x//X/AgAIABIAEwAiACIAMwAo ADoAMABDADUASAA9AFAAQgBYAEYAWwBHAF4ATABfAE0AYwBOAGIAUABnAFMAZQBPAGMAUABnAE8A ZwBUAG4AVgBsAFMAagBUAGoAUgBlAE0AZQBLAF8ARwBYAEQAWgA5AE4AOgBIADIARAAsADsAKQA9 ACQALAAYACMAEgAlAAkAHgAEABEAAAAPAPn/AwDw//X/5//r/9n/3f/U/9r/yv/Q/8D/xv+2/8b/ r/+1/6z/sP+k/6j/nv+k/53/of+W/5r/kv+W/5L/lv+R/5n/m/+i/6T/rP+s/7n/uf/E/8b/0P/Y /+T/5v/t//X/AwATACcAIwA4ADkASQBQAGYAXQB2AHMAjACJAKIAlQCyAKQAwACzAMwAvwDhANEA 9ADbAPsA2wD9ANwA+gDXAPsA0QDuAMYA4AC6ANUApwC/AJIAqwB4AJAAWwBvADcASAAdACsA/v8I AOD/5//E/8b/pv+n/43/iP91/2//Yf9a/07/SP9B/zz/OP8s/zD/Jf8v/yf/M/8r/zb/Nf9C/z// Uv9P/2H/W/9v/2z/iP+I/53/nP+5/7r/2P/Z/+//9f8KABMAJgA4AEEAVQBdAHIAewCSAI8ApwCo AL0AugDVAMsA6wDaAPkA5QD/AOYACgHkAAoB4QAEAd0A+wDNAO4AwwDlAK4AzQCaALMAgwCUAGwA fABPAGYAMwBGABUAIwD+/wQA4v/s/8z/1P+1/7v/p/+l/5L/j/+D/4L/cv9s/2v/Y/9g/1v/X/9a /1z/Wv9i/13/Zf9i/27/aP93/3H/hv+B/5j/l/+s/6z/uv/E/9b/2//o//D//v8LABUAHwApADcA NgBIAEcAWgBTAGMAWQByAGEAdwBlAH0AZgB/AGkAgQBlAHwAYgB5AF8AcwBbAG0ATwBdAEMAWAA+ AE4AMQBIADEAPwAoADUAIQAvAB0AJgAWAB8AFQAZABEAGgAQABcACQAQAAkAFAAHABAADAAUAAcA EAAGAA8ABwAQAAoAEwAGAAsACQASAAsAFAAQABgAEgAbABYAHgAQABQACQAUAAIADQAAAAgA+v/9 //X/AwD1//v/6//z/+L/6f/b/9v/1v/W/8z/z/+7/77/s/+0/6r/qv+t/6v/pf+p/6j/pf+o/6f/ rP+u/6//tv+6/7z/wv/E/9D/1v/a/97/7v/x//r/AwAJABIAGQAgACgANwA2AEYARgBYAFgAaQBr AHgAfQCOAI4ApQCXAKoApAC4AKsAvQCrAL4ArQC7AKMAvQChALcAmQCrAIcAnAB0AIYAWABpAD8A SwAkACwACQAUAOz/8f/V/9j/uP+5/6f/n/+L/4X/f/93/2v/Zv9Z/1P/Uf9M/1H/RP9Q/0X/Vv9P /1j/Uf9g/1v/bv9t/3v/e/+L/4v/nf+d/6v/s//J/9D/3P/l//b/BAAPABgALQA5AEQAVQBcAHMA cACFAIkAngCVALEAsADJALwA2ADEAOAAxgDgAMAA3AC5ANQAtgDLAKYAvQCZALEAiACWAHUAhgBb AG0AQgBOACsAMgATABYA9f/7/+b/6P/K/87/uP+4/6L/n/+T/47/hv99/37/d/9y/2f/af9f/2T/ Xf9k/13/aP9l/3T/a/98/3T/if+E/5f/lf+r/6f/vf+//9P/2f/x/+//AwAJABwAJQAzAD4ASABT AFkAYgBiAHEAcwCCAHYAhQB6AIgAfQCRAIIAkgB+AIsAcwCGAG8AfQBeAHAAUgBdAEgAUQA5AEcA LQA6AB0AKgAUAB0ABgASAPn/AADy//f/7v/0/+j/5v/h/97/1v/Y/9f/2P/X/9b/1//a/93/3P/f /+D/5//n//H/8f/0//T/AwABAAkACwAUABMAGwAeAC4ALwAwADIAOQA8AD8ASQBAAEwARgBPAEMA SgA/AEkAOwBFADIAOQAsADEAGgAiAAwADwD6/wMA7v/u/9z/3f/J/8r/vv+6/7X/tf+l/6X/ov+d /5j/jv+S/4r/jf+J/4//h/+P/4z/k/+Q/5j/lv+l/6L/s/+v/8P/wv/U/9X/4v/i//X/9v8PABMA JQAsADwARgBaAGQAdwCDAIsAmAChALIAswDFALwA0gDFAN8AzwDlANMA5wDJAOMAwwDdALMAzQCj ALMAjwCfAHIAhQBZAGwAOgBLAB0AJgD//wIA3v/m/8H/xP+p/6P/jP+J/2//a/9X/03/SP88/zf/ Jv8q/xj/If8S/xz/DP8Y/wX/F/8J/yL/Ef8s/xX/P/8u/1P/RP9o/13/if9+/6P/nv/C/7j/5P/i /wsABgAmACkASwBUAGgAcgCKAJkAqQCzALsAzQDPAOUA3ADyAO0AAAHuAAQB7AAIAewACQHlAP4A 2wDyAMsA4AC4AMYAngC0AIUAlgBoAHsATwBbADYAPQAWABwA+v/6/9r/4v/D/8H/pP+g/4X/gv9y /2v/Yf9Y/1L/Rf9F/zv/Pv8y/0H/Lf8//zL/R/8z/1D/P/9c/0r/bP9b/4T/ev+V/4n/rP+k/8T/ vf/e/9X/7//r/wcAAwAWABYAJAArADIAOwA8AEMARQBJAE8AUgBTAFkAUgBZAFIAWABYAFwAUABW AEsAVABJAFIARwBOAEAASQA7AEQAMgA1ADEAMwAqAC0AJwAsAB4AIwAbAB4AFgAWAA4AEwAOAAwA BQAJAAUACAAHAAcAAgAGAAEABgAEAAQABgAFAAQAAgAJAAwACAAOAA8ADQATABEAEgARABYAFQAQ ABAACgALAAwABAD+//n/9//x/+3/5//j/97/1v/T/8r/w/+9/7P/sf+o/6D/l/+d/4//jP+D/43/ hP+I/3v/iP99/4b/e/+J/37/hv95/5D/g/+S/4j/mP+S/6P/nf+u/6n/u/+1/8r/yP/b/97/8f/x /wUAAwAcAB0ALwA4AEwAVQBoAG8AeQCJAJAAmwCfALEArAC6ALgAxgC+AMwAwgDTAL4AwwC4AMIA pwCwAJwAoACDAIwAbgB0AFAAVAA4ADkAHQAcAAcA/f/s/97/zf/G/7f/pf+h/5D/if96/3D/YP9d /0r/Uf82/0T/M/88/yj/OP8l/zb/JP84/yT/Qv8s/0T/MP9U/0X/Xf9N/3b/Zv+I/4D/oP+e/8D/ s//Z/9f/9f/x/xIAEgAzADMATQBSAGgAcgCLAJMAnAClALIAvgC/AMgAwgDTAMoA2QDMANsAygDc AMUA1wDAAM4AtwDBAKMAtACVAKYAgwCNAG4AegBbAF0ARABJAC4ALAAUABQA+P/3/+P/2f/G/7// rf+g/47/g/98/3L/bf9a/2H/Tf9Q/0L/Tf84/0T/Nf9G/zL/Sv80/1X/P/9j/0r/cP9c/33/b/+Z /4r/qv+e/77/tf/Z/87/6//p/wAA/P8WABEAHwAeAC8ALwA8ADoAQQBIAEgATwBMAFEATABQAFIA WgBRAFgAUQBYAE4AUgBNAFEARQBHAD4ARgA6ADwAMwA1ACkAKgAlACEAFwAXABEADAAGAAIA+//2 //D/7v/x/+X/5P/X/+X/1P/g/9f/3f/Q/93/zv/f/9X/3//U/+P/2f/p/97/8f/q//j/7f/9//f/ AgD1/wQA/f8GAP7/CgACAAgA/v8EAAEA/f/+//z/9P/3/+7/7v/r/+n/4//j/9v/1P/M/8z/xP/I /77/wf+3/7r/sP+0/6r/rf+j/6b/m/+d/5b/mv+R/5j/iP+S/4T/k/+F/5n/iv+f/4//pv+W/7H/ pP/B/7T/z//C/+P/1P/0/+r/CgACACEAGgA9AD4AUABVAGkAaAB3AH8AiQCTAJUAnQChAKgAqACy AK0AugCwALcArgC0AKMArgCZAKIAigCKAHcAdgBgAGgATgBRADgAOwAdACIACQAEAO//7f/U/87/ s/+r/5f/kf+J/3n/cP9l/2L/Uv9P/z7/Q/8u/zX/Iv8s/xn/KP8U/yr/FP8v/xj/M/8c/z//LP9O /z7/Y/9R/3n/af+R/4L/rf+f/8v/uf/p/93/AQD+/yMAJgBJAEkAWgBiAHkAfQCJAJEAlQChAJ8A rwCuALYAtwDAALoAxAC1AMIAsQC/AKwAtwClAK8AlwCcAIsAjAB3AHsAYQBoAE0ATwAzADkAGwAa AAIABgDo/+v/y//H/7D/p/+a/4//hf92/3L/ZP9l/1T/WP9H/1D/OP9L/zT/Sv80/0n/Nf9T/z7/ XP9I/2z/Wv9//2n/jP97/6P/kv+z/6f/xP+8/9j/zP/r/+X/+f/1/woABAAUABMAIAAfACUAIwAw ACwAMwA1AD0APABCAEAARgBGAEcASQBOAFEASQBMAEQASABCAEIAQABAADoAQAA1ADYAKgAqACUA IwAcABsAEwAQAAkABAABAPz/+f/z//f/8v/x/+r/7v/l/+z/3f/q/+b/6f/i/+z/4f/x/+j/8f/q //H/6f8AAPb/9//w//3/9P/9//r//P/y//z/9//9//b//f/x//f/6f/x/+b/7f/k/+f/3v/i/9f/ 3P/T/9T/yv/V/8T/1f/I/8r/w//D/7//w/+2/8D/tP+5/7P/t/+v/7P/pv+s/6f/tf+q/7j/rv+9 /7T/w/+3/8n/v//S/8v/4P/Q/+b/3v/t/+r/AgAFABgAGQAiAB8ANQAwAEMAQABMAE0AVQBYAGEA YQBqAGgAbgBtAG8AcABtAGwAcABuAGIAYgBbAFwAUABNAEkAQgA5AC4AKgAjABcAEAAJAAIA8//r /+H/2P/H/77/u/+t/6v/mf+b/47/jf9//4f/dv96/2r/cP9h/2z/W/9q/1L/Yv9T/2X/UP9m/07/ a/9a/3H/ZP+E/3T/k/+A/6D/kP+v/57/y/+7/9j/0v/x/+3/BQD//yQAHgA1ADEARgBLAFoAXwBp AGsAcQB2AIEAhgCFAIkAigCUAI0AkwCOAJcAkACVAIcAkACCAIYAdQB4AGYAZwBVAFYAPQA7AC8A JAAXAA8A///1/+j/2P/Q/8j/s/+o/6X/lf+Q/37/fv9w/27/V/9h/03/Uf9C/03/NP9G/y//Tf8x /07/Nv9T/z//Yf9H/2v/Wf9+/2n/lP+A/6f/mP+8/7D/1f/J/+3/5P/9//v/EQAMACQAIgA4ADkA RABFAFAAUwBZAFsAXwBlAGEAZQBkAGwAZQBpAGQAZQBeAGEAUwBbAEcATQBBAEMALwAzACoALQAd ABoAEQARAP/////2/+7/5v/g/97/1v/X/8f/yP+8/7n/rv+6/63/q/+e/6r/mf+m/5f/o/+W/6T/ jv+o/5b/sv+h/7n/qf/A/6r/yf+3/9P/wf/a/8z/4f/Y/+n/3v/4/+T/+v/u/wEA9P8FAPr/DAAA AAoAAQAIAP3/CwD+/wMA9/8FAPz/AQD5//n/8f/2//D/8v/r/+r/3v/k/9r/2v/T/9b/yf/P/8b/ z//D/8j/vv/I/7v/xP+2/8X/tf/F/7n/z/+//8v/v//Z/8v/4//a/+//5//1/+3/BgAAAA8ADAAc ABkAJAAoADQAMgA+ADwASgBFAEwATABUAFIAVgBUAFAAUgBHAEMAQAA6ADUAMQArACcAGgAaABUA DwACAPv/9v/u/+L/2P/O/8P/xP+2/7D/pv+n/5j/m/+I/47/fP9+/3L/eP9k/2//XP9q/1T/ZP9P /2D/TP9e/0X/YP9M/2X/T/9s/1j/dv9m/4f/c/+T/4T/p/+Y/77/rf/Q/8L/7//e/wYA+f8aABMA MwAoAEMARQBUAFEAaABoAHYAeACHAIwAkQCVAJkAnQCcAKcAnwCmAJ0ApgCeAKEAmgCeAJEAkwB+ AH8AbQBzAFoAXQBIAEQANgAyABcAEwAEAPv/6f/h/9j/zv/C/7j/rv+j/5r/jf+M/3n/e/9l/2j/ Vv9l/0//Xv9F/1z/Qv9g/0j/Zf9M/2r/T/92/17/iv92/5f/hv+u/57/wf+1/9n/zP/x/+P/BQD8 /yIAFgAyACsAQwA6AFIAUgBjAGQAbQBwAH0AgQCCAIgAjQCTAIsAjwCJAJYAiwCPAIAAhAB8AIQA eAB7AG4AcQBsAG8AYwBjAFMAVABBAEYAOQA2AC0AJwAXABIAEQAGAP3/9v/x/+r/5P/Z/9n/z//P /8L/xf+4/8P/vP/C/7j/x/+4/8r/vf/N/8L/1f/I/9f/zv/m/9v/7//e//r/6v////L/AQD9/wsA AQATAAYAFgALABwAEwAaABYAHwAcACUAIQApACYAKgApACYAIgAdABoAIQAfAB0AGAAXABUAFAAR ABIADAANAAUACAD///3/9f/5//L/8P/s//H/6//z/+b/8P/p//X/7f/5//T/AAD5/wkAAQAQAAgA GwAXACQAHgAzACkARAA/AE0ASwBSAFIAXABcAGAAYgBqAGoAawBsAG4AbgBvAG0AcQByAGUAZQBj AGAAUQBNAEcAQwA5ADUAJQAeAA4AAgD+//T/7P/i/+D/1f/W/8f/x/+4/7n/rv+w/5v/ov+V/5v/ if+W/4P/kv9//5P/gf+P/4L/j/9//5f/if+j/5L/rf+g/8P/tf/T/8j/4//Z//b/6/8MAAMAKwAm AEEAOgBaAFoAbABvAIgAjACVAJkAmwCmAKoAsgC3AL8AtwC/ALwAywDDAMoAvwDLALoAxQCvALcA nwCoAJcAmQCFAIUAcQByAFgAWgBGAEcAKQAmAA8ACQD2//H/4v/b/8v/vv+0/6b/n/+P/47/fv98 /2v/cv9h/2b/Uf9f/0n/Vf9A/1j/Pv9Y/0f/Yv9Q/2v/Xf99/2z/j/97/6D/kf+1/6b/0f/E/+n/ 3v8EAAAAGAAUACgALABAAEEAVgBXAGMAaABxAHYAeAB+AIQAiwCHAI0AigCTAIoAkQCJAJIAgACM AH0AhABzAH0AcQB0AGkAZgBbAFwASABQAEEARQAxAC0AJQAnABUADgADAAEA8//y/+f/5f/Y/9H/ zv/H/8X/vP/C/7P/u/+t/7r/rv+1/6z/uP+o/7n/rv++/7L/wv+3/8n/vf/N/8X/2P/O/93/0v/m /97/6//k/+//5f/x/+n/9f/y//3/8/8AAPr/AgD8/wgABgAGAAYACwAHAAgABQAHAAsABwAJAA0A BwABAAMABgADAAEAAQD8/////f/5//n/+f/2//T/+//3//3/+//9//z/BAADAAsACQANAAoAFQAT ABkAGAAgABwAIwAkACwAKgA7ADcAPwBFAEwATABTAF0AVgBiAGUAbABlAG8AawB0AGoAcABlAG4A YQBoAFkAYgBUAFwATQBQAEgASQAzADkAIgAoABYAEwAEAP//+f/0/+f/4P/f/9b/0f/I/8z/xP/A /7z/vP+1/7r/sP+t/6n/mv+T/53/lf+b/5H/nP+V/6P/mv+k/53/rv+p/7j/sP/B/7n/0f/N/+X/ 4v/9//j/EAAMACYAKwA3ADsAUQBSAGIAZAByAHgAfwCFAIwAkgCXAJ4AoQCkAKUAsQCkALAAnACq AJcAoACLAJUAggCJAHUAfgBiAGwAUABcAEEARgAsAC4AGQATAPr//f/m/+n/1P/N/8P/u/+v/6L/ l/+Q/4T/d/92/2b/aP9Y/2H/Tv9U/0P/U/8//1P/Qf9V/0H/Xv9H/2v/Vv94/2b/hv95/5r/kf+u /6j/y/+//+X/2v/5//f/DQALACMAIwA3ADkASABFAFQAWABgAGgAaABvAG0AcgBzAHcAcwCAAHcA fgBzAH4AcQB9AHAAeABpAHEAXgBnAFMAWABGAEwANwA8ACcALQAZABsACgAJAPn/+v/j/+b/2v/T /8f/wf+4/7L/sf+q/6j/nP+f/5T/m/+V/5v/jf+c/4//nf+R/6T/nP+m/57/tv+n/77/t//K/73/ 0v/N/9j/2f/o/+b/6v/r//T/8//7//r////9/wMABQAIAAQACQAJAAwACQAFAAkABQAGAAIACAAA AP7//v/9/////v/8//v/9f/2//H/+P/z//T/8P/y/+z/8f/l/+z/5P/p/+H/4//h/+P/3f/c/+L/ 5v/l/+H/7f/s//D/9f/8/wIABQAFAA8AEQAaAB0AJQAlADAAMwA1ADsAPwBGAEkAUgBLAFEAUQBZ AEsAVgBEAEcAPQBHADoAPgAsADAAIwApABYAHwAJABQA+//+/+7/8v/c/93/0//P/8j/xf/A/7j/ r/+r/6X/of+f/5n/l/+O/4z/hv+F/3j/gf95/4X/fP+F/3j/iP9+/4z/hv+S/4z/nf+Y/6b/pv+1 /7L/yf/F/9v/3v/u//j/AAAJABcAGQArADEAOABDAEkAWgBdAGgAZQBvAG8AegByAIAAeACEAH0A jAB8AIkAcwB+AGwAeQBgAGwAWABkAEkAUAA9AEMALAAvABwAJAAMAA0A9//0/9//4f/Q/8//wv+6 /6z/qf+a/5b/iv+E/37/dP9w/2X/Yv9X/1j/Uf9S/0b/T/9D/0//Q/9b/07/Yv9V/3L/Yf96/3P/ kf+I/6L/nv+1/7D/y//I/+X/4//4//j/DQARABsAIQAtADMAOQA/AEUAUQBOAFsAUwBfAFgAZQBb AGcAXQBrAFoAYQBVAF8ATgBaAEUAUQBBAEcANwBBACwAOQAcACIAFAAZAAMABAD2//n/5P/g/9f/ 2//J/8f/vf+8/67/rv+m/6L/mP+S/5X/j/+P/4r/j/+H/5P/iv+X/5L/nf+X/6b/n/+x/6r/vP+4 /87/xf/T/9X/3f/e/+n/7P/y//b//f///wIACAAIAA4AEQAWABUAFgAVABsAGwAgABwAIgAcAB8A FQAhABoAIQAXAB8ADgAXAAgAEgAFAAgA+v/8//P/+f/r/+z/4f/j/9n/2f/O/9D/vv++/7f/tP+u /6z/q/+n/6f/n/+m/6H/p/+h/6n/pv+u/6r/t/+v/7z/tf/G/8T/0//R/9//3v/s/+3/+v///wcA BwAUABQAFAAWABcAGgAdAB8AIQAkACQAJgAhACYAHAAfABwAIgAWABkAEgAXAAoAEQAKAAwAAAAH AP7/AwD2//v/7f/z/+b/6f/a/+H/0//Y/8n/xv+//7//s/+y/6r/qv+n/6L/oP+e/5n/lv+Y/5P/ lv+R/5f/kP+c/5f/of+c/7H/rf++/7n/yf/G/9T/1v/m/97/7//r//v//v8KAAsAEAATABkAGAAi ACUAKQAsACwAMQAsADIAKAAuACEAKAAkACoAGQAeABkAGgATABUADwAQAAIABQD7//v/8f/z/+b/ 6v/e/9z/1P/Q/87/y//A/7z/sP+v/6X/oP+b/5T/lP+I/4P/fP98/3T/e/9y/3r/c/9+/3T/gP97 /4z/g/+V/5f/pP+b/7T/rv/F/8L/1v/X/+b/5//z//X/AAACAAwAEAAWABwAGwAiAB4AJwAjACYA JgArACEAJQAgACUAIgAmAB4AJAAbAB8AGAAXABIAEwAPABEABwAGAAIAAgAAAPr/8P/w/+H/4P/R /9H/x//F/8D/u/+v/67/ov+i/57/mf+Z/5P/lP+L/4//iP+L/4P/jv+F/5T/if+Y/4//of+e/6v/ p/+5/7b/wv/E/9X/z//g/97/5//t//f/+P8AAAIABAALAA4AFgAWABYAEQAWABUAFwAZAB4AGAAc ABkAHgAcAB0AFAAaABAAGAAOABMABgAIAPr/BAD5//v/7v/x/+X/5f/V/9n/zf/K/8X/wf+y/6// pf+g/5r/k/+O/4f/iP98/4D/ef9//3X/e/9x/33/fP+G/4L/kf+I/5z/kf+n/6T/tv+2/8r/yf/c /9n/5//m//D/8//9/wMABgAJAA4AEQAUABkAGwAdABcAHAAfACEAHgAhAB4AHgAaAB0AGQAZABEA EwALABAABgAIAAcABgD7//7/7v/z/+v/7P/j/+X/1v/W/8f/yP/D/8H/tv+2/6n/ov+h/5//nv+Z /5P/if+M/4j/lP+G/5D/g/+Y/5L/pv+X/6r/p/+5/7P/yv/E/9j/0f/l/+X/9//0/wEAAQAOAA8A GgAYABwAIQAsADAAJwApAC0AMgAwADEALQAyACYALAAqACwAJAAoACIAJQAbAB8AGwAhAA8AGgAL AA8ABQADAPv/+//z//L/5//q/9j/2f/O/87/vv+9/7P/sv+g/6P/mf+S/4r/g/+G/37/f/91/3// df98/3b/gv94/4f/f/+U/43/o/+Y/67/rP+4/7X/zP/J/9j/0v/o/+T/7f/r/+3/8//2//j/AAAC AP//AwADAAoACAAGAAkAEQALABEADwASAAoADwALABEABwARAAoADgAFAAsA/v8HAPn//v/2//j/ 8v/w/+P/5P/Z/9f/1v/P/8v/xP/B/8D/uP+3/7z/tv+y/6v/r/+q/67/qv+w/6z/sP+w/7f/tv/A /7r/wf/C/8v/yv/Y/9f/3P/c/+T/5f/s/+3/8f/0//H/8//3//j//v/9//v/AAD4//b/9f/x/+3/ 6P/o/+T/5P/h/93/2//W/9X/1v/U/9D/yP/P/83/yf/F/8X/w//B/8D/wP+9/7v/u/+9/7n/s/+x /7H/rP+t/6f/rf+j/6X/oP+i/5v/oP+b/6f/pf+p/6T/tf+v/77/tP/J/8j/2f/U/+H/4v/y/+// AwAEAA4ACwAYAB0AIAAlACoAMAAuADgAMgA3ADMAOQAzADsAMQA2ACoANQAqADAAJAAqABcAHQAV ABYADgAQAAcACgAAAP7/9//3/+v/6//n/+L/2f/Y/9L/0f/J/8n/uf+4/6//qP+j/5//l/+S/4// i/+I/33/hf96/4D/df9+/3H/ff9x/4T/ef+I/4D/k/+P/6D/mv+0/6j/w/+7/9D/zf/f/9n/7f/s //j///8AAAMAEAAQABgAHQAbAB4AJAAmACUAJwAmACsAJwApACYAJgAnACoAKgAwACQAKgAqACsA JQAoACEAKQAhACgAGgAjABIAGwASABUACQAKAAEABAD0//X/5P/p/9j/2//O/83/vv+8/7L/sv+l /6X/of+b/5v/lv+b/5L/l/+O/5b/jP+Y/5T/nf+Z/6P/nv+p/6X/rf+o/7r/tf/A/7r/xP/B/8b/ xv/L/8L/0f/N/9j/1//c/9v/4P/i/+f/4P/r/+b/7P/u//D/8//z//L/+v/6//v//f/8/wUAAAAG AAEABAAAAAUAAAAGAPz/AQD6//v/9f/z/+r/7f/s/+n/4//p/9//2f/V/87/0f/R/83/yv/G/8b/ zv/M/9b/0v/Y/9b/3f/Z/+L/1//q/+b/7//v//f/+f/7//v/BwAGAAsACgARABIAEAAQAA0ADgAQ AA4ABwAGAAgACwACAAEAAAD+///////8//3/+P/4//H/8v/0//P/7v/w/+7/6v/r/+n/5v/m/+P/ 4v/a/9v/1v/Y/8//0v/H/8T/yP/A/7v/uf+1/7D/s/+w/7L/r/+0/6r/t/+y/73/tf/E/8P/0//N /93/1f/q/+b/9//1/wcACAAUABEAGwAgACgAKwAsADAALgAzADEANQAxADYAMgA0AC4AMQAqAC4A KQAvACMAKAAdACAAHAAhABQAFQAUABYADgATAAgADQALAAsA//8AAPn/+//r/+n/4//j/9b/1f/T /8v/yP+8/7r/s/+v/6P/pP+X/5r/j/+R/4j/iv+C/4z/f/+M/4P/kf+M/5r/jf+j/5j/rP+l/7r/ t//G/8L/0//T/97/2P/p/+r/8//z/wAA/f8CAAMABQAKAAgAEAAKAA8ADQASABQAFAAXABcAHQAf ACAAIAAoACkAKQAqACoALAAqAC8ALwAzAC0AMgAlAC4AKgAvACUAKQAWABsAEgAWAAQABQD7//f/ 7f/t/+H/4f/S/9X/yf/I/8L/uP+//7r/t/+1/7z/tP+2/67/uv+0/7v/t/++/7b/xP+6/8L/wf/G /77/xv/D/8f/xf/F/8T/yf/D/8j/yP/C/8T/yf/C/8b/wP/M/8b/y//I/8//zv/S/9T/4f/b/+n/ 4v/u/+n/8f/u//n//f/0/wEA/v8DAAMAAwAEAAUAAwADAAQABQD+/wEA+v/4//f/+P/z//X/8v/z //L/9P/4//H/+//8//3/+/8EAAUADgAMABQAFwAYABkAIQAkACgAKAAnAC0AKQAvADAAMgAsACsA IgApAB8AHwAXABkADwAQAAQABAD2//r/8v/x/+b/5//j/+T/4P/W/9v/1P/W/9L/0//O/8z/x//N /8b/xP++/8T/w/+9/7v/tf+z/7D/p/+x/6X/pP+a/6L/lv+f/5b/n/+W/6D/lf+o/5j/qv+h/7b/ rf+9/7n/zP/F/9r/0//r/+b//f///w8AEQAbACAAKQAwADcAPABCAEcARwBTAFIAWgBVAFoAWwBk AFoAYwBeAGYAVwBhAFkAYABSAFwATQBTAEwATQBDAEgAPQBBADgAOwAqADUAIAAnAA4AFAACAAUA 8v/v/97/2v/J/8X/uf+w/6L/mf+R/4b/gv92/3P/ZP9m/1j/YP9O/1z/R/9c/07/Yf9O/23/Wf9w /2X/gf94/5D/h/+j/5n/tf+r/8f/w//c/9v/7//w/wEAAQAKAA8AHQAlACoALQAyADwAQwBLAEoA UwBVAFwAXwBoAGcAcgBqAHQAcAB/AHAAgwB2AIQAdQCDAHEAfABzAHoAYQBxAFYAWgBEAFEAMwA8 AB0AJwAMABMA9v/2/9//5//U/9D/v/+4/7T/qv+h/5b/nf+R/5f/jv+X/4z/mP+P/5//lP+c/5H/ qv+g/6z/rP+2/7D/vf+5/8b/wv/N/8j/1P/S/93/3f/l/9//6f/r//f/9f///wEABwAOABcAFQAd ACQAJgAuADQAOQA6AEQAQABLAEQASwBIAEkARABOAEIASwA9AEEAMAA8ACgALQAaACEADwASAAMA BAD0//T/6f/i/9//3//Y/9n/1P/P/8//zP/S/8r/1//T/9z/1f/e/9n/5v/i//D/7P/8//j/AQAH AAUACAALAA8ADQANABAADwARAA8ADAANAA0AEAANAA0ADQAKAAcACwAJAAsACgAKAAQABgAGAAUA AwACAAEAAwD+/wIA/v////X/9P/u/+v/4//j/9f/1v/N/87/wf/B/7r/tf+y/6b/rP+l/6j/nf+m /5b/pP+c/6b/of+r/6j/tv+z/8D/wf/T/9H/4f/i//b/+P8IAAUAFQAWACQAKAAsADIAMwA6AEAA SABCAE0ATwBYAFEAWQBTAGAAUwBjAFQAXQBQAFoATwBYAFAAWABLAFMARwBLAD0AQgA0AEAAJwAu ABcAGAADAAoA9f/1/+f/6P/R/8//wv+8/67/ov+d/5X/iP9+/4L/d/9w/2b/af9d/2n/W/9u/2L/ c/9m/3//c/+L/37/oP+a/7X/rv/I/8b/2//c//j/9f8KAA8AGgAkACoAMQA4AEAAPgBHAEsAXABT AGIAWwBpAGAAaQBkAG4AZQBsAGUAbgBnAHMAZwBxAGMAbwBfAGcAVwBfAEsAVgA/AEoANAA9ACYA KwAVABwA/v8EAO3/7v/Y/9n/xP/M/7v/tP+v/6n/pP+c/5z/mP+X/5P/l/+P/5z/l/+i/5z/qf+j /7f/s/++/7//zP/M/9z/2//t/+r/9v/3/wAABQAFABAADgAYABUAHwAhACYAIQAqACkAMwAtADIA LgAyADAAPAA1ADoAMgA3ADMAOgAvAD0AMAAzACUALwAeACUAFwAaAA4ADwAGAAcA9P/4/+f/6f/X /9X/xf/C/7z/t/+s/6P/pv+i/6H/mP+g/5b/oP+a/6r/pv+z/7H/xP+9/9L/yv/k/9z/8v/y/wIA CQAXABwAJgArADYAOwBCAEgARgBOAFQAWABVAF8AVABfAFcAYwBdAGcAWQBfAFcAWgBRAFgARwBQ AD8ASAA3AEQAKQAzACQAKAARABgABgAOAPX/9P/j/+b/0P/S/77/vP+l/53/lP+N/4L/e/95/2v/ bP9j/2n/Xv9j/1v/Y/9d/27/YP9//3P/i/+F/6L/nf+8/7X/2f/U/+z/6/8EAA0AIQAjADEAPABO AFYAYgBqAHIAgQCIAJUAlQChAJ8ArACiAK4AqgC9AKoAuwClALkAoQC0AKAAtACbAK0AkgCiAIgA mQB3AIgAXgBtAEkAWAAwAD0AHwAmAAIABADm/+n/x//M/6z/r/+P/4n/fP92/2n/YP9Y/07/S/9B /0n/Of9H/zf/TP89/1f/Tf9m/1X/eP9q/47/hf+g/5r/uv+z/9T/0f/z//L/CAAGACIAJQA0ADgA SABPAFkAYABqAHEAeQCDAIcAkwCQAKAAmgCrAKAAtQClALwApgC2AKgAuACiALQAngCsAI4AnACB AJMAbQB7AFsAbwBEAE4AKQAxAA4AGQD4//z/3f/g/8j/yf+w/7P/o/+h/5X/j/+N/4X/gf97/3// d/99/3T/gv96/4f/hP+R/4z/l/+R/6T/nv+y/67/v/+9/8v/yP/b/9j/5P/o//f/+f8GAAIADgAP ABwAHQAqACwANQA3AEIASgBJAFAAVQBbAFwAaABpAHEAZwBxAGYAbwBlAG4AXQBtAFEAZABMAFoA PABLAC4AOQAbACYACQATAPf//f/t/+3/1//Y/87/0//K/8r/wf+//8P/vf/L/8X/yf/H/83/0P/Y /97/5f/n/+//8f/6/wQADAASABEAGwAbACgAJgArACsALQAuADMAMgA2ADIAOwA5ADwAOwBAADkA QAA5AEMANQBCADoAQAA2AD4AMQA2AC0AMwAqAC4AHwAjABIAFQAHAAYA7v/1/9z/3//R/8z/vv+6 /7X/rP+k/6L/l/+T/43/hf+H/4P/h/+A/4P/ff+K/4T/kP+N/57/m/+w/6v/wf+7/9D/0v/j/+b/ +v/8/wsACwAiACQALQA1AD4ARwBMAFcAYQBuAG8AegB4AIQAhwCSAIoAmgCUAKEAlwChAJ0AqgCb AKsAmwCnAJcAogCLAJcAfgCQAHEAdwBdAGgARwBWACsANgASABkA+f8BAN//4v/E/8X/qv+q/4// jf95/3f/bf9j/1//Vf9Y/03/Vf9O/1f/T/9k/1j/a/9g/3f/b/+K/3z/lf+P/6r/p//A/73/1f/Y /+n/5f/5//r/DQAVAB4AHwA0ADQAQwBJAFYAWgBoAHIAdACBAIMAjwCMAJgAjwCbAJIAoACTAJ4A kACkAIoAngCJAJYAegCMAHEAgQBgAG4ATABWADwAPgAlAC4ADQAWAPr/AgDs/+z/1//X/8v/yv+/ /8P/uf+1/7D/rP+u/6v/rf+s/7T/tP+7/7f/uv+2/8L/wv/I/8r/z//U/9b/2f/d/+L/6f/m//b/ 9P/6/wAABwAHAAkADwAWAB0AHwAkACkALQAwADYAQQBCAEEASABGAEwASQBRAEQATgBBAEoAPwBH ADMAPAAyADoAJQAvABgAJgAIAA4A+v8BAOv/7f/n/+b/2//Z/9T/0//V/9L/1//T/9j/1//g/97/ 6P/n//X/9f8AAP//DwAQABkAHQApADMANwBBAEIASgBIAFUAUABeAFYAXwBcAGcAWgBoAF4AbABh AGcAYABpAF0AaABYAGYAVQBeAEkAUwA9AEkAOQA+ADIANAAkACgAEQAUAAQABgDx//T/4//j/83/ yf+8/7f/rf+k/5r/lv+W/4v/j/+I/4L/eP+I/3v/hf95/4z/gP+P/4f/oP+X/6v/qP+//7z/z//R /+j/6P/3//3/EAAOAB4AJQAzADwARABIAFQAXwBnAHkAdQCJAHwAjwCFAJgAiACeAIwAngCTAKIA kwCiAJAAoQCRAKAAiACTAIAAjABoAHgAWgBmAEkAUAAyADQAGgAeAAgABwDs/+z/1f/S/7b/uP+g /5//iP+B/3X/aP9l/1r/Yf9R/1X/Q/9X/0b/XP9L/2H/V/9m/17/ev9t/4b/fv+d/5n/rv+o/8T/ wv/Z/93/+v/9/xAAEwAeACQAMAA3AEEASgBKAFoAXwBwAG8AegB8AIoAiACVAJEAoQCTAKUAnQCp AJkAqwCWAKkAkACoAIwAoAB/AI8AdQCEAGIAawBOAFsAOQBBACEAKQAMABMA/f/7/+f/5//T/9T/ wf+9/7b/sv+n/6P/ov+d/5j/k/+c/5f/nf+W/6P/nP+q/6X/r/+z/7v/tv/J/8r/zv/P/9//3f/q /+v/9//9/wIABAAOABIAGQAeACEAJwArADQAOgA9AD0ASQBJAFUATQBZAFUAXwBRAF4AUgBaAE4A WABKAFIAQQBHADYAQwApADcAIQAsABIAFAADAAoA8v/5/+P/5//V/9f/zf/P/8b/wP/D/73/wf+9 /73/v//E/8D/yv/M/9L/1v/f/+T/8f/u/wAA//8FAA0AHAAjACgALQA1ADwAQgBHAEkAUABOAFkA WQBgAFsAZwBgAGoAYgBqAGEAbABjAGkAWwBjAFUAXwBQAFgAQgBNADsAQAAuADQAHAAiAAkAEAD4 //z/4P/d/83/y/+2/67/pP+b/5D/i/+B/37/df9q/2v/Yv9k/1j/Zv9a/2T/Wv9t/1//e/9s/4b/ gP+Z/5D/r/+o/8H/vf/X/9T/7v/s/wUAAwAcABsAMAA0AEcATwBjAGgAcACAAIMAjQCLAJoAlwCr AKIAswCtALsAsAC9ALMAxgCzAMMArgDBAKEAsgCVAKEAiACTAHAAggBeAGsAQABIACYALQAQABcA 7f/0/9D/1f+w/6r/jv+G/3r/cv9f/1r/WP9N/0v/Pf9H/zn/SP84/0j/N/9Q/z//Wf9O/2r/Xf+B /3f/lf+M/7H/rf/J/8L/4v/d//f/8/8PAA4AJAAqADkAQQBQAFgAZABuAHwAiwCSAJ8AnQCpAKgA ugCzAMMAuADJALgA0AC4AMwAtgDJAK8AwwClALgAmACoAIIAlABsAHkAUwBkADgASAAiACoACwAQ AOz/8P/Z/9j/wf/C/6//q/+e/5n/k/+N/4j/fP+B/3z/gP92/4X/df+H/37/k/+H/57/lP+k/57/ tP+t/8D/vP/O/83/4P/f/+//7v/6//7/CQAOABcAHAAeACMALwAwADEAOwA/AEUARgBUAEsAVQBM AFcAVABfAE8AWABQAFUATQBOAD0ARwAzAD4AKAAqABcAIQAKAAoA+f/1/+j/6f/Y/9f/zf/M/7// wP+9/7X/uv+0/7X/sv+3/7P/w/+//8n/x//S/9L/4v/g/+//9P8BAAQAFAAVACAAKAAuADEANAA9 AEEASABNAFEAVwBdAFUAXgBhAGsAZABuAGcAcQBjAGwAYwBtAGEAZABdAF8AUABdAEoAUgBAAEUA MwA3ACAAJgAJAAwA+//6/+j/5P/T/87/wf++/7D/r/+g/5r/jf+E/4T/d/94/2//dv9p/3j/a/92 /2z/fP9y/4r/e/+X/4r/o/+a/7X/rv/I/8L/2P/X/+//6f/5//b/FAAWAC0ALgA5AD8ASQBSAFsA YQBfAGgAcAB7AHYAggCEAI8AiQCWAJQAnwCQAKEAkQCgAIsAmACGAJQAeQCEAHEAfABeAGcATQBV ADcAOwAjACYACgAJAPT/8v/U/87/t/+y/6b/n/+Q/4z/fv95/3n/bf9p/1z/aP9e/2X/Wv9o/2D/ bf9j/3r/b/+E/33/mP+S/6j/ov+6/7X/yP/I/+D/2//t/+3//f/9/wwADgAZAB0AKwAvAEAAQABG AE8AUABcAFoAYABoAG0AaABuAGoAeABuAHYAcAB5AGcAcwBjAHAAXABkAFMAXQBFAE4AOgA9ACgA KwAYAB4ACAAIAPr/+f/m/+j/3f/a/9H/zf/E/73/vP+1/7b/sv+u/6r/sf+p/63/p/+0/7P/vP+1 /8T/vP/K/8L/0f/P/9n/3P/m/+r/8P/0//j/+/8DAPn/CQALAA8AEgAYABoAGAAdAB8AJQAjACQA JwAsACMAJAAqACkAKAAoACQAJgAbACIAGQAcABEAFAAGAAoA+f8BAPD/8f/e/+T/0//V/8P/vf+7 /7v/sf+p/6j/ov+m/53/o/+f/6f/o/+u/6r/vP+1/8f/wf/S/9H/5f/l//X/+P8HAAsAEwAbACMA KgAyADcARQBIAE0AVgBXAGQAYgBuAG0AeQB1AHsAfgCGAHcAggB4AIAAeACCAHEAeQBmAGsAXwBq AFIAVgBIAEsAOQA7ACoAKgAKAA0A9//8/+T/3f/O/8v/v/+4/6v/of+U/4v/hP99/3b/aP9y/2P/ Y/9Z/2T/Vf9m/1n/b/9e/37/bP+E/3j/lf+L/6j/of+//7T/0v/P/+j/4P/+////FgAaACoALQA9 AEAASgBTAF4AZABoAHQAcgB6AHoAjACAAI8AiQCSAIgAkgCJAJoAhQCRAIAAjQB3AIEAbAB2AFsA ZQBFAFIAOgA9ACgALQAPAA8A+P/6/93/2v/G/77/rv+q/5z/kv+L/3v/fP9v/3D/Zf9r/2D/aP9d /27/Xv9x/2P/ev9s/4j/ef+S/4f/of+X/7f/rP/I/8D/1v/X/+j/5/8AAPn/DAAIABkAGgAmACkA LgA1ADsAQgBFAEsASABSAE0AUwBOAFgATwBSAEoAVQBLAFIARABKAEAARwA2ADkAKQAuACAAIAAN ABEABAAHAPX/+f/l/+f/2P/Y/9D/y//F/8L/uf+3/7j/sf+s/6f/rP+m/7D/pf+y/63/uf+u/8H/ tP/J/8T/0f/K/93/3P/k/+j/9P/z//7//f8HAAwAEgASABoAHgAgACUAJQAnACgALAAvADIALwAw ACsALgAoACwAKQArACIAJAAhAB0AIAAeABgAGAAKAAoAAQD+//P/8P/n/+T/2f/V/8z/x/+8/7b/ rP+n/6X/n/+g/5T/mP+O/5n/jf+Z/4z/mP+O/6H/mP+p/6H/uP+y/8j/vf/Z/9L/7v/s/wEAAAAU ABYAJQAoADMANwA/AEMAUQBXAFkAZABkAG0AZQBqAG0AdwByAHwAcAB1AGoAdABjAGsAWgBgAE0A WABFAEcAOgA7ACYAKwAbABkABQAEAPL/7v/d/9//0P/I/7z/tf+t/6X/nP+U/4v/gv9+/3T/d/9o /3L/Zf9s/1z/af9d/23/ZP91/2n/gv92/4v/hf+f/5f/rf+l/8T/vf/U/9P/6f/o//n/+/8UABAA JwAnADYAOgBAAEYATABYAFYAXgBdAGoAYgBqAGoAcgBoAHQAbQB3AGkAcABmAHUAYABpAFsAYwBP AFQAPwBFAC8ANgAeACUADAANAP7//f/q/+f/0v/Q/8H/uP+w/6T/mf+W/4//hv+B/3r/ev9u/3H/ Zv9z/2X/cv9h/3b/Zf98/27/h/91/5b/hf+h/5j/sf+q/8X/vP/V/9H/5v/k//r/9/8JAA8AGAAb AC0ALAA2ADkARABMAE8AVgBSAFcAVQBeAFkAYwBbAGEAVwBeAFAAWABKAFAAQgBIADgAPgAnAC0A GwAiAAkADQAAAAQA8v/v/+L/4v/V/9P/yv/K/8D/vf+3/7L/qv+h/6n/nf+p/53/pf+Z/6v/ov+v /6T/sf+n/8b/u//M/8T/2f/P/+D/3v/x/+z/AwADABEADQAcABoAKwAvADAANABAAD8ARgBHAE8A UABVAFIAVgBZAFYAWQBXAFoATABQAEwAUQBCAEYAOgA/ADEAMQAjACgAEwAVAAkACQD1/+//5P/j /87/zv+8/7j/rf+n/6L/mf+S/4j/iv9//4L/dv99/3D/gP9u/3z/bv+A/3X/i/+B/5v/k/+w/6j/ wP+3/9f/z//o/+b////4/xMAFgAwAC4AQABBAFIAWABdAGcAbgB3AHsAggB/AIkAggCHAIEAiwB9 AIYAdgCDAGsAdgBkAG0ATwBWAEMARwAtADEAFgAYAAAAAwDu/+3/0v/N/7//uf+q/6X/kv+L/4D/ dP9w/2P/Yf9P/1f/SP9P/zn/TP83/0j/N/9P/0H/W/9E/2n/Vv93/2n/jv+F/6L/lv+8/7T/0v/L //L/7P8QAA8AJwAlAEQAQwBYAGQAagBxAH8AigCLAJYAmgCjAJ8ArwCoALYAqwC4AKgAuACkAK8A mwCnAJEAnAB+AIoAagBwAE8AWgA3ADwAGwAfAP///f/h/+D/vv+4/6X/m/+K/3//c/9h/1v/S/9J /zr/Pv8r/zP/Gv8w/x7/Mf8b/zT/Hf9D/yz/VP87/2X/VP9//2j/lf+I/67/n//L/7//5v/d/wUA /P8fABoANAA3AEwAUQBfAG0AcAB7AHwAiQCJAJIAkwCXAJMAngCSAJkAjQCaAIAAjwB7AIgAbQB3 AFkAXwBHAEkAMQA0ABsAIAAFAAgA8v/z/9v/1//J/8P/tv+t/6T/nP+R/4r/iv98/3z/cv93/2v/ dP9n/3f/bv96/2//hf96/5L/g/+d/4//rf+i/73/tv/Q/8v/5//k//3/+v8PABAAHwAjADIANgA+ AEQATABVAF0AXABeAGcAZgBwAGUAcQBtAHUAZQBzAGAAagBWAGMATwBXAEEASwAyADoAJAAqABUA FwAAAP7/7v/v/93/1f/E/8D/sP+p/53/lv+M/4X/g/91/3f/a/9v/2b/af9f/2b/WP9p/1r/cv9j /4D/cv+J/37/nP+S/7P/pv/G/7//3v/b//n/9f8SAA8AKAAqAEEAQQBWAFkAcAB4AHwAhACHAJEA iwCWAJMAmwCTAJsAlwChAJkAnQCTAJkAhgCPAHkAggBlAHIAUABVAEIARAAlAC0AGQAXAAcAAwDo /+T/1f/J/8T/uf+u/6P/n/+Q/4r/gf96/2r/cv9g/23/Xv9x/2H/a/9e/3D/Xv9+/3L/if97/5r/ jP+u/6H/vP+1/9b/0v/y/+3/CgALACIAIQA6ADkASwBLAF0AXwBsAG0AfgCBAIoAkgCXAJoAngCn AKkAsACpALcApgCyAKQAsACkAK4AmwCfAJAAmwCCAIsAcQBzAF0AYgBFAEgAIQAdABAABgD2//D/ 2v/V/73/uf+o/6P/mf+P/43/gf+E/3L/hf9z/3r/bP+B/3P/hf91/43/fv+U/4z/qf+f/73/sv/Z /9D/8f/q/wMAAAAWABUAMgAvAEsATgBgAGgAcQB1AIQAiwCQAJoAnQClAJoApQCjAKkAowCsAKIA sgCdAKkAlwCgAIoAjQB9AIYAbQB2AGAAZQBNAE8APgBBACcALgAYABQABAAEAPL/7f/Y/9L/xP++ /7L/qP+q/6b/of+W/53/j/+f/5P/o/+a/6X/n/+z/6v/vf+4/8j/xP/i/+L/+P/x/wgAAAAYABkA KAAoADQAOgBDAEUATgBRAFUAWwBtAG4AdQB3AHgAgAB/AIMAfACEAHgAewBuAHUAbQB1AGoAbQBg AGQAWQBbAEgASgAzADcAGAAeAAsAAwD4//b/6v/p/93/2P/S/8z/yf+9/7j/sv+s/6X/sf+r/63/ p/+6/7T/wv+5/9L/zP/f/9r/9//x/xEADwAnACYAPwA9AFQAXABrAHEAeQCBAIwAlgCkAKwAtgC/ AL8AyQDBAMsAugDFALEAuwCwALUAqAC4AKEAqwCPAJkAgACKAGoAcABTAFAAPAA8ACoAJgAXAA8A +v/3/+T/2v/O/8r/t/+r/6b/lv+S/4P/hP9w/3T/YP9w/1j/av9Y/3b/Y/92/2D/hf9w/47/gP+j /5b/uf+u/9b/zv/w/+P/DwANAC0ALgBLAEoAaQBsAIAAiQCWAKEAqwC5AL4AyQDNANwA0wDeANsA 7QDoAPUA7QD4AOkA+QDrAPcA2wDsAM4A4QC/AMwArwC9AJUAogB/AIUAZQBtAEYATgAsACgAEQAO AO//6//X/8//xf/A/7D/p/+a/43/i/97/3z/bf9y/2b/bf9e/2//Xf9w/2L/f/9w/5T/g/+k/5v/ uP+w/9L/y//s/+L/BgD//x8AGwA1ADUATABVAGkAbgB5AIMAlwCfAKQAqwCuALUAtgDBALEAyAC1 AMQAtQDAALEAuwCxAL8ApgCwAJgApACKAJgAggCLAG4AegBlAGwAVQBZAEIASgAsADMAHgAkAAIA BADn/+X/1f/R/8r/v//A/7T/tP+v/7X/qP+z/6f/tf+o/7X/rP/B/7j/z//G/+D/2f/x/+n//f/3 /w4ACQAWABoAJwAnADgAOABJAEkAVgBUAGQAZABpAHEAdgB7AHkAhQCDAIkAigCRAIcAkwCGAI8A hQCSAH4AiQB9AIkAeACGAGwAfQBiAGoATQBWAD0ASAAsADMAGgAgAAcACQD7//f/5//q/9r/2P/O /8j/wv+8/77/uP/A/7n/xv+6/8n/wP/W/8z/5//h//L/6v8GAAUAGwAXADIALwBDAEkAWABZAHAA dQCBAIkAigCUAJoAnwCcAKYAogCsAKIArwClALIApgCxAJ8AqQCjAK4AlACdAIQAkQB/AIcAcgB8 AGAAZwBOAFYAQQBFACwAMAAeAB0ABAAIAO7/8f/U/9j/wf/E/7X/rv+l/5r/lP+O/4//iP+P/4b/ m/+T/6b/nv+x/67/u/+3/8r/wf/f/9f/+P/0/wsACgAmAC0APwBBAEoAUgBgAGUAeAB/AIgAkgCb AKQArwC8ALQAwgC/AMwAzwDbANAA4QDPAN4A0ADgAM8A3ADAAM4AuwDIAKUAswCbAKYAgQCLAFwA ZQBBAEYAJQApAAkACwDw//H/1f/R/8D/t/+m/5//lv+L/4b/c/91/2n/bf9m/27/Xf9u/17/eP9o /4X/d/+Z/4//rf+m/8L/vP/f/9b/9v/x/xAADQAtACwASABSAGAAaQB2AIIAiwCVAJMAogCoALIA rwC+AL0AzwDDANEAzQDfAMcA1gDBANIAuADKAK4AvwCjAK0AmgCsAIkAmABzAIAAWQBnAEoAVQAt ADAAGQAgAP3//P/o/+T/2f/T/8X/wf+0/6//r/+n/6//pf+y/63/sP+q/7f/s/++/7j/yv/F/9n/ 1v/j/+X/+f/7/wwADwAWABcAIQAnADUAOQBFAEQATgBWAF8AZABkAG8AcAB2AHAAegB3AH0AfACD AH8AhgB7AIcAcgB8AG4AdABuAHMAYgBmAFEAWgA5AEAAIgAnABQAGAD//wMA7v/x/+D/4//M/8v/ w/+8/7X/r/+r/6j/ov+e/6P/nf+o/6D/sf+l/7v/tf/J/8f/1v/U//D/6/8DAAYAGgAcAC4AMQBC AEcAVQBdAGsAdQB0AH4AgQCPAIYAkgCKAJwAhwCYAIkAlwCBAJAAfACIAHQAgQBuAHYAYgBpAFMA XQA8AEUALQAuABoAGwAIAAwA8//1/+H/4v/M/8X/t/+y/6X/of+T/4n/eP9v/3D/Zf9l/13/W/9S /1P/Sf9a/0v/XP9T/2n/Xf92/2j/hv98/5b/j/+x/6r/xf/A/97/3v/y//P/CQAOACIAJAA1AEAA SQBVAF0AbQBsAHsAfgCOAI8AnACVAKcAmgCpAJ0ArQCYAKoAlACpAI8AnwCGAJUAegCJAG0AfwBf AG0ASABTAC0AMQAaABgA/P/9/+L/3//E/8P/q/+v/5T/lP99/3X/Zv9b/1j/Tv9F/zj/Qv8s/z// Mv9G/zX/Tf88/1n/Uf9p/1//hP96/5f/jP+0/63/x//L/+r/5//8//7/FgAZAC0ALwA8AEYATQBZ AGAAZgBmAGoAcQB3AHcAhQB+AIwAhACLAIMAkwCDAJQAegCHAHoAiABsAH0AaQB4AFoAagBGAE4A MQBCAB8AJgALABEA8v/2/9//4P/K/8j/uP+z/6n/q/+g/5j/kP+G/4j/f/+E/3b/g/94/4X/ev+G /4P/lP+P/6P/nf+t/6v/vv+7/83/yP/Y/9X/6f/n//T/+f8DAAQADgAUABsAHAAiACkALgAxADYA PgA4AEMAPABEAD4ARQA8AEQAOQBEADkAQAAuADIAKAAvABkAHQAGAAwA+f/9/+z/7P/Z/9r/w//J /7T/tP+g/57/k/+L/4T/eP92/3H/bf9h/2f/Xv9n/1n/af9i/3b/bP+D/3j/k/+F/6X/nf+7/7P/ zv/L/+T/6f/+//7/GgAeADAANQA/AEUAUABVAFcAYQBbAGIAYQBoAGUAagBfAGoAWABgAFQAXQBM AFMAPwBEADEANAAhACYAEgAVAP//+//r/+b/z//Q/73/uv+j/6D/j/+I/3X/bv9c/1H/Sv9B/zv/ Lf8y/x//LP8Y/yj/Ev8k/w7/Iv8S/yf/G/84/yj/Q/81/1r/S/9x/2T/gv99/6L/mf+4/7X/0f/K /+r/5/8EAAIAFwAYACoAMwA9AEYASwBYAF4AZwBiAGsAZQBwAGwAdABqAG8AawBzAGMAbQBeAGYA TwBZAEMASwA7AD4AHQAiAAoADgDx//b/3//e/8X/xP+r/6f/kf+J/3j/b/9f/1v/S/89/0D/Lf8t /xr/JP8O/xv/Df8h/w3/J/8T/y3/If88/y3/T/9D/2H/Uf94/3H/jf+I/6b/oP++/7//2v/X/+v/ 7P/9/wAACgANABwAGwAkACMALQAvADUAMwAxADUALwAzADAANwAsAC8AJgAoABsAIAASABgACwAN AAAAAwDw//b/5//o/9b/1f/E/77/rv+q/6H/m/+Q/4z/hv97/3X/av9t/17/Z/9Y/2L/UP9f/1H/ YP9V/2b/Wf9w/2X/e/9x/43/f/+Y/4//rP+h/7n/rv/J/8P/1//P/+X/5f/v/+///f/6/wQAAgAP ABAACgAOAA8ADQAIAA0ABwALAAEAAgD///7/+f/4//T/8f/r/+v/4v/e/9T/z//P/8X/tv+1/6z/ qP+d/5b/kv+J/4H/dv9z/2f/YP9U/1L/Qv9D/zX/Pf8r/zj/Jf83/yX/Nv8q/0H/Mv9T/0L/Zf9T /3X/af+R/4L/p/+Z/8T/t//c/9P/+f/1/wsACgAgACAAKgAsADgANgA9AEAAPABBAEQAQABDAEQA QAA+AD0APQAwADAAJgAnABkAGgAQAA8ABAD9//X/6//e/9j/0//L/7n/sP+q/53/kv+F/3L/Yv9l /1L/Tf87/zz/Jv8u/xP/GP8G/xH/+/4M//H+C//r/gr/7P4R//f+H/8D/zP/F/9B/y3/V/9F/3P/ XP+O/3//p/+b/8j/vP/i/9j/+f/5/xAADgAtACkAQgBFAFIAUwBbAFwAZgBmAGgAbABtAG8AbQBw AHEAcQBoAG8AXQBnAFUAVQBFAEkANQA0AB8AIAAHAAcA8v/p/9T/1P+9/7X/m/+R/3z/b/9c/07/ Rf8v/yv/E/8Q//f+AP/l/vb+2P7r/s/+6P7O/uz+zf73/tj+Av/l/hT/+P4k/wn/Pv8m/1f/Qf9t /13/h/9z/6L/kf+1/6b/xf+4/9T/zP/l/97/7//o/wEA9v8FAAAADQAGAA8ACgATAA4AFQAOABUA EwAUABAADgANAAYACgAGAAMA/P/5//D/7v/e/9//0v/L/7//vf+3/63/pf+W/5b/h/+I/3j/ff9s /2//Wv9q/1j/Yv9V/2j/Uf9n/1f/dv9h/33/bP+E/3r/kv+C/6D/j/+r/5//tf+r/8D/s//L/8D/ 0f/B/9j/y//Y/83/1//K/9L/xv/S/8b/0P/A/8r/vv/B/7f/vP+t/7r/rP+x/5//pf+S/5z/iv+R /37/i/90/3z/aP9z/17/Zv9Q/1r/R/9S/zj/TP81/0T/K/86/yP/Mv8Z/zf/HP87/yT/Qf8t/1D/ N/9f/1D/dv9k/4//fv+p/5//xv+x/+L/1P8EAPj/FwATAC8ALAA9AEIAUABPAFIAVwBdAFwAYABf AFgAVwBRAFMASQBJAD8APAAvACsAHAAXAAwAAQD5/+v/5//X/9L/xP++/63/pv+T/5L/f/97/2v/ Zv9P/0v/Lf81/xv/Iv8H/xH/9v4G/+b+/f7b/u/+0f7x/sz+6/7M/vH+0/79/t/+DP/u/iH/BP87 /yT/Wf87/3H/Wf+R/3r/r/+f/8z/vf/r/9//BQD9/yAAFgA7ADUARwBBAFgATwBeAFsAYwBhAGMA YABhAGYAYwBiAFoAWQBSAFMASABAADsAOAAqACUAFwARAAEA+v/y/+T/2//N/7z/sP+p/5j/jf94 /3H/Wv9T/z3/Of8d/yH/Af8L/+/++/7d/vX+1P7s/s7+9v7R/vb+0/4F/+X+FP/z/iT/B/8//yL/ WP8//2//YP+R/3z/qv+V/8H/s//a/8f/6f/e//n/7P8KAP7/DwAFABgAEAAgABYAKQAbACcAHwAj ACEAIwAcAB8AHQAaABYAFgARAAwACAADAPz//f/0//D/6f/d/9D/0P+//7v/sv+p/5r/mv+I/4// e/96/2f/bf9Y/2L/Sv9j/0j/X/9G/1z/P/9k/0v/cP9Z/3b/XP+G/3D/lP9//6P/iP+2/5z/yf+2 /9b/wv/e/8//6P/e//T/4v/+//H////x//7/8//9/+7//f/v//7/8//5//D/+//u//H/4v/r/9// 3f/Q/9j/zv/O/8L/zP+1/77/sv+2/6X/o/+X/5n/j/+N/4L/gP9t/3D/Xf9n/1f/Xf9L/13/R/9a /0T/Xf9H/13/S/9r/1n/fv9n/4//ff+k/5H/vP+v/9f/zf/y/+n/BQD8/xwAEgAoACMANwAxAD0A PQBHAEMASABAAEgAQgBEADoAOAAzADAAJwAhABkAEwAIAAQA+//w/+b/5P/X/87/xv+//6z/rP+Z /53/i/+G/3L/b/9V/17/Qv9J/zP/PP8j/y7/FP8k/wr/Gv/9/hH/7/4T//b+EP/t/hr//f4l/wX/ N/8a/0b/L/9g/0X/ev9k/5n/gv+z/53/0P/C/+j/2/8GAPz/GwAUADoANQBRAEwAXwBfAGUAZgBv AGsAcwBzAHQAdQBwAG8AbwBrAGMAZABfAF0ATQBOAEQAQAAyAC4AJgAgABEACgD///f/6f/d/9X/ w/+3/6j/ov+O/4T/cv9n/0//Sf8z/zb/GP8h/wT/Ef/2/gj/5v4H/+T+A//k/gn/6f4V//b+Kf8I /z3/IP9Y/0D/bP9U/4v/dv+o/5D/wf+1/9T/y//w/+T/CQD+/xkAEgAmACUANQA1AEAAPABOAEgA TgBJAFIATQBTAFMAVgBQAFAAUQBPAFAASgBHAEQARAA8ADcALAAqACAAGwAVABEAAQD8//L/5//c /9D/zP+//7T/oP+g/5L/j/9+/4D/Z/9v/1r/Zv9O/17/S/9e/0r/Yf9G/2j/Tf9w/1f/f/9k/4n/ dv+Z/4T/qv+Z/7X/p//B/7T/z//E/9f/0P/k/9r/7P/g//b/7v/8/+z//v/y/wkA/P8QAAYAFQAQ ABkAEwAeABYAIQAXAB4AGQAeABoAHQAcAB0AFQAPAAwACAABAPf/8v/s/9//1f/S/8T/vP+4/6v/ qv+g/5//jv+U/4f/jP99/5D/ev+S/3r/lP+C/5n/iv+k/5X/tv+n/8n/vv/c/8//6f/j//j/8v8G APz/EwAPABwAGQAiAB8AJwAlACgAJAArACYALAAiACMAHQAcABUAFgALAA4AAQAKAPv////0//T/ 6P/p/+H/5//V/9j/x//M/8H/wv+1/6//pf+d/5D/lP+F/4b/d/98/2P/av9c/2b/Uv9e/0z/Yv9M /2L/Tf9q/1X/cP9k/4H/c/+W/4r/p/+e/8P/s//a/87/8P/l/wMA/v8dABMANAApAEMAQwBLAE4A XABdAGMAZgBmAGoAbwBtAHQAcgBzAHMAbwBwAHMAbwBmAGYAYwBhAFkAVgBNAEUASQBBADsANwAp ACUAEgAOAAAA+f/p/+H/1P/L/7z/sP+d/4//hP90/3X/Yv9l/1D/Wf9D/1D/Nv9G/zH/Sv80/1D/ O/9X/0T/bP9Z/3r/bP+R/4H/p/+f/8H/tv/U/83/8v/o/wcAAgAZABoALAApADwAOgBFAEUAVABW AF8AYwBiAGcAYwBoAGYAbABkAGkAZgBoAGMAZwBgAF8AWQBVAFIAVABHAEcAOwA4ACwAKgAaABsA BwAFAPP/9P/f/9j/zP/H/7f/sf+p/5z/nP+K/43/fv+C/3P/gP9u/4L/b/+A/3X/i/98/5T/hP+h /5H/q/+j/77/s//P/8b/2P/U/+j/4//6//T/BwADAA4ADQAWABgAHQAeACcAIAAjACIALAAoADEA KwAvACoAMgAwADUALQAzAC8AMwA0ACoALgAtACwAJgAqACEAIgAXABUAEAAPAAIAAwD1//b/5P/l /9r/1P/K/8P/wP+5/7r/sf+y/63/r/+l/7L/pP+2/6z/wP+y/8z/wv/Z/9H/7P/l/wAA/f8PABAA IwAiADEAMQA8AEIARABKAEsAVABRAFUAVQBZAFQAUwBOAFQARQBKAEIAQwAyADIALgAsACEAHgAW ABUACQAIAAIA///y/+7/7P/o/9v/0v/H/8P/vP+z/6z/qf+h/5j/l/+T/4b/hP9//3b/dP9s/3P/ aP9y/2P/df9k/3r/cP+F/3j/lP+M/6X/oP+2/7L/0v/M/+n/6/8HAAgAGgAjADgAPgBMAFAAZgB1 AHYAhgCHAJoAlQCkAJ0ArwCdAK4AnwC0AKAAswCiAKwAmQCmAJMAoACHAJQAewCKAGsAeQBeAGYA SwBXADwARQAkACoAEAAUAPj//v/f/+b/xP/D/6v/ov+L/4T/eP9v/2L/WP9W/0v/Sf87/0L/Nf88 /y//QP8w/0z/O/9Z/0j/av9e/4H/fP+Y/4//t/+z/8r/0P/u//D/CQANACQAKwA4AEAATgBcAFsA ZwBuAHsAfwCPAIcAlQCQAJgAjgCgAI4AoACKAJ8AjACbAIMAlwCCAJEAegCGAG4AewBfAG0ATgBZ AEAASwArADoAHQAkAAkAEgD1/wAA3v/j/9H/0f+6/7z/q/+s/5//nP+W/5P/lP+O/5b/jf+U/43/ nv+T/6T/n/+0/7D/vv/A/87/z//e/+X/8v/2/wMACQASABkAHQApACsAMQAxAD4ANQBFADsARwBA AEoAQABMAEUAUQBBAFUAPwBRAD0ASAA7AE4AOgBGADcAQwAtADcALwA0ACQAMAAcACcAEQAYAAkA EQD5/wMA8P/4/+b/6P/g/+f/0f/W/87/zf/K/83/yv/K/8f/zf/U/9b/3P/Z//T/9/8DAA0AGwAj ACwANABCAFEAUABjAGQAdABvAIAAfgCWAIUAnQCMAJ8AiwCfAIoAnACBAJYAeQCRAGwAgABkAHAA VABhAEcAVAA8AEIALgAyAB4AJgASABoA/P8FAO//9f/f/+D/z//V/8X/x/+6/77/rf+x/6P/of+U /5r/j/+T/4j/i/+I/4L/hv+G/5D/jv+a/5j/qf+v/7j/vP/I/83/4f/u//n/AAAVAB4AKgA2AEcA VwBfAHEAdACOAIYAoQCVAKgAoACyAKEAuwCmAL4ApQC9AKIAvACeALIAlwCqAI8ApgCBAJcAdgCN AGoAfABZAGsASgBaADcAQQAnAC8AEwAbAP3/CADq//H/0P/V/7b/uP+h/6P/jf+Q/3//ff9w/3P/ av9h/2X/X/9f/17/Yv9c/23/aP95/3X/jv+M/6L/oP+5/7j/0f/U/+r/8P8FAAsAIQArADcASQBS AF4AYAB5AG8AgwCAAJUAkACoAJcArgCcALQAnwCyAJ4AswCcALEAlwCrAJQAqgCJAKMAhQCZAHsA lQBrAIEAYABxAFIAawBAAFQAMwBBACMAMQAQAB4A+v8GAOf/9//S/9z/w//J/7b/uv+r/6//o/+m /6D/o/+g/6P/o/+j/6r/rv+2/7z/wP/D/9H/1//f/+j/7v/7//z/CgANABgAGAAjACQAMQAtAD8A NQBHADoATgBAAE4ASQBaAEwAXgBPAF4ATABnAFIAYQBRAGYAVgBsAFQAaQBSAGkAUgBmAE4AXgBC AFwAPABRADAAQgAfADEAFgAnAA4AGgAAABAA8v/+/+r/+f/c/+z/2P/m/9j/4f/W/+L/3f/l/+3/ 8P/3/wIABgARABIAIQAkADEANgBBAEIAVQBQAGEAWwBvAGcAfQBvAIUAcwCFAHQAjQBzAIoAcQCI AG8AgABoAHUAXABuAFcAbABMAF8AQgBXAD0AUAAyAEcAHAAsABkAKAAHABkA/v8MAPX////m//P/ 1v/l/8b/z/+4/8P/q/+2/5//o/+X/5v/k/+X/5T/lP+T/5X/n/+c/6r/qf+0/77/xv/M/9//4v/v //X/CAANAB4AKgA1AEkASABcAGAAdwBsAIEAewCSAIcAoACQAKcAkACwAJoAuQCeALYAngC/AJYA tQCUAK8AkQCoAI0AogCAAJgAdQCLAGgAgQBbAHYARgBeADcAUAAeADYABwAaAPD/BQDf//H/wP/U /7j/w/+q/6z/mP+d/4n/iv+B/4T/fP+B/4D/gP+E/4X/jv+T/5T/nP+q/7T/vv/H/9P/4P/r//X/ AgAQABkAKAA5AEUASABcAGIAdwBwAIgAggCbAIsApgCVAK0AngC3AJsAvQCjAL0ApADAAJ4AvgCe ALwAnAC3AJAArQCOAKwAgwCbAHEAjwBlAIMAUwBrAEUAXQAyAEoAHgAyAAsAGwD9/wsA5v/y/9X/ 3//N/9T/xf/L/7z/wv+5/8P/uf/D/8T/z//O/9X/1//g/+H/7v/1/wEAAQAPABMAHwAeACoAKQA9 AC8AQQA9AEwARABVAEQAWwBKAGAAUABjAE8AYgBYAG0AVABqAFwAbQBXAHAAWABtAFkAbgBSAGoA TABnAFIAZQBEAFsAPQBUADMASQAmADwAIAAvABIAJQALABgAAAAOAPP/BgDp//z/5P/x/+L/7f/c /+v/5P/0/+v/+v/5/wMA/v8NAA8AIAAXACcAJwA5ADcASgBFAFYAUABeAFgAawBeAHUAZgB8AGkA fwBlAH0AZAB8AGAAeABeAG4AUgBqAEkAXABFAFEAPABKADEARQAiADIAFgAmAAsAGAADABIA9/8E APD////j//P/1P/j/8r/2/++/9D/tv/E/7b/w/+t/7L/p/+1/6j/tf+x/7//t//I/8H/zP/R/+D/ 5v/y//b/BwANAB8AIQA2ADsATwBLAGYAYQB6AG0AhwB8AJkAgwChAI0ApwCSALIAmQC2AJUAqwCV AK8AkQCqAIIAogCCAJ4AeACPAGsAgABiAHQAUwBlAEUAWQA2AEsAKQA9ABYAKgAGABMA7f/8/+D/ 7v/V/9v/xP/K/7X/vP+p/6//nP+g/5D/mv+P/5T/iv+R/47/lf+a/57/n/+r/7H/u//J/9T/1//e /+///P8FABUAFwArADAAQQBAAFQAUQBtAGQAgwBzAJEAgwCeAIYAoACJAKQAhwCkAI8ApgCLAKcA hQChAIMAmgB8AJUAdACMAG0AgwBoAHsAWABtAE0AYABEAFcANwBKACoAPgAeAC8ADAAbAP//CgDw //v/5P/r/9X/3P/P/9T/x//S/8P/y//E/8v/xv/M/8r/1f/W/+D/3P/s/+r/9f/1////AwASABEA IQAaACYAHwAwACsAOwAwAEIANgBGADgASgA5AE8AOQBFADcASAA4AEkANQBEADAAQQAvAEAAMQBB AC0ANQAnADsAKAA2ACIALgAiADEAGgApAA8AJAAUAB0ACQAVAAMAEQD5/wcA+P8EAPP//f/v//j/ 6//3/+3/+P/x//r/+/8GAAAACwANABcAFwAlACAAMgAvAD4AQABQAE0AXgBbAG0AYwB2AGgAfQBv AIgAcACCAGoAgABnAIAAXgB0AFkAZABJAFoAPABMADAAPwAlADMAFgAiAAgAFQD7/wkA8v/7/+b/ 8f/f/+X/1//i/9b/3P/K/9L/xP/O/8L/zf+7/73/tP+7/7n/vv+0/7f/vv+8/8D/xf/S/9f/1P/a /+T/7f/4//7/DgAWAB8AKQA2AEYAUQBeAGwAfgCBAJMAkwCqAJ4AtgCuAMUAtwDPAL4A0gC+ANIA wADZALkA0wCzAMsAqQDAAJ8AtwCSAKcAhACXAHIAhQBdAHMATABbAD0ATQArADYAFQAjAP3/CQDt //L/2f/c/8T/yv+u/7j/of+k/4//j/+F/4X/fP99/23/b/9w/2n/c/9s/3T/cf96/3n/if+H/5f/ mP+x/7P/wf/F/93/4f/v//b/GAAdAAQBJAEDAScBxADgAPAAEAFbAYwBdQGlAWIBjQFSAYIBXQGL AXEBoAFqAZ4BQAFxARwBRwESATwBBAEuAcwA+QCZALsAewCgAGIAewAvAEMA9/8FAMb/y/+f/6X/ dP90/0D/N/8N///+5P7S/sT+sP6t/pD+h/5q/mr+Sf5e/jf+Vv4v/lL+Kv5U/i/+Yf45/nT+UP6O /mj+rf6I/sv+rf7y/tn+F/8D/0n/N/93/2X/o/+e/9H/yf8GAAIANAA0AGEAbQCLAJoAvADPAOgA /AAOASoBKwFOAUwBdQFjAZEBeQGoAYQBvAGQAcMBjwHDAYwBvgF8Aa4BawGfAVIBgwE3AWIBEAFB AewAGAHEAOgAoQDCAHQAlABUAG8ALgA/AAsAHgDp//H/zf/P/6z/rv+Y/5D/e/9z/2L/WP9K/z// N/8n/yT/DP8M//r++P7l/ur+0v7a/r3+zP6r/rr+n/64/pf+t/6T/rn+mP66/pn+x/6n/s3+r/7p /sz+Bv/o/iT/CP9E/yn/af9X/5D/hv+5/7f/4v/e/w0ADwA2ADsAXgBnAIkAlgCsAL8AzgDqAO0A CwEMAS8BLwFVAUYBbgFcAYcBcgGaAXoBqAGGAbsBkgHGAZEBwwGMAb0BfwGtAXIBnwFYAX8BPAFl ARMBPAHyABYByADkAJ0AswBxAIMAPABIAAcADgDV/9b/of+g/3H/af87/zD/FP8E/+r+0f7G/qv+ n/55/n3+Wf5c/jP+dP5R/oH+Y/5X/i7+VP4u/nL+UP6A/mL+iP5o/pv+gP7D/qr+7/7a/h3/Ef9X /03/if98/8D/wP8KAAwARQBOAH4AkADAANMA+wAUASYBRQFcAXoBjAGwAaMBzQG5AekBywHzAcQB 9QG/AfEBtwHgAaIBywGIAaoBZQGHAUEBWwEYATMB7AAEAb0AygCJAJIAWwBeACsAIwD7//H/xv+6 /5j/hf9k/07/PP8i/wz/7P7Y/rj+tv6V/p3+c/6J/lz+dv5N/mv+R/5t/jv+df5J/oD+Xf6O/m3+ qP6I/r3+pP7r/tD+EP/9/jb/Jv9p/1z/i/+I/77/uf/q//D/EwAbAD0AUABoAH0AmgCwALwA0ADW APAA9wAXAQ4BLQElAUYBOgFdAUoBbQFUAXIBVgF9AV4BewFaAX8BTAFtAT0BWAElAUkBDAEkAe8A AQHLAOEAqQC0AIYAjgBiAGUAPQA8ACAAHQACAPf/6P/a/8r/vv+5/6b/pf+S/5r/iP+R/3j/hv9w /33/Zv96/2X/cv9b/17/Sf9b/0P/U/88/07/OP9H/zD/P/8p/zf/H/8v/yD/Lf8e/zT/JP8u/yH/ Mf8e/zf/KP9H/zT/Vf9I/2j/X/99/3j/l/+R/7H/qf/K/8j/6f/o/wAAAwAgACcAQgBQAF0AcACA AJAAlAClALUAxADKANoA5gD4APoADwERASsBHgE2ATMBTQFKAWQBTwFmAVQBawFQAWUBRAFaATkB TgEyAUYBIgE7Af0ABwHlAPEAxADMAJkAoQBsAHEAQAA6AA4AAwDl/9n/t/+r/4z/fP9f/0n/PP8o /xf//f71/tX+yf6q/qL+f/6P/mn+eP5N/mj+Qv5j/jr+Xf41/l3+Nf5m/kD+dP5O/ob+Z/6q/ob+ 1P60/gD/5f4z/x3/bf9a/6f/nv/p/+L/KQArAG4AcgCxALsA8QD+AC0BQAFsAYoBkwGzAbcB1QHM AfEB3gEDAtsBBQLcAQEC0AHyAcEB5AGlAcUBiAGmAWcBfgE8AVIBEAEhAeAA7wCqALcAeAB+AEcA SQAUABIA4//Y/7H/p/+A/3D/Uv85/x3/+/73/tT+0v6z/rr+mf6i/nz+kv5o/ob+Yf6G/mH+iv5e /pr+c/6o/oD+vP6Z/tz+v/75/t/+Hv8H/0//Of9t/13/lv+K/7v/tP/l/9z/BQD+/ywAMgBSAFgA dQB+AJIAmwCpALcAxgDTAN0A6QDxAAAB/wAPAQ0BHgEYASkBFwEsAR0BMQEWAS0BDwEjAQABFAHz AAQB1QDhAL0AxgCaAKQAhACLAGYAaQBLAEwAMgAtABoAEwAAAPv/9P/p/+P/1v/X/8f/zv+7/8v/ tP/G/7H/wf+0/77/sv+7/6z/sf+h/7D/mv+j/5P/of+O/5b/gf+N/3v/f/9t/3b/Yv9r/1T/YP9I /1f/P/9M/zX/QP8l/0P/Lf9B/y3/Sv81/1H/Pv9g/0X/b/9Y/3z/bP+N/4D/pv+a/8H/tP/l/9// /v/1/x8AFgA7ADkAVwBdAHkAfACZAKEAuQC/ANsA4gDvAPsAEAEhAS4BQwFEAVYBVQFtAWEBeAFm AXsBZAF4AV0BdQFQAWYBQQFUASoBOQEJARQB6gDyALkAwACSAJYAXgBbAC8AKwACAPf/1P/G/6X/ kv98/2f/UP83/yb/CP/6/tj+y/6m/q3+hf6U/mf+gf5P/nH+QP5j/jb+YP4v/mL+Lv5h/i7+bf49 /oT+V/6i/nT+y/6l/vb+2P4x/xj/av9P/63/lf/u/9//MwApAHUAcwC4AL4A9gD/ADcBSQFwAYkB ngG5AcMB4AHaAfgB5AEKAvABDwLrARAC4gEAAtEB7wGzAdIBkgGxAW8BjQFBAVgBFQEqAekA9QCy AL0AhQCLAE4ATQAeABYA7P/i/7f/rf+H/3L/TP8y/yj/Cv/5/tf+2/66/r/+nP6u/oT+nP5w/pX+ af6Q/mf+nP5s/qT+dv6t/oP+yf6g/ub+vf4D/+H+Jv8G/1D/Mv9z/1X/lv+C/7j/pP/b/8j/+v/r /xkAEwBAADsAXQBcAHwAegCNAJEAowCkALsAwwDPANgA4gDpAOsA+QD3AAQB/QAKAQUBDAECAREB AQEMAfUABgHqAPQA3ADkAMYAzwCzALkAmACdAIYAiABsAG0AWgBXAEUAPQAyACkAJAAZABYADAAK APv/+//s//b/5f/t/9z/5P/W/+D/yP/U/7z/xf+v/7v/pv+o/5T/mf+D/47/df96/1//ZP9K/1H/ Ov8+/yT/Mf8S/yP/A/8R//H+Cv/n/gj/4v4M/+v+Ev/1/iH/Av8u/xX/P/8q/1n/Pv9w/1n/hf93 /6v/of/L/73/8P/k/xIACQA0AC8AVgBXAH8AewCfAKUAwADJAOEA7AAFAQ0BJwEzAUsBXgFhAXgB cQGGAXsBkQF8AZMBfgGRAXQBiwFqAX0BUAFiATcBRwEYASUB9AD2AMcAzACXAJcAaABjADcALQAE APb/1v/E/6L/kP90/1z/Tf8w/x3/+v7m/sH+yf6e/qT+eP6P/mL+ef5H/mX+O/5c/jD+Vf4p/lT+ Jf5Y/ij+Y/41/nr+T/6Y/mv+vP6T/uX+w/4U//b+S/80/4v/dP/K/7r/DQADAE0ASgCTAI8A0ADX ABgBJwFJAV4BeAGPAZsBtAGyAdEBxQHjAdAB8QHOAfEBygHuAb8B3gGwAcsBlAGyAXMBkQFOAWMB LQE5AfwADAHSANwAowClAHQAdABAADsAEAAJAN3/0v+i/5b/cv9g/0v/MP8g/wD/+/7Y/t3+tP7D /pr+qv5//p3+b/6V/mL+l/5m/pb+Zf6e/m3+rf6A/sD+kv7Y/rD+9/7O/hH/7v4y/xP/Tv83/3j/ Xf+X/4D/u/+m/+H/y/////f/IgAWAEIAOgBdAF8AfQCEAJkAoAC4AL8A0QDYAOkA9QD4AAYBCgEh ARMBKgEdATEBHQEyAR0BLAEMAR8B/QAUAegA/ADcAOkAxgDLAKgArACSAJIAfgCBAGUAYQBUAEsA PAAxAC0AIAAXAAkACwD8//n/7f/w/9//6P/X/9f/xf/F/7b/vf+p/67/lv+c/4L/if9x/33/Yf9n /03/W/87/0j/LP85/yH/K/8J/xX/9f4S/+z+Df/t/gv/7f4R//H+Hf/7/iT/B/8x/x3/SP8v/1j/ Qf9v/17/iv93/6n/nv/K/7z/6//d/woAAwAvACoATQBOAHIAdgCRAJgAtAC9ANMA4AD+AAwBJAEz AToBUAFSAWQBZAF7AWQBfQFqAYEBawF/AWsBfQFcAXEBSwFdAS4BQgEWASMB7gD4AMkAzwCaAJkA bgBuAD0ANwAPAAAA2P/J/6//of99/2f/Wf88/yj/Av/x/sv+zP6k/rH+hv6T/mj+gv5R/mv+Pv5b /jD+T/4n/lD+IP5U/iP+Wv4y/m3+Pv6H/mb+sP6K/tv+t/4L/+3+Pf8m/3r/Zv+4/6n/+v/v/zkA NAB+AHsAwgDHAPYABQErATwBVQFsAXoBlAGSAa8BrQHIAbEB0wG7AdcBsgHSAa8ByQGeAbkBhAGh AWcBfQFFAVIBHAEqAfIA+QDIAMoAmQCaAGkAaAA8ADUACAAAANf/yf+l/4//e/9n/1P/Of8t/xL/ D//n/vL+z/7c/rT+zf6o/sH+l/67/pD+uP6O/rn+kf7B/pr+0f6l/uH+uP73/tX+EP/t/if/CP9A /yf/X/9F/3D/XP+Q/3//rP+Z/8P/t//h/9P/9f/r/xEABwAtACUARgA+AGMAXgB1AHgAjACOAKQA pAC3ALoAwwDPAM0A2wDiAOYA4ADqAN8A7ADdAOsA2gDnAM8A1wDDAMkAtQC6AJ8AqQCYAJwAhwCF AHUAeABpAGgAVgBSAEwARwBAADkAMQAoACYAHwAfABQADwAHAAAA9P/y/+P/3f/P/87/vP+5/6f/ pv+V/4//ef9+/2L/Yv9I/0v/NP82/xz/Hv8A/wX/4/75/tn+6v7J/uj+xf7s/sr+7v7K/vX+0v7+ /uH+Df/v/iP//v45/x7/V/8+/3H/Yf+Z/4X/uv+q/+H/0v8CAAAAKwAlAFMATwB5AIIAnwCmAMoA 0gD3AAgBFAElASwBQQFKAWABXgFyAWYBfAF2AYwBdgGOAXUBiwFqAX8BWQFrAUIBTwEfASwB/AAL AdQA2wCsAK0AfQB3AEYAQgAdABUA8//n/8L/tf+Z/4b/Z/9P/zD/Dv8T/+v+8P7N/tH+pv63/pD+ qP5//pH+ZP6I/l3+f/5T/oD+VP58/lP+gv5Z/pb+a/6x/o3+1/6z/gT/5/4z/xn/Y/9N/5z/hv/X /8z/EwALAFQAUACbAKEA0wDdAAkBGgE3AUwBWgFzAYIBkwGUAbMBpgHGAa0BzQG0AdMBrAHKAa0B xgGeAbgBhgGjAWkBgQFIAVsBIAE1AfkABwHRANoApQCpAHcAewBKAEMAGAASAOj/3//G/7H/lP98 /3X/XP9R/zP/LP8S/xv/+v4J/9r++f7P/ur+w/7l/r7+2P6z/ur+w/7z/s7+Af/e/hb/8v4r/w// Q/8r/2L/R/9+/2r/mf+E/7D/nP/T/8j/6//d//7/9f8XABIANgAvAEwATgBtAGkAfACDAJIAnQCq ALEAuwDDAMQA1gDfAO4A6QD2APUABAH2AAkB9QAIAfAA/QDvAPsA5wD5AOIA7wDUAOEAzQDWAMIA yQCzALwAnACgAIkAkwB4AHsAbgBqAGcAWwBYAFUATwBKAEcAPwA8ADUALAAmABkADgAKAP//+//o //D/4f/h/83/zP/B/7r/o/+p/5X/j/94/3j/Xv9a/z//Q/8k/zn/Hf8v/w7/Jv8G/yP/Cv8e/wX/ I/8L/yb/EP8x/xv/QP8r/1P/O/9m/1n/h/97/6P/lv/G/73/7P/f/w0ABQA4ADUAXQBbAIUAigCs ALMA0gDfAAQBFQEmATsBSAFhAV8BdwF7AZABhwGgAZUBrwGaAbIBngG3AZABrgGMAaABegGOAWcB ewFDAVMBIwE1AfoABQHIANEAnQCdAGgAaAA9ADcADQAAAN//z/+s/5j/bv9Z/0z/Mv8m/wj/A//h /t/+v/7J/qX+rv6G/p7+dP6I/mD+hP5c/oH+Wf6G/lv+l/5v/q/+iP7H/qL+7v7N/hr//f5I/y// ef9p/67/ov/v/+r/LQAnAG4AbwC0ALkA8wABASoBRAFWAW4BgQGbAaMBvwG8AdwBzQHvAdoBBALZ AQIC2wH9Ac4B7wG5AdcBnAG4AX8BlwFcAXIBPgFQAQwBIQHgAO8AsgC3AIYAjABTAFcAJwAnAAAA 9v/Z/83/rf+Z/4n/eP9r/1H/Q/8m/yj/Bv8M/+7+9/7b/vT+z/7m/sP+5f6+/un+yP70/tH+/P7e /hH/8/4l/wr/OP8f/0v/N/9m/1P/fP9p/5z/iP+3/6b/1v/M//H/5v8OAAcAKAAgAEEAQQBaAF4A dQCAAIoAlQCiALEAugDGANYA5gDjAPkA/QATAQoBHgEVAS8BGwEzARsBMAESASgBEgEqAQsBIQH7 ABAB8wAGAeoA+wDcAOoAywDZALkAwwCnALAAmAChAIwAkQB+AIIAbQBuAFsAXwBGAEoANQAyACIA GwAIAAYA+P/z/+z/4//W/83/w/+x/6f/lP+P/3r/ev9m/17/SP9E/yr/OP8d/x//Bf8S//v+Df/3 /gv/7/4N//P+E//5/h3/Av8w/xf/R/8s/1v/Sf93/2r/k/+J/7P/q//c/9j/AQD+/y0AKQBUAFwA fwCHAKEArwDHANIA+gANASUBQAFCAWMBZQGCAXcBmwGGAaoBmAG9AaEBwwGnAcwBpAHIAZYBuQGK AaoBeQGYAVwBeAE7AVIBEgEoAfIA/gDFANAAmwClAG8AcgBBAD8AGAARANv/zf+o/5f/fv9j/0r/ Nf8m/w3/A//q/uf+y/7V/rf+vf6k/q7+jf6h/oD+nf5+/pT+ev6W/nv+rP6L/sH+pP7b/sL+/P7i /iT/DP9M/zn/ev9t/7X/sP/q/+b/HQAfAGAAZQCPAJwAyQDWAPMACgEiATkBSAFlAWoBjAGEAacB mQG9AaMBxQGqAc8BrwHUAZ8BwQGNAbUBdwGbAWIBfAFEAVwBJAE/Af4AFgHbAPMAswDDAI4AmwBm AHUAPQA7ABIAEwDp/+X/vf+3/5v/jv95/23/X/9L/0X/Lv8w/xn/I/8L/wr/9f4D/+7+A//p/gL/ 5/4T//L+HP8C/yT/Dv83/yX/R/84/1j/Sv9t/1v/gf94/5n/kP+x/6v/zf/Q/+f/5P/9////GwAb ADQAOQBNAE0AXQBjAHMAewCKAJQAoQCxALYAyQC/ANIA1ADpAN8A9wDpAP8A6QAIAewABgHrAAMB 6AACAeUA/ADnAP0A4QD2ANoA7gDJANsAtwDJAKsAtwCgAKsAlgCbAIMAkAB7AIQAcgB3AGAAaABW AFUAPwBBADIALgAgABwACQAFAPT/7v/d/9r/x/+7/6z/pP+T/4v/dv9n/1H/Qf8+/y//Iv8Q/xH/ +/4A/+j+9/7j/ur+1v7j/tH+3v7M/uT+y/7p/tf++/7m/gn/9/4h/w//P/8u/2H/VP+C/3v/qv+n /9D/0f/8////JgApAFMAWgCFAJMAvADRAN0A9QAFASYBJAFCAUkBZwFcAXsBbwGSAXkBnQF8AaQB fQGkAYMBpwF2AZgBXwGBAUIBZQEqAUYBAQEgAdUA8QCvAL8AfwCQAFAAXAAcACIA7P/u/7P/s/98 /23/T/8+/yP/EP/1/uL+0P63/rP+l/6T/nD+eP5V/mP+QP5b/jX+TP4p/kz+J/5P/i7+Y/5B/nX+ Vv6V/nv+tv6c/t3+y/4G//P+Ov8s/2f/Xv+k/6H/4v/l/xoAIQBQAF8AiACSALsA0gDlAAMBEAEt ATUBVgFQAXUBaAGNAXYBmgGDAaoBhwGyAYEBrAFyAZgBWQGAAUgBcQEvAVQBDAEpAecA/AC7ANEA lQCrAGYAdAA4AEEACgAOAOX/5v+8/7n/lP+R/3H/bP9W/0n/Nv8p/xj/C/8F//P+8P7b/t7+xP7S /rn+zP6x/sn+tP7L/rf+1/7B/t3+yf7u/tf+/P7r/gv//v4g/xT/PP8y/1H/Sv9y/2b/jf+I/6n/ pP/B/8b/4f/i//r/+/8PABQAIgArAD0ASQBZAGEAbQCBAIEAlgCRAKEAoQC4ALUAyAC+ANMAxQDe AMgA4ADLAOgAxQDfAMoA5wDIAOIAwgDbAL8A1ACvAL8AmACpAIkAmwB5AIYAbAB3AFoAaABRAFwA QQBHADQANgAfACQADgATAPr//f/r/+v/1//R/8L/uf+r/6L/lf+P/4H/eP9q/1//TP8+/yz/HP8Z /wH/Bv/s/vT+4f7i/s7+0/69/s3+tv7F/q3+xf6t/sj+s/7S/rj+1/69/ur+1/7//u/+H/8P/z3/ Nv9e/1b/hP9+/6z/q//Q/9T/9//5/ysAMABeAGkAhACWAKwAvwDMAN8A6gABAQMBHwEaATUBMAFO ATwBVgFDAWQBQwFhAUcBZQE9AV4BKQFFARQBLgH2AAoB1ADpAK4AwACHAJIAWwBgADEANgD+/wMA y//J/5H/if9l/1f/Nf8j/wr/8/7d/sj+uv6c/pf+ev51/lf+WP47/kr+Jv40/g/+Jv4A/if+Af4x /gX+Ov4T/kz+Kf5m/kf+if5q/q3+kP7U/rn+Bf/z/jr/J/9u/2f/qf+r/+X/5P8dACUAUABaAIQA lACwAMkA2QDyAP4AGgEaAToBNQFSAUwBbQFVAXoBUwF0AUwBcQE9AVwBLgFGAQ4BKQHwAA0B0ADn AKsAwwCEAJUAWQBoAC4ANgAIAAkA2f/b/7j/tP+O/4f/aP9g/0z/PP8s/x3/FP8B///+6P7u/s/+ 1/64/sf+qv6//qT+uv6h/sL+of7K/qz+zf61/tb+uv7j/sz+8/7a/gT/6/4Q/wD/IP8N/zL/J/9C /zr/Xf9R/3L/Zv+A/3n/l/+T/6n/o/+7/7j/zP/K/+L/3v/0//f/CAANABcAHgAsAC0ANQA/AEUA UQBOAFwAXgBoAGcAcwBrAHUAcAB6AHYAhQB4AIcAeACIAHwAhABxAIIAZwByAGQAbwBcAGQAWABj AFEAUwBGAEwAPABAADQANQAcAB0AEQAUAAQA/P/p/+f/0f/O/7r/sf+g/57/if9+/2r/ZP9T/z3/ Kf8S/w//9/7s/tf+2v6+/sH+ov6t/o/+m/56/o/+cP5//mL+gP5d/n3+XP58/ln+if5q/p7+f/6t /pH+yf62/ur+2P4J//j+Mv8h/13/Tf+H/37/tP+r/+T/4v8bABsARQBQAHgAfwCdAKwAwgDTAOAA +QADAR4BFgEvASoBRQE2AVEBRAFgAUsBZAE9AV4BLwFJARsBMwH5AA8B2gDtALUAwgCMAJkAXgBi ADMAMwD3//n/xv+6/43/gv9a/03/Kf8X//z+4/7R/rj+rf6L/or+Zf5t/kj+T/4m/jr+E/4i/vz9 Ef7k/RH+5P0Y/ur9H/7y/S/+B/5K/iT+Z/5B/oz+a/69/pz+6P7M/hj/BP9R/0H/i/+C/73/uP/6 //n/KwA0AGgAbACVAJ4AwQDNAOMA+AABARoBHgE2ATgBWAE+AV0BQQFiAUABXAE5AVEBIgFBARQB LQH5ABQB4QD1AMAA0ACeAKoAcgB6AEsAUQAfACMA9v/2/8v/yf+m/5n/ef9t/1T/RP8z/xz/Ff/5 /vP+3v7d/sT+xP6g/rr+kf6r/on+pv6B/qT+f/6l/oH+rf6H/rX+kv69/p7+y/6s/tT+uv7p/sj+ +f7d/g3/9v4f/wb/N/8h/0n/Mv9g/0//dP9n/4r/gP+e/5f/tf+v/9L/yf/q/+j/AQACABIAFQAs ADEAQwBIAFEAVwBdAGgAbABzAHQAgAB1AIUAfQCIAIUAjwCBAIwAfQCLAHsAhgBwAHkAagBwAGAA ZQBaAFwATABNAEAAQAA0ADYAKgAoABYAFAAIAAEA9//t/+b/1//Q/8D/t/+k/5z/i/+D/3b/av9X /0n/Mv8l/wz/D//z/vb+2P7g/r/+xv6n/rv+nP6q/ob+pf6B/qL+fv6b/nj+kf5w/pX+c/6W/nP+ pf6H/rX+m/7N/rT+7P7O/gP/7/4o/xP/Sf83/2v/Yv+T/4X/u/+0//r/8v8cAB0ASgBPAHQAegCY AKMAugDHANcA5ADuAAIBBQEcARIBJgEiATUBLQE/ASYBOgEfATABCQEcAfQABAHZAOIAuADCAJYA mAByAHEARgBGACEAHQDv/+r/vf+y/5X/g/9q/1H/Qv8n/xr/+/7x/tX+y/6t/q/+jf6R/m3+ff5V /mD+Mv5I/hj+Pf4L/jb+Cv47/g3+Qf4V/lL+JP5l/j7+ff5X/p7+dv69/pv+6f7L/hr//v5O/zb/ fP9o/6//of/g/9f/CwAEADsANgBpAGsAigCTAK4AuADNANsA6QD2AP8AFAENAR8BFgEkARYBJgEP ASIBCgEbAf0ADgHrAPsA1gDnAL8AywCjAK8AhgCMAF8AYwA7AD8AGAAUAPD/7P/R/8T/p/+U/4b/ dP9n/0//SP8v/yb/C/8H/+z++f7Y/uX+xf7W/rH+z/6p/sP+of7E/qP+wv6d/sz+pf7M/qz+0v6v /tn+s/7f/sH+7f7O/v/+4f4L/+z+Hv8B/yr/E/8+/yv/VP9B/2f/XP+E/3T/nv+N/7n/sf/W/8z/ 8//p/wkABwAlACMAOwA+AE4AVABjAGgAdgB6AHsAgwCBAJAAkgCfAJMAoQCaAKQAlACfAJIAmgCL AJUAhwCRAIAAhQB2AH8AbgByAGcAaQBfAFsAVwBTAEQAPQAtACgAHAAVAAoA/f/x/+j/3f/S/8P/ sv+q/5n/lv+H/3f/Xv9U/zf/P/8q/yL/BP8S//H+/f7e/u7+zf7d/r7+z/6r/sj+n/6//qD+tf6Q /rX+iv65/pj+xf6f/s/+rf7m/sT+8/7Z/gz/8v4m/w3/Rf8x/2T/Uf+Q/37/u/+w/+j/4P8WAAwA QAA7AGYAZwCNAJEArQC1ANAA2wDsAPgAAwESARMBJgEiATcBLgFDAS0BPwEmATwBGwEoAQIBFAHu APoA0gDaALUAwACYAJoAdwB0AEoASgAgABwA+f/u/87/wP+g/5P/e/9l/1H/O/8r/xD/Av/l/t7+ vf7E/p3+of50/nz+T/5t/kX+Wf4s/lj+Lf5U/iX+W/4w/mD+N/53/kv+i/5f/qj+gv7H/qP+8v7R /hz/Af9K/zL/eP9o/6H/lv/Z/8z/CQD6/zEALgBeAF0AhACKAKkAqgDNANQA8gAAAQQBFgEaASsB IAE2ASQBOwEmATwBJgE6ARgBMgENASIB9wALAeEA9QDGANIApQCzAIAAhwBeAGQANgA3AA4ACQDo /+D/wv+3/5r/jP9+/2n/WP9D/zn/HP8i/wH/DP/r/vv+2P7s/sv+4v6//uD+u/7a/rj+3P64/tr+ tv7i/r7+4v7D/un+x/7x/s/+AP/e/gf/6/4Z//v+K/8S/0H/Kf9Q/zr/a/9d/4b/c/+j/5n/wf+2 /97/1v////X/GgAZADUAMgBOAFQAZgBoAHoAfwCJAJEAmgCfAKQAsQCwAL8AswDFALcAxgC3AMYA twDDAK8AuACuALkApwCxAKEApwCTAJUAjQCVAH8AggBzAHMAYQBgAE0ATAA0ADQAIwAZAAgA/P/x /+n/1f/K/7r/rP+e/5T/gf9z/2b/Tf9Q/zb/N/8f/yv/Bf8U//j+Cf/t/vj+2f7u/s3+4v7F/tz+ xP7Y/rT+0P6u/tb+tf7d/rz+4/7F/vH+1f4H/+r+G/8D/zP/Hv9O/zr/bP9c/4//fv+3/6j/6f/e /w0ADQA8ADgAXwBhAIQAjACpALMAyADbAN8A8wD6AAwBCQEdASABMgEoAUQBLAFDASYBQAEhATYB EQEgAf4AEAHqAPsA2QDmAL4AyACfAKsAhQCLAGoAZgBBADgAFwANAO7/4f/H/7j/o/+K/4H/Z/9V /0D/Mv8W/w//8P7z/tH+zv6q/rH+iP6h/nr+kv5p/ob+Zf6J/mT+j/5q/pr+cv6o/oH+uv6b/tX+ s/7y/tb+Gf8B/0D/KP9q/1f/k/+I/8H/tf/o/+X/FAAUAD0AQQBmAG0AjQCUALQAugDbAOcA8AAC AQQBFwEWAScBHwEzASIBNgEmATsBIAE0ARYBKwEKARsB+AAGAeEA8ADKANcAqwC0AIgAkQBoAGkA PgA/AB4AHAD6//L/1f/M/7z/rf+b/4v/gv9v/2L/Uf9N/zr/Qv8u/zD/FP8l/wr/I/8I/xr/Av8d /wD/Hf8G/yP/C/8m/w3/Kf8S/zP/Hv88/yX/Tv84/1f/RP9q/1f/ff9u/4//hP+i/5n/tv+w/9b/ z//x/+//BwAIACAAHwA3ADgATgBVAGMAaQB3AIAAggCOAIoAmQCRAJ8AnACoAKEAsgCkALcAoQCy AKAAsACXAKoAlACfAJAAmQCJAJMAggCJAHwAhAB1AH0AcAByAGgAaQBdAF4ATQBRAEQAQwAvAC8A IwAdAA4ADAD7//n/7//n/93/1P/F/77/sv+k/5v/i/+J/3n/df9k/2r/VP9f/0r/Uf9A/0b/L/89 /yn/M/8d/y3/G/8k/xP/Gf8F/xn/Bf8Z/wv/IP8M/yn/Gv80/yH/QP8x/1D/Rf9n/1n/f/90/6D/ mP/B/8D/6f/s/w0AEgA5AEEAYABtAIUAkACnALkAyQDZAOIA+wD+ABEBGQEuAS4BSwE0AVQBQAFb AT0BVwE1AVABJgE8ARgBMAEEARoB8QADAdUA6gC3AMsAlQCjAHMAeQBOAFMAKwArAAQAAQDe/9z/ u/+y/47/hP9r/1z/SP8z/yH/Df/9/ur+1f68/sD+qv6s/o3+pP58/p3+ev6g/n7+oP57/q3+jP69 /pr+0P6z/uv+0v4R//j+Nf8f/1z/Tv+B/3P/sf+r/9v/0/8LAAsAMQA0AFoAYAB/AIwArwC7ANUA 6gDyAAsBDQErAScBRgE8AVwBSgFpAVQBcgFYAXoBTgFuAUsBawE8AV0BKgFJARIBLQH3ABEB2ADq ALgAxgCIAJYAZABxAD0AQQAUABYA6//r/8r/w/+i/5j/gP90/1//Vf9I/zn/N/8m/yz/Gf8d/w7/ F/8A/xX/+/4S//n+E//9/hT///4R//z+Gf8E/yL/D/8t/xn/P/8u/1D/QP9f/03/cv9o/4f/gP+k /5n/vP+y/9r/1//2//b/FAAWADAANgBKAFoAZABxAHkAigCPAKEAowC0ALAAwQC8AM8AxADWAMwA 4gDOAOYA0gDmAMwA6ADLAOAAwADTALwA0QCuAMgArwC/AKUAtQCdALAAlQClAIsAmgB3AIUAaAB5 AFUAYgBAAEsALAAxABgAGwACAAIA7v/q/9X/1v/D/77/pP+f/5b/h/+D/3b/dv9q/2j/WP9a/07/ Tv9A/0z/Qv9C/zb/QP8x/zz/Lf80/yD/Mv8m/zT/Kf9A/y//TP8+/1P/S/9g/1f/b/9t/4b/hP+c /5n/tv+8/93/2f///wIAIAArAEYAUQBqAHsAkACiALMAxQDUAOwA9QANAQwBKwEjAUUBNQFaAUcB bwFVAXYBUgFyAUgBZwFCAV0BNQFUASEBPwETATAB/wAYAeoA/gDNAOAArQC+AI0AmwB0AH8ATABV ADEANwAKAA4A6v/p/8r/wP+l/5z/g/90/13/U/8w/yH/GP8H//j+5/7r/tT+3P7D/s/+u/7M/rT+ zv61/tP+vf7i/sv+9P7g/gn/+v4k/xP/Rf84/2f/Yf+L/4r/sv+x/93/5P8JAA0ALgA1AFoAZQCC AJIArQC8ANsA7gD2ABQBGQE2AS4BUQE/AWMBVAF3AV4BhgFkAYkBaQGRAWIBiwFWAXwBSAFuATUB WAEbAToB/AAbAdgA8ACzAMsAjACiAGUAdQA7AEcAFgAeAPD/8//K/8P/o/+h/4n/g/9s/17/W/9K /0b/PP83/yr/Lv8e/yj/Gv8b/xD/H/8Q/yL/Dv8d/xD/JP8V/y//Hv83/yj/Rf84/1f/Sv9o/2H/ ev90/5H/jP+o/6j/w//I/+H/6f8AAAcAIQAtAD8ATwBeAHEAegCSAJUArwCqAMYAvQDYAM8A7gDd APoA6AALAfMAFgH1ABYB8QASAe8AEQHrAAoB5gD9AOAA/QDRAOwAxwDjAL0A2QCyAMwApwC6AJgA rwCIAJkAcwCKAGIAdwBNAF4AOwBMACkANQAVAB0AAQAIAOn/8f/T/9b/wv/C/7P/rf+d/5n/j/+L /4L/ff96/3X/bv9o/2b/YP9g/17/WP9P/07/Qv9N/0n/T/9I/1P/U/9Z/1f/YP9i/2//bv93/3f/ gf+A/5j/mv+t/7P/y//O/+P/8P8IABMAKwA5AE4AXgBwAIYAlQCrALYA0wDRAO8A8AASAQoBLwEo AUgBPQFnAUkBbAFOAXcBTwF7AVABdwFEAWoBOgFeASoBUQEdAUEBBQEmAfIACwHUAO8AugDUAJgA rwB7AI4AWABmADkARwAVAB0A9v/+/9H/1/+1/7j/jv+K/2T/X/9G/z7/K/8d/xT/AP///un+6/7X /t3+zP7c/sT+1f6//tX+xf7c/sv+6P7V/vr+8P4U/wr/NP8t/1X/Uf9+/3z/of+k/87/1f/3/wQA JQAuAEwAWQB8AJIAqQDDAM4A6ADtABEBEQE5AS4BUQFIAXUBXwGJAXYBmwF8AawBhAG0AYgBtgGC AbIBcQGgAWEBjgFFAWwBKwFPAQcBKAHdAP4AuADUAJEApQBjAHYAPABJAA8AGQDg/+b/uv+//5b/ nP93/3j/Yf9c/0z/Qv86/zP/KP8e/x//FP8Y/wv/DP8B/wX/9f4I//v+Bv/8/hH/Bf8c/w7/K/8i /zz/M/9O/0j/Xf9X/3f/c/+X/5P/tv+5/8//2P/6//z/FAAjADUASgBdAHIAggCfAJ0AuwC5ANwA 1wD1AOYACQH+ACQBCgEzAREBOwEaAUMBFwFCARgBPwEPATMBBwEsAf8AIwH6AB0B6gAMAeMAAwHQ APUAxwDfALIAzgCkAMAAkQCiAH0AlwBmAHgAUQBkADkASAAjADUADQAVAPT////e/+P/yf/I/7P/ tv+l/6f/l/+Y/47/jP9//4X/dP91/2//bP9l/2H/Vf9T/1P/VP9S/0j/T/9L/1D/SP9Q/1L/VP9T /13/Wv9j/2T/cP9z/3v/gf+W/5v/sP+0/8z/1v/q//j/CgAZADAAQABUAGMAdQCOAJgAuQC+ANsA 2gD7APoAHQEdAUYBLwFbAUUBcgFNAXUBUQF/AU4BfwFSAXsBSgFzAT0BaQEuAVMBHwFHAQ0BMQH2 ABcB2QD1AL8A2QCbALMAegCKAFgAZwA5AEQAEAAbAOv/9f/H/87/n/+g/23/aP9S/0b/LP8e/xH/ Bf/z/uT+3v7O/sj+vf7A/rj+uv6t/rv+r/7B/rD+zP6+/t3+zv74/ur+GP8P/zf/Mv9b/1z/hv+D /6v/rf/X/97//v8LAC4APgBkAHgAjACnALgA1ADgAAEBAgEqASUBTAFCAWwBWwGFAW4BnwF+AasB iQG1AZIBwgGKAb8BggGwAW8BmwFWAYIBOgFgARkBPAHyABEBzQDpAKEAtwB3AI8ASgBWABkAJQDt //b/yP/F/6f/pP+G/4D/Yv9j/1D/R/81/yz/JP8b/xj/C/8H//3+/f7r/vT+6P7z/uL+8/7i/vT+ 5v77/vH+B//8/hj/Df8p/yb/QP82/1T/Uv92/3b/lf+Y/7v/uv/h/+n/AwARACkAOwBPAGMAcQCN AJUAswC3ANEAxwDtAOEABAH7AB8BAwEwAQ0BNgEWAToBFQE+ARUBPgEOATgBBwEsAf8AIgH1ABcB 6AAIAdoAAAHNAO8AuwDdAKIAxACOAKoAdgCWAF4AdQBOAF4ANQBBABsAJgAFAA4A8f/2/9j/2//B /8T/rf+s/5v/of+P/4r/gv+A/3r/dP9x/2r/a/9h/2L/XP9X/1n/Tv9J/03/R/9N/0b/Sv9F/0// TP9R/1D/Vv9X/13/Wf9h/2P/Z/9t/3r/ev+P/5T/o/+q/77/xf/e/+f/AAANAB0ALQBDAFUAZgB7 AIYAoACmAMAAyQDqAO0ADAEEASsBHQE+AS0BUwE0AV4BPAFjAT0BZQE+AWUBOAFeATIBUwEkAUgB FgE5AQIBJgHtAA4B1QDvALwA1gCdAK8AfgCQAFkAawA8AE4AFQAjAO//9//F/8f/lv+T/2//af9N /z//I/8X/wr/9v7t/tv+0f6+/rv+qf6x/p/+rf6a/q3+lf6v/pb+wP6u/tf+w/7w/tv+D/8I/zb/ Lf9Y/1L/hv+G/6z/qf/c/+L/EAAaAEAATQB4AIwApQDAANMA8wD7ABwBIQFGAUUBbgFlAY0BgwGu AZEBwgGoAdYBrwHbAa0B4AGlAdYBlgHHAYABqQFhAYcBPwFhARYBOAHwAAkBvgDaAI8AqgBfAHMA LwA3AAIACADU/9b/q/+m/4f/gf9q/2D/Sv88/zH/JP8e/wz/C////vv+7v70/uL+6v7V/u3+3P7t /tz+8v7h/v3+6v4L//r+Ff8F/yz/Hv88/zT/Wf9U/27/bf+W/5T/r/+w/9X/0v/z//r/GQAlADoA RgBdAG4AcwCKAI8AqQCkAMIAvgDXANMA8wDjAAEB7wAPAfYAFwH0ABoB8AASAegACgHnAAYB3gD9 ANcA8wDQAOkAwQDdALQA0QCoAL8AmgCwAI0AnwB7AIsAawB+AFwAawBNAFcAOwBHACoANAAaAB4A BQAMAOz/8v/e/+H/yP/I/7n/sv+q/6H/l/+P/4z/g/99/3P/cf9i/2H/Vv9L/z3/Q/84/zb/KP8u /yT/Kf8e/yP/Gf8h/xX/If8W/yP/Ff8s/yH/M/8r/0b/Ov9U/0//c/9p/43/h/+t/6j/0f/U//b/ /f8gACUATABXAHEAhQCdALUAxQDbAPEADQELAS4BLgFTAT4BYgFPAXQBXAF8AWcBigFjAYcBYQGF AVQBeQFNAW0BPgFfASUBRgEIASYB7AAGAccA3AClALgAgACNAFkAXwAuADYABAAJANH/0P+h/5z/ c/9r/0j/Of8k/wv/+v7m/tr+xP7A/qT+ov6I/pT+df6F/mL+fv5g/nj+WP58/mD+jP5x/qb+h/7D /qr+6P7W/gz//P47/yz/Zv9b/53/j//H/8X/9/8DADMAPwBqAHsAmwCvAMgA4gD0AA4BGwE4AT4B YAFcAX0BcwGaAYgBrgGQAbgBnwHEAZoBvQGPAboBewGkAWgBjQFKAWUBKAFGAQABIAHYAPIAqwDD AIIAkgBRAFgAIwAmAPP/9P/K/8v/n/+d/3//c/9d/1P/Qf8z/yn/GP8X/wL/Bf/z/vn+5/7r/tL+ 6P7P/ub+0f7r/tT+7v7a/vr+4/4D/+7+Dv/9/h//EP8w/yH/RP84/1r/W/98/3X/mf+T/7j/tP/Z /9z/+P/8/xUAHQA4AEEAVwBhAHIAfwCRAKEApwC7AL0A0wDQAOQA3QDxAOIA+QDjAP8A5gD+AOYA /wDfAPgA2AD1ANMA6gDMAOEAxQDcALkA0ACvAMIAogCwAI0AnAB/AIwAbwB6AF8AaABPAFgAOgBE ACUAKgAUABEABAD+/+3/6P/T/9H/xf++/7D/o/+a/43/j/9+/33/bv90/2P/Zv9V/0v/Nv8//y// N/8n/y//Fv8t/xr/Jv8U/yH/Ev8o/xf/Kv8Z/yn/Fv8y/yP/Pv8w/0r/Pv9g/1P/df9y/5T/kf+2 /7f/2v/Z//7/AgAiACwATQBWAHMAfwCdAK4AzgDhAO4ABAELASkBKAFEATwBWQFIAWUBUwFzAVgB dwFXAXgBVQF3AVEBcAFGAWEBNAFOARkBNAECARQB5ADyAMUAzwCfAKgAeQCDAFUAWgArAC8ACAAJ ANz/0/+h/5j/ev9s/1D/Q/8n/xX/Cf/x/ub+yf7I/qj+r/6S/pv+e/6M/m3+f/5e/nf+WP6B/mH+ iv5w/qH+gf68/qL+2v68/v3+5f4h/w3/S/83/3H/Zf+h/5b/2f/W/wgABgA4ADoAZQBtAJIAmgC7 AMQA3QDtAPwAEgEXAS4BMQFNAUEBXwFTAWoBXAF8AVoBfwFUAXYBRgFkATUBUQEbATIB/QATAd0A 8QC3AMgAkACgAGsAdAA7AEIAFwAWAPD/6v/L/8X/q/+j/5H/hf90/2b/Y/9Q/0//N/9G/zH/Nv8i /y3/Ev8n/xX/LP8U/zD/HP85/yP/Qf8l/0j/Nf9T/z3/Xf9N/2n/W/9+/27/if9//6D/lP+w/6j/ xv+9/9j/1f/p/+z/AQD+/xQAGAAkACcAMQA2AD4ARgBOAFUAXgBpAGYAbQBmAHYAagB2AGsAcgBm AHAAXwBqAF4AZgBaAF8AUwBQAEoAUABJAE0AQgBCADwAQAAzADkALwAwACsAIwAlACIAHgAaABwA FwAVABMADwALAA0ACAAIAAEAAQD6//v/9v/2/+v/8//m/+z/3v/n/+D/4//a/+H/2v/e/9X/2P/Q /8r/vv/B/7//vP+0/7r/sf+x/6n/rf+o/6L/oP+e/5f/mv+R/5P/iv+H/4D/h/9+/4X/fv+L/4D/ j/+H/5j/kP+k/5z/tv+r/77/t//V/8z/5P/b//v/9P8UAA0AJgArADgAPABLAFEAWgBbAGEAYQBo AG0AcgB3AHcAfwB8AH8AeQB6AH4AfAB7AH0AdAB6AHMAcABnAGQAVwBYAE4ASABAAD8AOAAxACYA IAAdABQABQD7/+v/4P/V/87/xf+3/7f/qv+m/5T/lP+D/4T/dv9x/2L/Zf9V/2D/Sv9Q/z3/Rf81 /03/Of9K/zf/Uv9A/1r/Rv9r/1v/c/9m/4b/ev+W/4j/q/+h/7b/r//L/8b/4//h//n/9v8IAAcA HwAbACsAKQA8AEAATgBQAF8AYQBpAGwAcwB5AIIAhwCQAJcAjwCSAJIAlwCMAJMAhQCFAHYAfwBs AHAAYABkAFQAUQA/AD0AJgAnABUADQADAPv/7//p/+T/3v/Z/8v/0P/L/8H/uP/A/7D/vP+z/7f/ rv+z/6f/tP+o/6//qP+5/6z/uf+q/8D/rf+6/7T/v/+z/8D/tv/B/7b/wP+3/8T/vP/H/8D/zP/K /83/yv/X/8z/3P/S/9//2//p/+D/7P/o/+//7//1//T/+f/z/wMA/P8FAP7/BwAEAAsABAALAAUA DQAIABEACQAOAAsAEAALABIACgASABIAGgAPAB4AFgAkAB0AKgApADIALwAzADAAOQA3ADsAPAA+ AEQAOwBCAEUARQBCAEUAQgBFAD8APAA/ADkALQAwACwAKgAbABsAHAAaAAsABQAaABkA2wDvAJYA nwB2AHoAtQDAALIAwQCKAJQAcwB8AGwAcgBJAE0ADgAPAOX/5f/G/8D/i/9+/2D/Uf83/yX/EP/7 /u7+0P7R/rL+vf6U/q3+g/6e/nD+mf5r/pH+Zv6V/mz+ov54/rT+i/7J/qD+5f7B/gv/4/4v/w// W/9A/4v/cv/B/7P/AQDx/z8ANwB+AH0AvQDDAAIBDAE2AU4BaAGBAZIBrAGmAcsBvQHhAbsB5QGy AdwBoQHBAYABpwFOAW4BFQEsAdoA7wCaAKMAVwBaAAoACgDH/7//fv9x/zz/JP8A/9/+w/6k/pP+ bP5n/jj+Pf4I/h/+7v0K/tP9+/2+/fL9uP36/bj9//3C/RD+0/0t/u/9Uf4c/oT+U/7F/pT+Af/a /lD/MP+d/4f/8v/h/0YAPACXAJoA6gD0ADIBRgFxAYgBogG/AccB7QHYAQkC4QEKAtoBBQLIAe8B pgHLAXsBoQFKAWgBEAEoAdQA4wCPAJoATgBWAA0AEADR/8//l/+J/2H/Uf8w/xn/Bf/r/t7+vP69 /pf+of51/pP+YP57/kr+dv5C/nD+Pv52/kb+hP5V/pz+cP6+/pH+5f69/hH/6/5J/yr/h/9p/8f/ tf8FAP//SQA+AIgAiQDCAMkA8QD+ABMBJgEvAUcBQQFUAT4BVwE0AVUBIgE+AQMBIgHkAPoAvwDQ AJYApABjAHAANQA+AAsACADe/9r/uf+s/4//hf9r/1//Uv86/zX/Gv9O/zv/U/9B/y3/EP8//yb/ Of8k/z7/IP84/yP/Sv80/0z/Nf9m/0r/iv9x/6f/lv/J/7f/8P/i/x0AEwBLAEIAeABxAKIAogDJ AMsA6QDvAPwABAENARUBBgEPAfwAAwHhAOYAwQDFAJkAlwBkAGcAMQAqAP7/7//D/7P/lf+B/1// Rf8q/wr/Cf/q/vD+y/7Y/rX+0P6r/sf+qP7J/qT+yf6p/s7+sf7Y/rj+4v7O/vb+3/4Q//f+K/8X /0X/Nf9k/1b/jP9+/7n/q//s/93/GAAWAFQAUgCSAJcA2wDmABQBJQFEAVUBbQGCAZMBqQGcAbEB rQHPAagBvAGZAbABeQGRAVoBaQElAS8B5ADsAKMAoABiAFgAHgAUAOH/z/+n/4v/cf9W/0D/H/8W //T+9v7X/s/+rf6o/oP+m/58/o3+bv6N/mX+hf5g/of+a/6L/mr+lP5y/qj+hv65/pr+2v6+/gj/ 8P4x/x3/af9W/57/iP/i/9f/IAAaAGsAbgCrAK0A8QD6ACgBNgFkAXcBiwGnAaIBvQGsAccBpwHE AZUBsQF8AZABVAFlASEBMQHxAP0AuQC/AIIAhABEAEIAAAD4/9L/w/+m/43/gf9p/1j/O/8+/yD/ Iv8C/wz/8v75/t/+7/7T/t7+wv7a/rj+0f6y/sz+s/7W/r3+4f7D/vP+1v4M//H+Kv8P/1L/PP98 /2T/t/+k//n/6P8xACgAaABmAJ0AoQDPANMA8wD9ABwBMQE2AUsBNgFHATwBVAEmAT8BFAEoAeoA /QDIANYAmACjAGYAbQA9AD4AEQANAOX/3v/B/7f/oP+S/4b/e/9q/1z/TP87/0L/K/84/yD/Lf8W /yj/DP8g/wj/If8J/x//Av8j/wT/Kf8Q/zj/J/9e/0T/dv9c/5f/gv++/67/7f/c/xkADwBRAE0A iQCIAMAAwwDzAPkAHAEqAT8BUAFLAWABTgFrAUcBXgEzAU4BEwEqAesA/AC0AMUAggCPAEEATAAN AAkA0P/E/5L/g/9f/03/M/8b/xj//v77/uX+7P7Q/tz+w/7W/rj+1P6z/tD+sv7W/sD+3f7C/u7+ 0f78/uP+FP/1/i7/D/9J/y//a/9S/5f/ff/F/7X/+//v/zUALQCFAHoAyADMAAIBDwFCAVMBbgGG AZMBrQG4AdgBxAHoAccB6wG8Ad0BngHFAXkBmgFDAV4BCgEhAckA2ACJAJIAQwBFAAcAAgDE/77/ iv96/1P/QP8m/w//+f7j/sn+p/6v/o/+nf55/o/+bP6H/mX+gf5f/oP+W/6J/mH+kv5o/pb+cP6z /ov+1/6x/vv+2f4r/xD/Yv9L/6L/jf/f/9H/KAAeAHcAdQDFAMwAEAEbAVUBZwGOAakBvgHkAdwB BQL1ARsC8AEbAuMBBwLHAfQBpwHMAXoBmgFDAWEBCwEjAccA2ACEAIwASwBPAA8ADwDi/9z/tP+s /57/jv96/23/X/9M/0H/K/8s/xf/F/8E//v+3v7x/tf+5f7P/uf+0P7p/sz+9v7a/gX/6v4c//z+ Mv8a/1//R/+L/3f/zP+6/wgAAABCADoAfwB9ALQAvwDlAPcAFAEiATYBSwFKAWcBVQFvAVABbgFF AV0BLAFGAQkBHwHlAPYAuQDEAJIAnABhAGkAOwBCABgAGgD1//D/1v/U/7j/sP+Z/4r/if97/3j/ a/91/2P/av9a/2P/Vf9V/0P/Vv9H/1P/Rv9U/0T/VP9F/2v/Wv+F/3r/nP+Q/7n/s//h/9j/EAAK AEIAPABvAHAApACrANsA5wALAR8BMQFKAVEBagFmAXwBbQGHAWUBggFYAXQBOAFOAQoBIgHbAPAA qQCzAHIAcwAyADYA8//p/7v/sP+N/3v/Zv9W/0X/Lv8x/xr/Fv8E/wz/9/7+/uj++v7q/vj+6f73 /uf+/f7r/g3/9/4W/wP/J/8W/zz/KP9X/0j/df9p/5z/kv/M/8f/AAD6/0IAPwCLAJAAwQDMAAMB FAEyAU4BZQF9AYoBrQGqAdQBvgHlAcgB7gG4Ad0BowHLAYABowFTAXIBFwEwAd4A8gChALAAZgBq ACEAIwDn/+f/rv+l/3z/c/9K/zn/E//5/vX+3f7d/sH+zf6r/rn+of6s/pj+pv6N/p/+h/6h/oj+ p/6H/q/+k/7D/qn+6v7Q/gH/7/4v/yD/YP9R/5D/iP/P/8n/GAAYAFoAYACnALUA8QABAS8BSAFt AZEBogHGAbQB3QHLAfkBxQHvAbwB6QGmAc0BhQGtAVkBfQEsAUwB9QATAboA0QCAAI4ASwBXABYA HwDv/+3/x//E/6H/mv+A/3j/Zv9b/0j/Pf8w/yn/Fv8L/wT/9/7y/ub+6f7b/uH+z/7i/sz+6f7Q /vP+2P4H/+v+J/8M/0H/L/91/2b/rv+j/+X/4f8ZAB0AWQBgAI8AmADEANUA8QAIARUBLwEuAUsB PQFhATsBXQE3AVYBIQFDAQQBJgHjAPoAuADUAJUApgBrAHsARABMAB4AIQD8/wEA4//m/8D/w/+g /53/kP+O/4j/g/96/3j/dP9r/2r/YP9g/1z/V/9V/1j/Uf9Q/0X/Wf9Q/2f/Yf91/2n/jf9+/6P/ mP/D/7j/5//e/xgAEQBKAE0AegCBAK4AugDbAPIACgEfASUBQAE6AVgBQQFfAT4BXwEoAUoBEQEu AewABwHDANYAkQCiAFwAcAAdACMA6P/y/7b/uP+N/4f/af9c/03/Q/8x/yH/H/8S/w7///4F//b+ A//y/vj+7P71/uj+/v7s/gr/9/4T/wX/If8X/zX/Kv9L/0X/a/9i/5P/kf++/77/+P/6/zsARQBz AIEAtQDIAOwACAEjAUEBVgF0AYMBpwGkAc4BuQHmAb0B6gG7AeUBpwHSAX8BrQFWAX4BIAE/AeUA AQGsAMEAaAB7ACoANwDy//n/tf+1/4b/hf9Q/0f/Gf8M//r+6v7b/sf+xv6y/rT+nf6i/ov+lv57 /or+cf6C/mn+gv5t/ov+cf6j/o3+vv6l/ub+zv4N//v+P/8x/37/bf+6/7T//v8EAFQAWgCaAKkA 7QAFATkBVAFwAZQBqAHSAc4BAALkARsC6QEgAucBHwLUAQYCuQHrAY8BvQFhAY4BLAFOAfEADgG4 ANAAfgCSAEkAWAAXACEA5f/r/7r/v/+T/5T/bP9r/03/R/8m/yD/Af/9/u7+4/7b/s/+zf69/r/+ rv66/qT+vv6n/sP+rv7V/rv+8P7U/hT//v5I/zz/d/9r/7D/qP/t/+z/LAAvAGEAbwCaAKwAyQDh APYADwERAS8BJQFFASsBTQElAUoBFwE7Af4AHgHiAAABvwDcAJgArgB3AIUATgBdACgALwAIAAoA 5//o/8D/wv+s/6z/mv+b/4z/kP9+/33/cP92/2f/av9h/13/Wf9S/0//S/9Q/0v/W/9V/1z/XP9s /2X/e/97/5L/j/+y/7T/3v/e/wsACwA7AEEAcAB9AKUAtgDXAOsAAQEWARoBOAExAUsBOgFbATQB VgElAUYBDQEtAeoABQG+ANcAiAClAFMAZAATAB0A3P/q/6v/sf9+/37/Vv9O/zP/LP8T/w3//f7z /u3+2f7h/s/+0f7D/sv+u/7R/sL+1P7A/tr+y/7p/t7+8/7q/hH/CP8q/x3/Tf9C/27/ZP+k/6T/ 5//u/x4AJQBbAGcAmwCqAN4A8QAVAS8BSgFrAXwBpgGeAckBuwHlAcQB9QHGAfQBtQHgAZUBwQFq AZMBOAFfAQMBIAHIAN4AjACiAE4AXwAPABgA3f/k/5r/mP9g/1X/OP8s/xL/Av/t/uD+1f7E/sD+ q/6t/pz+mf6G/oz+ev5+/mn+fP5n/oP+av6K/nT+of6H/r3+qP7f/sf+DP/4/j3/Lv98/3T/vv+6 /wcACABPAFUAngCxAOQAAAEhAUABUgF3AXcBpAGNAb4BngHIAaIBzAGVAcEBgAGoAWIBhQE4AV0B CwEuAdwA8wCqALkAeACGAEsAWAAaACcA9P/4/87/zP+p/6z/iP+K/2b/Yf88/zH/Kv8h/xT/B/// /u3+6v7Y/tz+zf7Q/r7+zv69/tL+vf7d/sn+7P7Z/hX///47/yr/Zf9Y/5f/jP/N/8n/BQAEAD0A PgBtAHoAoQC0AMgA3QDmAAIB/AAVAQMBJQEEASUB9wAYAeAABAHOAOcArQDFAI8ApgBtAIEASQBZ ACwANgAOABcA5v/r/9D/1f+5/7v/qf+t/5v/oP+Q/4//ev99/3D/bf9f/17/T/9S/07/Rf9E/zz/ RP87/0b/O/9J/0D/WP9P/2j/Xf9//3r/pf+b/8z/yP/8//b/KQAuAF4AZgCVAKEAtgDJANoA9QD3 AAoB/gAeAQcBJgEDARwB7AALAdkA8wC1AM8AlwCoAGIAcwAyAD8ABgAMAN//4f+0/7r/kv+O/3X/ bv9Z/1D/Rv8+/zj/Lf8g/xX/C//+/gn///4D//z+BP/8/gn/Af8O/wX/Fv8K/yL/E/8w/yb/TP9C /2j/YP+W/43/zv/O//z/+/81ADsAbwB3AKoAtADhAPEAFgErAUIBXwFsAYwBgwGoAZMBvwGVAcAB iQGwAW4BlgFOAW8BJAE9AfEADAG+ANUAgwCVAEkAUgASABQA2P/X/5n/lf9s/2b/Rf80/yL/Ef8D /+/+5/7W/sz+uf62/qX+o/6M/pD+e/6J/nH+g/5k/oT+aP6J/m/+mP6B/rP+l/7Q/rT++v7i/if/ E/9f/1L/of+b/+b/4/81ADIAgwCJAMYA1QAAARoBNQFSAVwBegF7AZoBigGvAY4BtQGBAawBbgGd AVgBegE3AVYBCgEjAdkA9QCnAL0AeQCJAFAAXwAjACYA+//6/9b/1f+u/6b/jP+H/2P/W/87/y7/ J/8X/w3/AP/4/uf+4v7S/tn+xv7F/rP+xP6u/sb+rf7M/rT+5/7J/gj/8f4l/w7/UP88/4D/cP+x /6X/6f/g/x8AGgBWAF0AhQCUAK0AvgDOAOAA5AD4AO4ABAHwAAcB5AD/ANYA7AC9ANEAoQC0AIQA kABkAHAAQQBNACAAKQD7//z/3//g/8v/wv+1/67/o/+d/5X/k/+B/3//df9u/2n/YP9c/1b/Uf9G /0v/N/9I/zX/O/8x/0T/Nv9L/zz/WP9I/2r/Wv+A/3P/oP+U/8b/xf/z/+3/JgApAFsAYQCKAJQA tQDBANYA6ADmAP8A/wAWAf0AGQH6ABMB6wAFAdMA6QCuAMEAgACTAFAAYwAnACsA9//3/8n/x/+f /5j/fP9v/1b/Sf9A/zL/Iv8S/xT/A/8A/+v+6v7T/ur+0v7p/tD+6f7V/u3+3P7y/tr+/f7r/gz/ 8/4l/wv/N/8l/2L/UP+R/4f/uv+0/+z/6v8gACQAWABfAJQAnwDOAN4ABAEYATEBSgFTAXMBbwGT AYUBqgGFAasBeQGeAV8BgAFCAWABFgEzAekA/wCsAL8AegCGADsARQAIAA8Ayv/G/43/hP9j/1P/ Nv8p/xL//v75/uD+2/6+/sT+q/6y/pT+n/5//pP+cf6E/mj+e/5b/n7+X/6H/mX+mP53/q3+j/7N /q3+9f7U/iP/Av9Y/0b/mP+M/9z/2P8wAC4AdQB1ALQAwQDzAAQBKgE+AU0BagFyAZABgwGmAYoB sAGCAaoBdgGYAVwBfQE9AVgBEAEpAeEA+QCvAMAAggCQAFMAVwAjACYA9//3/87/yf+n/57/gv91 /1v/Rv9B/yz/If8Q/w7/+f7+/ub+6f7T/tz+w/7Y/r3+zv6x/s3+rP7Z/rz+8P7P/gn/6f4o/w7/ S/8x/33/av+u/5r/4//X/xYADgBMAEsAdwB/AKQAsQDFANQA3gDpAOcA9wDqAPgA3gDuANMA4AC8 AMoAnwCvAIMAjQBmAGoARABKACQAJAABAAAA7P/o/9b/z//C/7//sf+t/6z/pf+f/5n/lf+S/4r/ hf+D/33/dv9z/2//bP9q/2H/af9h/2z/YP9w/2f/eP9t/4j/ff+g/5P/vP+y/9r/0v8HAP7/NQA0 AF4AXQCEAIoAqwCuAMUA0QDYAOgA4gD2AOUA+QDeAO8AzADdALIAvgCPAJkAXgBkADQANQABAP// 1//N/6z/nv+C/3f/Xf9M/z7/Lv8k/xD/Ff/8/v3+5v7o/tH+5f7O/uD+yf7n/tD+7/7X/vP+3P77 /uf+Cf/1/hv/BP8r/xj/T/89/3r/bP+g/5r/zf/F//7/+v8yADEAZgBsAJ0AqQDZAPAAEQEjAT8B VQFaAXUBcwGWAYQBpgGHAacBegGaAWQBfwE/AVkBGQEwAeQA+wC2AMQAdQCCAEYASQAPAAMAy//A /5r/i/9r/1z/Qf8w/yP/CP8F/+v+7P7R/tf+u/7E/qX+sv6S/qH+gv6V/nH+lP50/pb+b/6f/nn+ p/6H/r/+ov7b/rr+/f7h/i7/Ff9h/07/mP+F/+P/0P8rACQAbABoAKoAtADkAPUAFQEkAUEBVgFg AXcBcwGMAXwBmgF0AY4BYQF/AUwBawEvAUcBBgEWAdgA5ACtALcAfACGAFEAVgAmACQA+v/5/9b/ 0P+s/6D/hP9w/2f/U/9L/zf/NP8f/x3/B/8I//D+9v7d/un+zv7f/sL+1v62/tv+vv7q/sv+9v7V /gz/9f4x/xL/WP85/3z/Zv+t/5n/4P/R/xYADQBFAEQAdAB5AJwAowC8AMsAzADiANwA7gDeAPMA 2ADmAM4A2QC2AMQAnQCrAIAAjgBhAGwAOgBDAB8AHAAAAP7/7P/f/9H/x/+//7j/rv+m/6L/lv+V /47/jP9+/37/c/92/2z/bP9g/2r/XP9l/1n/Zv9X/2b/Vf9s/1z/ef9j/4f/c/+d/4z/uf+r/9T/ yv8BAPr/LQAqAFYAVgB8AIEAoAClALoAwQDRANsA2gDsAOQA9ADeAO4AzADaALIAvgCRAKAAaQBx AD0AQAAXAA8A6P/j/7n/s/+a/4f/cf9c/0r/Of8x/x3/Fv/+/vf+3v72/tj+7f7P/uv+0f7v/tL+ 8f7c/vT+4P4C/+z+D//6/iX/C/81/x7/Wf9H/4T/dP+r/53/1//O/wgA/f85ADAAbgBvAJ8AqgDa AOUADAEdATwBTwFoAX0BhgGlAZIBtAGYAbYBkAGsAXUBlQFSAXABMwFKAQABDgHJANgAlQCfAFIA VAATABUA3f/b/6r/nf90/2X/Tf82/yr/Df8K/+3+6v7O/s7+tP69/p/+rv6O/p/+ef6S/mv+kv5t /pX+cP6d/nn+rf6J/sH+of7e/r7+A//o/jL/GP9h/1P/pP+W//L/6P8tACsAdwB9ALIAvQDwAP8A IwE3AVMBZwFzAY4BiwGsAZEBtwGUAbUBhgGoAXIBkwFQAWoBKAFAAf4AEgHSAOAAmwCmAG0AdwBC AD8AEwAVAOP/2/+s/5//jf99/2v/Wf9N/zj/Mv8f/xf/Af8D/+r+7/7Z/tz+x/7W/rf+0f6v/s/+ sf7j/sD+6v7N/gf/6P4g/wL/R/8o/27/V/+e/4v/0f+//wcAAgA2ADMAaABrAJIAmgCxAL4AyQDW ANoA6ADcAOcA2gDmAMkA2wC9AMwAogCwAIkAmQBrAHAASgBJACgAKAAQAAwA8//v/93/1f/L/8T/ vP+1/6n/pv+j/57/mf+O/5D/h/+E/3z/gv93/37/cv96/2z/c/9l/3b/a/98/2z/gf90/5L/gP+n /5v/vv+w/+f/2v8NAAcAMQAsAFMAVwB9AH0AmACdALcAuwDPAN8A3QDvAOQA7wDiAPEAzgDiALUA wwCWAKMAcwB6AEcARQAjABoA8v/v/8r/vP+e/47/ff9i/1b/O/8//yn/Gf8H/wT/6v76/tv+9v7e /vP+1/71/t3+9/7l/gH/7P4Q//b+F/8C/yf/EP9F/zP/bP9W/4X/c/+t/6P/0v/H//7//P80ADAA agBuAJ8ApgDXAN0ABAERATMBRwFfAXkBdgGWAYQBowGFAacBggGgAWYBhQFKAWYBJgE6AfgACQG+ ANIAjwCYAE8AUAAQAAwA2f/P/6b/lv98/2T/Uf8//yn/Fv8M//X+8f7V/tv+vP7E/qb+t/6U/qH+ fP6f/oH+oP6E/qb+iv6x/ov+wP6k/tP+tv7w/tL+FP/4/jn/Jv9y/2D/t/+p//D/6v8yADIAZwBx AKUArADeAO0AEQEmATgBUAFWAXgBaAGKAXcBlwF1AZgBaAGOAVEBbgEwAUsBBwEfAeAA9QCyAMUA iACUAFcAXAAtAC0ABgACANn/1P+t/6H/kf+E/2//Zf9d/0v/Rv81/zT/H/8g/wz/Ff/8/gb/8f79 /uT+//7h/gb/6/4L//P+Hv8G/y//G/9M/zn/bf9V/5P/g/+7/7X/8v/l/x4AGABMAEoAegCAAJkA qgC3AMYAyQDbAM4A5QDTAOUAygDZALkAxQCiAK8AgwCVAGYAcQBCAEkAGgAeAPz//v/j/+H/zP/F /7n/s/+p/57/oP+V/5T/iP+O/4L/kf+E/4v/hf+F/33/hv9//4//hf+O/4f/lP+U/5f/lv+o/6P/ u/+u/8z/wv/f/9z/AQD9/zAALQBOAFAAcgB0AJkAngC4AMkA1gDlAPMA/gD+ABcBDAEjAQcBHwH8 ABkB6wADAcsA3ACkALEAeQCBAEwAUQAdAB4A7f/k/7f/sf+M/4D/Yf9V/0L/Lv8e/wn/+v7j/uv+ 0/7c/sP+3f7C/uD+yv7j/sj+7v7U/vL+3v4E//D+FP///iz/G/9N/0L/bP9h/43/hv+6/67/5f/c /w8ADgBGAEsAfQCAALEAuQDoAPUAEwEpAUQBYQFtAYsBgQGjAZABsgGNAbIBgQGmAW0BjwFQAWoB JwFDAfwADgHHANgAjACYAEsAUQAWABgA3P/a/6r/oP9//3L/Wf9N/zP/Hv8T//7++P7h/ub+0P7Q /rT+vP6g/rT+mP6y/pn+sv6b/r3+ov7B/qz+z/62/uj+y/4D/+v+G/8J/0v/Pv+D/3z/vP+v//L/ 6v8sACkAZQBrAJwAqQDPAN8AAgEXASgBPQFEAV4BVAFxAV4BfwFdAX0BUgFvATYBVQEYATIB8wAM AcwA5AChALUAeQCHAE0AWAAoACwAAQD9/9P/0f+3/6//m/+V/4L/dv9q/2X/WP9R/0X/Pf8z/yr/ If8c/xr/B/8R//z+EP/9/hP//P4Z/wL/Kf8S/zj/I/9P/z3/bf9d/5P/if+8/63/6v/i/xUAEQBH AEkAcQB1AJEAnwCqALoAvgDQAMUA3wDMAOAAxgDdALsA0AClALgAjwClAHUAgwBYAFsANwBDABsA IQAFAAgA8v/y/9//3//U/9H/w//A/7f/uP+x/67/rf+r/6L/nf+i/6D/nf+a/5j/mP+X/5T/mP+X /5X/k/+d/5n/of+b/7T/q//A/7P/4f/Y/wQA//8gACEAPABCAGEAZgB/AIYAmwCpALgAxADMAOAA 1ADtAN0A7wDbAO0AxwDZALQAxQCVAKEAbwB/AEoAVQAiACkA+P/9/9P/0/+u/6n/h/+F/2j/ZP9C /zT/Nv8l/yb/Ev8X/w7/Gf8I/xj/DP8W/wv/If8U/yH/F/8s/yL/Nf8n/0r/Qf9i/13/fv96/5v/ l/+4/7X/3v/d/wkACwA2ADkAYgBtAJgApgDEANsA+wASAS4BSAFHAV8BXgGDAWkBjQFoAYcBXgF/ AUoBawEuAU0BCgEnAd0A9gCrAMIAcgB/AEMASQAEAAwA2f/Y/67/rP+G/4H/W/9Q/z//Mv8h/w// D//5/vP+3f7d/sb+1f68/s/+uf7I/rf+yf6x/tH+tv7b/sL+6P7N/vv+5P4X/wL/M/8h/2D/Uf+Z /47/x//H/wMABAA9AEEAdQCEALEAwQDqAP8AEwErAT8BYgFZAYMBbAGSAXUBoQFwAZoBYwGIAVEB dAEtAVEBDgEmAeMA+AC1AMsAhQCXAFoAawAwADUA/f8EANv/3P+3/7H/lv+V/33/eP9m/1n/Sv9F /zf/MP8o/x3/Gv8M/wn//v4D//f+Cv/5/g7//P4b/wz/Kf8a/0L/Lv9Y/03/gf9y/6X/ov/X/9L/ CAAEAD0APgBoAHAAjQChAK8AxwDPAOQA3AD1AOsABgHrAAkB4wABAc8A7AC4ANoAmwCyAH8AkwBa AGwAOwBEAB8AHQD9/wIA5//q/8r/0f+2/7b/q/+i/5j/kv+K/4b/g/97/3b/cf9x/3T/b/9r/3H/ af9t/2v/cP9n/3T/av95/3f/i/+I/5r/lf+6/7X/3v/c//7//f8hACcARwBPAGsAeACQAJ8AuADH ANYA7ADrAAUB+gAVAfwAFwH7ABMB6QAEAdMA7ACyAMsAjwCjAGUAeAA9AEkADgAWAOP/5/+4/7f/ k/+V/23/Y/9F/zj/Mf8k/xr/D/8O/wT/Cv/8/gX/9v4G//r+Bf/5/g3/Af8Y/wT/IP8U/zv/MP9Q /0f/bv9h/47/hv+s/6//2//Z/wUACAA2ADkAaQB2AJ4AqwDVAOQACAEkAS8BTAFQAWwBZgGDAW0B jwFwAZABZAGLAVABdgEyAVUBDwEvAeUA/gC2AMQAfgCLAEgAUgATABkA5P/h/7r/tP+P/4b/Zf9g /0f/O/8r/x3/FP8F//r+7P7i/tD+3f7M/tT+w/7U/sD+1f7E/tj+xv7n/tD+8P7c/gv/+P4i/w7/ TP85/3z/cv+i/57/1P/R/wwACgA+AEIAeACEAK4AugDZAPIABwEfASYBQwE9AV8BVwF2AVUBfAFR AXIBPwFgASoBSgEQASsB6gAFAcQA2QCeALIAbwB+AEoAVAAbAB8A7P/w/87/z/+u/6j/k/+O/3v/ dv9p/2P/Vf9N/0X/O/85/y7/L/8m/yf/Iv8p/xn/K/8g/zD/I/88/zD/Tf9C/2X/W/+A/3X/pv+a /8n/wP/y/+//GQAfAEgAVABxAH8AlwCkAK8AwwDIAOAA2ADuAOAA+wDdAPcA2ADtAMMA2wC2AMkA mQCoAHIAfgBNAF4ALQA6AA8AFgD3//n/2v/c/8X/xf+u/63/oP+d/5H/kf+E/3//dP9w/3P/b/9u /2j/bP9q/2//a/9z/23/cv9q/3j/c/9+/3v/j/+L/6T/pP/H/8j/4P/h/wYAAQAfACIARgBMAGcA awCMAJkArQC+AM4A4gDhAPgA8wAKAfQAEgH1AA4B5wABAdUA6AC1AMUAkwCmAG4AgABPAFYAHgAm APr////R/9T/qf+q/4P/ev9s/2D/Vv9R/0z/RP85/zD/Ov8t/y//If82/yr/L/8j/zj/KP8//zX/ UP9L/1v/V/9r/2H/fv96/5r/lv+0/7X/2//Z/wEAAQAqADIAVgBcAIsAmQDCANEA5AD8AAwBJAEs AUYBQAFiAU8BbwFOAXMBTAFyAT0BWwEkAUUB/gAdAdsA+QCtAMQAfwCTAEwAWQAdACwA8v/4/8z/ zv+h/5n/gP94/2D/U/9G/z3/J/8b/w////7//vH++v7m/vP+4f73/uH+9P7j/vr+5f7+/u7+D/// /iP/Ef8+/y3/Zv9W/4n/gv+z/6v/4//c/w8AEwBBAEUAdgB9AKkAtwDUAO0A/QAXAR0BOQE5AVsB RwFqAUoBcAFIAWwBOAFaAR8BPwEIASMB3QD6AL4A1QCPAKEAbAB6AD8ARwARABYA7f/y/8v/yv+v /6z/lv+U/3z/d/9q/2L/Vf9L/0H/PP84/yz/L/8k/yH/FP8j/xf/If8S/y7/Hf83/yb/Qv8x/1f/ S/94/2n/lf+M/7z/tP/j/93/EAARADoAQQBjAGkAigCWAKYAswC6AM8AzwDiANIA7gDWAOgA0ADl AL0A0wClALcAiQCaAGkAegBOAFUALwAyABAAGAD4//z/3v/e/8z/x/+1/7f/qf+f/53/lP+J/4D/ i/+H/4L/gP+F/4H/hf+C/4v/hv+N/4T/j/+K/5j/k/+m/6D/tv+w/9P/0f/o/+j/AwADAB0AIgBA AEUAXwBpAIAAjgChALUAwgDUANsA8QDqAAQB9AAIAfcAEQHtAAQB1wDvAMQA2QCfALQAfQCNAFIA XQAoADEA+P///8//0f+l/6L/df9p/1n/Tf87/zP/KP8X/xn/Cv8P//3+Cf/2/gP/9P4E//j+Df/9 /g7/B/8g/xL/NP8k/0b/Ov9c/1b/dv9y/5v/lP+9/7v/4v/k/w0AFQBDAEoAdACAAKYAtQDhAPQA DgEhATEBTAFMAWwBYgGHAXABkwFwAZUBZwGQAVkBewE9AWEBFwEzAe4AAQG8ANIAiQCbAFMAXwAh ACgA8P/z/7//vf+V/5L/a/9h/0n/Q/8k/xr/BP/u/vT+5P7l/tL+3P7J/tb+vv7V/sD+z/6//tr+ yP7n/tD++/7k/gn/+f4q/x//V/9K/37/dP+r/6P/3v/Z/xAADABDAEgAfACDALAAvgDhAPEABgEe ASYBRgFEAWUBTAF1AU8BdAFKAW4BNwFaAR4BOgH+ABkB2QDxALEAxwCGAJsAXABpACsAMAAGAAsA 4v/e/8D/vv+j/6D/jv+G/3T/af9i/1T/T/8//0H/NP81/yf/LP8a/yX/Ff8n/xb/Jv8a/y7/IP85 /yv/T/9B/2X/Vv+H/3X/q/+m/9T/z//9/wAAMwA2AFsAYgCCAI0AogCvAMYA1QDYAOwA5wADAfoA DwH5ABEB5gACAdQA6gC2ANEAnQCzAHwAjABeAGkAPQBFABgAIwD9/wcA6f/o/9D/y/+7/7z/pP+h /4//i/+K/4X/gv+A/3//eP95/3f/ev90/3v/cf94/2//fP92/4X/fv+O/4T/nv+c/77/u//S/9L/ 8v/y/w8AFAAvADUAUgBfAH4AhgCdAKcAwADNANgA5wDoAAQB9AAJAfcADAHtAAQB4wD4AMQA1wCo ALcAgACTAFwAZwAvADgACAANANj/2/+u/6b/h/+C/2v/Yv9S/0T/P/8v/zD/I/8n/xj/Hf8S/xX/ C/8V//7+GP8F/xr/Cv8k/xf/Lf8k/z7/Mv9R/0n/av9l/4X/fP+s/6T/y//J//j/+/8iACUAWABh AJUApADBANMA7AABARMBLQEuAUcBRQFkAVQBcgFWAXgBTQFyAUABYwEkAUEB/wAgAdYA7gCxAL4A fACJAEoAVwAdACIA8P/2/8D/wf+h/5n/eP9s/1z/UP83/yn/Ff8I/wX/8v75/uH+5f7V/uP+zf7e /sv+3P7L/uH+yv7s/tX++P7c/hL/9f4u/xv/Uv9B/3T/bP+e/5b/0v/L/wUABwA9AEMAdAB5AKUA twDTAOgA/AAXASIBQgE7AVkBRgFuAUgBZgFEAWYBNQFSARUBOAH7ABUB2wDvALAAxACNAJ0AagBy AD4ARAAQABEA8f/x/8z/x/+z/6z/l/+P/33/df9j/1r/U/9I/0D/NP8y/yj/KP8Z/yT/Ff8c/xD/ JP8Q/yb/Ev81/yT/Rf84/2H/T/98/3H/of+U/83/x//9//3/JgAqAFUAXwB9AI8AoQC0AMIA1ADZ APMA6gADAfMACwHuAAcB5wABAdUA7AC5ANAAngCyAH4AjABbAGcAPQBIAB8AIgD+/wMA5//p/8v/ yf+0/7D/nP+c/4n/f/+A/3b/df9s/2v/ZP9l/1j/X/9Y/1z/VP9c/0//W/9N/13/T/9n/2H/g/9/ /5X/kv+0/7L/0v/S//j/9/8dAB4ARQBOAHEAewCgAKkAwgDPAOIA+AD7ABIBBAElAQcBIwEGAR4B 9gASAd8A+ADBANcAogCwAHUAhwBIAFQAIgAoAPH/9f+9/7r/nv+Y/3f/cf9Z/1T/R/86/zH/Iv8h /xH/Ev8A/wX/9P77/uv+9P7k/vv+5f7//u3+Cv/8/hT/BP8q/xv/Qv80/2T/Vf+D/3n/sv+n/97/ 2f8XABkAVABdAIwAjwDDAM0A7gAAARgBLgE3AVYBVAF0AWIBhQFoAY8BYwGHAVkBegE7AWIBHAE1 AfUACwHIAN0AlgClAGkAdAA+AEYACwAPAOL/3v+4/7L/jP+H/2f/Yf9C/zP/KP8U/xX/Av8B/+3+ 8/7g/uX+zP7b/sX+1v67/tX+u/7W/sP+7P7V/gD/7/4e/wv/Qf8y/23/XP+a/5H/z//L/wUAAwA+ AEEAdAB9AK4AuwDfAPQACQEkATEBTgFEAWUBUQF0AVEBcwFQAW4BOwFeASEBQAEEARsB4gD3AL0A zwCRAKQAYABvADoAQgATABYA8f/y/8//zP+w/7L/mP+R/3//fP9o/2T/VP9P/0H/O/8t/yL/J/8Y /x//Ef8b/wz/Hv8M/yX/EP8y/x//QP8x/17/Uf96/3H/q/+g/9X/0f8AAAIALQA1AFcAXwCDAI0A pgCwAMIA0wDZAO4A5QD7AOkAAAHjAPYA2QDsAMIA2ACmALUAhQCQAGAAbQBBAE0AHwAnAP3/BQDj /+L/xf/C/7P/sv+S/5D/gf94/3f/bv9q/2j/Zv9h/2T/XP9c/1X/Xf9W/1v/Vf9g/1z/Y/9Y/2z/ a/+H/4H/mv+S/6//rf/P/8j/7//q/w4AEgAyADUAXgBlAIUAkgCmALwAygDlAO0ABgEBARkBDQEp AQ0BJQEAARcB8gAGAdUA6ACsAL8AhgCXAF4AaQAzADMAAgD//8n/xP+h/5n/ff90/1r/T/9E/zb/ Lf8c/x//DP8M//P+Af/w/vn+6P70/uL+8f7b/vj+6P75/uv+Dv/6/h//DP8x/yL/Sf86/27/Yf+P /3//vP+y/+b/4v8eACEAWgBjAJIAmgDCANMA7wAFARoBLwE7AVQBXAFzAWMBggFtAYkBYgGAAU4B cgE3AU8BEAEmAeMA/QC4AMkAiQCYAFYAYAAqAC0A+v/6/8//y/+s/6L/if93/1f/RP89/y7/Iv8U /xH/BP/+/vD++/7l/ur+0v7j/s7+2v7D/tz+w/7X/sL+7P7V/gD/6f4Z/wH/PP8o/1//Uf+H/3j/ u/+w/+3/6/8pACYAYgBkAJMAnQDEANUA9gAOAREBLwEtAUkBNwFXATgBVAEsAU4BIAE9AQcBJQHt AAYBygDhAKwAugB/AIgAWABiADIANgASABgA9P/z/97/3P+9/7n/pv+n/5L/jv+A/3b/bP9k/1X/ Tv9I/zj/Pv80/zL/I/8x/yH/Lv8d/zH/Hf87/yP/RP8z/1v/R/93/2T/mv+P/8b/wP/r/+T/HgAY AEAAQQBnAGsAiwCWAKYAtwC8AMwAzQDcAM8A3gDIANwAvADLAKYAtwCMAJkAbQB5AE4AXQAuADQA EQARAPf/8v/Z/9X/wP+8/6n/n/+R/4f/hP99/3r/dv9v/23/cf9o/23/Zf9o/2L/YP9Y/2P/Vv9g /1j/Zf9a/2//Zv+I/33/nf+T/7b/qP/R/8X/8v/q/wwACgA9ADwAaABrAJcAnADAAM8A6wD6AAkB GgEeATIBKAE/ASsBQQEbATMBDgEiAfMABAHPAOEApwCzAHoAiQBJAE4AEQAWAOf/4/+5/7L/jv+D /2//X/9R/0D/Of8m/yL/Ev8X/wL/B//y/v/+8f76/uf+9v7f/vv+5v4A/+j+Bv/z/hX///4n/xL/ PP8q/17/Sv+A/3D/p/+Y/9//1v8ZABcASwBNAIgAjwC8AMQA6wD4ABcBKgE8AVUBXAF2AWsBiQF0 AZMBawGMAVwBgQFCAV4BHgE4AfAABwG/ANQAjgCXAFwAZQApACwA+f/4/8j/w/+i/5z/dv9r/1L/ Pf89/yj/I/8P/xH//f77/ur+7P7Z/t7+y/7Y/sH+0P60/tH+tP7Z/rz+5P7H/vX+3v4P//r+Mv8b /17/SP+L/33/w/+0//j/9v81ADYAbwB0AKsAtwDnAPcAEwErATYBTgFOAW0BXAF9AVsBeQFUAXMB RAFgASwBSwEMAR8B6gD9AMUA1gCeAK4AegCFAFUAWQAwADcAEQAVAPD/6v/X/9P/wP+0/6z/ov+b /5T/h/+A/3X/a/9l/1f/WP9K/0//QP9L/zr/Sf84/0z/O/9N/z3/W/9N/2//X/+P/4P/t/+q/9v/ 0f8FAPz/KwAnAFUAUgB5AH4AnQCqAL0AxgDRAOIA4gDuAN4A8QDWAOkAxwDUALQAuwCOAJ0AagB5 AE0AUwAtAC8ABQAEAOr/4//J/8P/sv+q/57/kf+D/3j/e/9v/3X/av9x/2j/bv9k/2z/ZP9r/2H/ bf9f/27/Yf9x/2b/ff9v/4r/e/+Z/43/pv+f/8L/t//a/9L/+P/x/yIAGgBJAEYAcQByAJsApQDJ ANAA7AD8AAYBFwEbATQBJQE9ASUBQwEXATABBQEZAecA+gDFANEAlQCiAGcAbAA0ADUA/P/7/8// x/+l/5b/ev9p/1v/Sv87/y7/Kv8S/xP/+/4G/+3++f7m/vD+2/7l/sr+5/7P/u3+2P72/t7++v7o /gr/9f4a/wf/Lv8e/0v/Of90/2P/oP+S/9v/0f8HAAQAQgBDAHkAggCwAL8A4gDuABEBKAE7AVcB WwF8AXABkAF6AZwBcQGUAWwBjQFOAWoBJwFAAf0ADgHNANwAmQCnAGkAcQA1ADoACQAHAN7/1/+v /6f/e/9s/2L/Uv9D/zH/Lv8c/xn/A/8G//D+8f7d/ub+0f7c/sX+1v69/tL+uv7b/sT+4P7I/vf+ 3f4M/+/+Jv8T/0n/Nv91/2X/pP+X/93/1P8QAA8ATABPAIoAkwC5AMgA6AD1AAsBJAEhAT0BMwFS ATgBUwE1AU8BKAFCARQBMQH3ABQB2ADyALIAwgCKAJkAYABtAEYATQApACsAEAANAPH/7f/c/9n/ x//C/7z/tP+m/6T/lf+M/4v/gP+B/3T/df9r/2j/X/9j/1X/X/9R/1v/Tv9h/1b/Z/9Z/4X/df+j /5b/wf+4/+T/3v8QAAoAOQA1AFsAXQB9AIMApQCwAMEA1ADUAOkA4ADyAOIA9ADYAOgAyQDYALEA wQCeAKcAdwB+AFQAWwAuADEAEQAOAO7/6f/V/8v/uf+t/5r/j/+N/4T/gP92/37/dP96/3L/dP9n /3T/bf9x/2v/c/9t/3L/Z/93/23/hf97/43/g/+Y/47/qv+f/73/sf/a/9L/9v/q/xYADABAADoA agBrAJAAlAC/AMYA5gD1AAABDQESAScBHQExARgBKwESASgBAAEPAeMA9AC9AMsAkQCdAF8AZwAq AC4A+P/3/8j/w/+c/5H/e/9q/1X/RP89/yv/Jv8T/xL//v4I//b+//7n/u7+2P7w/tz+8f7b/vr+ 3f75/uX+CP/3/hL/+/4o/xD/Nv8j/1f/RP94/2b/qP+c/+D/2/8UAA8ARwBKAH8AhQCzALwA6QDz ABQBJQE6AU4BWQFyAWcBhgFqAZMBbgGRAVkBegE/AV8BGAEwAewAAgHAANEAigCZAFkAYQAoACsA +v/8/8v/x/+X/4v/d/9s/1X/TP87/y3/J/8a/xf/Bv8G/+7++f7k/u/+1f7k/s/+2v7K/t/+xf7l /sv+6/7T/vv+4v4Q///+MP8a/1b/Pv9+/2z/r/+e/+X/3P8bABoAUgBUAI0AkgC5AMsA5QD6AAgB HgEcATEBKQFEAS8BSQEiAUEBEQErAfkAEwHdAPAAuADHAJAAnQBoAHMARwBMACoALAAPAAsA7v/u /9v/1v/G/73/tP+r/53/lv+I/4T/g/95/3j/Z/9s/2H/Yf9W/1r/T/9R/0P/UP8//1X/Q/9b/0j/ Yv9Q/3f/bP+Y/4v/r/+m/9f/yv/5/+z/FwAUADsAQABlAGgAgwCLAJ4ApgCvALsAuQDKALcAxgCs AL0AmQCpAH8AkQBoAG4AQwBOACIAJgADAP//4P/c/8b/v/+s/5//i/9//37/cf92/2j/cf9p/3T/ ZP9z/2v/d/9r/3n/cv93/27/ff92/33/dv+J/4D/lv+Q/6D/mv+y/6z/vv+8/9L/0P/u/+z/EQAJ AC8AMQBXAFsAewB+AKMArQDOANgA4wD3APsADAEJAR8BCwEcAQMBGgH1AA8B3gDtALkAygCTAKAA YQBsACkALwD9//n/y//C/5n/kf9z/2L/Uv8+/zb/Hv8h/wj/DP/0/gL/5/79/ub+8v7c/u3+0v70 /uD++v7o/gX/8/4X/wT/IP8R/zH/IP9I/zf/Y/9S/3v/aP+n/5f/2//N/wAA+/87ADgAbAByAJwA pQDIANgA/gAQASABNwFLAWcBXAF+AW4BjQFxAZYBZgGLAVUBdQE4AVcBDgErAecA/AC1AMYAhgCO AE4AVwAeACYA8P/u/8H/uf+W/4r/ef9p/1n/S/9F/y7/Lv8b/x7/CP8P//r+BP/w/vz+4/7v/tz+ 7P7X/ur+2f7t/tv++f7h/gP/6/4c/wT/Mv8a/1f/QP9+/2r/q/+Y/9j/z/8OAAcASQBKAHkAewCl AKwAygDVAOMA9gD8ABEBAwEXAQsBHwH9ABUB7wAEAdcA6gC+AM4AnACnAH0AhQBTAFgAMQA6ABcA GwD8//z/4//j/9L/yv+8/7f/sP+u/5//lf+M/4H/hv96/3v/cf9w/2j/aP9d/1z/Uf9V/0b/UP8/ /1P/O/9T/0L/Xv9P/3X/YP+J/3r/pP+U/8H/r//f/9H/AgD6/yUAIABKAEwAZQBpAIIAiACQAJsA nACrAJoArQCRAKEAgACLAGoAdgBSAFoAMwA4AA4AFQDy//P/2P/N/7//t/+j/5r/iv9//33/cf97 /2b/d/9n/3T/bP91/2r/e/9x/3z/dv99/3v/gP94/4n/gP+R/4f/m/+N/6L/mP+s/6b/vP+1/83/ xv/e/9v////1/xoAFwBCAD4AZQBnAIwAlACrALMAyADZANwA7QDvAPoA9AABAfAABAHkAPoA0gDn ALQAwwCPAJsAYQBsADIAMwAEAAAA1P/M/6X/nP+C/3j/Yf9S/0f/Mf8s/xr/H/8M/xL/AP8H//L+ +f7e/v3+5P7+/uv+B//x/g7/+P4X/wL/I/8P/y7/G/9A/yz/Uv8+/2//Yv+e/5D/v/+1/+b/3/8R ABAAQABHAHEAdgCiAKgAywDZAPwADAEZAS0BNwFSAUsBYQFQAW4BTgFuATkBVwEjATsBBAEjAdcA 7wCuAMAAfwCLAFIAWgAjACEA9f/s/8L/uv+m/5X/gf90/2j/Wv9V/0H/Rf8w/y//Hf8h/xL/Ef8B /wz/9P76/ub++v7k/vP+3P71/tz++P7l/gP/7v4S//v+Kf8Q/zz/LP9h/1H/kP96/7z/sP/z/+r/ IgAeAE4AVQB7AIcAowCyAMEAzgDVAOYA5wD2AOwAAAHlAPcA2ADvAMQA1wCpALkAiwCYAGwAeQBK AFQAMgAvABAAFgD4//r/6//n/9P/zP/I/8H/uf+u/6b/n/+g/5n/mv+R/5P/jP+K/4b/hf94/3j/ b/90/2b/av9d/2L/Vf9r/17/ef9p/3//dP+S/3//qP+a/7//uP/a/9P/+P/2/xwAGgA8AD4AWQBh AG8AfACBAIwAjwChAIoAmQCAAJUAdwCFAFsAagBJAFQAKgAvAAYADgDt//D/2P/N/7T/rP+d/47/ i/9+/4H/dv9+/3D/fP9v/3v/bv9+/3f/h/9//43/gv+U/4z/nv+W/6b/n/+t/6n/uf+1/8D/vP/L /83/2//S/+r/5//8//z/FAAWADEAMgBQAFQAdwB6AJsApACzALwAzwDeAN0A8QDmAPgA7AAFAekA /QDbAO0AxwDZAKgAtQCBAI0AVABYACEAJADx//D/vf+8/5b/iP90/2T/Uf8//zT/If8c/wn/E/// /gH/7f7y/tr+9/7f/vz+5P4C//D+D//6/hX/Bf8m/xX/Lv8e/0T/M/9S/0X/a/9g/47/iv+t/6P/ 1f/N//z/9/8iAB8ATgBQAH0AggCqALUA2QDnAP4ADwEbATMBNAFOAUIBXQFEAWQBOQFYAScBPwEJ ASAB5gD6ALUAxwCKAJgAWQBhACUAJgD0/+//wv+6/5z/jP90/2L/Vv9F/z3/K/8s/xT/Gv8J/xP/ +/4J//P+Af/u/vn+3v7v/tr+9v7f/vv+4v4B/+v+C//1/h7/BP8r/xb/SP83/2b/U/+L/37/sf+q /+b/4f8YABkATQBNAHsAhQCkALEAywDaAOgA/gD5AAwBBwEiAQcBJQEAARsB6AADAdgA6QC1AMcA jQCdAGkAdwBJAFMAIgAoAAQACQDf/+P/yf/K/7X/s/+f/6D/i/+C/4T/fv99/3L/ef9x/3D/Zf9u /2P/aP9a/2L/Wf9b/1L/XP9V/13/T/9o/1r/dv9t/4L/d/+d/43/tf+q/8//w//u/+f/DwAPADIA NQBVAFgAcAB5AIUAkwCTAKQAngCpAJsAqgCQAKYAhgCSAGoAfABQAFsAMQA1AA4AEgDo/+n/xf/E /6X/mf+P/4f/e/9v/2z/Yv9l/1v/aP9d/2L/WP9q/2D/cf9n/3r/cf9+/3//jf+H/5f/kf+l/6H/ rv+o/7n/t//E/8L/0f/N/+T/3//8//r/FQASADIANABTAFYAfwCIAJYAoQC0AMEAyQDcANsA7wDm AP8A7QAGAekAAQHZAPIAvgDXAKIAswBzAIAARwBNABIAGQDj/+L/s/+z/4f/e/9Z/07/Ov8q/xX/ A/8I//D+9f7Y/t3+wv7c/sL+4P7G/uL+y/7v/tr++/7q/gr/+P4X/wb/J/8U/zv/Kf9L/zz/af9Z /5b/iP+w/6f/3f/b/wsABgA3ADQAXABeAIoAlAC5AMMA5wD6AA8BIgEtAUoBTAFpAVoBdwFUAXwB UQFzATgBWAEgATsB/QAQAdIA5wCcAKkAcAB2ADYAOgD+////0//Q/6X/nP+A/3T/ZP9V/0r/O/84 /yf/Jv8U/yP/Dv8Q//r+B//4/gP/7/7+/un+/f7s/gj/9P4F//P+Fv/9/ij/D/85/yb/U/87/3L/ W/+Q/4P/w/+7//f/8/8oACMAVQBaAIMAkACvALsA0wDmAPAADAEHASEBEgEuARgBMAEPASoB/AAW AeMA+wDEANUAnwCuAH0AjABYAGIANAA5ABEAEQD2//T/2v/V/8n/w/+t/6j/nf+V/4//iv+I/3v/ fv90/3X/cP9t/2T/af9d/2D/Vv9g/1L/Wf9J/2L/Uf9q/1r/ev9m/4L/d/+a/4z/sP+f/9D/w//x /+j/EAAMADkANABZAF4AeACAAJAAmwCjAK8ArQC9ALAAvACnALUAmACnAIEAjABpAHAASgBTACcA LQAKAA0A5//g/8z/yf+2/6//pf+g/5j/kf+T/4v/kv+K/5X/jf+V/4z/mv+Y/5//n/+m/6X/sf+w /7//wf/H/8b/0P/P/9j/2P/l/+T/8//x/wEA/v8OABMAIgAfADgAPgBXAF4AawBxAIAAiACVAJwA nwCqAKgAswCtALsAqwC5AKMAswCXAKIAfACJAFoAZQA4AD8AFQAZAO7/7v/J/8X/rf+k/4v/gv9w /2P/Xf9N/0b/Ov9A/zH/Nv8p/zL/If88/y7/Rf85/1D/RP9i/1n/d/9t/4X/hf+Y/5X/p/+j/73/ vP/M/8z/7v/u////AgAPABIAJQAsADYAQABOAFoAZgByAH8AigCWAKQArAC3AL4AzgDOANsA0gDh ANUA6gDNAOEAxwDUALIAvgCbAKgAfgCKAGUAbQBCAEQAIwAlAP//AQDi/9z/xP+8/7D/o/+g/5T/ lf+K/43/g/+G/3r/gf97/4X/f/+E/4H/g/9+/4T/gv+I/4j/kP+R/5b/lf+W/5n/mf+g/57/nP+n /6P/tP+t/73/vP/L/8z/5P/n//b/9v8JAAsAFAAbACgALAA2ADcARABOAFMAWABQAF4AVgBgAFYA XgBPAFQASABMADsAPwAvADIAHQAfABQAEAAGAAAA///4//f/9f/w/+b/6//q//H/7P/t/+T/8//t //f/9/8CAAYAAwAJABEAFQARABoAFgAbABcAHQAQABcADgAWABQAGwAPABYAEAASAAsADgAJAAcA //8EAAMABgAEAAYACQADAAUABQALAA4AAwAKAAcACQAEAAMA/f8BAPb/+f/t/+7/4P/g/9L/0//H /7v/tf+v/6f/oP+d/5X/j/+B/4r/g/+G/4D/jP+E/5P/jP+i/5r/r/+p/7//uf/R/8v/5P/i/+// +P8GAA4AFwAhACoANAA3AEQARABQAE4AWQBYAGMAYgBoAGcAdABrAHQAdgCAAH8AjQCFAI4AiQCV AI8AnQCTAKEAiACbAIwAngCLAJUAfQCHAHQAgwBiAGwATQBbAC8AOgAaACAA/v///97/4P/H/8P/ sP+t/5r/j/+C/3n/af9i/2P/Wv9X/03/VP9C/1T/RP9U/0P/XP9S/2f/Xv91/2j/iP98/5X/iP+j /53/sv+n/8f/v//a/9f/6f/v//z//v8RABMAIQAlADUAOgBLAE8AYABiAHMAeQCFAJIAkgCdAKQA swCvAMEAsgDDALMAyACwAMMApAC1AJ0ArwCLAJkAfQCHAGAAcABIAFgALgA4ABMAIAD+////7f/q /9b/2P/G/8b/uf+2/6z/qv+h/5v/nv+U/5f/jv+U/47/jv+D/47/h/+M/4b/kv+K/5T/jP+Y/47/ mv+P/6r/pf+x/6b/tv+n/7j/sP/H/77/0//Q/+f/3P/0//L/CAABABEAEQAgACAALwAvADcAQABD AEwASABRAEcAVQBIAFYAQwBGAD4ARgA2AEMAMgA8ACcAMQAiACsAGQAfABQAGAAOAA4ACgASAAYA CQAJAAwACAAJAAwAEQAPABQAEQAWABcAGwAWABwAFwAbABcAHQAcACAAGAAiABMAGgAXABgAEAAV AA4AFgAOAA8ADAALAAYACAAGAAYAAwAEAAcABgAAAAMA/v/7//f/+P/w//P/6P/q/+T/4//d/9r/ 1f/V/8f/xf+5/7f/sf+s/6L/oP+e/5j/k/+M/47/if+T/43/lP+M/5r/mP+m/5z/sP+u/8H/wP/K /83/4P/k//P/+v8KAA0AGwAkACwANQA+AEkASQBUAFUAYQBfAG4AagB6AHEAgQB4AIoAgQCNAI0A lwCPAJgAigCbAIkAmgCHAJoAgwCSAH0AigBzAIUAZwB1AFkAZABKAFMAMQA2ABsAIQABAAYA6P/r /9H/0f+3/7f/mv+c/43/f/96/2j/av9c/17/Sf9R/z7/TP89/0//P/9W/0j/W/9V/2z/Yf93/27/ hv98/5L/j/+m/5//tv+y/8z/xv/l/+T/9f/0/wYADQAaAB8AKwAsADwAQwBTAFcAXgBoAHEAegB+ AI0AjgCcAJoApwCfAK8ApQCzAKEAswChALEAmwCpAI0AmgCFAI4AbAB3AFsAYwBHAE4AMgA4AB8A IQALAAgA8f/w/+D/3f/S/8z/w/++/7z/u/+w/6z/q/+m/6f/n/+o/53/nv+Z/6T/nP+l/5v/p/+h /6r/o/+u/6T/sP+p/7b/qf++/7f/wf++/8r/xv/W/9L/3//Z/+v/5v/2//v//////wsACwAVABoA GQAhACUAJQArADAAMAA2ADUANwAyADcALQA0ACoANwAiAC0AHgAsABwAHQAYAB4AFQAaABEAEwAQ ABUAEgAWAA8AFAATABUAHAAgAB8AJQAiACIALgAvAC4AMQAxADoANwA/AEEARwBEAEUAQwBIADgA QQA5AEEANwA7ADQAOAApADAAKwAtACIAJQAiACMAGwAgABQAGQAHABEABgAOAPv/AAD6//j/8P/x /+f/6P/f/+H/0v/S/8r/yP+9/7z/sv+x/6X/p/+k/5v/nv+Y/5n/lP+Y/5L/nf+c/6j/o/+q/6P/ uv+v/8H/vf/V/9D/4//l//n//P8KABAAHwAkAC8ANABCAEMATABWAFoAZQBmAHEAcgCBAHQAfwB7 AIgAhACRAI0AkwCJAJEAhwCTAIYAjgCCAIwAegCHAHQAgwBpAHQAXgBnAEkAWAA6AEIAIwAsABAA EgD3//b/4//g/8j/xP+y/6//nP+Y/4z/gP95/2z/a/9i/2L/V/9b/07/Vv9J/1n/Tv9h/1b/b/9g /3T/bP+F/3z/kf+P/6f/pP+2/7b/y//K/+X/3//0//X/AgALABgAHgAuAC4APwBGAE0AUgBdAGYA aABxAHYAggCBAI8AkgCfAJYAqACfAK0AmwCoAJoAqACRAKAAjACYAIAAiABxAH0AXQBjAEgAUwAw ADsAHwAgAAcAAgDv//P/2f/a/8r/yv+6/7j/tv+r/6X/n/+d/5T/mv+O/5f/j/+T/4z/lv+O/5j/ j/+g/5b/qf+e/6n/pP+u/67/uv+3/7r/u//J/8T/1f/M/93/3f/n/+j/+v/+/wIACgAYABMAIQAh ACsAMAA4ADoAQABHAEYARwBNAFIATABYAE4AWQBIAFQASABTAEEARgA7AEMALwA2ACMALAAYACAA EgAWAAcACwAAAAQA//8AAPf//v/1//z/9//6//L/9f/1//3/+////wQABQAEAAYADAAOAAwADgAP ABYAEAAYABQAFAAUABQAFgARAAwAEAASABQADgAQAA8AEwAQABEAEQASAAYACwAIAAQABAACAAQA AwD9//r/+P/5//P/8v/q/+b/3//i/9f/2P/Q/8//yP/C/7r/t/+1/63/sv+r/6n/ov+p/6b/rv+q /7H/rP+4/7f/xP+//9D/1f/a/9//7//2/wEABAAUABYAHgAnADEAPQA7AEYASABSAE4AWABfAGoA aABvAG4AeQB0AIEAewCIAHoAiAB4AIYAdgCGAHUAgAB3AHwAbwB3AGgAcABhAG0AVgBfAEYATAAy ADkAIgArAAsAEwD3//v/5f/i/8v/zf+0/7H/oP+g/5P/iv99/3v/cf9n/2j/Xf9f/1X/Yv9P/2H/ U/9q/1v/dP9r/4D/df+N/4n/nP+W/6v/p//C/8D/1f/Q/+f/5f/7//v/CAAQAB0AIQAuADQAQQBH AFMAWwBiAGwAbAB6AH4AhwCHAJMAlgCjAJgAqACZAKwAowCxAKMArgCYAKgAjQCeAH8AlAB0AIIA YgBsAEwAWwA6AEUAJQAuAAwAFgD9/wQA7v/x/9z/3v/R/9T/yP/F/77/vP+8/7X/t/+x/7X/sf+z /63/t/+w/7T/tP+8/7f/v/++/8L/wf/H/8b/yv/K/8//0P/X/9P/3f/e/+L/4v/t/+n/9v/0//z/ /P8HAAgADwAPABcAFwAhACgAIAArACoAMQAuADYAMAAxAC4ANAAoACsAKQAvACIAKQAZACYAFAAb AA8AEQAFAAQAAAABAPz//f/8//7/AAD///z//v8HAAYACAAMAAsAEQATABsAHAAlACgAKQAtADMA NQA5ADoAPgA9AEEAOQBAADkAPwA3AD4AOQA8AC8AMwAuACwAJQAnAB0AIwAYABwAEwAWAAoADQD/ ////+f/6/+7/7f/k/+X/4v/e/9r/2P/N/8j/v/++/7b/r/+q/6P/nv+V/5z/k/+Y/47/lP+M/5b/ kP+X/5L/ov+f/6r/pf+3/7T/x//E/9z/2P/s/+f/AAAAABIAGwAmAC8AMwBBAEQASwBRAGAAYQBt AGgAbwBxAH8AcgCEAHoAiQB9AI0AggCMAH8AjAB4AIUAdAB+AHAAeABsAGsAYgBqAFcAXABMAFQA PQBJADAANgAfACAAEAAPAPn/+v/q/+X/0//P/8H/u/+s/6j/l/+U/5H/hf+J/3r/eP9n/3T/av9z /2n/ef9q/37/c/+K/4H/j/+G/5//mv+v/6r/wf+4/87/zv/d/9r/7P/u//z///8FAAgAFAAZAB8A JgAvADAANwA4ADsASQBKAFMAUgBeAFoAZQBqAHEAaQByAG4AeABxAHgAbwB9AG8AeQBrAHsAYABr AFgAZgBSAFsARQBOADIAQAApAC0AFQAfAAcAFQD7/wIA8P/1/+v/4f/g/9v/2f/R/9H/0P/M/8b/ zv/D/8n/yf/M/8j/yv/I/8//x//K/8r/0//J/83/xv/L/8n/y//J/8z/zP/P/8v/2P/O/9j/0P/d /9f/3v/c/+n/4//t/+f/9f/u//7//P8EAAEADAAOABMAFwATABkAHwAfAB4AHwAcACQAGwAiAB0A IQAVABsAEgAZABAADwANABIABwAEAAkABwADAAoACgAKAAgADwANAA8AEQAZABQAHQAcACEAIQAk ACUAJQArACsALgA3ADUAPAAvADcAMgA3AC4ALwApAC4AKQAkACUAIgAhAB4AGgAZABcAEwAUABQA DQALAAsACgAGAAMAAAADAP3/+//5//P/7f/w/+3/7P/e/9v/2v/b/83/zf/E/8L/v/+7/7n/s/+z /6//s/+t/63/qf+0/63/tP+q/7j/sv+//7r/x/+//9f/1f/o/+P/+P/2/wgACAAPABQAIwAmACwA MwA6AD0ARwBHAFAAVQBUAFgAXwBgAGUAcQBjAG8AaQBwAG0AcQBlAG4AbABzAG4AcwBqAHIAaAB1 AGYAcgBaAGYAVABeAEwAUwBDAEcANgA7ACQAJwAUABgABAAGAO//7f/a/97/yv/G/73/tP+t/6H/ nv+Y/5b/lP+T/4n/jv+F/5L/if+Y/47/m/+V/6L/nv+v/6v/uP+1/8b/xf/Q/9H/3P/d/+n/7P/1 //X/+//7/wUACAALABMAFQAdACIAIwAtAC0ANwA1AD4AQwBEAEkAUABPAFIAWQBVAF8AWgBhAFgA ZgBYAF8AUwBaAEwAUwBGAEUAOAA5ACgALgAZABwADQATAP3////3//L/6P/k/+H/3f/f/9v/1v/W /9b/0v/W/87/1P/N/9f/1f/a/9L/3v/Z/93/3v/m/+H/6P/l/+f/6v/q/+j/6v/v//D/8f/v/+// 9v/x//T/9f/3//j//P/3//z/AQAHAAQADQAKABQAEgAVABsAGgAfAB0AIAAgACMAHgAlACAAIgAb ACQAFgAeABAAFwAPAA8ABAAEAP7////2//f/7v/w/+7/6v/q/+f/6P/r/+n/6P/r/+z/8v/u//r/ +f8BAAQACgAFAA4AEwAVABcAHQAdACEAJAAfACcAIQArACUAKQAmAC8AIwAnACgAJwAkAB0AJgAi ACYAIgAcABoAHQAaABsAHAATABUAFgAWABMAFAAKAAwABwAEAPz//v/3//r/8P/q/+D/4f/T/9D/ zP/G/8P/wf+9/7X/t/+5/7T/rP+z/6z/s/+q/7v/sf+//7b/xv++/9L/zf/f/9//6//q//n/+P8E AAoAFQAZACIAJgArAC8AMwA8ADwAOwBCAEkASABSAEoAUQBRAFYAUgBaAFEAVwBWAFsAUQBcAFMA WgBSAFoATABUAE8AVQBGAEwAPQBFADcAPQAvADMAJAAqABwAGgAJAAsA/v/8/+j/6P/X/9T/x//F /77/uP+u/6X/qP+f/6H/lf+d/5L/mv+Q/57/lv+j/5T/pv+d/7H/qf+9/7T/wv+//9H/y//W/9P/ 5v/g/+v/7P/4//b//P/+/wYABAANAA8AFQAWABsAGwAhACQAKQAsADQAOAA4AD8AQgBMAEMATQBF AE0ASQBTAE4AUgBIAE8ARwBPAEAAQwA7AD8AKwAzACIAKQAYABsADQAOAAAAAQD0//r/7P/u/+j/ 6P/h/93/3v/f/9//3P/f/93/4P/d/+P/4//o/+X/7P/s/+7/7v/4//n/+P/6//7/AwD9/wAABgAI AAMABgAIAAUABQADAAUAAwAHAAkABAAEAAkADAAMAA8ADQAOABEAEgAPABIADwAVABMAEwAWABYA DwAQAA0ADgAHAAcABgAGAPn/+v/6//n/7f/z/+f/5//h/+H/3//f/+H/2P/f/93/5f/h/+r/5//z /+z//v/7/wUABQAUABQAIAAhAC0AMgAyADsAQABIAEoAUgBPAFcAVgBcAFcAXgBWAFwAWwBfAFQA XwBWAGQAVgBZAFIAVwBMAFAARwBJAD4AQQA2ADsAKAAsACIAJwASABQACAAGAPz/9//q/+X/1v/S /8f/wv+2/7D/qf+f/53/j/+S/4n/iv95/4L/dv9//3L/ff9w/4L/d/+I/3//lv+E/5//l/+s/6f/ wP+8/9X/zv/p/+X/+P/5/wwAEAAeACMAMwAyAD0AQwBRAFQAXwBiAGgAbgBuAHcAcwCAAHcAgwB+ AIsAfwCLAIAAiwCCAI0AgACKAHcAhgBzAHwAZwBxAGAAaABRAFcAQgBLAC4ANQAfACMAAgAJAPX/ 8P/e/9j/yf/D/7L/pf+i/5n/lP+A/4b/ef99/23/ev9p/3b/Zv94/2r/fP9t/4P/cf+L/37/kv+I /6D/kf+u/6v/t/+y/8j/u//S/8z/3P/X/+j/4//4//L//v/5/wkACAAXABkAIgAoAC8AMwA7ADsA RABFAE0AVABSAFgAVQBdAFoAYgBaAGMAWQBeAFIAXwBNAFMASgBOAD4ARQAyADgAJwAsABoAHwAP ABUAAwAEAPn/+v/z//T/7f/s/+r/6//p/+H/5//d/+X/4f/m/+D/4//g/+f/5P/l/+H/5//n/+n/ 5f/m/+X/4//i/+f/4f/l/+D/5//f/+H/2v/j/+D/5f/c/+f/4v/v/+n/8P/r//P/7//4//X/9//2 //z/9v8BAPv/BAADAAAA//8AAAIA/f////7////7//b/9P/0//D/8v/1/+3/8//x/+//8f/2//T/ +f/1//3///8IAAMADgALABQAFwAcAB8AJQApAC8ALQA7AD0AQAA9AEMAPwBCAEMAQgBCAD4ARQBA AEEANgA2ADMAMAAvACsAJQAhACIAGwAVABMADQAJAAcA//8EAPn/9//z//P/7//v/+b/5P/d/9v/ 0v/W/83/x/+7/8H/t/+7/63/sf+i/6b/mv+n/53/nv+W/6D/lv+d/5f/oP+V/6j/ov+0/63/vf+z /8n/w//Y/9L/5v/k//b/8/8GAAcAFAAYACQAIwAwADAAOgA9AEkATABRAFsAVgBdAFsAYQBeAGcA XQBiAFoAZQBfAGQAWwBaAFgAWABXAFcATgBTAEkATABEAEcAOQA3ADIAMQAkACMAHQAZAA4ACgD9 //b/9P/q/+H/2f/S/8H/xv+0/7T/p/+u/57/rP+U/6T/lf+g/5L/n/+T/5//jf+p/5f/r/+h/7b/ qv/A/7j/z//C/9f/zf/j/9z/7P/l//f/9P8AAPz/EQAHABQADwAeABsAJgAlAC4AMAAwADQAPAA8 AD4AQQBFAEkARwBNAEkAUQBNAFAATwBUAE4ATwBLAE0ARQBNAD4ARAA5ADwAMAAwACQAIQAXABcA CgAKAAIA/f/x/+7/7f/m/+H/1v/Z/9H/1//P/9X/yf/S/8n/1//K/9b/y//b/9X/3v/P/+X/2f/q /97/6P/h/+j/4f/u/+j/8//s//L/7P/v/+n/8v/u//f/6//7/+7/+//r//7/9f/8//f/AwD9/wMA 9/8EAAEACQACAAYAAwAGAAYABgAEAAYABAAFAAEAAwD///n/+v/1/+//8f/v/+v/6//n/+P/5P/c /+j/3f/i/9z/6f/f/+f/4//u/+v/+P/p/wEA9f8DAAEAEQALABwAFAAnACAALQAoADUANAA9ADYA PgA/AD4AQABEAEEAPgA+AEMAQAA/AEAAQAA8ADMAMQAzADIAKQAoACUAIgAeABsAFQAUAAsACQAH AP3//v/0//H/7P/h/9v/1//P/8j/v//A/7f/tf+r/6z/of+h/5T/m/+N/5P/hv+U/4P/lf+C/5T/ iP+b/4v/pv+S/6v/n/+7/6//y/+9/9r/1f/s/+j/AQD6/w8ABgAdABcALgApADsAOwBHAEYATwBS AFQAVgBgAF8AYQBkAGgAaABsAGoAbgBwAGoAbgBpAG4AZABlAGEAYgBaAF4AVABWAEcASAA+AD8A MwA2ACIAIwAOABAAAgABAPD/6f/h/9v/yv/C/77/tv+w/6f/rv+g/6L/lf+f/5P/n/+O/5//kP+e /5b/qP+d/63/n/+z/63/v/+3/8n/xP/W/8z/4f/d/+3/6f/5//P////7/wMABwAOAAkAGQAaAB4A HQAoACgAKwAsADEALAA1ADEAOwA1AD0APQA+ADwAPwA8ADwAOwA5ADkANAA1ACsALAAiACIAGAAZ AA4AEAAJAAUA/v/7//T/7v/u/+T/7f/h/+//3//r/9v/6P/e/+P/3f/q/+L/6//j/+//6f/4//H/ /f/3//////8GAP3/BwAEABEAEAATABQAGwAaABsAIAAhAB8AJwAgACMAHwAgAB4AJgAjACMAHgAm ACMAIwAkACIAHwAeABgAHgAVABEADQAWABAAFwALAA0ACwALAAUADQAHAAsACgAEAP//AwAAAAAA ///6//X/8f/q//L/7f/z/+r/9v/w//3/+f8EAPz/DwAMABMADgAfAB4ALQAsADYANwA/AEAATABN AFEATwBVAFcAWwBbAF4AXwBdAF4AXgBkAFoAWgBXAFkAUgBVAEsARwBHAEcAPgA+ADkANgA3AC0A LQAqACkAKQAhABoAGQATAAoABgD8//j//P/z/+n/5P/n/97/4P/W/9n/zv/V/8r/z//L/9f/zP/S /8n/1v/J/9X/zv/c/87/4//X/+f/5P/6//P/CAACABMADgAkACAAMQAwADQANQBCAEAAUABUAF0A WwBgAF0AZwBrAGgAawBvAHIAcABzAHEAcABtAHEAbgBrAGYAZwBjAGUAYABiAFcAWQBNAFYASgBG AEAAPQA1ADAAKAArABsAGQANAA8AAwD9//b/7v/n/93/2v/O/8b/wv+//7L/vP+r/7P/pP+p/6D/ pv+b/6j/nv+r/6D/s/+l/7f/p/+8/7D/xf+6/87/yf/V/9L/3//Z/+7/4//2//D/+//0/wIA+/8G AAIAEwAPABcAFAAfABkAJwAgACsAKQArACwANAA1ADkAOgBBAD4APQBDAEAARwBBAEUAQQBCADsA QQA2ADgANQA3ADAALwAoACgAIgAlABoAGgAUABcACAANAAoABQADAPv//f/7//r/9v/9//b//P/z //n/8//3//D//P/3////+P/8//b/AAD5/wAA+//+//v/AgD+//z/+/8AAPn//v/3//7/9f/5/+3/ 9f/s//L/6P/1/+7/8f/s//H/7f/0/+z/8v/q//P/8f/5//b/+P/y//3/+//7//n//v/8////+P/8 //f/9f/4//X/8//0//P/9v/0//P/7v/2//b/9v/w//r/+v/9//v/AQD//wwACgATABUAGwAdACQA JQAtADAANQA3ADIAOwA+ADwAPQA9AEEARABBAEMAQgBFAD4APwA+AD4AOgA5ADYANgAxADAAKQAr ACEAIAAcABsAFgAXABYAEgAOAAwABAABAPb/+f/1//f/6//l/+T/3v/X/9b/z//O/8j/xf+9/7r/ t/+0/7b/r/+z/6b/r/+l/63/p/+0/6f/uf+u/8D/uP/I/8D/1v/R/9//2f/x/+f//P/1/wYABgAS ABIAIQAoACsAMAA4ADcAPQBBAEcASQBMAE4ATwBYAFUAWgBYAFsAWwBfAF4AaABgAGEAXgBgAFgA WQBTAFkAVABSAEoASgA/AD4ANQA5ACUAMAAeACAACQAJAAEA+//v/+r/2v/X/8v/x//B/73/uP+v /7D/qv+l/5n/pf+a/57/k/+h/5j/pP+a/6r/of+u/6f/uv+y/7//uf/N/8f/0//Q/9z/2//l/+H/ 9f/w//r/+P8DAAIADgAMABEAFQAWABsAIgAhACkALAAvADgAOQA8AEIAQgBKAEoASwBRAEsATQBM AE4ARwBRAEoAUABCAEEAOgBDADkAPAAxADYAIQAnACAAIgAWABcADwAOAAcABAAAAAEA///6//j/ 8f/z/+7/8//t//D/8P/z/+v/8P/s//b/9f/6//j//v/8//7/AQADAAEAAgAFAAsADQAGAAYABwAL AAoACQALAA0ADQALAAsADAAHAAQAAwAIAAIABwABAAYABAAEAAYABgAAAAUAAgADAP7/AgD6/wAA 8v/3//P/9f/u/+7/5//n/+L/4//d/9//2v/Z/9v/2v/b/9f/1//Z/9r/2v/h/97/4f/g/+3/6f/2 /+///P8BAAsACgARABQAGQAZAB8AIgAiACcALAAsACkALwAvADEAMAAzAC0AOQAtAC8AKAAuACgA KAAeACQAEwAXABUAFgALAAwABgAIAP7/AQD5//3/6//s/+n/5//h/9//2f/V/8z/yP/F/8n/wP+7 /7v/tP+3/6//rv+o/6j/pf+s/6f/p/+h/6j/pf+y/6r/tP+z/7//uv/H/8X/z//S/+D/4v/y/+// ///8/w0ACwAdABwAIwArADIANwA1AD4AQABIAEIASgBDAE0ASABOAEcATABGAE8ARwBPAEYASQBC AEcAPQBCADEAOwAsADQAJAApAB4AIAASABIACgAKAP3/AQDt//P/5f/i/9X/0//F/8T/vf+0/7D/ rP+m/57/ov+Y/5r/kP+a/4n/l/+L/5f/kP+Z/5P/oP+Z/6n/pf+z/7D/vP+6/8j/w//V/9T/3//g /+n/6//0//n//v8EAA4AEgAVAB0AHQAgACYAKgAmACsALQAwAC8ANgAwADgAMwA4ADQAPgAzADwA NQA/ADIAPgAzADgALQA3ACoANAAmACwAHgAlABcAHAAOABgABQALAPv/AADw//b/6//t/+D/5//a /9v/0f/X/9D/zv/O/8v/y//L/83/zf/Q/9D/0v/S/9z/1v/X/9r/4//g/+P/4v/m/+T/6P/o/+3/ 6//x/+r/7v/v/+7/6//r/+//7P/s//H/6v/t/+3/7//u//P/8f/1//L/8v/0//j/+f/3//n//P/8 //7/AAD+////+v/5//j//f/0//f/8v/x/+r/7//t/+r/6P/o/+L/4v/i/9z/3v/Z/9f/1v/c/9r/ 3v/i/+b/5//r/+n/7f/w//X/+P/7//v//v/9/wUACQAIAA0ADAASABMAFwAXABgAGAAWABgAGQAa ABgAEgAXABQAEgARABQACwAPAAwADQAIAAoACAAFAAIABQD//wQA+f/5//v/9v/x//H/7P/s/+j/ 5v/h/+H/2f/a/9T/z//K/8r/xf/C/7j/tv+5/7L/sv+v/6//sf+x/63/sv+w/7v/uP/A/7v/xf/E /8//1f/V/9v/7f/t//X/8/8CAAAADAAQABYAIAAiACQAIgAsACoALgAvADEALQA1ADUAOAA3ADoA PQA9ADwAQQA5AD8AOQA/ADYAQAA1ADgANAA8ADIAOAAtADEAJgAkACIAIwATABkABAAIAPf//P/u /+7/4f/f/9X/2P/J/8f/vf+8/7T/sP+t/6f/qP+f/6T/n/+k/5z/p/+d/6r/of+v/6v/uP+z/73/ uf/E/8H/zv/O/9X/1v/d/9//5P/f/+z/7//x//X/+v/7//3///8DAAcABgAIAA4ADQAOABIAFAAa ABcAHQAcACMAHgAmACQALQAlACkAJwAsACUAJgAjACUAGwAiABYAGwANABIABQAHAAEA/v/6//n/ 7P/u/+X/4//g/97/3//W/9b/0f/V/9L/0f/L/9H/0f/S/9H/3P/Y/93/3P/j/+D/4//d/+f/7P/t /+z/6v/w/+3/8v/v/+//7v/u//P/7f/q/+7/6v/s/+z/6v/s/+X/6f/p/+r/5//r/+n/5//r/+j/ 5//s/+//6P/q/+j/6v/p/+j/5f/k/9//4v/g/+D/2P/U/9r/1//V/8//0//M/9D/yf/L/8r/yv/G /8j/xf/M/8X/1//L/9j/0f/f/93/5v/h//H/6v/4//b/AQABAAUACQAPABAAFgAWABkAHgAfACYA IwApACMAKAAkACsAHQAlACMAJQAfAB4AFwAfABUAGwAUABcAFAAWAAsAEQAFAAgABAAHAPr//v/3 //r/8f/x/+j/5//k/+L/2P/d/87/zP/J/8P/wP+8/7T/sP+x/6T/q/+k/6j/of+r/57/qv+i/63/ ov+z/6//u/+2/8T/vv/Q/8//2f/S/+j/5P/w/+z/+//2/wEABQAFAA4ADQAQABEAFQAYABwAGwAg ABgAHgAbACIAHgAjACAAIAAhACIAHwAnACIAKAAkACYAIgAnACAAJgAfAB4AGgAeABgAGQASABQA CQAOAAYABgD7//r/7f/u/+j/6f/e/9z/1f/U/8r/zP/H/8L/x/++/7//uf+8/7j/u/+3/77/uP/B /7z/x//D/8v/x//Q/8v/1f/P/9n/1v/f/9//5v/k/+v/6f/q/+n/8f/q/+7/7P/y//H/7v/y//H/ 8P/v//D/9//x//b/9P/6//v//P/6//7///8CAAAA//8DAAIABAAEAAMABAAFAAEABAD+//7//P// //j/9f/y//b/7//q/+3/5v/q/+r/4//j/+X/3//p/+T/6P/o/+z/7P/v/+7/9v/2//b//v8EAPz/ BAABAAYABwAKAAkACAALAAYABQAEAAcAAgABAPv/+P/4//D/9P/u/+//8f/r/+r/5v/h/+P/3//f /93/4P/a/+L/4f/f/93/3v/Z/+H/3//k/+D/4v/a/9n/1v/f/9f/3P/X/9v/2//a/9n/1//W/9b/ 1P/V/9L/1//Y/9//2f/d/+D/6P/o//L/7P/+//v///8DAAkADgAWABQAHQAiACUAKwArADIALwA1 ADgAPAA5AEAAOABAADcAPQA4AD4AMQAyACkALgAjACsAIAAhABYAFgAQAA8ABwAHAP7//v/6//r/ 9P/y/+v/6P/n/+P/3//d/9v/1f/Q/8X/yf/F/77/uv+1/67/qv+g/6L/nv+c/5X/mv+R/5f/jf+c /5L/nf+S/6X/k/+o/53/tv+m/7n/t//I/8X/2P/U/+T/4f/v/+7//P8CAAoACQAXABcAHAAgACcA KQAoAC0AMQAxADEAMgA0ADgAMAA4ADMAOgA0ADYANgA1ACsAMAAtADAAKAAsACcAKgAgACcAHwAm ABYAFwAMABEABQAHAP3////z/+//6v/p/9z/2f/W/9L/yv/C/8L/uv+2/7H/s/+t/7D/pf+v/6r/ sv+r/7r/rf+//7H/wf+5/8n/v//T/9H/3P/Z/+P/4P/p/+r/9f/z//T/8v/8//n/AgD7/wQAAAAD AP7/BgABAAMABAD+/wIAAQAAAAIABgACAAMABgAGAAIABAAJAAsAAgAJAAYACwAGAAUAAwD///3/ AwD7//j/9v/0/+//8P/l/+b/4//k/97/2v/e/9j/3f/Z/9z/1v/e/97/5v/h/+v/5//5//H/+f/6 /wkABgAQAA4AGAAcACAAIgAmACgAKAAsAC0ALgAsADAAKgAsACcALAAsADEAJgAlABkAGAAOAA0A CQALAPv/+//4//v/9P/w//D/6//j/+T/4v/j/+H/2//Y/9j/0//O/8//yP/H/8T/xP/A/7r/t/+1 /7D/tP+v/7H/rf+t/6j/r/+p/7T/rP+8/7T/wv+7/87/xP/X/9H/5v/i//X/8v8HAAkAFQAXACgA JQA1ADUARgBMAE0AUgBUAFsAXwBnAF0AZABdAGMAWABkAFMAXgBTAFYATABPAEEARwA4ADoANQAy ACIAIgAdAB4AEgAUAAkABQD///7/8v/x/+L/3//X/9b/y//D/77/t/+s/6T/pf+Y/5b/jP+S/4P/ hv96/4L/dP98/3H/hP91/4r/ef+R/4P/m/+O/63/n/+9/7D/zf/J/+L/3v/0//T/AwAFABQAFQAj ACkALgAzADgAQABBAEcASABOAE0AVQBNAFQAUwBZAE0AUABIAE0ASgBOAEYATABCAEIARABEAD0A QQA7ADcALwAwACQAKgAgACAAFwAXAAgACAAAAP//8//x/+v/6f/e/9n/1v/S/9L/xv/C/7b/wv+3 /7n/r/+7/7L/wf+4/8X/vv/P/8b/2v/R/+X/4P/x/+n/+//0/wQAAgANAAsAEgASABQAHQAZABgA GwAdABkAGQAYAB4AFwAaABcAFgATAA8ADgAPAAwAEgAPAA0AEAALAA8ACwAIAAsACQANAAoABgAF AAoAAwAGAAMA/P////f/9P/z/+3/7v/o/+b/5P/m/+L/5//m/+D/3v/e/+H/3//l/+f/7v/x//j/ /P/+/wEACAAMABgAHAAdACIAMgAtADkANwA9AEEAQQBHAEAARgBBAEYAPwBGADcAOgAuADgAKAAt ABsAIgATABIADAALAP7/+//1//P/7P/r/+f/4//h/9j/3//X/9n/0f/R/8n/yv/A/8X/wf/B/7z/ wP+9/7f/tf+2/7P/tv+v/7T/q/+w/6z/tf+r/7f/sf+//7v/yv/F/9L/y//h/9z/8f/w//z//P8Q AA8AIwAoADMANwBAAEUATQBTAFUAYQBgAGwAYwBtAGQAdQBjAG0AYwBtAF4AZABXAGEATQBVAEYA TgBAAEEAPAA6ACoAKwAiACIAGwAbABMADwAHAAMAAAD6//L/8f/g/+X/2f/U/8f/yf+4/7P/sP+p /6n/n/+e/5j/mP+R/5T/jv+T/4j/l/+P/5f/jf+i/5j/rf+i/73/tP/N/8b/4f/a/+3/6/8BAPv/ CwAPAB8AIAAqADAANQA7AD4AQwBCAEsASgBRAFAAUwBPAFMATQBTAEsATwBIAFEAQQBHAEQASABD AEEAPgBFAEAAPwA0ADkAMAAwAC8ANAAiACYAIQAkABUAGAAMAAsABAAEAPr/+f/t/+v/5v/i/9z/ 2//V/9X/0v/M/87/zP/L/8X/1f/R/9f/0P/a/9D/2v/Y/+L/4//t/+r/8f/1//7//v8CAAIACgAI ABAAEAAMABAADwARAA8AEgANABAACgANAAwADgABAAgABwAHAAEA//8DAAMAAAAAAAMAAgACAAUA BAAJAAQABAAIAAkABQAHAAQACgADAAMAAAD8//z//f/7//3/+v/5//v//f/z//T/9v/6//b/+f/4 //r//v///wQABAAKAA4AGAAbAB4AIgApACsALQA2ADUAPQA5AD8APQBFADsAQgA9AEYAOAA7ADMA OQAqADIAIgAjABUAEgAJAA0AAgD///b/+f/r/+v/5//h/9z/2P/V/9X/z//L/8r/xv/I/8T/yP/D /8n/vv/G/77/wv+//8X/vv/D/7v/w/+//8X/vf/H/8f/yv/G/9f/0v/b/9j/6f/j//L/8P////3/ CwAMABwAIAArAC4APQA9AEUASwBXAFwAYQBvAG0AdwByAIAAegCEAHcAhgB5AIEAbgB5AG0AdgBj AG4AVQBZAE0ATgBDAEUANgA6AC0AMgAhACEAGAAYAAkADAAHAAQA+P/2//L/7//d/+T/2//V/9b/ zv/C/8D/vf+2/7H/sP+v/6X/rv+m/6z/ov+q/6P/rf+k/7X/rf+7/7X/yf/H/9n/0f/l/+b/9//0 /wcACQAWABYAJgAqADIAOgBBAEUASABRAE8AXQBaAF0AXQBlAFkAYwBWAFkAUgBbAFAAWQBJAEwA QQBLADcAQgA2ADkAMAA2ACcAMAAkACgAHAAgABYAGwAUABcACgAPAAQACgD+////9f/3/+3/8v/o /+X/4f/g/9n/2f/X/9X/0//Q/9D/yf/Q/8r/1f/K/9n/0f/a/9b/5f/h/+r/6v/x//X/AAD6/wcA BAAOAA8AEgASABYAGAAXABgAGAAYABYAGAAWABgAEQAVAA0AEgALABIABwAMAAMABAD//wEA/f8C APz//v/+//3//P//////AQD7//3//f8AAP7////5/wEA+P/+//j////9/wMA9//8//z//f/+//v/ ///7/wEABQAFAAgACAAKABAAFgAdACMAIQAkACsAMgAvAEAAOAA+AEEARQBHAEoATABQAEwAVQBN AFMASwBOAEIAQgA2ADkALQAqAB4AIwARABIABwAHAP//9//z/+3/6f/k/93/1//W/87/z//H/8n/ wv/I/7z/w/+4/8H/uv+//7z/wv+5/77/v//B/7//wv/C/8b/xv/P/8f/0v/Q/9//2v/j/97/5//q //f/9f8HAAMAEQASACMAJQA1ADUAPwBFAFAAVQBdAGMAZABxAGwAewBxAHwAeACCAHIAfgBwAHgA ZwB1AGUAbABZAGEASwBUAEEARwA0ADoAKAAwAB4AJgASABcACAALAP7/AAD1//X/6f/s/+X/4//b /9z/0f/W/8v/xv/F/8L/vv+7/73/tv+4/7P/uP+y/7T/rv+5/7X/uf+y/8H/uv/I/8T/0v/O/9z/ 2P/m/+H/8f/0/wMABAAJAA8AGAAdACcAJwArADAAMgA0ADsAQwBAAEgAPwBIAD4ARABAAEEAOAA/ ADcAPgAxADQALAAsACcALQAnACsAIgAlAB4AJAAcAB4AGAAWABUAGAASABoAEgAQAA4ADwAFAAYA BQAEAP3/AAD5//3/9v/2//D/8//v//L/7f/p/+r/5v/q/+f/5//k/+j/6//s/+3/8P/z//b/9//8 //z///8CAAcADAANAA0ACwAPAAoAFAANABgADAAUAA0ADgAIAAUAAQADAP3/+v/8//z/8//1//D/ 8v/q/+z/7v/u/+j/7v/w//L/7P/w//b/8v/1//P//f8AAP7/AgAGAAwAAQAIAA4AEAASABYAEAAT ABIAFwAXABkAFgAXACAAIgAiACcAKQAuAC4ANQA0ADoAOwA/AD0ARABHAFAASwBUAE4AWABWAFgA VABgAFcAYQBTAF0AUABaAEkAUAA+AEUANAA5ACgAKgAUABwACgAPAAAA///z//T/5P/i/+L/3P/T /87/zv/J/8X/wf/E/77/wf+7/8D/u/+9/7v/w/+8/8H/u//F/8H/xP++/8r/xf/K/8r/1f/P/9n/ 2v/l/+L/7P/q//f/+P8FAAMAEAAXACMAIwAtADYAPABDAEsAWABVAGMAZABwAGkAdwBuAHwAcQB+ AHQAggByAH4AcgB8AGYAcABhAGcATwBbAEcAUAA8AEQALwA0ACEAKAAXABwADAAJAAAAAQDy//b/ 5f/u/97/3f/X/9H/xP/G/8D/uv+2/7H/rv+q/6v/pf+m/6L/oP+Z/6P/l/+d/5f/pP+c/6v/of+x /6r/uP+0/8n/xv/Y/9T/5P/m//j/9v8MAAoAFQAZACwAMAA5AD0AQQBMAEsAVgBXAGAAWQBmAF4A agBdAGgAWgBpAFcAYgBUAF4ATABYAEYAUgA9AEkAOABBADAAOwAuADMAKAAqAB4AJAAXABoAEAAb AAgAEQAAAAUA9f/9//H/9f/n//D/4f/n/9r/1//Y/9j/1P/S/9H/z//T/87/zf/R/9T/0P/a/9b/ 4P/e/+b/4//q/+n/9v/z//7/9f8GAAQACgAGAA0AEgASABcAFQAWABIAFAAVABgAEgAVABIAEwAO AA8AEAARAAcADAAHAA0ABgAJAAUACwAFAAkABgAIAAoACgAGAAkABwAMAAcABwAJAAcADgAPAA0A EwAKABEADQAMAAgADAAJAAwACgAJAAkADwAMABIAEwASABwAHgAgACAAJQAiACgAKgAuADAANQA2 ADgAPQA8AEAAPwBGAEIASABFAEgAPwBHADwAQQA0ADcALQAwACMAKAAWABoACAANAAAA///2//L/ 6f/w/+L/3v/b/9f/2f/Y/9D/yf/M/8f/zf/L/8r/yf/L/8n/xP/H/8v/yP/M/8f/yv/N/8z/zP/P /8z/1v/P/9n/1//i/9z/5v/n//P/8P/2//j/BAAJABYAFgAiAB0ALQAyADsAQQBJAE8AUQBaAFsA XwBfAGoAYgBtAGYAbgBlAGwAYgBrAFwAaQBSAGIAUABUAEMASgA6AD8AMQAyACQAJwAdABsAEgAT AAoADAAAAAUA+//8//L/7//n/+T/3//d/9b/1f/N/8z/x//F/7v/wP+7/7n/tf+z/7X/sv+y/6z/ r/+s/7f/tP+6/7j/v//A/8j/y//V/9j/5f/l//T/8v8FAAcADwATABwAHwAuADUANAA9ADwARQBG AFQASABNAEwAXABQAF8AUgBbAFAAVQBMAFgASwBSAEIAUQBCAE8APABHADsARABDAEsAOABCADEA OwAuADkAJgAsACEAKQAfACQAFAAdABQAGQAJAA4ABQAKAPz////6//z/7//0//D/8v/w/+//7v/t /+r/7//u//L/6f/t//D/8v/y//X/+v/4//r///8BAAcAAAABAAUAAQABAAMAAwAIAP7/AwABAAUA +/8DAPv////6//f/9P/2/+//8//0//X/9v/0//j/9v/7//b////8////+/8DAAUABAAFAAkACgAK AA4ADwATAA8AEgAWABcAEQAWABYAFAAVABUAGAAeABsAHQAbAB8AHgAqACIAKQAlAC4AKQAyACwA MgA0ADgAOQA5ADoAPQA4ADwAPABCADgAPAA2ADwALQA4ACgAKwAbACEAGAAbAAkACwADAAQA+//4 //T/9f/o/+T/4P/e/9j/1v/R/9T/0P/L/9L/yf/M/8b/zv/J/8z/yf/P/8z/z//K/9D/0P/Q/9X/ 2f/U/9j/1f/f/9r/4v/i/+T/5v/v/+7/9//1//r//P8EAAkACgAMABQAGAAgACMAKAAwADIAOAA5 AEEAPwBFAEcATwBIAFAASgBSAEkATgBFAFAAQgBNAEQATgA3AEIAOQBAAC8ANQAjAC4AHQAgABUA HQALABQACQAMAAAABQD//wYA+//9//j/9//v//H/6v/r/+r/7P/j/+b/3P/f/97/3v/Z/9X/1P/W /9P/1//U/9H/0v/S/9f/1//U/9n/3v/d/+D/3P/p/+v/6v/w//r/AQD+/wQABgALAAwAEgASABoA GAAeABwAJQAiACgAJQAsACUAKwAkACoAJwAtACMAKgAdACYAJQAoAB0AJQAjACUAGgAiAB0AIQAa ACAAHAAiABwAHAAbACMAHgAjABgAJQAZABsAFwAgABgAGQAVABsAFQAYAA8AFwAMABcACQASAAYA BwAHAAgABgAGAAUABgAGAAgACQAMAAUABgAIAAkACAAFAAkACAAGAAgABAAJAAMABAAAAAMA+//+ //X/9P/u/+7/6v/t/+T/3f/i/9v/3//d/9n/1v/a/9j/2P/W/9X/1v/c/9z/2f/X/97/3//j/+T/ 6P/m/+r/6f/z//H/+v/4//z//P8CAAMAAgAMAAEACgAKAAoADgAQABYAGAAdAB4AJAArACcAKQAt AC4AMwA5ADUAPgA/AEcASgBLAEsATQBMAFIASQBUAEkAVABJAFAAQgBKADgAQwAzADsALAA0ACAA JgAXABkACQANAP//AgD6//v/7P/s/+D/4f/f/9//2P/Z/9f/0f/W/9X/0v/U/8//0P/Q/8r/z//I /8//0P/P/83/2P/Q/9X/1//W/9z/3//e/+H/3v/n/+n/8P/x//r/8v/8/wEABwAMAA4AGAAaACQA KgArADMAOAA6AEYARABJAEcATgBOAFkAUABfAFUAXwBWAGMAVABgAFUAXgBOAF8ATQBXAEYATgBC AEkAOgBDADcAPAAwADYAJwAuACAAJgAVAB4AEwAZAAkADwD+/wYA9//9/+//9//q/+//4//o/9n/ 3f/Y/9T/z//N/8j/yP/K/8f/xf+9/77/wv/E/8H/w//F/8f/yP/N/8f/0f/K/9n/1P/g/97/6P/k //D/7v/5//j/AAAEAAgABAANAA4AEwAWABgAHAAbACQAIQAkACYALQAkAC0AKwAvACsALgAtADUA KwA0AC4ANwA1ADcANAA+ADQAPAA1AD4ANgBAADYAQwAwADkANQA8ADAANgAqADIAKAAsACQAKQAb ACEAGQAYAA8AFQAOABIADAALAAMABQD+/wAA+f/+//f/9f/y//P/8//y//H/7f/r/+v/6v/k/+X/ 5v/j/+P/4f/Z/+H/3f/Y/9f/1P/Y/9P/z//O/8z/zv/M/9L/zf/S/83/2P/V/9n/1//e/93/4v/i /+v/6f/u//L/+P/5//7/AQAHAAgADAANABYAFQAXAB0AGwAkACAAJQAmAC0AKAAvADEANQAxADUA MwA7ADcAPQA2AEAANgBCADsAQwA7AEIAQQBGAD0AQgA+AEcAOwBCADgAQgAyADcALgA2ACUAKwAf ACUAGQAZAAwAEAACAAUA+v/4//X/7f/q/+f/3v/a/9n/1//T/83/z//P/8n/yv/L/8b/yP/I/83/ zf/G/8X/y//L/8z/zP/T/9H/1f/Y/9v/3P/f/+T/5P/k/+j/5//y//H/9//4//z/+v8EAAYACwAQ ABUAGgAcACUAHwAlACwALgAvADUANwA/ADoAQwA+AEYAPQBHAEIATABFAE4AQQBOAEEASwA8AEkA NgBDADgAPwAxADYAKAAyACQAKQAkACkAHgAgABkAGgARABAACAAJAAQAAgADAAMA9//1//H/8v/q /+r/5f/i/9//2//a/9r/1P/R/8//zf/I/8P/y//D/8P/w//E/73/yP+7/8b/wv/F/8j/zv/P/9D/ 0f/X/9b/3//h/+T/6P/t//H/+f/8//r/AAAKAA8AEAATABQAHAAZAB8AIQAoACcAKwArAC4ALAA5 ADUAPwA1ADsAOwA9ADgAQgA8AEQAPwBDADwARgA8AEgAOABEADkAPwA4AEAANgA4ADYAOgArADQA JQAqABoAHQAVAB0ADAAQAAYABQABAAUAAQD8//r/+f/z//b/6//x/+//7//q/+n/6v/k/+r/5//m /+T/5f/j/+f/5//m/+H/5f/i/9z/3P/d/93/2f/Y/+D/2f/f/9v/5P/e/+H/3P/i/+L/5//i/+z/ 6//v/+7/9f/0//j//P8BAAEAAwAIAAsAEwAOABkAGQAfAB8AJAAkACoAJwAuAC4AMwAyADQANAA7 ADwAQQA8AEIAOgA+AEAARwBBAEYAQABIAEIASgBBAE4AQQBOAEQASABCAEcAPQBHADkARQA0AD4A LwA1ACoAMgAjACYAGgAfABIAFgAGAAgA+v/4//L/8f/o/+f/3v/Z/9P/0f/J/8b/wP/A/77/vP+2 /7j/tv+1/7P/sv+y/7b/uP+w/7n/s/+1/7X/vf+6/8P/vv/F/8T/z//I/9P/0f/Z/93/5f/h/+7/ 7f/2//b/AgABAA8AEAAYABoAJQAkACoAMQA2ADsAPQBDAEYATABMAFEATwBVAE8AWwBSAFsAUQBZ AFIAXABMAFYASwBSAEYAUABBAEUAOAA+ADMAOgAuADIAJAArAB8AJgATABsADgARAAYACAD+/wAA 9f/0//H/8//s/+f/4//h/+D/2//T/9P/0P/O/8n/w//A/8D/wP+3/7n/tP+3/7T/sf+2/7j/s/+4 /7f/uP+z/8H/vP/G/8P/yv/J/87/zv/U/9P/3v/d/+b/6P/t/+z/+f/1//r///8AAAUADAANABEA FQATABUAHAAdACIAJQAqADAALwA4ADMAOwA1AEEAPQBIAEIARgBFAEsARgBMAEYATQBFAFEAQgBO AEMATQBAAEYAOgBDADYAPAAxADQAKwAuACQAJwAbACAAFAAbAAsAEAAGAAYAAAD+//f/9f/v//H/ 5v/s/+D/4P/e/9X/1f/T/9H/0P/M/8r/yv/F/8n/wf/C/7//v/+7/8P/uv++/7r/w/+//8H/vv/B /77/xP/C/87/yv/T/83/1v/X/9//3v/o/+n/7//x//j/+v/+/wQABwAQABMAFQAcABwAJAAoAC0A MQAzADYAOAA+ADgARABAAEcAQABEAEYATgBDAEsAQgBOAEUASgBDAEsAPwBGAD4ARwA4AEUANwBA ADQAOwAxADgAKAAuACEAKAAaACEAFAAWAAsADgACAAQA+f/6//L/6//i/+H/3P/V/9H/0P/N/8P/ xf+//8P/vv+//7j/vP+0/7n/sP+6/7X/uv+2/7//u/++/7f/w//D/8T/xf/J/8j/z//L/9j/1P/f /9j/4//h/+n/5P/t/+r/9f/y//z//v8EAAAADAAMABIAFQAaABsAHAAcACcAJAAsAC0ALgAzADQA NgA3ADsAOQA7AD8AQAA9AD8APABAADsAQQA9AEAAOAA8ADkAOwAxADMANQA4AC4AMwAuADEAKwAs ACAAJgAhACIAIAAeABYAFwATABIACgAKAAYAAwD+//z/9P/x/+v/6f/n/+L/3//W/9n/2P/W/8r/ zf/F/8f/v//E/7//wf+9/8H/uf/D/7n/xv/C/8n/wv/Q/8f/0P/M/9z/1P/g/93/6f/m/+//8f/5 //f//f/+/wkACQAOAAsAFgAXAB8AHAAmACkAKgAvADAANAA1ADoAOwBBAEIARABDAEgARgBKAE0A TQBKAFAASwBQAEgATgBIAE0AQgBFAD8AQAA4ADkAMgAwACYAJwAdACIAEgATAAkACAD+//3/+f/4 /+3/7P/p/+H/2f/U/9r/0//Q/8j/yf/E/8P/wP/B/7z/u/+1/73/sP+7/7T/uf+y/7f/rf+5/7D/ t/+z/7z/tv++/7j/yP/A/87/xv/W/9T/3v/X/+b/4f/x/+r/+//1/wMABQALABIAGQAaACYAKQAr AC4ANAA3ADsAQwBAAEoARQBJAEkAUQBMAFQASwBRAEUASwBGAEQAPABEADsAPgA6ADYAMwA3ACsA LQAqAC8AHgAdABsAGwASABMADgANAAQAAwD7//3/8v/s/+v/6P/k/9z/1//Q/9D/xP/J/8H/wv+3 /77/sP+2/67/tP+s/7H/qv+x/6L/tf+n/7j/rP+9/7D/w/+4/8T/vf/N/8T/0f/M/+P/2P/s/+T/ +P/z//3//f8IAAkADQAQABoAGQAgAB0AKAAoADAAMgBAAEEAQQBFAEAASgBRAFMAVABaAFsAYgBi AG0AZQBqAGoAbwBoAHIAZABrAF4AZQBfAGMAUwBYAE8AVQBPAE0AQwBDADkANAAxAC4AJAAlACMA IQAeABsAFgASABQACgAWAA8AFgAPABIAEAASAAsADAAEAAYA/v////f/+v/x//H/7v/u/+v/7//o /+v/5f/v/+j/6f/e/+X/3f/o/+P/6P/l/+7/6f/t/+f/6//m//P/7P/5//P//P/2/wIA//8IAAgA EwAMABkAFAAaACEAIgAiACYAKgAvACwAMQAzADcAPAA4AEAAPQBCAD0APwBDAEIAQwBHAEgASQBI AEgATQBOAE4AUABOAE8ASwBOAEwATgBKAE8AQgBCAD8AQAA2ADoAMwAyACYAKwAjACUAGgAaAA8A EgAIAAQAAgD3//b/8f/y/+r/6f/g/+P/2f/c/9X/0v/M/87/xf/K/73/xP+6/8H/uf/A/7H/vf+0 /73/sf++/7P/wP+4/8T/vv/K/7//0P/F/9f/x//b/9X/5v/f//P/5//9//D/BQD8/w8ADAAeABgA JAAgADEAMgA6AD0APgBBAEwATgBWAFoAVQBYAF4AYwBhAGQAWwBdAFgAWwBTAFUAUABPAEcASQBD AEkAPAA5ADIAMwAzAC4ALQAvACYAIgAfABkAIQAbABQAEAAVABUAFQAQABIADAAOAAoABQAEAAAA +//7//n//P/1//b/7//x/+z/8v/p//b/8f/5//L/+//0/wEA+P/5//X//v/4//7/AAAIAAcADQAP AA8ADgAUABMAFAAWABUAEQAXABcAGwAXABoAGAAYABkAHAAaABYAFwAZAB4AGAAZACIAGwAiAB8A JQAiACsAJAAvAC4AMQAxADcAOAA4ADgAOAA0ADQANQA3ADwANQA0ADcAPQA3ADQAOQA5ADQANQAz ADIAMAAzAC0AMAAsADAALgAtACkAKQAoACYAKAAiACQAIQAgACIAHQAaAB0AGgAbABgADwANAA0A CQABAAEA/f/2//X/8f/s/+n/5P/g/97/3v/X/9D/0//K/8//yP/Q/8T/yv/C/8z/wf/L/8n/1f/L /9j/zf/g/9P/5f/g/+v/6//x/+//BQD9/wUAAgAPAAoAFQAPABwAIAAjACEAKAAvADIANgA9ADcA PQBCAEgATABLAE8AUwBYAFYAXQBZAGAAWgBeAFwAYQBXAFwAVwBbAFEATQBIAE0AQwA/ADoAPwAu AC4AIgAkABoAEwARAAgAAwD8//f/8f/p/+P/5f/c/9r/0P/R/8L/zP/A/8j/vP+9/7L/v/+0/73/ s/+9/7T/vv+0/8H/uv/B/7v/yP/C/8b/xf/N/8f/0v/M/9v/0//i/93/6v/n//f/7v8EAP3/DAAH ABMAFQAiACYALgAvADkANgBAAEEAQwBFAE8AVQBSAFoAVABbAFUAVwBUAFcASgBQAEoATAA/AEQA OQA8AC8AMQAsAC0AJQAkAB4AHQAYABUAFQAWAAoADwAKAAoACQAIAAUABQAAAAAA/f/2//n/+f/3 //f/8f/r//H/7f/o/+r/6//l/+b/4f/k/9z/4f/e/9//3v/h/93/7f/h/+n/3v/w/+n/9P/r//r/ 8/////v/BAABAAcABgALAAUABwADAAsADAAOAAcADQAMAAsACQALAAgACgAJAAsABQAHAAcACwAI AAUACAAMAAoABwAJAAkACQAOAAgAEQASABMAFAAWABcAGQAaABkAHAAdABoAIQAbABkAGgAaABkA HAAaABcAEgAWABUAGQAXABMAFAASABIAEwAXABkAFQAUABAAEgASABIAFgAVABEAEQASABEADwAM AAsACgALAAIAAAADAPn/+P/3/+//6//l/+H/3f/b/9j/zP/T/9L/yP/G/8P/vf/A/7f/v/+4/77/ tv/B/7r/w//E/9D/yP/T/8r/3v/c/+T/3v/s/+j/9//y/////P8EAAQAEwASABQAEgAfABoAJAAi ACsALAA8ADcAQgBBAEkARwBMAE0AWABaAFgAWwBeAGEAYABkAGIAZQBfAGUAXQBgAFwAXwBRAFQA SQBQAEEARwA1ADcAKQAqAB4AGQAPAA8ABwAAAPn/9P/s/+f/6P/i/9//1f/X/9H/0f/P/9D/w//H /8P/x/+8/8H/uP++/7n/v/+6/8P/uP/A/7f/vP+2/8D/uP/F/77/yv/C/87/yf/S/87/2//T/+D/ 3//p/+T/9P/s////+P8GAAUAEgAUABYAHwAjACQAKgAvADUANwA4ADsAOwBDAD4ARQA/AEUAPgBE AD8APgA8AD0ANgA5ADMANgAtADQAKAAtACMAKQAjACMAIQAiAB0AHAAaAB0AGQAWABUAEwANABEA EAAOAAUAAgABAAEA9//z//H/6P/o/+X/5P/f/9j/1P/Y/9H/0f/F/8z/wf/I/73/wv++/8T/uv/D /77/wP+4/8j/u//G/8H/zv/E/8//yP/W/8f/2f/S/9f/0P/Y/9T/4P/Y/9v/1v/k/93/5f/g/+r/ 4P/s/+T/8v/v//f/9/8AAP//CAAGAA4ACwAUAA8AHwAbACoAKQAvAC4ANgA6ADUAPAA6AD8APgBB AD0AQAA8AD4AOQA5ADUANAAyADEALwAvACoAKAAdACgAGwAeABIAFgATAA8ADgAMAAcAAwADAP// +//2//b/6f/o/+H/5P/c/9n/0P/T/8b/x/+//8D/tf+2/6v/rf+m/6n/m/+k/5b/n/+W/6L/lf+h /5T/qv+b/6n/nv+0/6j/vP+3/8b/vv/Q/8j/3//R/+z/3P/0/+n/AgD8/w4ABgASABMAHgAcACMA JgAtADAANAAyADwAPgBDADsARwBJAE8AUABPAFQAVQBXAFYAWgBUAFoAUwBWAE4AVQBNAFAARABI AEAARAA1ADYALQAoAB4AHgAMAAsA///6//X/8//j/9//2//U/8z/xv/C/7f/uP+t/7b/rP+u/5// sP+c/6X/lP+m/5j/pP+d/6n/n/+o/6D/rv+i/63/o/+0/6z/uP+x/7//tP/C/7r/yf/A/9D/w//Z /8//3//a/+n/5P/v/+z/+v/3/wUAAwAQAA4AFwAXAB8AIAAoACkANAAwADIANQA4ADYANgAyADcA NQAxADIANQAzACwAMwApACoAIgAlACcAJQAcAB0AGgAYABMAFQAPABAACgAHAAYABwAEAP7//v/7 //3/+P/8//j/9f/y//D/6v/q/+L/6P/g/+D/1//c/9b/1f/N/9T/zf/L/8T/xv/A/8T/uf/E/7// wf+3/8H/vf/G/7v/y/+//83/wv/U/8v/3P/T/97/1//k/93/7f/n/+r/5//x/+v/9P/v/+//7f/5 //f////8/wUA/P8BAP3/BQABAA4ACQAMAAgAFAARAB0AFwAlAB8AJwAkACwALQAsAC8ANgA5ADYA OgA4AD8AOAA6ADcAOQA4ADMANgA0ADEAMQAwACsAJwAoACEAIAAdABwAGgAUABEAEQAQAAoABwAC AP///v/5//f/9f/t/+r/6//k/9//4v/V/9b/0P/P/8b/yf/A/7//u/+2/7H/s/+p/67/ov+p/5v/ pv+W/6j/m/+s/5n/q/+a/7L/p/+1/6r/v/+x/8f/v//Q/8n/1f/V/+z/4v/y/+z//v/3/wkABgAM AAoAFwAUAB4AHAAiACMAKgAuACwALwA2ADgANAA7ADwAPQA+AD0AQgBGAEMARQBHAEgARwBHAEIA SQBDAEIAPgBBADkAOAAuADAAHgAkABwAGQANAAkAAAACAPb/8P/q/+D/3v/R/8//zP/D/7z/vP+y /7f/q/+t/6P/q/+f/6z/ov+o/6D/qv+Z/6z/mf+v/6L/sv+o/7T/q/+0/6r/vv+t/77/tP/H/7v/ yP/C/9H/xv/V/8//3P/a/+T/4v/q/+j/8v/y//z/9/8DAAUAEAAOABcAGAAgABwAIwAjACoAKwAu AC4ALwAuADIALQAxADEALAAuACgALAAlACYAHwAhAB8AIAAYABQAFAAQABEAEgAOAAwACAAHAAcA BwAIAPz/CAAAAAMA/v/+//z//v/6//j/+P/1//T/8v/t/+n/6v/r/+P/3v/b/+H/1v/Z/9H/1//Q /9H/yP/O/8T/zf/F/8z/xv/L/7//zf/D/9D/xP/R/8n/0v/I/9X/z//W/9P/2P/O/93/1f/e/9f/ 3v/U/+L/2f/g/9n/4v/b/+j/3v/k/+H/6P/i/+//4f/3/+z/+f/z//3/+/8HAAYADQAKABQAFAAZ ABkAHgAiACMAJgApACoAKQApAC8AMwAtADMAMgA2ADIAMQAwADAAKQAsACgALAAkACEAHwAdAB8A FwAXABgADwARAA8ADgAIAAMA///6//f/9f/y/+7/7f/r/+n/4P/f/9n/1//R/9D/xf/I/7//vP+2 /7f/sv+u/6T/q/+j/6r/nv+m/6D/pP+d/6//nv+t/6H/sv+q/7r/sf/F/7v/y//F/9j/zf/h/9v/ 8P/o//X/8P/9//z/BwAEABAADwAWABMAGgAYACIAIwAmACQAJwArADEAMgAxADIANQA3ADkAOAAz ADgAOAA5ADsAPAA0ADIAMgAvADAALQApACgAHAAdAB4AGAARAA4ABgADAAAA9//z/+//4//i/93/ 2P/Z/8z/zf/C/8f/vf/K/7z/wf+x/8P/vv+7/7T/xv+9/8n/uv/I/73/zP/H/8//zf/V/8//2P/W /97/2v/h/9z/4v/g/+r/5v/p/+b/8v/0//X/9v/+//f/AgACAAsACQALAA8AFwAbABwAHgAiACMA IgAlACoALQAwADIAMQA4AC4AMgAxADgALgAxAC4AMAAlACsAJAApACEAJAAgAB8AGgAZABMAEgAO ABEAFwAXABoAGAAXABUADAALAAoACgALAAUACgAHAAYABQAIAAEA/v/8//z/+P/3//D/9P/x/+z/ 5P/m/+T/4f/e/+L/1//V/87/0v/O/9D/yP/N/8j/yv/I/8r/xP/K/8L/0//O/9L/xf/W/83/0v/O /9j/0P/X/8//2f/a/93/2v/i/9z/5P/d/+r/4//p/+b/8P/s//T/7f/+//T/AwD5/w0ACQAQAA4A GQAVACAAHgAsACoALAAuADAANAA5ADwAPQBBADsAPgBBAEQAPgBCAEAAQQA9AD4ANAA5ADAANAAt AC8AHwAgAB4AHgAYABMAFAAIAAMAAQD///z/9//z//b/7v/o/+P/2//c/9r/1f/V/8z/0v/K/8n/ wf/D/7f/u/+z/7j/q/+w/6L/qf+j/6r/o/+q/53/q/+k/7H/oP+y/6n/uP+s/8H/t//J/8H/0v/N /93/2P/n/+L/8//v/wEA/v8JAAoAEwAVABsAHwAmACQALAAoACwALgAxADYANgA9ADwAPgA+AEQA PgBEAD0ARAA+AD4ARABJAEIASABBAEcAPgA/ADwAPAA3ADoAMwA0ACoALgAlACcAFgAfABMAFAAD AAgA+f/6/+7/7v/l/+T/3v/b/9T/z//L/8z/x//E/8P/vv/B/8H/vv+7/73/vP/B/7f/vP+9/8P/ u//K/7z/xP+9/8f/wf/L/8j/yf/E/9D/y//U/9D/2f/U/+H/3f/l/+P/7f/m//H/9P/8//7/BAAH AA8ADAAWABwAHwAjACUAKAAuAC8ANQA6ADcAPQA3AEIAOgA/ADoAQAA8AEYAOgBBADUAOgA0ADkA LgA2ACgAKgAmACoAHgAfABwAHgAXABoAEgASABEADQAQAAwACgAMAAUACwACAAIA/v////n/9v/z //T/7//r/+b/4//j/+P/3//X/9v/0v/P/8//z//I/8n/xf/N/8X/yv/E/8n/xP/O/8H/1P/J/9f/ y//U/9X/2f/X/93/2//h/+D/6f/j/+v/7P/u/+3/9f/0//v/+P/7//v///8DAP//AgAGAAoADwAN ABEAFQAXABkAGgAdACIAJgArAC8AMQAyADUAOAA4AD0APABEAEAARgBFAEYAQQBJAD8ARAA8AEQA PwBDADkAPAAyADcAMgA0AC4AKgAlACkAIAAbABIAFQARABAADAAOAAUABAD+//3/+//4//P/7//x //D/6//r/+n/6//d/9r/1v/T/9P/yv/N/8X/xP+7/8H/wP+7/7f/wf++/7//uv/F/7v/xP/C/9D/ yv/W/9j/5v/e/+v/8v/7//j/BQAFAAoADwAaABsAHgAhACkALQAxADgAPAA6ADkAQABAAEUASABK AEcASwBJAFIASgBPAEkATwBHAFIARwBSAEYATQBDAEoAQQBLAEMAQwA4ADsANgA7AC4ALgAnACgA GgAbAAsAEQAEAAQA+v/3/+v/6f/k/+H/2//U/9H/y//H/8T/xf+//77/tv++/7T/vv+1/73/uf+8 /7j/vv+7/8L/uf/J/8P/yv/K/9H/zf/U/8//3P/Z/97/3//p/+X/6//n//P/7v/4//j/AQAAAAIA BAAPABMAHAAdACYAIwAoAC0AMAAyADUAOQA7AEEAOwBIAEEASwBDAEsAQgBRAEIASABDAEoAQABA ADgAQQAwADwALwA2ACMAKgAdACIAGAAaABcAFQAPABAACgAOAAMABAABAAMA/f/7//3/+P/1//f/ 8v/v/+v/6//p/+j/4v/j/+L/4v/e/9v/3v/X/9r/1P/W/9T/1v/T/9T/0//T/9X/2f/X/9n/2P/i /9r/5P/i/+v/6v/x/+3/9//w//f/9v/+/wAAAgAGAAoABgAFAAkABwAOAA0ADQAOABMADQAUABEA EAAPABMAFAAaABcAFgAaABsAFgAcABoAIgAcACEAIAAmACIAJwAjACwAJAAtACkAMgAuADMAMAA2 ACkAMgArACkAJwApACUAJwAbACAAGwAgABMAFAAVABQACwAPAAoADgAIAAoAAQAHAAAA//8BAAEA +v////z//v/3//r/9//4/+//8P/m/+j/5P/g/9z/3P/b/9b/1f/Q/8v/yf/N/8X/xP/B/8X/v//K /8H/x//D/8j/wv/R/87/0f/T/93/3v/k/+L/8v/t//f/+P8DAAYACQALAA8AGwAaAB4AIwAmACgA KwAuADgAMQA9ADcAQQA9AEYAQQBFAEEARwBBAEwAQwBOAEkAUgBIAE8ASABVAEUATABCAEwAPABF ADIAPQArADIAJwAoABoAHQALABEA/v8KAPv/+v/o/+n/4P/c/9n/0//P/8n/x//H/8f/w//G/7// xv++/8L/u//D/8H/xf/A/8v/yP/M/8z/0//S/9n/1P/g/9z/4//l/+f/4//t/+7/8v/0//f/+v/9 //7/AQAGAAoADwASABUAGgAhACIAIwAnACwALAAxAC0ANQAwAD4AOABAADkAQwA2AD4ANwBAADQA PAAxADcALAA0ACcAKwAlACUAHgAkABYAGQAWABgAEQAQAAgADAANAA8ADAAIAA0ABwAOAAoACwAN AAkADQAKAAwACAAKAAcACwAHAAoACgAQAAYADAAEAAoABgAIAAIABQABAAgAAQADAP3/AAD//wIA //8CAAMAAgAFAAQAAQAJAAQABQAGAAoABgAKAAcADwAHAAoABwAKAAYABwAIAAgAAgAEAP//AwD+ /wAAAQD9//n//v/5/wIAAQABAAAAAAAEAAcAAwAIAAoACgASABIAEQAVABQAGwAdACMAIAAoACgA LQAlADAAKgAzACsAMQAsADEALgAyADAAMQAsAC0AKwAtACcAJwAgACoAJQAqACEAIwAeAB8AGQAf ABYAGQAPABYADwAOAAkADQAEAAcAAAABAPr//P/y//X/6v/s/+L/5f/a/9f/2f/V/9T/1P/P/8// y//K/8j/xv/H/8L/yv/H/8b/x//N/8z/1v/T/9v/3f/f/+T/6//s/+//9//8//7/AAAFAAkADQAT ABQAGAAfACMAJgAlADEALgAzADQANgAxADcAOQA+ADsAPwA/AEgAQwBHAEYASwBDAE0ASQBMAEEA TgA/AEwAPwBIADYARAAwADsAMQA3ACUAMAAcACYAEQAXAAQADQD6//7/8v/2/+b/5//h/+L/3P/X /9X/1v/O/9L/0P/O/9H/0v/O/8//z//R/9T/1f/R/9j/2P/c/9X/2f/a/93/4P/g/+L/4f/f/+P/ 6f/o/+r/7P/x//P/9P/2//3/AAADAAYADgATABQAFgAbACEAKAAqAC8AMgAwADoANgBBADgARQA6 AEUAPQBNAD8ATAA7AEYAOQBGAC4APgAwADkAKwAxACcAMQAdACQAGgAoABcAIQAQAB8ADwAVAA4A HAAOABkADwAYABEAEwAQABMADgAVAAsAFQAIAA0ACgAJAAcACwADAAUA+v8BAPr/AQD1//n/9P/1 /+7/9v/v//P/7v/z//D/9f/r/+z/9P/x//L/8v/x//D/7f/w//P/9//0//T/8//5//T/+P/2//f/ 7v/0//X/9f/w//H/8v/z//X/9//4//z/+P/7//3//f8CAAkACQAPAA8AEwAVAB4AFgAeACMAJwAm ACoALgA3ADQAPQA3AEEAOQBDAD0ARAA7AEIAOgBEADgAPgA3ADsAMQA8ADAANQArADIAKAAxACUA KQAiACkAHQAjABsAIwAaABwAGQAeABEAFgANABMABgAPAAUACQD6//v/9f/8/+3/7P/h/+b/1//a /9H/0v/M/8j/yv/C/8L/vv/E/73/wP+8/7//vf/D/8H/zv/E/9D/0P/b/9f/4//h/+v/7v/1//T/ /f8AAAUACQAOAA8AGwAhACIAKwAkACsALQA0ADEAOgA1ADwAQABHAEcASwBHAEwATQBZAFUAXgBX AF8AVQBqAFoAaQBXAGgAWQBqAFAAYgBTAGEASgBWAEMAUQA6AEkAMgBCACMAMQAdACMADwAbAAkA DgD//wQA/v8AAPH/+P/u//T/7f/y/+3/8P/s/+7/6v/s/+f/6//m/+r/5P/p/+T/6v/j/+b/3v/p /+P/6P/i/+j/3P/h/+H/4//g/+T/5P/o/+n/7f/s//D/6//1//f/+v/7////BQAMAA0AFwAUABsA HwAiACYALAAmADQAMAAyAC4AOQAvADUAKgA0ACwANgArADEAJgAyACMALQAgACsAJQApACEAKAAe ACkAHwArACMAKQAmAC0AJgAxACYAMgApACwAKQAyACMALwAkACsAHgApABwAIwAUAB0AEAAVAAUA CgAAAAIA/f////f/+v/w/+//7f/t//H/7//v/+z/6P/r/+7/6f/p/+z/6//o/+j/6P/n/+j/6P/s /+v/6f/l/+n/5f/m/+j/5f/h/+P/3//l/+D/4P/g/+X/4v/o/+j/6f/u//P/+P/1/wAAAgAJAA0A EAAXAB4AHgAnACwAKAAyADIAPAA8AEMAQABHAEEASgBDAEgAPgBKAD8ASAA8AEYAPAA8ADkAPwAz ADoAMAA1AC8ANAAqADAAJAArACEAJwAcACUAHgAnABwAJAAYAB0ADQAWAAUADAAFAAcA+/8DAPP/ 8v/t/+7/5P/j/97/3//Z/9b/1v/T/8//zP/O/8v/xf/E/8n/xP/P/8z/2P/U/9z/1f/i/+H/7P/s //P/9f/1//v/AgAJAA8AFgAWABcAGAAhAB0AJAAhACkAIwAwACkALwAvADMALwA2ADEAPAA1AEQA PgBHAEYATABCAFIASgBUAFIAXQBPAFwAUQBbAEsAVgBLAFgASABUAEAATQA8AEMAMwA8ACsANwAl AC4AIQAlABgAHQATABoADgARAAoADAAFAAoAAAAEAAAAAwDx//f/9P/6//T/+f/w//b/8//1//L/ 9//s//D/7f/r/+j/6P/k/+j/3v/h/97/4P/Z/97/3f/g/9n/3f/i/+T/5f/k/+n/7v/z//b//P// /wMABgALABEAFAAaAB8AIQAiAC0AKAAtACkANAAuADcAKgA2ADMAPAAvADwALQA5ACwANwArADgA LgA0ADEAOQAwADcAMQA7ADoAOAA4AEAAOABCADgAPwA4ADsANwBAADUAOwAzAD8AKwAzACgAKgAY ACMAFAAYAAYACgD7/wAA9P/x/+v/6v/l/+P/2f/a/9f/1f/U/83/zf/J/9H/zf/L/8n/y//I/87/ zf/Q/9H/1P/W/97/3v/c/97/3P/f/+H/4f/k/+L/4P/n/+r/7v/y/+r/9P/4/wEABgAMAAwAFgAV ACIAJwA1ADgAOQBBAEEASQBTAF0AWABkAGMAbABnAHIAaQB5AG0AeQBtAHsAZwB1AGQAcABfAGgA WQBmAFEAVwBNAFYAQQBIADwAQAAwAD8ALgAwACUAKQAkACsAHwAcABkAGwASABcACgAKAAQAAgD5 //n/8P/x/+r/6v/b/93/2v/W/8r/z//I/8j/wf+9/73/vf+8/7b/vf+5/73/v//F/8T/z//J/9f/ 1P/f/+H/7v/s//H/8//8//7/AwAFAA4AFAAVAB8AGQAgABwAJQAbACsAIQAsACYAMQAlADQAKgA2 ADEAOAAxADwAMwBAAD0ARgBBAEcAQQBKAD4ASwBHAFUASQBSAEUAUQBHAE4AQQBQADwARgAyADwA LgAyACkAMQAeACkAFwAcAA8AGAAJABIA/v8EAAMAAwD8//3/9/////X/+P/4//n/9P/3//f/9f/z //T/9v/3//P/8//y//D/6P/s/+b/5v/e/+H/4P/b/9n/2f/W/9j/0//R/9P/1f/W/9H/2v/V/+H/ 2//m/+L/7P/m//T/8P/3//v/AgAEAA8ADAAVABMAGgAcACQAJQAlACwAKQAtACMALwAqADAAJgAu ACYALAArADIAKQAyAC4AMQAvADUAKgA4ADIAOAA2ADkAPQA8ADsAQAA8AEYAOgBAADgAQwA1AD4A MgA6ACkAMwAlACcAHAAfAA0AEgABAAkA/f/+//H/8v/p/+b/4v/l/9r/2//U/9X/0P/S/9b/0P/V /9P/zf/K/9P/0//W/9j/1f/T/9f/0//V/9n/1v/Y/9b/2//Y/9n/2f/b/97/4f/h/+b/5v/m/+3/ 8f/z//b/+/8BAAUACAATABQAGgAiACcALgAyADwAPABBAEYATwBLAFYAUQBaAFEAWABRAFgATwBW AEYAUQBKAFAAPgBJADcAQQA2ADgAKQAyACQAJgAfACEAGQAdABUAFAAUABQAEwAQAAkADAAEAAkA /f8BAPb/+f/y//j/7//t/+X/6P/i/+H/2f/a/8//0P/L/8v/wv/B/73/vP+9/7z/wP+8/8P/uf/D /8H/zP/L/9j/1f/a/9n/5v/j/+7/7f/4//r/AQADAAsACQANABQAFQAZABUAHgAcAB8AHgAkABwA JgAfACIAHwAoACIAKQAqACoALQArADEANAAyADwAMgA8ADwAPgA8AEEAPQBDAEAAQwA/AEAAOQBA ADUAPQAvADYALgAyACQAKgAaAB0AFQAXAAsADgABAAQA/P/9//X/8//1//H/8f/v//P/7f/w/+v/ 7//o//L/8f/x//T/+v/2//P/9P/2//b/8v/x//P/8f/q/+r/5//p/+T/4P/m/+T/4v/i/+H/4P/d /9r/4P/g/+P/4//p/+r/7v/s//f//f8CAAEABwANABEAGQAeACIAJAAoACYAMgAuADgAMAA5ADAA NAAzAD0AMQA6ADIAOQA1ADcANwA8ADIANwA2ADsAMwA9ADUAPgA1AEAANwBAADcAPgA4AEYAPABG ADoAQwA7AEIANQA7ACYAMgAkACoAFQAcAAoAEQD+/wQA9f/5/+n/6f/k/9z/1P/W/9P/zv/J/8j/ xv/G/8P/vv/E/8P/xP/A/8b/wv/D/8X/yv/N/83/zf/T/9L/1v/Q/9T/0f/V/9H/0//W/9P/1P/Z /9n/3v/d/+P/4v/o/+T/8v/u//f/+f8GAAwADgATAB4AHwArADMANgBCAD4ASwBFAE8ASQBWAFEA YABOAF0ATgBiAEoAVABHAFMARwBMADkARQAvAEEALwA3AB0AKQAaACMAFgAZABAAFgAPABQAEAAR AAUACgAGAAkAAwAHAP3//v/2//r/9f/z/+j/5v/l/+T/1f/Z/9P/0v/H/8b/vv/A/7f/tv+z/7P/ r/+w/7H/q/+0/7L/vf+5/7v/wP/J/8X/0f/J/93/2v/n/+X/9v/u//z/+P8BAAQABgAMAAwAEQAR ABQAGAAdABoAHAAXACQAGwAfACIAJgAiACcAKAArACoALwAyADgANwA8AD0APwBAAEQARABNAEEA TQBHAE0AQwBLAD4ASwA2AEEAMQA5ACMAKgAaACIACgAVAAMADgD4/wIA8P/y/+r/6f/j/+L/3v/d /93/2v/X/9L/3P/f/93/2//Z/9b/3P/a/+D/3//e/97/3f/h/9j/3//d/9r/2f/W/9f/1//T/9D/ 0f/T/9H/zf/W/9f/2v/Z/+D/3v/h/+H/6f/s//L/9v/4/wMABwAPABAAGQAXABwAHwAtACQALQAq AC4AJwAzACYALwAjACsAJAArACAAIwAbACEAGAAZABcAHAAOABYADAAWABAAEgARABwAFAAXABcA GgAWABkAHAAhABoAIQAfACAAGAAdABgAHwATABsAEQATAAkACQACAAIA+P/1/+//7//s/+f/6P/g /9v/2P/h/9v/2//W/9r/0//X/9f/2P/a/9j/3P/b/9//3P/f/9v/2v/Z/9f/1//Y/9b/0v/O/9L/ y//M/8n/xP/K/8n/x//G/8X/x//K/8f/0P/O/9T/1v/f/9//7v/z//T/+P8FAAYAEgAVACIAJwAu ADcANwBAAD0ASgBHAE4ASgBXAE4AWgBUAGEAUQBcAEwAWABIAFcARQBSAEEATwA/AEUAOgBBADgA PgA5AD8ALAA8ADMANwApACoAIgApAB4AIQASAA8ACgAKAP//BADv/+//4//j/9X/0v/I/8j/vv+2 /6v/n/+i/5n/mv+O/5T/i/+S/4b/k/+K/5z/lf+i/5j/r/+l/7r/sv/D/8P/0//U/+L/4P/x/+// AgACAAkADgATABMAHwAjACgALAAtADQAMwA+AD4ARwBHAFMAUQBXAFYAYABYAGcAYgBsAGgAcwBq AHkAbgB7AGsAeQBuAHoAZgBxAFsAYwBRAFkAQABQADQAPgAiACkAEgAUAAAAAwDu//D/3//e/9P/ 0f/O/8T/wP+7/7n/s/+u/6z/sv+t/6z/qv+x/67/tP+u/7b/sv+6/7j/uf+1/73/uP+8/7n/uv+2 /77/uP++/7r/xP+5/8X/vv/K/8f/1f/O/9b/1v/f/93/7f/s//b/+/8HAA0AEwASABoAHAAkACoA MgA0ADYAPgA7AEEAOgBCADoAQAA/AEEANQA7ADQANwAuADQAKQAsACIAKAAhACEAGwAjABsAIAAc ACAAHQAhABsAIwAcACQAIAAoAB0AIwAdACUAGgAeABYAGAAOABAADAAKAP7/AgD3//f/8P/v/+X/ 5//a/9r/1P/Q/9D/x//K/8b/yP/C/8T/vv/D/8H/w//A/8L/wP/D/8P/xP/E/8n/yf/E/8L/yv/F /8X/wv/D/8X/yf/H/8n/xP/G/8D/xv/I/83/x//O/9H/1//a/+L/5//s/+v//P/4/wUACwAVABwA IgAqADUAOQA9AEUASABSAE8AVwBYAF4AWwBiAF0AZgBWAGYAWQBoAFUAXgBOAFkARgBPAEIAQwAy ADQAMAAyACcAKwAjACYAGgAgABoAGAALAA8ABgAHAP3/+f/y//X/6P/m/+L/3//W/9H/yv/G/7n/ tP+u/6b/o/+f/57/l/+P/4b/kf+D/43/gv+T/4X/lf+H/5n/lf+k/5v/sf+t/7z/u//O/83/3f/W /+//6v/6//3/BQAFABAAEQAYABsAHwAiACYALwArAC4ALgA0ADgAPQA+AEIAQwBIAEwATgBPAFEA UwBaAFMAWQBWAGEAVwBiAFsAZABUAF4AUABZAEcATgBCAEYALwA0ACcAKwAVABgABQAJAPv/+v/t /+3/4P/b/9b/0f/P/8T/x/+8/8D/uf+9/7X/u/+0/8L/uv++/7f/wf/A/8D/wP/E/7//yf/E/87/ xP/K/8H/zf/F/8f/w//L/8H/yf/D/87/yf/M/8H/0f/K/9P/zf/f/9v/4f/g//D/6//5//P/AwD/ /wgADgAVABcAHAAhAB4AJQAlACYAJwAuACgALAAlAC4AIQAqACQAJwAkACUAIwAlABwAHgAgACIA HgAeACkALQAqACoAKwAqADIANQA1ADUALwAvADoAPwA3ADUAOwA+ADYAOwAzADsAKwAsACEAJwAZ AB4AEQAUAAYACAD7//3/+v/8//L/8f/r/+r/6//o/+P/3v/i/9X/3v/W/93/2v/d/9j/4P/b/9z/ 2v/Z/9X/z//J/9j/0P/V/9P/2P/R/93/3f/g/9v/4//Z/+X/4P/r/+D/9v/t/wEA9/8HAAUAFwAX ACYAKQA0ADUAQwBEAEwAUABWAFoAYgBkAGsAcQBuAHYAewCBAH4AiwCCAIoAewCGAH0AfgB2AHUA ZwBuAFYAXABSAFUASQBLAEUASgA6ADgAOAA6ADMAMAAkACMAGwAdABUAFgAQABAADQAGAP7/+//q /+n/3P/c/9T/zf/H/8H/u/+2/7T/rP+n/6H/pP+b/6n/mv+t/53/r/+g/7b/qv+//7H/w/+//9P/ 0P/j/9z/8//r//7/+f8IAAUAEwASACMAHAAgACQALQArADYANwA0ADoAPwBAAEQASgBHAEUARABK AE4AUQBQAE4ATgBTAFEAUQBYAFgAUwBYAE8AWgBLAFQAQwBJADwAQwAzADgAKgApAB8AGwANAAoA /f/6//D/7P/l/9v/2P/Q/8//wP/F/7//vv+z/7r/sP+5/7H/uf+t/73/sv/E/7b/xf+//8v/wv/L /8X/zP/K/9H/yv/X/87/1//Q/9v/0//a/9T/2v/W/97/2v/g/9f/5f/d/+r/4f/x/+r/+v/5/wAA /f8LAAUAFAAOABgAGgAeAB4AKQAoACkAKgAtADIAMAAvACsALQAoACwAJAAmACIAJAAcABwAFgAV ABQAEAAQABEADwALABAADAAQAAwAEwAPABUAEQAWABQAFgAYABwAHAAfABoAIgAcABwAHgAaABcA GwAWABIAEwARAA0ADAAJAAcAAQABAPv/+f/v//L/6v/q/+T/5v/h/+T/3//j/+H/4f/a/+H/3f/h /9v/4P/Z/97/0f/f/9b/2P/T/9z/0v/U/9X/2f/X/9f/0v/Z/9T/3v/Z/9r/2f/a/9n/3v/c/+j/ 5f/x/+7//f/+/wwADAAZABgAKgAqADMAOQA+AEkASwBTAFoAYABgAGIAZgBwAGUAbgBjAGsAXwBn AFkAZgBQAFoATwBVAEQASAA4AEEANwAyACwAKwAkACUAGAAYABQAEAAKAAoA//////n/9f/w/+n/ 6P/g/+D/1P/U/8j/xv+8/7r/sP+p/57/o/+Z/5z/lv+b/47/mP+M/5n/jP+d/5L/o/+c/6X/nf+z /6j/vP+w/8//zf/Z/9n/8P/r/////f8MAAsAFAAUACIAIwAuADEAMQA0ADgAPwBCAEkASABPAFAA UwBVAFcAXQBbAF8AYwBeAGQAWgBdAGEAZwBgAGIAXgBjAF4AYgBVAFkASwBUAEkATQA+AD4AOAA7 ACoAKgAdAB8AEAASAAYABgD9//n/8P/r/+n/4f/i/9v/2v/V/9r/0v/Y/9L/3f/T/+P/2v/q/+P/ 6P/o//X/8//7//L/8v/z//L/8//5//b/+P/3//f/9//3//P/9//3//b/8f/2//L/8//w//b/8//6 //r////4/wUAAAAJAAkADwAQABgAFwAbABsAIgAkACYAIQAlACcAIwApACMAJAAlACYAIwAmABsA IgAdACMAGQAcABoAHAAUABYAGgAZABYAFQAXABwAHQAVACAAIAAiACQAKQAlACoAKQAtACwAKgAm ACcAKQAhACcAIQAeABsAHAARAA4ABQAJAAIAAgD6//H/8f/s/+f/3//h/9b/2f/O/9b/0v/P/8r/ 1f/O/9D/xv/W/87/y//E/8n/xf/M/8f/y//G/8j/wv/J/8f/yf/E/8r/xv/M/8b/zv/L/8v/z//V /9b/3f/X/+r/5//y/+3//v/5/w0ADAAWAB0AJAAmADMAOABEAEQATABOAFEAWQBcAGMAXwBjAGEA ZgBhAGkAXwBlAFQAVwBQAFQAQwBIAD4AQgAzADcAKgAtACMAJQAXABoADgAMAAUAAQD8//r/8f/0 /+f/5//d/9v/1v/U/9D/yP/C/73/uf+0/6j/pf+g/5//nf+S/5n/kP+U/4n/kP+K/5H/i/+a/4// nf+Z/6v/ov+0/6T/v/+4/9X/yP/h/97/7//v/wEAAwAMAA8AHwAiACkAKQAwADQAOAA8AEEARgBI AE4ASQBVAFAAVQBSAFcAVABZAFYAVwBQAFoAUQBVAFIAUwBSAFYATABSAEcATAA+AEgAOQBBADEA OAAjACoAFwAaAAgADwD7////7//u/+L/4//W/9b/zf/D/8X/u/+//7b/uv+x/7f/rf+5/7L/vf+1 /7//uv/K/8P/0P/I/9f/z//e/9j/4P/d/+X/4P/r/+n/7v/r//L/7v/4/+//8//z//b/8v/7//j/ /P/+//7/+P8DAAEABAAEAAUABAALAA0ADAAOABQAFQAYABYAHQAdABkAIgAaACEAFwAdABkAHgAc ABsAEQAWABEAEQAQAA0ADgALAAMABgAEAAMAAQD//wEAAQACAAUABwAIAAkADAAPAA8AFAASABcA GAAaABoAHQAbAB0AHQAXABwAGgAZABMAEgAPABIABwAHAPv//v/6//b/7P/t/+b/6P/l/9z/2//U /9b/0P/P/8v/zP/J/8X/xv/E/8P/wf+7/8P/u//C/7j/w/+2/8H/u//C/7j/wf+3/8L/u//F/77/ w/+7/8z/yP/R/8v/1f/Q/+b/4//x/+///f/8/wcADAAdAB0AJgAkADsARABHAFEAVQBdAFwAYQBq AHEAcAB4AHQAfQBuAHsAbAB2AGcAcgBiAGsAWQBhAFQAWwBCAEoAOQA/AC4ANQAlACcAGwAbAA8A CgAAAAQA+f/7/+z/7f/k/+T/2f/V/83/zv/E/8D/tf+w/6v/qv+k/5//nf+R/5T/jv+O/4f/kP+G /4r/hf+T/43/mf+N/57/mP+o/5//tf+v/8H/wf/V/9P/4P/e/+7/8v/+/wQADQARABQAHAAmACgA KQAuADEANwA6AEEAOwBGADsASgA/AEoAQQBGAEMARABCAEsAQQBKAD4ASAA/AEQAPQBBADoAPQAu ADgALgAyACQAKgAdACEAFAAVAAgACgD5/wAA9P/2/+X/5f/f/93/0//P/8v/x//I/8T/w/+//8T/ vP/E/77/w/+9/8z/wf/M/8X/y//K/9T/z//Z/9L/2//Y/+H/2//e/+H/5v/l/+b/4f/h/+T/5//h /+n/4f/r/+L/6P/n/+T/4P/l/+L/5//i/+v/5v/r/+7/9P/0//D/8f/3//j//P/9/wIA/////wAA BAAHAAIAAQACAAQABQABAAMABAD7/wEAAAABAP///f8AAAIABAADAAgAAgAJAAEADAAJAA8ADAAU ABYAGQAdABsAHwAhACEAHwAlAB4AJQAlACcAIAAdABsAHAAVABcACwAIAAEAAgD+//r/8//x/+3/ 5//h/9r/1//a/9H/zv/M/8j/xv/A/8H/v/+8/6//uv+w/7H/rv+w/6v/q/+m/63/qv+s/6b/qv+n /6b/oP+q/6T/qv+m/7T/rf+7/7T/wv+9/8r/xf/U/9b/4//j//H/8/8CAAAAEgARAB4AIgAyADUA PQBFAFEAWQBYAF4AYABwAGMAcABoAG4AZABuAGMAcABeAGoAVABeAEsAUwBCAEwAOAA9AC8ANQAh ACEAFgAXAAcACQD+//z/7//x/+f/5f/Y/9P/zv/L/7//vP+u/67/qP+l/5//nf+X/47/jf+H/4X/ g/+D/37/gv9+/4T/ef+H/3f/jv+D/4//iv+b/5r/pv+e/7j/sf/G/8D/2f/S/+P/4P/y//D/AAD/ /xEADwAYABoAIgAoACoAMwAwADkANwA8ADsARQA9AEUAOwBEADwASAA/AEYAPABCADsAPwA5AD0A NgA8ACsAMgAqAC4AIgAnABoAHAAQABIACAALAP3//v/y//D/5v/n/93/3P/V/87/yv/F/8b/vv/C /7b/u/+1/73/sv++/7T/wf+0/8P/vf/N/8P/1P/L/9X/0f/d/9f/6P/i/+z/5P/0/+//8//2//f/ +P/9//r//v/+//r/+f/+/wIA+//4//7/AAD6//v/AAD5/wEA/f8BAPj/AAABAP3//f/6/wAAAQAC APz/AAD+//7//v8AAP3////6//7/+P/9//v//P/2//z//P/2//z/+v/4//v/+v/5//7//v8AAAQA DAANABEAEgAXABgAGwAfACIAJAAqACgAKQAyACoAMQAuADgAMAA4ACsANAAnADEAJAAlABkAHAAT ABYADQARAAcABQD9//3/8P/x/+f/6v/h/9z/1f/T/9H/yv/G/77/vv+8/7v/tf+0/6r/sv+v/63/ qf+l/6L/pv+l/6P/nv+k/5//p/+j/63/pP+s/6T/tf+v/8D/u//K/8P/1v/X/+T/4//1//X/CAAH ABMAFwAiACkANQA9AEUATABRAFcAWgBiAGEAaABhAG4AZABuAGMAagBbAGQAWQBgAEwAVQBHAE4A OgBCACkALgAcACQAEAAUAAIABgD1//H/5P/o/9r/2f/L/8b/v/+9/7P/qv+j/5r/mf+R/5H/hf+G /33/gf92/3j/cP91/2z/d/9u/3v/cP99/3T/h/9//5L/h/+g/5b/p/+i/77/tf/H/8j/3f/a/+// 7P8EAAIADQATABsAIwAmACsAOQBBAEEASABJAFEATABVAFAAVABOAFcATQBYAEkAVABJAFAARABL AEEASQA4ADoANAA3ACkAMAAlACMAGwAcAA0AEQACAAQA9v/3/+v/5//c/9r/0P/S/8j/w/+9/7r/ uP+t/7D/q/+n/6L/qP+j/6n/o/+t/6T/sv+n/7z/rP/C/7j/yf/B/83/yv/X/9P/4//e/+r/6P/v /+//8//z//r/+v/4//j/AgD//wAA//8CAAIAAQADAAAABQD+/wEAAQD//wMAAQAGAAQABAADAAUA /////wQABQAEAP3/AAD+/wQA+v///wAABAADAAYABQAHAP7////9//z/+P/4//7//P/+//z//v8A AAMA//8KAAkABgAMABEADQASABAAGAAXABoAGAAdACEAHgAeACQAJAAhACEAHwAnAB8AIQAaAB4A EgAWAAsADwAEAAMA/f/5//P/7P/r/+j/4//g/93/1v/Q/8r/yf/J/7//vP+9/7T/t/+x/7j/r/+x /6z/sv+r/6v/qP+q/6j/p/+m/7D/q/+0/6f/uv+y/73/tP/A/8H/yv/G/9b/0//g/9v/6//o//f/ 9v8DAAcAEgAUACQAIwAxAC8APQBCAEQATABKAFgAVQBbAFsAZQBaAGcAXwBkAFoAYgBXAF0AUgBZ AEgATgA/AEUANAA6ACkAKQAeACQADAAMAAUABQDz//L/6P/o/9z/2//Y/9H/yv/C/7//vf+6/7T/ tf+w/6j/of+o/57/pv+Z/53/mf+d/5L/ov+X/6H/lv+r/5//r/+r/7z/tP/I/8D/0P/M/9v/2f/q /+j/+P/1/wwABwAXABUAIgAkAC8ALgA6AD0AQABHAEsATgBLAFEAUABWAE0AWgBMAFUASgBQAEkA TwBDAEYAQQBJAEAAQAA0ADYAMQAxACgALAAeAB4AFQAVAA0ACgABAAQA+P/6/+//6//m/+H/3//b /9P/z//L/8b/x//A/7//vP+4/7H/uf+z/7b/uf+8/7T/wf+6/8j/wP/L/8n/2//U/93/2//n/+H/ 7v/t//b/9v/6//r/AgAEAAwACgAIAAoACQAMAA8ADQANAAkACQAOAAsADwAKAAgABgAJAAgACgAD AAgAAwACAAMABAD//wMA//8AAPv/+//8//7//v8AAPn/+//2//z/9//3//b/9//x//f/9f/4//f/ 8//5//X/+f/4/wAAAQAGAAIADAAJABAAEgAPABcAGAAbACIAJAAfACMAJAAnACgALAArAC8AJwAv ACoALgAjACkAJAAjABsAHAAUABYAEQAMAAUABQD7//n/7//u/+j/6f/b/9r/0f/P/8//yv/G/8H/ v/+5/77/sf++/7L/t/+t/7H/rP+0/6v/s/+p/7f/rv+z/67/uv+1/7z/u//G/8P/zP/I/9n/2P/h /+D/7//x//7/AAAKAA4AGwAaACgALAA3AEIARwBNAFMAWQBaAGMAYQBsAGkAcgBwAHYAbQBzAG0A cwBkAG4AYQBlAFIAXQBHAFAAPgBDADEAMwAlACQAGgAZAAgACQD5//b/6//k/9v/0v/M/8v/wf+5 /7z/r/+s/6L/ov+Y/5v/k/+a/47/j/+K/5H/hf+T/4P/lf+H/5j/h/+b/5L/pv+c/7L/qP+7/7H/ zP/G/93/1P/x/+r////8/wsADQAYABsAKQAqADYAPABFAEgA")
			.appendTo("body");
		};

		self.queryStringToJSON = function() {            
		    var pairs = location.search.slice(1).split('&');

		    var result = {};
		    pairs.forEach(function(pair) {
			pair = pair.split('=');
			result[pair[0]] = decodeURIComponent(pair[1] || '');
		    });

		    return JSON.parse(JSON.stringify(result));
		};

		self.jsonToQueryString = function(json) {            

			var items = Object.getOwnPropertyNames(json);
			var string = null

			for (var i=0; i< items.length; i++)
			{
				if (string) 
				{
					string = string + "&" + items[i] + "=" + json[items[i]]
				} else {
					string = "?" + items[i] + "=" + json[items[i]];
				}
			}

			return string;
		};	

		self.stopAudioAlert = function() 
		{
			$(this.audioPlayer).remove();
			this.audioPlayer = null;
		};	

		self.getName = function(obj)
		{
			var str = obj.name;
			if (!str) str = obj.jid ? obj.jid.split("@")[0] : "";
			return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
		}		

		self.BrowserDetect = 
		{		 
			init: function () {		
				this.browser = this.searchString(this.dataBrowser) || "An unknown browser";			
				this.version = this.searchVersion(navigator.userAgent)
					|| this.searchVersion(navigator.appVersion)
					|| "an unknown version";
				this.OS = this.searchString(this.dataOS) || "an unknown OS";

				this.width = 0;
				this.height = 0;


				if ( typeof( window.innerWidth ) == 'number' )
				{
					this.width = window.innerWidth;
					this.height = window.innerHeight;

				} else if ( document.documentElement && ( document.documentElement.clientWidth || document.documentElement.clientHeight ) ) {

					this.width = document.documentElement.clientWidth;
					this.height = document.documentElement.clientHeight;

				} else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {

					this.width = document.body.clientWidth;
					this.height = document.body.clientHeight;
				}		
			},

			searchString: function (data) {
				for (var i=0;i<data.length;i++)	{
					var dataString = data[i].string;
					var dataProp = data[i].prop;
					this.versionSearchString = data[i].versionSearch || data[i].identity;
					if (dataString) {
						if (dataString.indexOf(data[i].subString) != -1)
							return data[i].identity;
					}
					else if (dataProp)
						return data[i].identity;
				}
			},

			searchVersion: function (dataString) {
				var index = dataString.indexOf(this.versionSearchString);
				if (index == -1) return;
				return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
			},

			dataBrowser: [
				{
					string: navigator.userAgent,
					subString: "Chrome",
					identity: "Chrome"
				},
				{ 	string: navigator.userAgent,
					subString: "OmniWeb",
					versionSearch: "OmniWeb/",
					identity: "OmniWeb"
				},
				{
					string: navigator.vendor,
					subString: "Apple",
					identity: "Safari",
					versionSearch: "Version"
				},
				{
					prop: window.opera,
					identity: "Opera"
				},
				{
					string: navigator.vendor,
					subString: "iCab",
					identity: "iCab"
				},
				{
					string: navigator.vendor,
					subString: "KDE",
					identity: "Konqueror"
				},
				{
					string: navigator.userAgent,
					subString: "Firefox",
					identity: "Firefox"
				},
				{
					string: navigator.vendor,
					subString: "Camino",
					identity: "Camino"
				},
				{		// for newer Netscapes (6+)
					string: navigator.userAgent,
					subString: "Netscape",
					identity: "Netscape"
				},
				{
					string: navigator.userAgent,
					subString: "MSIE",
					identity: "Explorer",
					versionSearch: "MSIE"
				},
				{
					string: navigator.userAgent,
					subString: "Gecko",
					identity: "Mozilla",
					versionSearch: "rv"
				},
				{ 		// for older Netscapes (4-)
					string: navigator.userAgent,
					subString: "Mozilla",
					identity: "Netscape",
					versionSearch: "Mozilla"
				}
			],

			dataOS : [
				{
					string: navigator.platform,
					subString: "Win",
					identity: "Windows"
				},
				{
					string: navigator.platform,
					subString: "Mac",
					identity: "Mac"
				},
				{
					   string: navigator.userAgent,
					   subString: "iPhone",
					   identity: "iPhone/iPod"
			    },
				{
					string: navigator.platform,
					subString: "Linux",
					identity: "Linux"
				}
			]
		};	

		return self;
	}(of.util || {}, Strophe, jQuery, of));
	
	
	of.util.BrowserDetect.init();
	

	function connectOpenfire(jid, password) 
	{
	    //console.log("connect", jid, password);
	    
	    var localAudio, localVideo;
	    
	    if (connection && connection.jingle) {
		localAudio = connection.jingle.localAudio;
		localVideo = connection.jingle.localVideo;
	    }

	    // BAO
	    connection = new Openfire.Connection(config.bosh);
	    
	    connection.resource = of.util.BrowserDetect.browser.toLowerCase() + ":" + of.util.BrowserDetect.version + ":" + of.util.BrowserDetect.OS.toLowerCase();		
	    of.connection = connection;

	    var email = SettingsMenu.getEmail();
	    var displayName = SettingsMenu.getDisplayName();
	    
	    if(email) {
		connection.emuc.addEmailToPresence(email);
	    } else {
		connection.emuc.addUserIdToPresence(SettingsMenu.getUID());
	    }

	    if(displayName) {
		connection.emuc.addDisplayNameToPresence(displayName);
	    }

	    if (connection.disco) {
		// for chrome, add multistream cap
	    }
	    if (RTC) connection.jingle.pc_constraints = RTC.pc_constraints;
	    
	    if (config.useIPv6) {
		// https://code.google.com/p/webrtc/issues/detail?id=2828
		if (!connection.jingle.pc_constraints.optional) connection.jingle.pc_constraints.optional = [];
		connection.jingle.pc_constraints.optional.push({googIPv6: true});
	    }
	    if (localAudio) connection.jingle.localAudio = localAudio;
	    if (localVideo) connection.jingle.localVideo = localVideo;

	    var anonymousConnectionFailed = false;
	    
	    connection.connect(jid, password, function (status, msg) 
	    {
		//console.log('Strophe status changed to', Strophe.getStatusString(status));
		
		if (status === Strophe.Status.CONNECTED) 
		{
		    if (config.useStunTurn) {
			connection.jingle.getStunAndTurnCredentials();
		    }

		    connection.send($pres());    	// BAO    		    
		    $(document).trigger('ofmeet.connected', [connection]);
		    registerEventHandlers();
		    
		    
		} else if (status === Strophe.Status.CONNFAIL) {
		    if(msg === 'x-strophe-bad-non-anon-jid') {
			anonymousConnectionFailed = true;
		    }
		    $(document).trigger('ofmeet.error', ['connection.failed']);
		    
		} else if (status === Strophe.Status.DISCONNECTED) {
		    if(anonymousConnectionFailed) {
			// prompt user for username and password
			$(document).trigger('passwordrequired.main');
		    }
		} else if (status === Strophe.Status.AUTHFAIL) {
		    // wrong password or username, prompt user
		    $(document).trigger('passwordrequired.main');

		}
	    });
	}
	
	function registerEventHandlers () 
	{
		connection.addHandler(_handlePresence, null, 'presence');
		connection.addHandler(_handleMessage, null, 'message');
		connection.addHandler(_handlePrivate, 'jabber:iq:private', 'iq');

		connection.roster.registerCallback(_handleRoster);			
	};
	
	/** PrivateFunction: _handlePresence
	 * Presence Handler
	 *
	 * Parameters:
	 *   (Object) presence object 
	 */
	_handlePresence = function(pres) 
	{	
                var presence = $(pres);

		var jid = presence.attr('from');
		var bare_jid = Strophe.getBareJidFromJid(jid);

		if (jid.substring(0, 5) == "rayo-") return true;			
		if (jid.substring(0, 5) == "Jitsi") return true;			

		if (of.connection.roster.isSelf(bare_jid)) 
		{
		    if ((of.connection.jid !== jid)&&(presence.attr('type') !== 'unavailable')) {
			// Another resource has changed it's status, we'll update ours as well.

		    }
		    return true;
		}

		var ignore = false;

		for (i = 0; i < pres.childNodes.length; i++) 
		{
			var xmlns = pres.childNodes[i].getAttribute("xmlns");  

			if (xmlns && (xmlns.match(Strophe.NS.MUC) || xmlns.match("urn:xmpp:rayo") ))
			{
				ignore = true;
			}		
		}

		if (ignore) return true;

		$(document).trigger('ofmeet.contact.presence',
		{	
			type: presence.attr('type'),
			full_jid: jid,
			jid: bare_jid,
			state:  presence.attr('type') == "unavailable" ? "offline" : presence.find('show').text() || 'online',
			status: presence.find('status').text(),
			isSelf: of.connection.roster.isSelf(bare_jid)
		});
                	
		return true;
	};
	
	/** PrivateFunction: _handleMessage
	 * Message Handler
	 *
	 * Parameters:
	 *   (Object) message object 
	 */
	_handleMessage = function(message) 
	{
		var id = $(message).attr("from");
		var from = $(message).attr("from");
		var to = $(message).attr("to");		
		var reason = null;
		var password = null;
		var composing = false;
		var offerer = null;
		var type = $(message).attr("type");
		
		$(message).find('x').each(function ()  	
		{
			var namespace = $(this).attr("xmlns");
			
			$(message).find('offer').each(function() 
			{	
				offerer = $(this).attr('jid');			
			});			

			if (namespace == "jabber:x:conference")
			{
				$(message).find('invite').each(function() 
				{	
					offerer = $(this).attr('from');			
				});
				
				id = $(this).attr('jid');
				reason = $(this).attr('reason');
				password = $(this).attr('password');
				
				if (!reason)
				{
					$(message).find('reason').each(function() 
					{				
						reason = $(this).text();
					});				
				}
				
				if (!password)
				{
					$(message).find('password').each(function() 
					{				
						password = $(this).text();
					});				
				}				
			
				$(document).trigger('ofmeet.conversation.invitation', [{id: id, from: from, reason: reason, offerer: offerer, password: password}]);				
				
			} else if (namespace == "http://jabber.org/protocol/muc#user")	{			
				
				$(this).find('reason').each(function() 
				{				
					reason = $(this).text();
				});
				
				$(this).find('password').each(function() 
				{				
					password = $(this).text();
				});
				
				$(this).find('decline').each(function() 
				{				
					from = $(this).attr("from");
					$(document).trigger('ofmeet.conversation.declined', [{id: id, from: from, reason: reason, offerer: offerer}]);				
					
				});

			} else {
				$(this).find('composing').each(function ()  	
				{
					composing = true;
				});

				$(document).trigger('ofmeet.conversation.composing', [{id: id}]);								
			}
		});

		if (type != "groupchat" && type != "error")
		{
			$(message).find('body').each(function ()  	
			{
				var body = $('<div/>').text($(this).text()).html();
				var xid = getId(from);
				var jid = xid.address;
				
				if (xid.domain != of.connection.domain)
				{
					jid = makeJidFromUsername(xid.resource.id);
				}

				var timestamp = moment().clone().startOf('day');

				if ($(message).find('delay').length > 0) {
				    timestamp = moment($(message).find('delay').attr('stamp')).clone().startOf('day');
				}
				
				$(document).trigger('ofmeet.contact.message', {jid: jid, body: body, timestamp: timestamp, to: to});					
			});
		}
		
		return true;
	};
	
	
	/** PrivateFunction: _handleRoster
	 * Contacts Roster Handler for roster push
	 *
	 * Parameters:
	 *   (Array) List of roster items
	 */
	_handleRoster = function(items) {
		
		$(document).trigger('ofmeet.roster.items', [items]);
		return true;
	};	

	/** PrivateFunction: _handlePrivate
	 * Acts on a bookmarks event. When a bookmark has the attribute autojoin set, joins this room.
	 *
	 * Parameters:
	 *   (String) iq - Raw XML Message
	 *
	 * Returns:
	 *   (Boolean) - true
	 */
	_handlePrivate = function(iq) {
		
		var iq = $(iq);
		
		$('conference', iq).each(function() {
			var item = $(this);
			$(document).trigger('ofmeet.room.items', [{autojoin: item.attr('autojoin'), jid: item.attr('jid'), name: item.attr('name')}]);
		});
		return true;
	};		

	/** Function: getId
	 * Generate a JID object from a JID
	 *
	 */
	 
	function getId(jid) 
	{
		if (!jid) jid = of.connection.jid;
		var resource = Strophe.getResourceFromJid(jid);
		var capabilities = resource ? resource.split(":") : []
		
		return {

                	username: Strophe.getNodeFromJid(jid),
                	domain: Strophe.getDomainFromJid(jid),
			address: Strophe.getBareJidFromJid(jid),                	
                	resource: {
                		id: resource,
                		browser: capabilities[0] || "",
                		version: capabilities[1] || "",    
                		os: capabilities[2] || ""                  		
                	}
		};
	};
	
	
	/** Function: makeJidFromUsername
	 * Convert username into a JID
	 *
	 * Parameters:
	 *   (String) username - TraderLynk username
	 *
	 * Returns:
	 *   (String) TraderLynk JID
	 */	
	 
	function makeJidFromUsername(username) 
	{
		var jid = username;
		if (username.indexOf("@") == -1) jid = jid + "@" + of.connection.domain;
		return jid;
	};	
	/**
	 * We ask for audio and video combined stream in order to get permissions and
	 * not to ask twice.
	 */
	function obtainAudioAndVideoPermissions(callback, novideo) {
	    // Get AV
	    var cb = function (stream) {
		console.log('got', stream, stream.getAudioTracks().length, stream.getVideoTracks().length);
		callback(stream);
		trackUsage('localMedia', {
		    audio: stream.getAudioTracks().length,
		    video: stream.getVideoTracks().length
		});
	    }

	    var media = ['audio', 'video'];
	    var resolution = config.resolution || '360';

	    if (novideo)
	    {
		media = ['audio'];
		resolution = null;
	    }

	    console.log("using media", media);

	    getUserMediaWithConstraints(
		media,
		cb,
		function (error) {
		    console.error('failed to obtain audio/video stream - trying audio only', error);
		    getUserMediaWithConstraints(
			['audio'],
			cb,
			function (error) {
			    console.error('failed to obtain audio/video stream - stop', error);
			    trackUsage('localMediaError', {
				media: error.media || 'video',
				name : error.name
			    });
			    messageHandler.showError("Error",
				"Failed to obtain permissions to use the local microphone" +
				    "and/or camera.");
			}
		    );
		},
		resolution);
	}

	function generateRoomName() {
	    var roomnode = null;
	    var path = window.location.pathname;

	    // determinde the room node from the url
	    // TODO: just the roomnode or the whole bare jid?
	    if (config.getroomnode && typeof config.getroomnode === 'function') {
		// custom function might be responsible for doing the pushstate
		roomnode = config.getroomnode(path);
	    } else {
		/* fall back to default strategy
		 * this is making assumptions about how the URL->room mapping happens.
		 * It currently assumes deployment at root, with a rewrite like the
		 * following one (for nginx):
		location ~ ^/([a-zA-Z0-9]+)$ {
		    rewrite ^/(.*)$ / break;
		}
		 */
		if (path.length > 1) {
		    roomnode = path.substr(1).toLowerCase();
		} else {
		    var word = RoomNameGenerator.generateRoomWithoutSeparator();
		    roomnode = word.toLowerCase();

		    window.history.pushState('VideoChat',
			    'Room: ' + word, window.location.pathname + word);
		}
	    }

	    roomName = roomnode + '@' + config.hosts.muc;
	}

	function doJoin() 
	{
	    var roomjid;
	    
	    if (!roomName) {
		generateRoomName();
	    }

	    roomjid = roomName;

	    if (config.useNicks) {
		var nick = window.prompt('Your nickname (optional)');
		if (nick) {
		    roomjid += '/' + nick;
		} else {
		    roomjid += '/' + Strophe.getResourceFromJid(connection.jid); // BAO
		}
	    } else {

		var tmpJid = Strophe.getResourceFromJid(connection.jid);	// BAO
		roomjid += '/' + tmpJid;		
	    }
	    
	    roomjid += '-' + Math.round(Math.random() * 10000);
	    
	    connection.ofmuc.roomJid = roomName; // BAO    
	    connection.emuc.doJoin(roomjid);
	}

	function waitForRemoteVideo(selector, ssrc, stream, jid) {
	    // XXX(gp) so, every call to this function is *always* preceded by a call
	    // to the RTC.attachMediaStream() function but that call is *not* followed
	    // by an update to the videoSrcToSsrc map!
	    //
	    // The above way of doing things results in video SRCs that don't correspond
	    // to any SSRC for a short period of time (to be more precise, for as long
	    // the waitForRemoteVideo takes to complete). This causes problems (see
	    // bellow).
	    //
	    // I'm wondering why we need to do that; i.e. why call RTC.attachMediaStream()
	    // a second time in here and only then update the videoSrcToSsrc map? Why
	    // not simply update the videoSrcToSsrc map when the RTC.attachMediaStream()
	    // is called the first time? I actually do that in the lastN changed event
	    // handler because the "orphan" video SRC is causing troubles there. The
	    // purpose of this method would then be to fire the "videoactive.jingle".
	    //
	    // Food for though I guess :-)

	    if (selector.removed || !selector.parent().is(":visible")) {
		console.warn("Media removed before had started", selector);
		return;
	    }

	    if (stream.id === 'mixedmslabel') return;

	    if (selector[0].currentTime > 0) {
		var videoStream = simulcast.getReceivingVideoStream(stream);
		RTC.attachMediaStream(selector, videoStream); // FIXME: why do i have to do this for FF?

		// FIXME: add a class that will associate peer Jid, video.src, it's ssrc and video type
		//        in order to get rid of too many maps
		if (ssrc && jid) {
		    jid2Ssrc[Strophe.getResourceFromJid(jid)] = ssrc;
		} else {
		    console.warn("No ssrc given for jid", jid);
	//            messageHandler.showError('Warning', 'No ssrc was given for the video.');
		}

		$(document).trigger('videoactive.jingle', [selector]);
	    } else {
		setTimeout(function () {
		    waitForRemoteVideo(selector, ssrc, stream, jid);
		    }, 250);
	    }
	}

	$(document).bind('remotestreamadded.jingle', function (event, data, sid) {
	    waitForPresence(data, sid);
	});

	function waitForPresence(data, sid) {
	    var sess = connection.jingle.sessions[sid];

	    var thessrc;

	    // look up an associated JID for a stream id
	    if (data.stream.id && data.stream.id.indexOf('mixedmslabel') === -1) {
		// look only at a=ssrc: and _not_ at a=ssrc-group: lines

		var ssrclines
		    = SDPUtil.find_lines(sess.peerconnection.remoteDescription.sdp, 'a=ssrc:');
		ssrclines = ssrclines.filter(function (line) {
		    // NOTE(gp) previously we filtered on the mslabel, but that property
		    // is not always present.
		    // return line.indexOf('mslabel:' + data.stream.label) !== -1;

		    return ((line.indexOf('msid:' + data.stream.id) !== -1));
		});
		if (ssrclines.length) {
		    thessrc = ssrclines[0].substring(7).split(' ')[0];

		    // We signal our streams (through Jingle to the focus) before we set
		    // our presence (through which peers associate remote streams to
		    // jids). So, it might arrive that a remote stream is added but
		    // ssrc2jid is not yet updated and thus data.peerjid cannot be
		    // successfully set. Here we wait for up to a second for the
		    // presence to arrive.

		    if (!ssrc2jid[thessrc]) {
			// TODO(gp) limit wait duration to 1 sec.
			setTimeout(function(d, s) {
			    return function() {
				    waitForPresence(d, s);
			    }
			}(data, sid), 250);
			return;
		    }

		    // ok to overwrite the one from focus? might save work in colibri.js
		    //console.log('associated jid', ssrc2jid[thessrc], data.peerjid);
		    if (ssrc2jid[thessrc]) {
			data.peerjid = ssrc2jid[thessrc];
		    }
		}
	    }

	    //TODO: this code should be removed when firefox implement multistream support
	    if(RTC.browser == "firefox")
	    {
		if((notReceivedSSRCs.length == 0) ||
		    !ssrc2jid[notReceivedSSRCs[notReceivedSSRCs.length - 1]])
		{
		    // TODO(gp) limit wait duration to 1 sec.
		    setTimeout(function(d, s) {
			return function() {
			    waitForPresence(d, s);
			}
		    }(data, sid), 250);
		    return;
		}

		thessrc = notReceivedSSRCs.pop();
		if (ssrc2jid[thessrc]) {
		    data.peerjid = ssrc2jid[thessrc];
		}
	    }

	    // NOTE(gp) now that we have simulcast, a media stream can have more than 1
	    // ssrc. We should probably take that into account in our MediaStream
	    // wrapper.
	    var mediaStream = new MediaStream(data, sid, thessrc);
	    var jid = data.peerjid || connection.emuc.myroomjid;
	    if(!mediaStreams[jid]) {
		mediaStreams[jid] = {};
	    }
	    mediaStreams[jid][mediaStream.type] = mediaStream;

	    var container;
	    var remotes = document.getElementById('remoteVideos');

	    if (data.peerjid) {
		VideoLayout.ensurePeerContainerExists(data.peerjid);

		container  = document.getElementById(
			'participant_' + Strophe.getResourceFromJid(data.peerjid));
	    } else {
		if (data.stream.id !== 'mixedmslabel'
		    // FIXME: default stream is added always with new focus
		    // (to be investigated)
		    && data.stream.id !== 'default') {
		    console.error('can not associate stream',
			data.stream.id,
			'with a participant');
		    // We don't want to add it here since it will cause troubles
		    return;
		}
		// FIXME: for the mixed ms we dont need a video -- currently
		container = document.createElement('span');
		container.id = 'mixedstream';
		container.className = 'videocontainer';
		remotes.appendChild(container);
	    }

	    var isVideo = data.stream.getVideoTracks().length > 0;

	    if (container) {
		VideoLayout.addRemoteStreamElement( container,
						    sid,
						    data.stream,
						    data.peerjid,
						    thessrc);
	    }

	    // an attempt to work around https://github.com/jitsi/jitmeet/issues/32
	    if (isVideo &&
		data.peerjid && sess.peerjid === data.peerjid &&
		data.stream.getVideoTracks().length === 0 &&
		connection.jingle.localVideo.getVideoTracks().length > 0) {
		//
		window.setTimeout(function () {
		    sendKeyframe(sess.peerconnection);
		}, 3000);
	    }
	}

	// an attempt to work around https://github.com/jitsi/jitmeet/issues/32
	function sendKeyframe(pc) {
	    //console.log('sendkeyframe', pc.iceConnectionState);
	    if (pc.iceConnectionState !== 'connected') return; // safe...
	    pc.setRemoteDescription(
		pc.remoteDescription,
		function () {
		    pc.createAnswer(
			function (modifiedAnswer) {
			    pc.setLocalDescription(
				modifiedAnswer,
				function () {
				    // noop
				},
				function (error) {
				    //console.log('triggerKeyframe setLocalDescription failed', error);
				    messageHandler.showError();
				}
			    );
			},
			function (error) {
			    //console.log('triggerKeyframe createAnswer failed', error);
			    messageHandler.showError();
			}
		    );
		},
		function (error) {
		    //console.log('triggerKeyframe setRemoteDescription failed', error);
		    messageHandler.showError();
		}
	    );
	}

	// Really mute video, i.e. dont even send black frames
	function muteVideo(pc, unmute) {
	    // FIXME: this probably needs another of those lovely state safeguards...
	    // which checks for iceconn == connected and sigstate == stable
	    pc.setRemoteDescription(pc.remoteDescription,
		function () {
		    pc.createAnswer(
			function (answer) {
			    var sdp = new SDP(answer.sdp);
			    if (sdp.media.length > 1) {
				if (unmute)
				    sdp.media[1] = sdp.media[1].replace('a=recvonly', 'a=sendrecv');
				else
				    sdp.media[1] = sdp.media[1].replace('a=sendrecv', 'a=recvonly');
				sdp.raw = sdp.session + sdp.media.join('');
				answer.sdp = sdp.raw;
			    }
			    pc.setLocalDescription(answer,
				function () {
				    //console.log('mute SLD ok');
				},
				function (error) {
				    //console.log('mute SLD error');
				    messageHandler.showError('Error',
					'Oops! Something went wrong and we failed to ' +
					    'mute! (SLD Failure)');
				}
			    );
			},
			function (error) {
			    //console.log(error);
			    messageHandler.showError();
			}
		    );
		},
		function (error) {
		    //console.log('muteVideo SRD error');
		    messageHandler.showError('Error',
			'Oops! Something went wrong and we failed to stop video!' +
			    '(SRD Failure)');

		}
	    );
	}

	/**
	 * Callback for audio levels changed.
	 * @param jid JID of the user
	 * @param audioLevel the audio level value
	 */
	function audioLevelUpdated(jid, audioLevel)
	{
	    var resourceJid;
	    if(jid === LocalStatsCollector.LOCAL_JID)
	    {
		resourceJid = AudioLevels.LOCAL_LEVEL;
		if(isAudioMuted())
		{
		    audioLevel = 0;
		}
	    }
	    else
	    {
		resourceJid = Strophe.getResourceFromJid(jid);
	    }

	    AudioLevels.updateAudioLevel(resourceJid, audioLevel);
	}

	/**
	 * Starts the {@link StatsCollector} if the feature is enabled in config.js.
	 */
	function startRtpStatsCollector()
	{
	    stopRTPStatsCollector();
	    if (config.enableRtpStats)
	    {
		statsCollector = new StatsCollector(
		    getConferenceHandler().peerconnection, 200, audioLevelUpdated, 2000,
		    ConnectionQuality.updateLocalStats);
		statsCollector.start();
	    }
	}

	/**
	 * Stops the {@link StatsCollector}.
	 */
	function stopRTPStatsCollector()
	{
	    if (statsCollector)
	    {
		statsCollector.stop();
		statsCollector = null;
		ConnectionQuality.stopSendingStats();
	    }
	}

	/**
	 * Starts the {@link LocalStatsCollector} if the feature is enabled in config.js
	 * @param stream the stream that will be used for collecting statistics.
	 */
	function startLocalRtpStatsCollector(stream)
	{
	    if(config.enableRtpStats)
	    {
		localStatsCollector = new LocalStatsCollector(stream, 100, audioLevelUpdated);
		localStatsCollector.start();
	    }
	}

	/**
	 * Stops the {@link LocalStatsCollector}.
	 */
	function stopLocalRtpStatsCollector()
	{
	    if(localStatsCollector)
	    {
		localStatsCollector.stop();
		localStatsCollector = null;
	    }
	}

	$(document).bind('callincoming.jingle', function (event, sid) {
	    var sess = connection.jingle.sessions[sid];

	    // TODO: do we check activecall == null?
	    activecall = sess;

	    startRtpStatsCollector();

	    // Bind data channel listener in case we're a regular participant
	    if (config.openSctp)
	    {
		bindDataChannelListener(sess.peerconnection);
	    }

	    // TODO: check affiliation and/or role
	    //console.log('emuc data for', sess.peerjid, connection.emuc.members[sess.peerjid]);
	    sess.usedrip = true; // not-so-naive trickle ice
	    sess.sendAnswer();
	    sess.accept();

	});

	$(document).bind('conferenceCreated.jingle', function (event, focus)
	{
	    startRtpStatsCollector();
	});

	$(document).bind('conferenceCreated.jingle', function (event, focus)
	{
	    // Bind data channel listener in case we're the focus
	    if (config.openSctp)
	    {
		bindDataChannelListener(focus.peerconnection);
	    }
	});

	$(document).bind('setLocalDescription.jingle', function (event, sid) {
	    // put our ssrcs into presence so other clients can identify our stream
	    var sess = connection.jingle.sessions[sid];
	    var newssrcs = [];
	    var media = simulcast.parseMedia(sess.peerconnection.localDescription);
	    media.forEach(function (media) {

		if(Object.keys(media.sources).length > 0) {
		    // TODO(gp) maybe exclude FID streams?
		    Object.keys(media.sources).forEach(function (ssrc) {
			newssrcs.push({
			    'ssrc': ssrc,
			    'type': media.type,
			    'direction': media.direction
			});
		    });
		}
		else if(sess.localStreamsSSRC && sess.localStreamsSSRC[media.type])
		{
		    newssrcs.push({
			'ssrc': sess.localStreamsSSRC[media.type],
			'type': media.type,
			'direction': media.direction
		    });
		}

	    });

	    //console.log('new ssrcs', newssrcs);

	    // Have to clear presence map to get rid of removed streams
	    connection.emuc.clearPresenceMedia();

	    if (newssrcs.length > 0) {
		for (var i = 1; i <= newssrcs.length; i ++) {
		    // Change video type to screen
		    if (newssrcs[i-1].type === 'video' && isUsingScreenStream) {
			newssrcs[i-1].type = 'screen';
		    }
		    connection.emuc.addMediaToPresence(i,
			newssrcs[i-1].type, newssrcs[i-1].ssrc, newssrcs[i-1].direction);
		}

		connection.emuc.sendPresence();
	    }
	});

	$(document).bind('iceconnectionstatechange.jingle', function (event, sid, session) {
	    switch (session.peerconnection.iceConnectionState) {
	    case 'checking': 
		session.timeChecking = (new Date()).getTime();
		session.firstconnect = true;
		break;
	    case 'completed': // on caller side
	    case 'connected':
		if (session.firstconnect) {
		    session.firstconnect = false;
		    var metadata = {};
		    metadata.setupTime = (new Date()).getTime() - session.timeChecking;
		    session.peerconnection.getStats(function (res) {
			if(res && res.result) {
			    res.result().forEach(function (report) {
				if (report.type == 'googCandidatePair' && report.stat('googActiveConnection') == 'true') {
				    metadata.localCandidateType = report.stat('googLocalCandidateType');
				    metadata.remoteCandidateType = report.stat('googRemoteCandidateType');

				    // log pair as well so we can get nice pie charts
				    metadata.candidatePair = report.stat('googLocalCandidateType') + ';' + report.stat('googRemoteCandidateType');

				    if (report.stat('googRemoteAddress').indexOf('[') === 0) {
					metadata.ipv6 = true;
				    }
				}
			    });
			    trackUsage('iceConnected', metadata);
			}
		    });
		}
		break;
	    }
	});

	$(document).bind('joined.muc', function (event, jid, info) 
	{
	    updateRoomUrl(window.location.href);
	    
	    var displayName = !config.displayJids ? info.displayName : Strophe.getResourceFromJid(jid);
	    
	    if (displayName)
	    {
	    	if (displayName.indexOf(" (me)") == -1) displayName = displayName + ' (me)';
	    	$(document).trigger('displaynamechanged', ['localVideoContainer', displayName]);
	    	document.getElementById('localNick').appendChild(document.createTextNode(displayName));
	    }
	    
	});

	$(document).bind('entered.muc', function (event, jid, info, pres) {
	    //console.log('entered', jid, info);
	    if (info.isFocus)
	    {
		focusJid = jid;
		//console.info("Ignore focus: " + jid +", real JID: " + info.jid);
		// We don't want this notification for the focus.
		// messageHandler.notify('Focus', 'connected', 'connected');
		return;
	    }

	    messageHandler.notify(info.displayName || 'Somebody',
		'connected',
		'connected');

	    // Add Peer's container
	    var id = $(pres).find('userId').text();
	    var email = $(pres).find('email');
	    if(email.length > 0) {
		id = email.text();
	    }
	    VideoLayout.ensurePeerContainerExists(jid,id);
	});

	$(document).bind('left.muc', function (event, jid) {
	    //console.log('left.muc', jid);
	    var displayName = $('#participant_' + Strophe.getResourceFromJid(jid) +
		'>.displayname').text();
	    messageHandler.notify(displayName || 'Somebody',
		'disconnected',
		'disconnected');
	    // Need to call this with a slight delay, otherwise the element couldn't be
	    // found for some reason.
	    // XXX(gp) it works fine without the timeout for me (with Chrome 38).
	    window.setTimeout(function () {
		var container = document.getElementById(
			'participant_' + Strophe.getResourceFromJid(jid));
		if (container) {
		    VideoLayout.removeConnectionIndicator(jid);
		    // hide here, wait for video to close before removing
		    $(container).hide();
		    VideoLayout.resizeThumbnails();
		}
	    }, 10);

	    delete jid2Ssrc[jid];

	    // Unlock large video
	    if (focusedVideoInfo && focusedVideoInfo.jid === jid)
	    {
		//console.info("Focused video owner has left the conference");
		focusedVideoInfo = null;
	    }

	    connection.jingle.terminateByJid(jid);
	});

	$(document).bind('presence.muc', function (event, jid, info, pres) {

	/* BAO

	    //check if the video bridge is available
	    if($(pres).find(">bridgeIsDown").length > 0 && !bridgeIsDown) {
		bridgeIsDown = true;
		messageHandler.showError("Error",
		    "Jitsi Videobridge is currently unavailable. Please try again later!");
	    }

	    if (info.isFocus)
	    {
		return;
	    }

	*/
	    // Remove old ssrcs coming from the jid
	    Object.keys(ssrc2jid).forEach(function (ssrc) {
		if (ssrc2jid[ssrc] == jid) {
		    delete ssrc2jid[ssrc];
		    delete ssrc2videoType[ssrc];
		}
	    });

	    $(pres).find('media[xmlns="http://estos.de/ns/mjs"]>source').each(function (idx, ssrc) {
		//console.log(jid, 'assoc ssrc', ssrc.getAttribute('type'), ssrc.getAttribute('ssrc'));
		var ssrcV = ssrc.getAttribute('ssrc');
		ssrc2jid[ssrcV] = jid;
		notReceivedSSRCs.push(ssrcV);

		var type = ssrc.getAttribute('type');
		ssrc2videoType[ssrcV] = type;

		// might need to update the direction if participant just went from sendrecv to recvonly
		if (type === 'video' || type === 'screen') {
		    var el = $('#participant_'  + Strophe.getResourceFromJid(jid) + '>video');
		    switch (ssrc.getAttribute('direction')) {
		    case 'sendrecv':
			el.show();
			break;
		    case 'recvonly':
			el.hide();
			// FIXME: Check if we have to change large video
			//VideoLayout.updateLargeVideo(el);
			break;
		    }
		}
	    });

	    var displayName = !config.displayJids ? info.displayName : Strophe.getResourceFromJid(jid);

	    if (displayName && displayName.length > 0) $(document).trigger('displaynamechanged',   [jid, displayName]);
		
	    var id = $(pres).find('userId').text();
	    var email = $(pres).find('email');
	    if(email.length > 0) {
		id = email.text();
	    }
	    Avatar.setUserAvatar(jid, id);

	});

	$(document).bind('presence.status.muc', function (event, jid, info, pres) {

	    VideoLayout.setPresenceStatus(
		'participant_' + Strophe.getResourceFromJid(jid), info.status);

	});

	$(document).bind('kicked.muc', function (event, jid) {
	    //console.info(jid + " has been kicked from MUC!");
	    if (connection.emuc.myroomjid === jid) {
		sessionTerminated = true;
		disposeConference(false);
		connection.emuc.doLeave();
		messageHandler.openMessageDialog("Session Terminated",
		    "Ouch! You have been kicked out of the meet!");
	    }
	});

	$(document).bind('passwordrequired.muc', function (event, jid) {
	    //console.log('on password required', jid);

	    messageHandler.openTwoButtonDialog(null,
		'<h2>Password required</h2>' +
		'<input id="lockKey" type="text" placeholder="password" autofocus>',
		true,
		"Ok",
		function (e, v, m, f) {},
		function (event) {
		    document.getElementById('lockKey').focus();
		},
		function (e, v, m, f) {
		    if (v) {
			var lockKey = document.getElementById('lockKey');
			if (lockKey.value !== null) {
			    setSharedKey(lockKey.value);
			    connection.emuc.doJoin(jid, lockKey.value);
			}
		    }
		}
	    );
	});

	/**
	 * Checks if video identified by given src is desktop stream.
	 * @param videoSrc eg.
	 * blob:https%3A//pawel.jitsi.net/9a46e0bd-131e-4d18-9c14-a9264e8db395
	 * @returns {boolean}
	 */
	function isVideoSrcDesktop(jid) {
	    // FIXME: fix this mapping mess...
	    // figure out if large video is desktop stream or just a camera

	    if(!jid)
		return false;
	    var isDesktop = false;
	    if (connection.emuc.myroomjid &&
		Strophe.getResourceFromJid(connection.emuc.myroomjid) === jid) {
		// local video
		isDesktop = isUsingScreenStream;
	    } else {
		// Do we have associations...
		var videoSsrc = jid2Ssrc[jid];
		if (videoSsrc) {
		    var videoType = ssrc2videoType[videoSsrc];
		    if (videoType) {
			// Finally there...
			isDesktop = videoType === 'screen';
		    } else {
			console.error("No video type for ssrc: " + videoSsrc);
		    }
		} else {
		    console.error("No ssrc for jid: " + jid);
		}
	    }
	    return isDesktop;
	}

	function getConferenceHandler() {
	    return activecall;
	}

	/**
	 * Mutes/unmutes the local video.
	 *
	 * @param mute <tt>true</tt> to mute the local video; otherwise, <tt>false</tt>
	 * @param options an object which specifies optional arguments such as the
	 * <tt>boolean</tt> key <tt>byUser</tt> with default value <tt>true</tt> which
	 * specifies whether the method was initiated in response to a user command (in
	 * contrast to an automatic decision taken by the application logic)
	 */
	function setVideoMute(mute, options) {
	    if (connection && connection.jingle.localVideo) {
		var session = getConferenceHandler();

		if (session) {
		    session.setVideoMute(
			mute,
			function (mute) {
			    var video = $('#video');
			    var communicativeClass = "icon-camera";
			    var muteClass = "icon-camera icon-camera-disabled";

			    if (mute) {
				video.removeClass(communicativeClass);
				video.addClass(muteClass);
			    } else {
				video.removeClass(muteClass);
				video.addClass(communicativeClass);
			    }
			    connection.emuc.addVideoInfoToPresence(mute);
			    connection.emuc.sendPresence();
			},
			options);
		}
	    }
	}

	$(document).on('inlastnchanged', function (event, oldValue, newValue) {
	    if (config.muteLocalVideoIfNotInLastN) {
		setVideoMute(!newValue, { 'byUser': false });
	    }
	});

	/**
	 * Sets muted audio state for the local participant.
	 */
	function setAudioMuted(mute) {
	    if (!(connection && connection.jingle.localAudio)) {
		preMuted = mute;
		// We still click the button.
		buttonClick("#mute", "icon-microphone icon-mic-disabled");
		return;
	    }

	    if (forceMuted && !mute) {
		//console.info("Asking focus for unmute");
		connection.moderate.setMute(connection.emuc.myroomjid, mute);
		// FIXME: wait for result before resetting muted status
		forceMuted = false;
	    }

	    if (mute == isAudioMuted()) {
		// Nothing to do
		return;
	    }

	    // It is not clear what is the right way to handle multiple tracks.
	    // So at least make sure that they are all muted or all unmuted and
	    // that we send presence just once.
	    var localAudioTracks = connection.jingle.localAudio.getAudioTracks();
	    if (localAudioTracks.length > 0) {
		for (var idx = 0; idx < localAudioTracks.length; idx++) {
		    localAudioTracks[idx].enabled = !mute;
		}
	    }
	    // isMuted is the opposite of audioEnabled
	    connection.emuc.addAudioInfoToPresence(mute);
	    connection.emuc.sendPresence();
	    VideoLayout.showLocalAudioIndicator(mute);

	    buttonClick("#mute", "icon-microphone icon-mic-disabled");
	}

	/**
	 * Checks whether the audio is muted or not.
	 * @returns {boolean} true if audio is muted and false if not.
	 */
	function isAudioMuted()
	{
	    var localAudio = connection.jingle.localAudio;
	    
	    if (localAudio)
	    {
		    for (var idx = 0; idx < localAudio.getAudioTracks().length; idx++) {
			if(localAudio.getAudioTracks()[idx].enabled === true)
			    return false;
		    }
	    }
	    
	    return true;
	}

	// Starts or stops the recording for the conference.
	function toggleRecording() {
	    Recording.toggleRecording();
	}

	/**
	 * Returns an array of the video horizontal and vertical indents,
	 * so that if fits its parent.
	 *
	 * @return an array with 2 elements, the horizontal indent and the vertical
	 * indent
	 */
	function getCameraVideoPosition(videoWidth,
					videoHeight,
					videoSpaceWidth,
					videoSpaceHeight) {
	    // Parent height isn't completely calculated when we position the video in
	    // full screen mode and this is why we use the screen height in this case.
	    // Need to think it further at some point and implement it properly.
	    var isFullScreen = document.fullScreen ||
		    document.mozFullScreen ||
		    document.webkitIsFullScreen;
	    if (isFullScreen)
		videoSpaceHeight = window.innerHeight;

	    var horizontalIndent = (videoSpaceWidth - videoWidth) / 2;
	    var verticalIndent = (videoSpaceHeight - videoHeight) / 2;

	    return [horizontalIndent, verticalIndent];
	}

	/**
	 * Returns an array of the video horizontal and vertical indents.
	 * Centers horizontally and top aligns vertically.
	 *
	 * @return an array with 2 elements, the horizontal indent and the vertical
	 * indent
	 */
	function getDesktopVideoPosition(videoWidth,
					 videoHeight,
					 videoSpaceWidth,
					 videoSpaceHeight) {

	    var horizontalIndent = (videoSpaceWidth - videoWidth) / 2;

	    var verticalIndent = 0;// Top aligned

	    return [horizontalIndent, verticalIndent];
	}

	/**
	 * Returns an array of the video dimensions, so that it covers the screen.
	 * It leaves no empty areas, but some parts of the video might not be visible.
	 *
	 * @return an array with 2 elements, the video width and the video height
	 */
	function getCameraVideoSize(videoWidth,
				   videoHeight,
				   videoSpaceWidth,
				   videoSpaceHeight) {
	    if (!videoWidth)
		videoWidth = currentVideoWidth;
	    if (!videoHeight)
		videoHeight = currentVideoHeight;

	    var aspectRatio = videoWidth / videoHeight;

	    var availableWidth = Math.max(videoWidth, videoSpaceWidth);
	    var availableHeight = Math.max(videoHeight, videoSpaceHeight);

	    if (availableWidth / aspectRatio < videoSpaceHeight) {
		availableHeight = videoSpaceHeight;
		availableWidth = availableHeight * aspectRatio;
	    }

	    if (availableHeight * aspectRatio < videoSpaceWidth) {
		availableWidth = videoSpaceWidth;
		availableHeight = availableWidth / aspectRatio;
	    }

	    return [availableWidth, availableHeight];
	}


	$(window).bind('beforeunload', function () {
	    if (connection && connection.connected) {
		// ensure signout
		connection.disconnect();
	    }
	    disposeConference(true);
	});

	function disposeConference(onUnload) {
	    var handler = getConferenceHandler();
	    if (handler && handler.peerconnection) {
		// FIXME: probably removing streams is not required and close() should
		// be enough
		if (connection.jingle.localAudio) {
		    handler.peerconnection.removeStream(connection.jingle.localAudio, onUnload);
		}
		if (connection.jingle.localVideo) {
		    handler.peerconnection.removeStream(connection.jingle.localVideo, onUnload);
		}
		handler.peerconnection.close();
	    }
	    stopRTPStatsCollector();
	    if(onUnload) {
		stopLocalRtpStatsCollector();
	    }
	    activecall = null;
	}

	function dump(elem, filename) {
	    elem = elem.parentNode;
	    elem.download = filename || 'meetlog.json';
	    elem.href = 'data:application/json;charset=utf-8,\n';
	    var data = populateData();
	    elem.href += encodeURIComponent(JSON.stringify(data, null, '  '));
	    return false;
	}


	/**
	 * Populates the log data
	 */
	function populateData() {
	    var data = {};
	    if (connection.jingle) {
		Object.keys(connection.jingle.sessions).forEach(function (sid) {
		    var session = connection.jingle.sessions[sid];
		    if (session.peerconnection && session.peerconnection.updateLog) {
			// FIXME: should probably be a .dump call
			data["jingle_" + session.sid] = {
			    updateLog: session.peerconnection.updateLog,
			    stats: session.peerconnection.stats,
			    url: window.location.href
			};
		    }
		});
	    }
	    var metadata = {};
	    metadata.time = new Date();
	    metadata.url = window.location.href;
	    metadata.ua = navigator.userAgent;
	    if (connection.logger) {
		metadata.xmpp = connection.logger.log;
	    }
	    data.metadata = metadata;
	    return data;
	}

	/**
	 * Changes the style class of the element given by id.
	 */
	function buttonClick(id, classname) {
	    $(id).toggleClass(classname); // add the class to the clicked element
	}

	/**
	 * Locks / unlocks the room.
	 */
	function lockRoom(lock) {
	    if (lock)
		connection.emuc.lockRoom(sharedKey);
	    else
		connection.emuc.lockRoom('');
	}

	/**
	 * Sets the shared key.
	 */
	function setSharedKey(sKey) {
	    sharedKey = sKey;
	}

	/**
	 * Updates the room invite url.
	 */
	function updateRoomUrl(newRoomUrl) {
	    roomUrl = newRoomUrl;

	    // If the invite dialog has been already opened we update the information.
	    var inviteLink = document.getElementById('inviteLinkRef');
	    if (inviteLink) {
		inviteLink.value = roomUrl;
		inviteLink.select();
		document.getElementById('jqi_state0_buttonInvite').disabled = false;
	    }
	}

	/**
	 * Resizes and repositions videos in full screen mode.
	 */
	$(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange',
	    function () {
		VideoLayout.resizeLargeVideoContainer();
		VideoLayout.positionLarge();
		isFullScreen = document.fullScreen ||
		    document.mozFullScreen ||
		    document.webkitIsFullScreen;

		if (isFullScreen) {
		    setView("fullscreen");
		}
		else {
		    setView("default");
		}
	    }
	);

	/**
	 * Sets the current view.
	 */
	function setView(viewName) {
	//    if (viewName == "fullscreen") {
	//        document.getElementById('videolayout_fullscreen').disabled  = false;
	//        document.getElementById('videolayout_default').disabled  = true;
	//    }
	//    else {
	//        document.getElementById('videolayout_default').disabled  = false;
	//        document.getElementById('videolayout_fullscreen').disabled  = true;
	//    }
	}

	$(document).bind('error.jingle',  function (event, session, error)
	{
		console.error("Jingle error", error);
	});

	$(document).bind('fatalError.jingle', function (event, session, error)
	{
		sessionTerminated = true;
		connection.emuc.doLeave();
		messageHandler.showError(  "Sorry", "Internal application error[setRemoteDescription]");
	});

	function onSelectedEndpointChanged(userJid)
	{
	    //console.log('selected endpoint changed: ', userJid);
	    if (_dataChannels && _dataChannels.length != 0)
	    {
		_dataChannels.some(function (dataChannel) {
		    if (dataChannel.readyState == 'open')
		    {
			dataChannel.send(JSON.stringify({
			    'colibriClass': 'SelectedEndpointChangedEvent',
			    'selectedEndpoint': (!userJid || userJid == null)
				? null : userJid
			}));

			return true;
		    }
		});
	    }
	}

	$(document).bind("selectedendpointchanged", function(event, userJid) {
	    onSelectedEndpointChanged(userJid);
	});

	function onPinnedEndpointChanged(userJid)
	{
	    //console.log('pinned endpoint changed: ', userJid);
	    if (_dataChannels && _dataChannels.length != 0)
	    {
		_dataChannels.some(function (dataChannel) {
		    if (dataChannel.readyState == 'open')
		    {
			dataChannel.send(JSON.stringify({
			    'colibriClass': 'PinnedEndpointChangedEvent',
			    'pinnedEndpoint': (!userJid || userJid == null)
				? null : Strophe.getResourceFromJid(userJid)
			}));

			return true;
		    }
		});
	    }
	}

	$(document).bind("pinnedendpointchanged", function(event, userJid) 
	{
	    onPinnedEndpointChanged(userJid);
	});

	$(document).on('videomuted.muc', function(event, jid, value) 
	{
	    if(mediaStreams[jid] && mediaStreams[jid][MediaStream.VIDEO_TYPE]) {
		var stream = mediaStreams[jid][MediaStream.VIDEO_TYPE];
		var isMuted = (value === "true");
		if (isMuted != stream.muted) {
		    stream.muted = isMuted;
		    Avatar.showUserAvatar(jid, isMuted);
		}
	    }
	});
	
	$(document).ready(function ()
	{
		console.log("of.document.ready");
		$('body').append('<div id="videospace"> <div id="largeVideoContainer" class="videocontainer"> <div id="activeSpeaker"> <img id="activeSpeakerAvatar" src=""/> <canvas id="activeSpeakerAudioLevel"></canvas> </div> <video id="largeVideo" autoplay oncontextmenu="return false;"></video> </div> <div id="remoteVideos"> <span id="localVideoContainer" class="videocontainer"> <span id="localNick" class="nick"></span> <span id="localVideoWrapper" /> <audio id="localAudio" autoplay oncontextmenu="return false;" muted></audio> <span class="focusindicator"></span> </span> </div> </div>');
	});
	
	
	of.initialise = function initialise() 
	{
	    console.log("ofmeet.initialise");
	    
	     if (!navigator.webkitGetUserMedia)
	     {
	     	of.enabled = false;
	    	$(document).trigger('ofmeet.ready');	
	    	return;
	     }

	    if (RTC === null) {
		RTC = setupRTC();
	    } else if (RTC.browser !== 'chrome' && config.enableFirefoxSupport !== true) {
		return;
	    }
	    
	    $('#videospace').css("display", "block");
	    
	    VideoLayout.init();
	    Moderator.init();
	    
	    simulcast = new SimulcastManager();

	    // Set default desktop sharing method
	    setDesktopSharing(config.desktopSharing);
	    // Initialize Chrome extension inline installs
	    if (config.chromeExtensionId) {
		initInlineInstalls();
	    }
	    
	    // By default we use camera
	    getVideoSize = getCameraVideoSize;
	    getVideoPosition = getCameraVideoPosition;

	    VideoLayout.resizeLargeVideoContainer();
	    $(window).resize(function () {
		VideoLayout.resizeLargeVideoContainer();
		VideoLayout.positionLarge();
	    });
  
	    // Listen for large video size updates
	    document.getElementById('largeVideo')
		.addEventListener('loadedmetadata', function (e) {
		    currentVideoWidth = this.videoWidth;
		    currentVideoHeight = this.videoHeight;
		    VideoLayout.positionLarge(currentVideoWidth, currentVideoHeight);
		});

	    document.getElementById('largeVideo').volume = 0;

	    toastr.options = {
		"closeButton": true,
		"debug": false,
		"positionClass": "notification-bottom-right",
		"onclick": null,
		"showDuration": "300",
		"hideDuration": "1000",
		"timeOut": "2000",
		"extendedTimeOut": "1000",
		"showEasing": "swing",
		"hideEasing": "linear",
		"showMethod": "fadeIn",
		"hideMethod": "fadeOut",
		"reposition": function() {
		},
		"newestOnTop": false
	    };
	    
	    of.enabled = true;
	    $(document).trigger('ofmeet.ready');	    
	};
	
	of.isVisible = function () 
	{
		return $('#videospace').css("display") == "block";
	}	

	of.visible = function (flag) 
	{
		if (flag)
		{
			$('#videospace').css("display", "block");
		} else {
			$('#videospace').css("display", "none");			
		}
	}

	of.ready = function (username, password, nocss) 
	{
		var headers = null;
		
		if (username && password)
		{
			headers = {"Authorization": "Basic " + btoa(username + ":" + password)};
			of.username = username;
			of.password = password;
		}
		
		$.ajax({type: "GET", url: of.server + "/ofmeet/config", headers: headers}).done(function(data)
		{
			eval(data);
			of.visible(false);
			
			if (!nocss)
			{
				var cssId = 'ofmeet-css';

				if (!document.getElementById(cssId))
				{
				    var head  = document.getElementsByTagName('head')[0];
				    var link  = document.createElement('link');
				    link.id   = cssId;
				    link.rel  = 'stylesheet';
				    link.type = 'text/css';
				    link.href = of.server + '/ofmeet/api/ofmeet.css';
				    link.media = 'all';
				    head.appendChild(link);
				}
				
			}
			of.initialise();
		})
	}

	of.addSIPPhone = function addSIPPhone(sipNumber) 
	{
		connection.rayo.dial(sipNumber, roomName, roomName);
	}
	
	of.removeSIPPhone = function removeSIPPhone() 
	{
		connection.rayo.rayo.hang_up();
	}

	of.isScreenSharing = function isScreenSharing() 
	{
		return isUsingScreenStream;
	}
	
	of.toggleScreenSharing = function toggleScreenSharing() 
	{
	    if (switchInProgress || !obtainDesktopStream) {
		console.warn("Switch in progress or no method defined");
		return;
	    }
	    switchInProgress = true;

	    // Only the focus is able to set a shared key.
	    if (!isUsingScreenStream)
	    {
		obtainDesktopStream(
		    function (stream) {
			// We now use screen stream
			isUsingScreenStream = true;
			// Hook 'ended' event to restore camera when screen stream stops
			stream.addEventListener('ended',
			    function (e) {
				if (!switchInProgress && isUsingScreenStream) {
				    toggleScreenSharing();
				}
			    }
			);
			newStreamCreated(stream);
		    },
		    getSwitchStreamFailed);
	    } else {
		// Disable screen stream
		getUserMediaWithConstraints(
		    ['video'],
		    function (stream) {
			// We are now using camera stream
			isUsingScreenStream = false;
			newStreamCreated(stream);
		    },
		    getSwitchStreamFailed, config.resolution || '360'
		);
	    }
	}

	of.toggleFilmStrip = function toggleFilmStrip() 
	{
	    var filmstrip = $("#remoteVideos");
	    filmstrip.toggleClass("hidden");
	};
    
	of.toggleVideo = function toggleVideo() 
	{
	    buttonClick("#video", "icon-camera icon-camera-disabled");

	    if (connection && connection.jingle.localVideo) {
		var session = getConferenceHandler();

		if (session) {
		    setVideoMute(!session.isVideoMute());
		}
	    }
	}

	of.doAudioMuted = function doAudioMuted(flag) 
	{
	    setAudioMuted(flag);
	}

	of.doVideoMute = function doVideoMute(flag) 
	{
	    setVideoMute(flag);
	}	
	
	of.toggleAudio = function toggleAudio() 
	{
	    setAudioMuted(!isAudioMuted());
	}	

	of.connect = function connect() 
	{	    
	    var jid = config.hosts.domain;
	    
	    if (of.username)
	    {
	    	jid = of.username +  "@" + config.hosts.domain;
		authenticatedUser = true;	    	
	    }

	    if (config.userName && config.userName != "null")
	    {
		jid = config.userName +  "@" + config.hosts.domain;
		authenticatedUser = true;
	    } 
	    
	    if (of.resource) jid = jid +  "/" + of.resource;	    
	    
	    connectOpenfire(jid, of.password);	    
	}

	of.leaveRoom = function leaveRoom() 
	{
	    disposeConference();
	    sessionTerminated = true;
	    connection.emuc.doLeave();
	    roomName = null;
	    
	    if (connection.jingle.localAudio)
	    {
		connection.jingle.localAudio.getAudioTracks().forEach(function (track) {
		    track.stop();
		});
	    	
	    	connection.jingle.localAudio = null;
	    }
	    
	    if (connection.jingle.localVideo)
	    {
		connection.jingle.localVideo.getVideoTracks().forEach(function (track) {
		    track.stop();
		});
		
	    	connection.jingle.localVideo = null;	    	
	    }	    
	}
	
	of.joinRoom = function joinRoom(room) 
	{
	    if (connection && connection.connected && Strophe.getResourceFromJid(connection.jid) // .connected is true while connecting?
		&& (connection.jingle.localAudio || connection.jingle.localVideo)) {
		if (room) roomName = room + '@' + config.hosts.muc;
		doJoin();
	    }
	}


	of.obtainMediaPermissions = function obtainMediaPermissions(novideo) 
	{	   	
	    obtainAudioAndVideoPermissions(function (stream) 
	    {
		var audioStream, videoStream;
		of.stream = stream;

		if(window.webkitMediaStream)
		{
		    var audioStream = new webkitMediaStream();
		    var videoStream = new webkitMediaStream();
		    var audioTracks = stream.getAudioTracks();
		    var videoTracks = stream.getVideoTracks();

		    for (var i = 0; i < audioTracks.length; i++) {
			audioStream.addTrack(audioTracks[i]);
		    }

		    for (i = 0; i < videoTracks.length; i++) {
			videoStream.addTrack(videoTracks[i]);
		    }
		    VideoLayout.changeLocalAudio(audioStream);
		    startLocalRtpStatsCollector(audioStream);

		    VideoLayout.changeLocalVideo(videoStream, true);
		    
		    $(document).trigger('ofmeet.media.obtained');		    
		}
		else
		{
		    VideoLayout.changeLocalStream(stream);
		    startLocalRtpStatsCollector(stream);

		}		
		
	    }, novideo);		    		    
	}
	
	of.addMediaToRoom = function addMediaToRoom() 
	{	
		Moderator.allocateConferenceFocus(roomName, function() 
		{
			$(document).trigger('ofmeet.media.added', [roomName]);		
		});	
	}

	of.getVCard = function getVCard(jid, callback, errorback) 
	{
		of.connection.vCard.get(jid, function(vCard)
		{
			if (callback) callback(vCard);	

		}, function(error) {
			if (errorback) errorback(error);	
			console.error(error);
		});				

	};
	
	of.setVCard = function setVCard(vCard, callback, errorback) 
	{
		of.connection.vCard.set(vCard, function(resp)
		{
			if (callback) callback(resp);	

		}, function(error) {
			if (errorback) errorback(error);			
			console.error(error);
		});				

	};	

	of.fetchContacts = function fetchContacts() 
	{
		of.connection.roster.get();
	};
	
	of.findUsers = function findUsers(search, callback)  
	{
		console.log('findUsers ' + search);

		var iq = $iq({type: 'set', to: "search." + of.connection.domain}).c('query', {xmlns: 'jabber:iq:search'}).c('x').t(search).up().c('email').t(search).up().c('nick').t(search);

		of.connection.sendIQ(iq, function(response)
		{	
			console.log('findUsers response', response)
			var users = [];

			$(response).find('item').each(function() 
			{
				var current = $(this);							    					
				var jid = current.attr('jid');
				var username = Strophe.getNodeFromJid(jid);

				var name = current.find('nick').text();
				var email = current.find('email').text();		

				users.push({username: username, name: name, email: email, jid: jid});								
			});
			
			if (callback) 
				callback(users);
			else 
				$(document).trigger('ofmeet.find.users', {users: users});
			
		}, function (error) {		
			console.error(error);
		});
	};	

	of.fetchBookmarks = function fetchBookmarks() 
	{		
		of.connection.sendIQ($iq({type: "get"}).c("query", {xmlns: "jabber:iq:private"}).c("storage", {xmlns: "storage:bookmarks"}).tree(), function(resp)
		{
			//console.log("get bookmarks", resp)
						
			$(resp).find('conference').each(function() 
			{	
				$(document).trigger('ofmeet.bookmark.conference.item', {name: $(this).attr("name"), jid: $(this).attr("jid")});				
			})
			
			$(resp).find('url').each(function() 
			{
				$(document).trigger('ofmeet.bookmark.url.item', {name: $(this).attr("name"), url: $(this).attr("url")});
			});
			
		}, function (error) {		
			console.error(error);
		});		
	};

	of.fetchChatHistory = function fetchChatHistory(from, to) 
	{		
		of.connection.mam.query(from, {"with": to,  onMessage: function(message) 
		{
			//console.log("Message from ", message);
			
			var msg = $(message).find("forwarded message");
			var body = $(message).find("forwarded message body").text();
			var timestamp = $(message).find("forwarded delay").attr("stamp");
			var item = {from: msg.attr("from"), to: msg.attr("to"), type: msg.attr("type"), body: body, timestamp: timestamp};
			
			$(document).trigger('ofmeet.chat.history.item', item);
			return true;			
			
		}, onComplete: function(response) {
		
			$(document).trigger('ofmeet.chat.history.complete');		
			
		}, onError: function(error) {
			console.error("ERROR ", error);		
		}});
	};

	of.fetchWorkgroups = function fetchWorkgroups() 
	{
		console.log("fetch workgroups")
	
		var iq = $iq({type: 'get', to: "workgroup." + of.connection.domain}).c('workgroups', {jid: of.connection.jid, xmlns: 'http://jabber.org/protocol/workgroup'});

		of.connection.sendIQ(iq, function(response)
		{
		    console.log("fetch workgroups", response)
		
		    $(response).find('workgroup').each(function() 
		    {
			var current = $(this);
			var jid = current.attr('jid');	
			var name = Strophe.getNodeFromJid(jid);
			var room = 'workgroup-' + name + "@conference." + of.connection.domain;
			
			$(document).trigger('ofmeet.workgroup.item', {name: name, jid: jid, room: room});

		    });
		    
		}, function (error) {		
			console.error(error);
		});
	};
	
	of.joinWorkgroup = function joinWorkgroup(workgroup, maxChats, callback, errorback) 
	{
		console.log("join Workgroup")
		of.connection.workgroup.joinWorkgroup(workgroup, maxChats, callback, errorback);			
	};
	
	of.leaveWorkgroup = function leaveWorkgroup(workgroup) 
	{
		console.log("join leaveWorkgroup")
		of.connection.workgroup.joinWorkgroup(workgroup);			
	};	
	
	of.setPresence = function(config) 
	{
		var presence;

		if (config.show  && config.show.toLowerCase() == "unavailable")
		{
			presence = $pres({type: "unavailable"});

		} else {	

			presence = $pres();	

			if (config.show  && config.show.toLowerCase() != "available")
			{	
				if ("dnd,xa,away,chat".indexOf(config.show) == -1) config.show = "chat";
				presence = presence.c('show').t(config.show).up();
			}

			if (config.status) 
			{
				config.status = Strophe.xmlescape(config.status);	
				presence = presence.c('status').t(config.status).up();
			}
		}			

		of.connection.send(presence);
	};
	
	of.sendMessage = function(message, callback, errorback)
	{
		try {
			var msg = $msg({to:message.jid, type:"chat"}).c("body").t(message.body).up();
			
			if (message.thread) message = message.c("thread").t(message.thread).up();
			
			of.connection.send(msg);
			if (callback) callback();
		} catch (e) {			
			if (errorback) errorback(e);
		}	
	}
	
    	of.VideoLayout = VideoLayout;  
    	of.server = window.location.protocol + "//" + window.location.host
    	of.data = {};
    	of.enabled = false;
    	
    	return of;
    	
}(ofmeet || {}));